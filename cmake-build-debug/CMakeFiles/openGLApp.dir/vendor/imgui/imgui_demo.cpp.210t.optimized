
;; Function ImVec2::ImVec2(float, float) (_ZN6ImVec2C2Eff, funcdef_no=4, decl_uid=2361, cgraph_uid=4, symbol_order=4)

ImVec2::ImVec2(float, float) (struct ImVec2 * const this, float _x, float _y)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->x = _x_4(D);
  this_2(D)->y = _y_6(D);
  return;

}



;; Function ImVec4::ImVec4() (_ZN6ImVec4C2Ev, funcdef_no=8, decl_uid=2407, cgraph_uid=8, symbol_order=8)

ImVec4::ImVec4() (struct ImVec4 * const this)
{
  float D.15437;
  float D.15436;
  float D.15435;
  float _5;
  float _7;
  float _9;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->w = 0.0;
  _5 = this_2(D)->w;
  this_2(D)->z = _5;
  _7 = this_2(D)->z;
  this_2(D)->y = _7;
  _9 = this_2(D)->y;
  this_2(D)->x = _9;
  return;

}



;; Function ImVec4::ImVec4(float, float, float, float) (_ZN6ImVec4C2Effff, funcdef_no=11, decl_uid=2399, cgraph_uid=11, symbol_order=11)

ImVec4::ImVec4(float, float, float, float) (struct ImVec4 * const this, float _x, float _y, float _z, float _w)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->x = _x_4(D);
  this_2(D)->y = _y_6(D);
  this_2(D)->z = _z_8(D);
  this_2(D)->w = _w_10(D);
  return;

}



;; Function bool ImGuiTextFilter::IsActive() const (_ZNK15ImGuiTextFilter8IsActiveEv, funcdef_no=79, decl_uid=4360, cgraph_uid=49, symbol_order=49)

bool ImGuiTextFilter::IsActive() const (const struct ImGuiTextFilter * const this)
{
  bool D.17558;
  const struct ImVector * D.17557;
  bool D.17556;
  const struct ImVector * _2;
  bool _5;
  bool _6;

  <bb 2>:
  _2 = &this_1(D)->Filters;
  _5 = ImVector<ImGuiTextFilter::TextRange>::empty (_2);
  _6 = ~_5;

<L0>:
  return _6;

}



;; Function ImGuiTextBuffer::ImGuiTextBuffer() (_ZN15ImGuiTextBufferC2Ev, funcdef_no=81, decl_uid=4522, cgraph_uid=51, symbol_order=51)

ImGuiTextBuffer::ImGuiTextBuffer() (struct ImGuiTextBuffer * const this)
{
  void * D.17840;
  struct ImVector * D.17366;
  struct ImVector * D.17365;
  const value_type D.4528;
  struct ImVector * D.17364;
  struct ImVector * _4;
  struct ImVector * _7;
  struct ImVector * _11;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Buf;
  ImVector<char>::ImVector (_4);
  D.4528 = 0;
  _7 = &this_2(D)->Buf;
  ImVector<char>::push_back (_7, &D.4528);

  <bb 3>:
  D.4528 ={v} {CLOBBER};
  return;

<L1>:
  D.4528 ={v} {CLOBBER};
  _11 = &this_2(D)->Buf;
  ImVector<char>::~ImVector (_11);
  _13 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_13);

}



;; Function char ImGuiTextBuffer::operator[](int) (_ZN15ImGuiTextBufferixEi, funcdef_no=83, decl_uid=4496, cgraph_uid=53, symbol_order=53)

char ImGuiTextBuffer::operator[](int) (struct ImGuiTextBuffer * const this, int i)
{
  char * D.17438;
  sizetype D.17437;
  char * D.17436;
  char D.17435;
  char * _3;
  sizetype _5;
  char * _6;
  char _7;

  <bb 2>:
  _3 = this_2(D)->Buf.Data;
  _5 = (sizetype) i_4(D);
  _6 = _3 + _5;
  _7 = *_6;

<L0>:
  return _7;

}



;; Function const char* ImGuiTextBuffer::begin() const (_ZNK15ImGuiTextBuffer5beginEv, funcdef_no=84, decl_uid=4498, cgraph_uid=54, symbol_order=54)

const char* ImGuiTextBuffer::begin() const (const struct ImGuiTextBuffer * const this)
{
  const struct ImVector * D.17573;
  const char * D.17572;
  const struct ImVector * _2;
  const char * _5;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  _5 = ImVector<char>::front (_2);

<L0>:
  return _5;

}



;; Function const char* ImGuiTextBuffer::end() const (_ZNK15ImGuiTextBuffer3endEv, funcdef_no=85, decl_uid=4500, cgraph_uid=55, symbol_order=55)

const char* ImGuiTextBuffer::end() const (const struct ImGuiTextBuffer * const this)
{
  const struct ImVector * D.17724;
  const char * D.17723;
  const struct ImVector * _2;
  const char * _5;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  _5 = ImVector<char>::back (_2);

<L0>:
  return _5;

}



;; Function int ImGuiTextBuffer::size() const (_ZNK15ImGuiTextBuffer4sizeEv, funcdef_no=86, decl_uid=4502, cgraph_uid=56, symbol_order=56)

int ImGuiTextBuffer::size() const (const struct ImGuiTextBuffer * const this)
{
  int D.17433;
  int D.17432;
  int _3;
  int _4;

  <bb 2>:
  _3 = this_2(D)->Buf.Size;
  _4 = _3 + -1;

<L0>:
  return _4;

}



;; Function void ImGuiTextBuffer::clear() (_ZN15ImGuiTextBuffer5clearEv, funcdef_no=88, decl_uid=4506, cgraph_uid=58, symbol_order=58)

void ImGuiTextBuffer::clear() (struct ImGuiTextBuffer * const this)
{
  struct ImVector * D.17542;
  const value_type D.4536;
  struct ImVector * D.17541;
  struct ImVector * _2;
  struct ImVector * _6;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImVector<char>::clear (_2);
  D.4536 = 0;
  _6 = &this_1(D)->Buf;
  ImVector<char>::push_back (_6, &D.4536);
  D.4536 ={v} {CLOBBER};
  return;

}



;; Function ImColor::ImColor(int, int, int, int) (_ZN7ImColorC2Eiiii, funcdef_no=113, decl_uid=4896, cgraph_uid=83, symbol_order=83)

ImColor::ImColor(int, int, int, int) (struct ImColor * const this, int r, int g, int b, int a)
{
  float sc;
  float D.15446;
  float D.15445;
  float D.15444;
  float D.15443;
  float D.15442;
  float D.15441;
  float D.15440;
  float D.15439;
  struct ImVec4 * D.15438;
  struct ImVec4 * _4;
  float _8;
  float _9;
  float _12;
  float _13;
  float _16;
  float _17;
  float _20;
  float _21;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Value;
  ImVec4::ImVec4 (_4);
  sc_6 = 3.9215688593685626983642578125e-3;
  _8 = (float) r_7(D);
  _9 = _8 * sc_6;
  this_2(D)->Value.x = _9;
  _12 = (float) g_11(D);
  _13 = _12 * sc_6;
  this_2(D)->Value.y = _13;
  _16 = (float) b_15(D);
  _17 = _16 * sc_6;
  this_2(D)->Value.z = _17;
  _20 = (float) a_19(D);
  _21 = _20 * sc_6;
  this_2(D)->Value.w = _21;
  return;

}



;; Function ImColor::ImColor(float, float, float, float) (_ZN7ImColorC2Effff, funcdef_no=119, decl_uid=4878, cgraph_uid=89, symbol_order=89)

ImColor::ImColor(float, float, float, float) (struct ImColor * const this, float r, float g, float b, float a)
{
  struct ImVec4 * D.15455;
  struct ImVec4 * _4;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Value;
  ImVec4::ImVec4 (_4);
  this_2(D)->Value.x = r_6(D);
  this_2(D)->Value.y = g_8(D);
  this_2(D)->Value.z = b_10(D);
  this_2(D)->Value.w = a_12(D);
  return;

}



;; Function ImColor::ImColor(const ImVec4&) (_ZN7ImColorC2ERK6ImVec4, funcdef_no=122, decl_uid=4869, cgraph_uid=92, symbol_order=92)

ImColor::ImColor(const ImVec4&) (struct ImColor * const this, const struct ImVec4 & col)
{
  struct ImVec4 * D.16615;
  struct ImVec4 * _4;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Value;
  ImVec4::ImVec4 (_4);
  this_2(D)->Value = *col_6(D);
  return;

}



;; Function ImColor::operator ImU32() const (_ZNK7ImColorcvjEv, funcdef_no=124, decl_uid=4851, cgraph_uid=94, symbol_order=94)

ImColor::operator ImU32() const (const struct ImColor * const this)
{
  ImU32 D.16619;
  const struct ImVec4 * D.16617;
  ImU32 D.16616;
  const struct ImVec4 * _2;
  ImU32 _5;
  ImU32 _6;

  <bb 2>:
  _2 = &this_1(D)->Value;
  _5 = ImGui::ColorConvertFloat4ToU32 (_2);
  _6 = _5;

<L0>:
  return _6;

}



;; Function ImColor::operator ImVec4() const (_ZNK7ImColorcv6ImVec4Ev, funcdef_no=125, decl_uid=4853, cgraph_uid=95, symbol_order=95)

ImColor::operator ImVec4() const (const struct ImColor * const this)
{
  struct ImVec4 D.15456;

  <bb 2>:
  D.15456 = this_2(D)->Value;

<L0>:
  return D.15456;

}



;; Function static ImColor ImColor::HSV(float, float, float, float) (_ZN7ImColor3HSVEffff, funcdef_no=127, decl_uid=4865, cgraph_uid=97, symbol_order=97)

static ImColor ImColor::HSV(float, float, float, float) (float h, float s, float v, float a)
{
  float b;
  float g;
  float r;
  float r.351;
  float g.350;
  float b.349;
  struct ImColor D.4958;
  struct ImColor D.15447;
  float b.349_6;
  float g.350_7;
  float r.351_8;

  <bb 2>:
  ImGui::ColorConvertHSVtoRGB (h_2(D), s_3(D), v_4(D), &r, &g, &b);
  b.349_6 = b;
  g.350_7 = g;
  r.351_8 = r;
  ImColor::ImColor (&D.4958, r.351_8, g.350_7, b.349_6, a_9(D));
  D.15447 = D.4958;
  D.4958 ={v} {CLOBBER};
  r ={v} {CLOBBER};
  g ={v} {CLOBBER};
  b ={v} {CLOBBER};

<L2>:
  return D.15447;

}



;; Function ImGuiListClipper::ImGuiListClipper(int, float) (_ZN16ImGuiListClipperC2Eif, funcdef_no=129, decl_uid=4994, cgraph_uid=99, symbol_order=99)

ImGuiListClipper::ImGuiListClipper(int, float) (struct ImGuiListClipper * const this, int items_count, float items_height)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  ImGuiListClipper::Begin (this_2(D), items_count_4(D), items_height_5(D));
  return;

}



;; Function ImGuiListClipper::~ImGuiListClipper() (_ZN16ImGuiListClipperD2Ev, funcdef_no=132, decl_uid=5001, cgraph_uid=102, symbol_order=102)

ImGuiListClipper::~ImGuiListClipper() (struct ImGuiListClipper * const this)
{
  int D.15458;
  static const char __PRETTY_FUNCTION__[38] = "ImGuiListClipper::~ImGuiListClipper()";
  static const char __PRETTY_FUNCTION__[38] = "ImGuiListClipper::~ImGuiListClipper()";
  int _3;

  <bb 2>:
  _3 = this_2(D)->ItemsCount;
  if (_3 == -1)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("ItemsCount == -1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1452, &__PRETTY_FUNCTION__);

  <bb 4>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  return;

}



;; Function const char* ImFont::GetDebugName() const (_ZNK6ImFont12GetDebugNameEv, funcdef_no=174, decl_uid=7090, cgraph_uid=144, symbol_order=144)

const char* ImFont::GetDebugName() const (const struct ImFont * const this)
{
  struct ImFontConfig * D.15508;
  struct ImFontConfig * D.15505;
  const char * iftmp.356;
  const char * D.15503;
  const char * iftmp.356_1;
  struct ImFontConfig * _4;
  struct ImFontConfig * _5;
  const char * iftmp.356_6;
  const char * iftmp.356_7;
  const char * _8;

  <bb 2>:
  _4 = this_3(D)->ConfigData;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->ConfigData;
  iftmp.356_6 = &_5->Name;
  goto <bb 5>;

  <bb 4>:
  iftmp.356_7 = "<unknown>";

  <bb 5>:
  # iftmp.356_1 = PHI <iftmp.356_6(3), iftmp.356_7(4)>
  _8 = iftmp.356_1;

<L3>:
  return _8;

}



;; Function void ShowHelpMarker(const char*) (_ZL14ShowHelpMarkerPKc, funcdef_no=404, decl_uid=11357, cgraph_uid=303, symbol_order=303)

void ShowHelpMarker(const char*) (const char * desc)
{
  float D.13173;
  bool D.13172;
  float D.13170;
  float D.13169;
  bool retval.0;
  bool _5;
  bool retval.0_6;
  float _9;
  float _10;
  float _11;

  <bb 2>:
  ImGui::TextDisabled ("(?)");
  _5 = ImGui::IsItemHovered (0);
  retval.0_6 = _5;
  if (retval.0_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::BeginTooltip ();
  _9 = ImGui::GetFontSize ();
  _10 = _9;
  _11 = _10 * 3.5e+1;
  ImGui::PushTextWrapPos (_11);
  ImGui::TextUnformatted (desc_13(D), 0B);
  ImGui::PopTextWrapPos ();
  ImGui::EndTooltip ();

  <bb 4>:
  return;

}



;; Function void ImGui::ShowUserGuide() (_ZN5ImGui13ShowUserGuideEv, funcdef_no=405, decl_uid=2443, cgraph_uid=304, symbol_order=304)

void ImGui::ShowUserGuide() ()
{
  struct ImGuiIO & D.13179;
  struct ImGuiIO & D.13175;
  bool retval.1;
  struct ImGuiIO & _9;
  struct ImGuiIO & _10;
  bool retval.1_11;

  <bb 2>:
  ImGui::BulletText ("Double-click on title bar to collapse window.");
  ImGui::BulletText ("Click and drag on lower right corner to resize window\n(double-click to auto fit window to its contents).");
  ImGui::BulletText ("Click and drag on any empty space to move window.");
  ImGui::BulletText ("TAB/SHIFT+TAB to cycle through keyboard editable fields.");
  ImGui::BulletText ("CTRL+Click on a slider or drag box to input value as text.");
  _9 = ImGui::GetIO ();
  _10 = _9;
  retval.1_11 = _10->FontAllowUserScaling;
  if (retval.1_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::BulletText ("CTRL+Mouse Wheel to zoom window contents.");

  <bb 4>:
  ImGui::BulletText ("Mouse Wheel to scroll.");
  ImGui::BulletText ("While editing text:\n");
  ImGui::Indent (0.0);
  ImGui::BulletText ("Hold SHIFT or use mouse to select text.");
  ImGui::BulletText ("CTRL+Left/Right to word jump.");
  ImGui::BulletText ("CTRL+A or double-click to select all.");
  ImGui::BulletText ("CTRL+X,CTRL+C,CTRL+V to use clipboard.");
  ImGui::BulletText ("CTRL+Z,CTRL+Y to undo/redo.");
  ImGui::BulletText ("ESCAPE to revert.");
  ImGui::BulletText ("You can apply arithmetic operators +,*,/ on numerical values.\nUse +- to subtract.");
  ImGui::Unindent (0.0);
  return;

}



;; Function static bool ImGui::ShowDemoWindow(bool*)::FuncHolder::ItemGetter(void*, int, const char**) (_ZZN5ImGui14ShowDemoWindowEPbEN10FuncHolder10ItemGetterEPviPPKc, funcdef_no=407, decl_uid=11502, cgraph_uid=305, symbol_order=359)

static bool ImGui::ShowDemoWindow(bool*)::FuncHolder::ItemGetter(void*, int, const char**) (void * data, int idx, const char * * out_str)
{
  bool D.15433;
  const char * D.15432;
  const char * * D.15431;
  long unsigned int D.15430;
  long unsigned int D.15429;
  long unsigned int _2;
  long unsigned int _3;
  const char * * _5;
  const char * _7;
  bool _10;

  <bb 2>:
  _2 = (long unsigned int) idx_1(D);
  _3 = _2 * 8;
  _5 = data_4(D) + _3;
  _7 = *_5;
  *out_str_8(D) = _7;
  _10 = 1;

<L0>:
  return _10;

}



;; Function static int ImGui::ShowDemoWindow(bool*)::TextFilters::FilterImGuiLetters(ImGuiTextEditCallbackData*) (_ZZN5ImGui14ShowDemoWindowEPbEN11TextFilters18FilterImGuiLettersEP25ImGuiTextEditCallbackData, funcdef_no=408, decl_uid=11540, cgraph_uid=306, symbol_order=372)

static int ImGui::ShowDemoWindow(bool*)::TextFilters::FilterImGuiLetters(ImGuiTextEditCallbackData*) (struct ImGuiTextEditCallbackData * data)
{
  int D.15427;
  const char * D.15424;
  int D.15423;
  char D.15422;
  short unsigned int D.15421;
  int D.15418;
  short unsigned int D.15417;
  int _1;
  short unsigned int _4;
  int _5;
  short unsigned int _6;
  char _7;
  int _8;
  const char * _9;
  int _10;
  int _11;

  <bb 2>:
  _4 = data_3(D)->EventChar;
  _5 = (int) _4;
  if (_5 <= 255)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _6 = data_3(D)->EventChar;
  _7 = (char) _6;
  _8 = (int) _7;
  _9 = strchr ("imgui", _8);
  if (_9 != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _10 = 0;
  goto <bb 6> (<L4>);

  <bb 5>:
  _11 = 1;

  # _1 = PHI <_10(4), _11(5)>
<L4>:
  return _1;

}



;; Function static float ImGui::ShowDemoWindow(bool*)::Funcs::Sin(void*, int) (_ZZN5ImGui14ShowDemoWindowEPbEN5Funcs3SinEPvi, funcdef_no=409, decl_uid=11562, cgraph_uid=307, symbol_order=383)

static float ImGui::ShowDemoWindow(bool*)::Funcs::Sin(void*, int) (void * D.11560, int i)
{
  float D.15415;
  float D.15414;
  float D.15413;
  float _2;
  float _3;
  float _4;

  <bb 2>:
  _2 = (float) i_1(D);
  _3 = _2 * 1.00000001490116119384765625e-1;
  _4 = sinf (_3);

<L0>:
  return _4;

}



;; Function static float ImGui::ShowDemoWindow(bool*)::Funcs::Saw(void*, int) (_ZZN5ImGui14ShowDemoWindowEPbEN5Funcs3SawEPvi, funcdef_no=410, decl_uid=11565, cgraph_uid=308, symbol_order=384)

static float ImGui::ShowDemoWindow(bool*)::Funcs::Saw(void*, int) (void * D.11563, int i)
{
  int D.15408;
  float iftmp.348;
  float D.15406;
  float iftmp.348_1;
  int _3;
  float iftmp.348_4;
  float iftmp.348_5;
  float _6;

  <bb 2>:
  _3 = i_2(D) & 1;
  if (_3 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.348_4 = 1.0e+0;
  goto <bb 5>;

  <bb 4>:
  iftmp.348_5 = -1.0e+0;

  <bb 5>:
  # iftmp.348_1 = PHI <iftmp.348_4(3), iftmp.348_5(4)>
  _6 = iftmp.348_1;

<L3>:
  return _6;

}



;; Function ImGuiTextFilter::~ImGuiTextFilter() (_ZN15ImGuiTextFilterD2Ev, funcdef_no=412, decl_uid=11850, cgraph_uid=310, symbol_order=453)

ImGuiTextFilter::~ImGuiTextFilter() (struct ImGuiTextFilter * const this)
{
  struct ImVector * D.15400;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Filters;
  ImVector<ImGuiTextFilter::TextRange>::~ImVector (_2);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImGui::ShowDemoWindow(bool*) (_ZN5ImGui14ShowDemoWindowEPb, funcdef_no=406, decl_uid=2434, cgraph_uid=312, symbol_order=459)

void ImGui::ShowDemoWindow(bool*) (bool * p_open)
{
  void * D.17870;
  void * D.17869;
  void * D.17868;
  void * D.17867;
  bool D.15396;
  bool D.15395;
  int D.15393;
  int D.15392;
  bool D.15391;
  unsigned int D.15389;
  struct ImDrawList * D.15388;
  bool D.15387;
  bool D.15385;
  bool D.15384;
  bool D.15383;
  bool D.15382;
  bool D.15380;
  bool D.15379;
  bool D.15378;
  bool D.15377;
  bool D.15376;
  bool D.15374;
  bool D.15373;
  bool D.15372;
  bool D.15371;
  bool D.15370;
  bool D.15369;
  bool D.15368;
  bool D.15367;
  bool D.15366;
  bool D.15365;
  bool D.15364;
  bool D.15363;
  float D.15361;
  bool D.15360;
  bool D.15358;
  bool D.15356;
  bool D.15354;
  bool D.15353;
  bool D.15352;
  bool D.15351;
  bool D.15349;
  bool D.15347;
  bool D.15345;
  bool D.15344;
  bool D.15343;
  bool D.15342;
  bool D.15340;
  bool D.15338;
  bool D.15337;
  bool D.15336;
  bool D.15335;
  bool D.15334;
  bool D.15333;
  bool D.15332;
  struct ImGuiIO & D.15331;
  bool D.15330;
  bool D.15328;
  bool D.15326;
  bool D.15325;
  bool D.15324;
  bool D.15323;
  bool D.15320;
  float D.15318;
  bool D.15316;
  float D.15315;
  float D.15314;
  int D.15313;
  bool D.15312;
  bool D.15311;
  bool D.15310;
  bool D.15309;
  bool D.15308;
  bool D.15304;
  bool D.15301;
  bool D.15299;
  bool D.15296;
  bool D.15295;
  bool D.15294;
  bool D.15293;
  bool D.15292;
  bool D.15290;
  bool D.15288;
  bool D.15287;
  bool D.15285;
  bool D.15284;
  bool D.15282;
  bool D.15280;
  bool D.15278;
  bool D.15276;
  bool D.15274;
  bool D.15273;
  bool D.15270;
  bool D.15269;
  bool D.15266;
  bool D.15264;
  bool D.15263;
  bool D.15262;
  bool D.15260;
  bool D.15258;
  bool D.15257;
  bool D.15256;
  bool D.15254;
  bool D.15253;
  bool D.15252;
  bool D.15251;
  bool D.15249;
  bool D.15247;
  bool D.15246;
  bool D.15244;
  bool D.15243;
  bool D.15242;
  struct ImDrawList * D.15239;
  struct ImFont * D.15238;
  float D.15237;
  struct ImDrawList * D.15235;
  struct ImGuiIO & D.15234;
  struct ImGuiIO & D.15233;
  bool D.15232;
  bool D.15231;
  bool D.15230;
  float D.15229;
  struct ImGuiIO & D.15227;
  bool D.15226;
  struct ImGuiIO & D.15225;
  bool D.15224;
  float D.15223;
  float D.15222;
  float D.15212;
  bool D.15210;
  float D.15209;
  float D.15208;
  unsigned int D.15204;
  float D.15203;
  bool D.15202;
  bool D.15200;
  bool D.15199;
  bool D.15198;
  bool D.15194;
  bool D.15193;
  struct ImGuiStyle & D.15191;
  bool D.15185;
  struct ImGuiStyle & D.15180;
  struct ImGuiStyle & D.15178;
  bool D.15177;
  bool D.15171;
  bool D.15164;
  float D.15163;
  float D.15162;
  bool D.15161;
  bool D.15158;
  bool D.15157;
  float D.15154;
  bool D.15153;
  bool D.15151;
  bool D.15150;
  bool D.15149;
  bool D.15146;
  bool D.15145;
  bool D.15144;
  bool D.15143;
  bool D.15131;
  bool D.15130;
  bool D.15129;
  bool D.15127;
  bool D.15125;
  const struct ImGuiPayload * D.15123;
  const struct ImGuiPayload * D.15122;
  bool D.15121;
  bool D.15119;
  struct ImGuiStyle & D.15118;
  bool D.15116;
  bool D.15114;
  bool D.15112;
  bool D.15110;
  bool D.15109;
  struct ImGuiStyle & D.15106;
  struct ImGuiIO & D.15104;
  float D.15099;
  float D.15098;
  bool D.15096;
  float D.15094;
  bool D.15092;
  bool D.15091;
  bool D.15089;
  bool D.15088;
  bool D.15085;
  bool D.15084;
  bool D.15080;
  struct ImGuiIO & D.15078;
  bool D.15076;
  bool D.15075;
  bool D.15072;
  bool D.15071;
  bool D.15070;
  bool D.15068;
  bool D.15064;
  bool D.15063;
  bool D.15060;
  bool D.15059;
  bool D.15058;
  bool D.15057;
  bool D.15056;
  bool D.15048;
  bool D.15041;
  struct ImGuiIO & D.15033;
  bool D.15032;
  bool D.15031;
  struct ImDrawList * D.15027;
  struct ImDrawList * D.15024;
  float D.15023;
  struct ImDrawList * D.15020;
  struct ImDrawList * D.15017;
  float D.15016;
  bool D.15015;
  bool D.15012;
  bool D.15011;
  bool D.15010;
  bool D.15009;
  bool D.15008;
  bool D.15007;
  bool D.15006;
  bool D.15005;
  float D.15004;
  struct ImGuiIO & D.15003;
  bool D.15002;
  bool D.15001;
  bool D.15000;
  float D.14999;
  float D.14998;
  bool D.14997;
  bool D.14996;
  bool D.14995;
  bool D.14994;
  bool D.14993;
  bool D.14989;
  bool D.14988;
  bool D.14987;
  bool D.14986;
  struct ImGuiStyle & D.14985;
  bool D.14976;
  bool D.14975;
  bool D.14974;
  bool D.14973;
  bool D.14972;
  bool D.14971;
  bool D.14970;
  bool D.14969;
  bool D.14968;
  bool D.14967;
  bool D.14966;
  bool D.14965;
  const char * D.14963;
  char label[32];
  int i;
  const char * mouse_cursors_names[7];
  struct ImVec2 mouse_delta;
  struct ImVec2 value_with_lock_threshold;
  struct ImVec2 value_raw;
  struct ImDrawList * draw_list;
  int button;
  static bool embed_all_inside_a_child_window = 0;
  int focus_ahead;
  static float f3[3] = {0.0, 0.0, 0.0};
  static char buf[128] = "click on a button to set focus";
  int has_focus;
  bool focus_3;
  bool focus_2;
  bool focus_1;
  static char buf[32] = "dummy";
  int i;
  int i;
  int i;
  int i;
  int i;
  int i;
  int i;
  int i;
  int i;
  int i;
  struct ImGuiIO & io;
  int i;
  const char * lines[8];
  static struct ImGuiTextFilter filter;
  int j;
  int i;
  struct ImGuiListClipper clipper;
  int ITEMS_COUNT;
  int i;
  static bool v_borders = 1;
  static bool h_borders = 1;
  static float bar = 1.0e+0;
  static float foo = 1.0e+0;
  bool hovered;
  char label[32];
  int i;
  char label[32];
  int n;
  static int selected = -1;
  const char * paths[3];
  const char * names[3];
  bool node_open;
  static float color[4] = {4.000000059604644775390625e-1, 6.99999988079071044921875e-1, 0.0, 5.0e-1};
  static int item = 1;
  static bool dont_ask_me_next_time = 0;
  char buf[64];
  static char name[32] = "Label1";
  static float value = 5.0e-1;
  int i;
  int i;
  int i;
  static bool toggles[5] = {1, 0, 0, 0, 0};
  const char * names[5];
  static int selected_fish = -1;
  struct ImVec4 clip_rect;
  struct ImVec2 pos;
  static struct ImVec2 offset;
  static struct ImVec2 size;
  float hue;
  const char * label;
  char num_buf[16];
  int n;
  int num_buttons;
  int line;
  float scroll_x_delta;
  float scroll_max_x;
  float scroll_x;
  static int lines = 7;
  int line;
  float scroll_max_y;
  float scroll_y;
  int i;
  bool scroll_to;
  static int scroll_to_px = 200;
  static int track_line = 50;
  static bool track = 1;
  int i;
  int i;
  bool node_open;
  const float spacing;
  const float values[5];
  struct ImVec2 size;
  int i;
  struct ImVec2 sz;
  static int selection[4] = {0, 1, 2, 3};
  static int item = -1;
  const char * items[4];
  static float f2 = 3.0e+0;
  static float f1 = 2.0e+0;
  static float f0 = 1.0e+0;
  static bool c4 = 0;
  static bool c3 = 0;
  static bool c2 = 0;
  static bool c1 = 0;
  static float f = 0.0;
  char buf[32];
  int i;
  int i;
  bool goto_line;
  static int line = 50;
  static bool disable_menu = 0;
  static bool disable_mouse_wheel = 0;
  int i;
  int ny;
  int nx;
  int i;
  const struct ImVec2 small_slider_size;
  const int rows;
  static float values2[4] = {2.0000000298023223876953125e-1, 8.00000011920928955078125e-1, 4.000000059604644775390625e-1, 2.5e-1};
  static float values[7] = {0.0, 6.0000002384185791015625e-1, 3.499999940395355224609375e-1, 8.9999997615814208984375e-1, 6.99999988079071044921875e-1, 2.0000000298023223876953125e-1, 0.0};
  static int int_value = 0;
  const float spacing;
  static int vec4i[4] = {1, 5, 100, 255};
  static float vec4f[4] = {1.00000001490116119384765625e-1, 2.0000000298023223876953125e-1, 3.00000011920928955078125e-1, 4.39999997615814208984375e-1};
  static int end_i = 1000;
  static int begin_i = 100;
  static float end = 9.0e+1;
  static float begin = 1.0e+1;
  const struct ImGuiPayload * payload;
  const struct ImGuiPayload * payload;
  int n;
  int n;
  ImGuiColorEditFlags flags;
  static int picker_mode = 0;
  static int inputs_mode = 2;
  static struct ImVec4 ref_color_v;
  static bool ref_color = 0;
  static bool side_preview = 1;
  static bool alpha_bar = 1;
  static bool alpha = 1;
  bool open_popup;
  static struct ImVec4 backup_color;
  static struct ImVec4 saved_palette[32];
  static bool saved_palette_inited = 0;
  int misc_flags;
  static bool hdr = 0;
  static bool options_menu = 1;
  static bool alpha_half_preview = 0;
  static bool alpha_preview = 1;
  static struct ImVec4 color;
  static float phase = 0.0;
  char buf[32];
  float progress_saturated;
  static float progress_dir = 1.0e+0;
  static float progress = 0.0;
  float (*<T6b3>) (void *, int) func;
  static int display_count = 70;
  static int func_type = 0;
  static float refresh_time = 0.0;
  static int values_offset = 0;
  static float values[90] = {0.0};
  static float arr[7] = {6.0000002384185791015625e-1, 1.00000001490116119384765625e-1, 1.0e+0, 5.0e-1, 9.20000016689300537109375e-1, 1.00000001490116119384765625e-1, 2.0000000298023223876953125e-1};
  static bool animate = 1;
  static char text[16384] = "/*\n The Pentium F00F bug, shorthand for F0 0F C7 C8,\n the hexadecimal encoding of one offending instruction,\n more formally, the invalid operand with locked CMPXCHG8B\n instruction bug, is a design flaw in the majority of\n Intel Pentium, Pentium MMX, and Pentium OverDrive\n processors (all in the P5 microarchitecture).\n*/\n\nlabel:\n\tlock cmpxchg8b eax\n";
  static bool read_only = 0;
  static char bufpass[64] = "password123";
  static char buf6[64] = "";
  static char buf5[64] = "";
  static char buf4[64] = "";
  static char buf3[64] = "";
  static char buf2[64] = "";
  static char buf1[64] = "";
  int y;
  int x;
  int i;
  static bool selected[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
  char label[32];
  int i;
  static bool selected[16] = {0};
  static bool selected[3] = {0, 0, 0};
  char buf[32];
  int n;
  static bool selection[5] = {0, 0, 0, 0, 0};
  char buf[32];
  int n;
  static int selected = -1;
  static bool selection[5] = {0, 1, 0, 0, 0};
  bool is_selected;
  int n;
  static int item_current_4 = 0;
  static int item_current_3 = -1;
  static int item_current_2 = 0;
  static const char * item_current;
  const char * items[14];
  static ImGuiComboFlags flags = 0;
  int frame_padding;
  int i;
  struct ImVec2 uv1;
  struct ImVec2 uv0;
  float zoom;
  float region_y;
  float region_x;
  float region_sz;
  static int pressed_count = 0;
  struct ImVec2 pos;
  float my_tex_h;
  float my_tex_w;
  void * my_tex_id;
  struct ImGuiIO & io;
  static char buf[32] = "日本語";
  struct ImVec2 pos;
  static float wrap_width = 2.0e+2;
  int i;
  int i;
  static bool closable_group = 1;
  bool node_open;
  ImGuiTreeNodeFlags node_flags;
  int i;
  int node_clicked;
  static int selection_mask = 4;
  static bool align_label_with_current_x_position = 0;
  int i;
  static int listbox_item_current = 1;
  const char * listbox_items[9];
  static float col2[4] = {4.000000059604644775390625e-1, 6.99999988079071044921875e-1, 0.0, 5.0e-1};
  static float col1[3] = {1.0e+0, 0.0, 2.0000000298023223876953125e-1};
  static float angle = 0.0;
  static float f2 = 0.0;
  static float f1 = 1.23000003397464752197265625e-1;
  static int i1 = 0;
  static float f2 = 6.69999979436397552490234375e-3;
  static float f1 = 1.0e+0;
  static int i2 = 42;
  static int i1 = 50;
  static float vec4a[4] = {1.00000001490116119384765625e-1, 2.0000000298023223876953125e-1, 3.00000011920928955078125e-1, 4.39999997615814208984375e-1};
  static double d0 = 9.9999900000100000761449337005615234375e+5;
  static float f0 = 1.000000047497451305389404296875e-3;
  static int i0 = 123;
  static char str0[128] = "Hello, world!";
  static int item_current = 0;
  const char * items[14];
  static float arr[7] = {6.0000002384185791015625e-1, 1.00000001490116119384765625e-1, 1.0e+0, 5.0e-1, 9.20000016689300537109375e-1, 1.00000001490116119384765625e-1, 2.0000000298023223876953125e-1};
  int i;
  float spacing;
  static int e = 0;
  static bool check = 1;
  static int clicked = 0;
  static const char __PRETTY_FUNCTION__[34] = "void ImGui::ShowDemoWindow(bool*)";
  ImGuiWindowFlags window_flags;
  static bool no_nav = 0;
  static bool no_close = 0;
  static bool no_collapse = 0;
  static bool no_resize = 0;
  static bool no_move = 0;
  static bool no_menu = 0;
  static bool no_scrollbar = 0;
  static bool no_titlebar = 0;
  static bool show_app_about = 0;
  static bool show_app_metrics = 0;
  static bool show_app_style_editor = 0;
  static bool show_app_custom_rendering = 0;
  static bool show_app_window_titles = 0;
  static bool show_app_fixed_overlay = 0;
  static bool show_app_constrained_resize = 0;
  static bool show_app_auto_resize = 0;
  static bool show_app_long_text = 0;
  static bool show_app_property_editor = 0;
  static bool show_app_layout = 0;
  static bool show_app_log = 0;
  static bool show_app_console = 0;
  static bool show_app_main_menu_bar = 0;
  bool D.14956;
  bool D.14954;
  bool iftmp.347;
  bool retval.346;
  struct ImVec2 D.11908;
  const char * D.14948;
  int D.14945;
  const char * D.14944;
  int D.14943;
  bool retval.345;
  double D.14934;
  float D.14933;
  double D.14932;
  float D.14931;
  double D.14930;
  float D.14929;
  double D.14928;
  float D.14927;
  double D.14926;
  float D.14925;
  double D.14924;
  float D.14923;
  struct ImVec2 * D.14922;
  struct ImVec2 * D.14921;
  unsigned int D.14920;
  bool retval.344;
  struct ImVec2 D.11896;
  int D.14916;
  bool D.14915;
  int D.14914;
  bool D.14913;
  int D.14912;
  bool D.14911;
  bool retval.343;
  bool embed_all_inside_a_child_window.342;
  struct ImVec2 D.11894;
  int D.14900;
  bool D.14899;
  int D.14898;
  bool D.14897;
  int D.14896;
  bool D.14895;
  int D.14894;
  bool D.14893;
  int D.14892;
  bool D.14891;
  struct ImVec2 D.11893;
  int D.14890;
  bool D.14889;
  int D.14888;
  bool D.14887;
  int D.14886;
  bool D.14885;
  int D.14884;
  bool D.14883;
  int D.14882;
  bool D.14881;
  int D.14880;
  bool D.14879;
  int D.14878;
  bool D.14877;
  int D.14876;
  bool D.14875;
  int D.14874;
  bool D.14873;
  int D.14872;
  bool D.14871;
  int D.14870;
  bool D.14869;
  int D.14868;
  bool D.14867;
  float D.14865;
  float D.14864;
  struct ImVec2 D.11892;
  bool embed_all_inside_a_child_window.341;
  bool retval.340;
  struct ImVec2 D.11890;
  bool retval.339;
  struct ImVec2 D.11889;
  bool retval.338;
  struct ImVec2 D.11888;
  bool retval.337;
  bool retval.336;
  bool retval.335;
  bool retval.334;
  struct ImVec2 D.11883;
  struct ImVec2 D.11881;
  struct ImVec2 D.11879;
  bool retval.333;
  bool retval.332;
  bool retval.331;
  struct ImVec2 D.11876;
  bool retval.330;
  struct ImVec2 D.11875;
  double D.14800;
  float D.14799;
  float D.14796;
  float D.14790;
  double D.14786;
  float D.14785;
  float D.14782;
  bool D.14776;
  const char * iftmp.329;
  bool D.14771;
  const char * iftmp.328;
  bool D.14766;
  const char * iftmp.327;
  bool D.14761;
  const char * iftmp.326;
  bool retval.325;
  bool retval.324;
  double D.14746;
  float D.14745;
  float D.14742;
  double D.14739;
  float D.14738;
  bool retval.323;
  bool retval.322;
  bool retval.321;
  double D.14718;
  float D.14717;
  float D.14714;
  double D.14710;
  float D.14709;
  double D.14708;
  float D.14707;
  bool retval.320;
  bool retval.319;
  ImGuiConfigFlags * D.14700;
  ImGuiConfigFlags * D.14699;
  ImGuiConfigFlags * D.14698;
  ImGuiConfigFlags * D.14697;
  bool * D.14696;
  int D.14695;
  bool D.14694;
  int D.14693;
  bool D.14692;
  int D.14691;
  bool D.14690;
  int D.14689;
  bool D.14688;
  int D.14687;
  bool D.14686;
  int D.14685;
  bool D.14684;
  bool retval.318;
  const char * D.14678;
  const char * D.14675;
  bool retval.317;
  bool D.11843;
  int D.14664;
  bool retval.316;
  unsigned char D.14660;
  bool retval.315;
  bool retval.314;
  bool retval.313;
  bool retval.312;
  int D.14639;
  bool retval.311;
  float D.14634;
  float D.14633;
  struct ImVec2 D.11808;
  struct ImVec2 D.11807;
  bool retval.310;
  bool h_borders.309;
  double D.14624;
  float D.14623;
  double D.14622;
  float D.14621;
  int D.14620;
  int D.14619;
  int D.14618;
  int D.14613;
  bool h_borders.308;
  bool iftmp.307;
  bool retval.306;
  int D.14604;
  bool v_borders.305;
  bool retval.304;
  bool retval.303;
  bool retval.302;
  bool retval.301;
  bool retval.300;
  struct ImVec2 D.11802;
  struct ImVec2 D.11800;
  struct ImVec2 D.11799;
  bool retval.299;
  int D.14578;
  const char * D.14577;
  const char * D.14576;
  int D.14572;
  bool D.14571;
  int selected.298;
  struct ImVec2 D.11797;
  bool retval.297;
  struct ImVec2 D.11791;
  bool retval.296;
  bool retval.295;
  bool retval.294;
  bool retval.293;
  bool retval.292;
  struct ImVec2 D.11788;
  bool retval.291;
  struct ImVec2 D.11787;
  bool retval.290;
  bool retval.289;
  struct ImVec2 D.11786;
  bool retval.288;
  bool retval.287;
  struct ImVec2 D.11783;
  bool retval.286;
  struct ImVec2 D.11782;
  bool retval.285;
  struct ImVec2 D.11781;
  bool retval.284;
  struct ImVec2 D.11780;
  bool retval.283;
  struct ImVec2 D.11778;
  bool retval.282;
  bool retval.281;
  struct ImVec2 D.11777;
  bool retval.280;
  bool retval.279;
  struct ImVec2 D.11776;
  struct ImVec2 D.11773;
  bool retval.278;
  struct ImVec2 D.11772;
  bool retval.277;
  bool retval.276;
  double D.14480;
  float value.275;
  bool retval.274;
  bool retval.273;
  struct ImVec2 D.11770;
  bool retval.272;
  bool retval.271;
  const char * D.14460;
  bool * D.14459;
  bool retval.270;
  struct ImVec2 D.11768;
  bool retval.269;
  bool retval.268;
  bool retval.267;
  const char * D.14441;
  bool * D.14440;
  bool retval.266;
  struct ImVec2 D.11766;
  bool retval.265;
  const char * D.14426;
  struct ImVec2 D.11765;
  bool retval.264;
  bool retval.263;
  int selected_fish.262;
  int selected_fish.261;
  const char * iftmp.260;
  struct ImVec2 D.11763;
  bool retval.259;
  bool retval.258;
  bool retval.257;
  struct ImDrawList * D.14401;
  struct ImFont * D.14400;
  float D.14399;
  float D.14398;
  float D.14397;
  float D.14396;
  float D.14395;
  float D.14394;
  float D.14393;
  float D.14392;
  struct ImVec2 D.11759;
  struct ImDrawList * D.14391;
  float D.14390;
  float D.14389;
  float D.14388;
  float D.14387;
  float D.14386;
  float D.14385;
  struct ImVec2 D.11758;
  float D.14383;
  float D.14382;
  struct ImGuiIO & D.14381;
  float D.11757;
  float D.14380;
  float D.14379;
  struct ImGuiIO & D.14378;
  float D.11756;
  bool D.14374;
  bool D.14372;
  bool iftmp.256;
  bool retval.255;
  float D.14367;
  float D.14366;
  float D.14365;
  float D.14364;
  float D.14363;
  float D.14362;
  float D.14361;
  float D.14360;
  bool D.11752;
  int D.14352;
  bool retval.254;
  unsigned char D.14348;
  bool retval.253;
  bool D.11749;
  int D.14339;
  bool retval.252;
  unsigned char D.14335;
  bool retval.251;
  bool retval.250;
  float D.14328;
  float D.14327;
  struct ImVec2 D.11746;
  double D.14324;
  double D.14323;
  float D.14321;
  struct ImGuiIO & D.14320;
  bool retval.249;
  float D.14315;
  float D.14314;
  struct ImGuiIO & D.14313;
  bool retval.248;
  float D.14309;
  float D.14308;
  float D.14307;
  float D.14306;
  int D.14305;
  struct ImVec2 D.11742;
  struct ImColor D.11740;
  struct ImVec4 D.11741;
  struct ImColor D.11738;
  struct ImVec4 D.11739;
  struct ImColor D.11736;
  struct ImVec4 D.11737;
  float D.14304;
  int D.14298;
  const char * iftmp.247;
  int D.14294;
  const char * iftmp.246;
  int D.14290;
  const char * iftmp.245;
  int D.14288;
  int D.14287;
  int D.14281;
  int D.14279;
  int D.14276;
  int iftmp.244;
  int lines.243;
  float D.14271;
  float D.14270;
  float D.14269;
  struct ImVec2 D.11729;
  struct ImVec2 D.11728;
  bool retval.242;
  double D.14264;
  double D.14263;
  float D.14262;
  float D.14261;
  struct ImColor D.11723;
  struct ImVec4 D.11724;
  int track_line.241;
  bool track.240;
  float D.14251;
  float D.14250;
  int scroll_to_px.239;
  float D.14248;
  struct ImVec2 D.11721;
  float D.14247;
  float D.14246;
  unsigned int D.14243;
  const void * D.14242;
  long int D.14241;
  float D.14240;
  float D.14239;
  struct ImVec2 D.11720;
  const char * iftmp.238;
  const char * iftmp.237;
  const char * iftmp.236;
  const char * iftmp.235;
  bool D.11718;
  struct ImVec2 D.11717;
  bool track.234;
  bool track.233;
  bool D.11715;
  bool retval.232;
  struct ImVec2 D.11711;
  struct ImVec2 D.11710;
  struct ImVec2 D.11708;
  bool retval.231;
  struct ImVec2 D.11705;
  struct ImGuiStyle & D.14197;
  struct ImVec2 D.11703;
  struct ImVec2 D.11702;
  struct ImVec2 D.11701;
  struct ImVec2 D.11700;
  struct ImVec2 D.11699;
  bool retval.230;
  struct ImVec2 D.11698;
  struct ImVec2 D.11697;
  float D.14192;
  float D.14191;
  float D.14190;
  struct ImGuiStyle & D.14189;
  float D.14188;
  float D.14187;
  struct ImVec2 D.11696;
  float D.14186;
  float D.14185;
  float D.14184;
  struct ImGuiStyle & D.14183;
  float D.14182;
  float D.14181;
  struct ImVec2 D.11695;
  bool retval.229;
  struct ImVec2 D.11690;
  struct ImVec2 D.11689;
  struct ImVec2 D.11688;
  struct ImVec2 D.11687;
  struct ImVec2 D.11686;
  bool retval.228;
  int * D.14172;
  struct ImVec2 D.11673;
  struct ImVec2 D.11672;
  struct ImVec2 D.11671;
  struct ImVec4 D.11670;
  struct ImVec4 D.11669;
  bool retval.227;
  float D.14162;
  float D.14161;
  float D.14160;
  float D.14159;
  bool retval.226;
  struct ImVec2 D.11667;
  int D.14154;
  bool retval.225;
  bool D.14140;
  bool D.14138;
  bool disable_menu.224;
  bool iftmp.223;
  bool retval.222;
  struct ImVec2 D.11664;
  int D.14132;
  bool disable_menu.221;
  int iftmp.220;
  bool disable_mouse_wheel.219;
  int iftmp.218;
  int line.217;
  int line.216;
  float D.14107;
  float D.14106;
  struct ImVec2 D.11662;
  bool disable_mouse_wheel.215;
  int iftmp.214;
  bool D.11661;
  struct ImVec2 D.11660;
  bool retval.213;
  bool retval.212;
  struct ImVec2 D.11655;
  float * D.14092;
  double D.14085;
  float D.14084;
  bool D.14081;
  bool D.14079;
  bool iftmp.211;
  bool retval.210;
  float * D.14073;
  int D.14072;
  int D.14071;
  double D.14062;
  float D.14061;
  bool D.14058;
  bool D.14056;
  bool iftmp.209;
  bool retval.208;
  struct ImVec2 D.11648;
  float * D.14050;
  float D.14049;
  float D.14048;
  struct ImColor D.11646;
  struct ImVec4 D.11647;
  float D.14047;
  float D.14046;
  struct ImColor D.11644;
  struct ImVec4 D.11645;
  float D.14045;
  float D.14044;
  struct ImColor D.11642;
  struct ImVec4 D.11643;
  float D.14043;
  float D.14042;
  struct ImColor D.11640;
  struct ImVec4 D.11641;
  struct ImVec2 D.11637;
  struct ImVec2 D.11635;
  bool retval.207;
  bool retval.206;
  bool retval.205;
  struct ImVec2 D.11627;
  bool retval.204;
  struct ImVec2 D.11626;
  bool retval.203;
  bool ref_color.202;
  const float * iftmp.201;
  int inputs_mode.200;
  int inputs_mode.199;
  int inputs_mode.198;
  int inputs_mode.197;
  int picker_mode.196;
  int picker_mode.195;
  bool D.13984;
  bool side_preview.194;
  bool alpha_bar.193;
  bool D.13975;
  bool alpha.192;
  int D.13971;
  bool ref_color.191;
  bool side_preview.190;
  bool D.11622;
  int D.13957;
  bool retval.189;
  unsigned char D.13953;
  bool retval.188;
  struct ImVec2 D.11615;
  __int128 unsigned D.13948;
  struct ImVec4 * D.13947;
  const void * D.13946;
  struct ImVec4 * D.13942;
  const void * D.13941;
  bool retval.187;
  float D.13934;
  float D.13933;
  float D.13932;
  float D.13931;
  struct ImVec4 color.186;
  struct ImVec4 * D.13928;
  struct ImVec2 D.11611;
  bool retval.185;
  float D.13925;
  struct ImGuiStyle & D.13924;
  unsigned int D.13921;
  unsigned int n.184;
  struct ImVec2 D.11609;
  bool retval.183;
  struct ImVec2 D.11608;
  int D.13913;
  bool retval.182;
  struct ImVec2 D.11606;
  bool D.11607;
  struct ImVec2 D.11605;
  bool D.11603;
  int D.13899;
  bool retval.181;
  unsigned char D.13895;
  bool retval.180;
  float D.13892;
  float D.13891;
  float * D.13890;
  float * D.13889;
  float * D.13888;
  bool D.13883;
  bool saved_palette_inited.179;
  long int D.11597;
  struct ImVec4 * D.11596;
  struct ImVec4 * D.11595;
  struct ImVec4 * retval.178;
  bool D.11599;
  int D.13871;
  bool retval.177;
  unsigned char D.13867;
  bool retval.176;
  int D.13865;
  int D.13864;
  int D.13863;
  bool options_menu.175;
  int iftmp.174;
  int D.13857;
  bool alpha_preview.173;
  int iftmp.172;
  bool alpha_half_preview.171;
  int iftmp.170;
  bool hdr.169;
  int iftmp.168;
  struct ImColor D.11584;
  bool D.11587;
  int D.13834;
  bool retval.167;
  unsigned char D.13830;
  bool retval.166;
  bool retval.165;
  float progress.164;
  struct ImVec2 D.11582;
  int D.13823;
  float D.13822;
  float progress.163;
  float iftmp.162;
  float progress.161;
  float iftmp.160;
  float D.13811;
  struct ImGuiStyle & D.13810;
  float progress.159;
  struct ImVec2 D.11579;
  float progress_dir.158;
  float progress_dir.157;
  float progress.156;
  float progress_dir.155;
  float progress_dir.154;
  float progress.153;
  float progress.152;
  float progress.151;
  float D.13793;
  struct ImGuiIO & D.13792;
  float D.13791;
  float progress_dir.150;
  float D.11578;
  bool animate.149;
  int display_count.148;
  struct ImVec2 D.11575;
  int display_count.147;
  struct ImVec2 D.11574;
  int func_type.146;
  float (*<T6b3>) (void *, int) iftmp.145;
  struct ImVec2 D.11557;
  int values_offset.144;
  struct ImVec2 D.11556;
  float refresh_time.143;
  float refresh_time.142;
  float phase.141;
  float phase.140;
  float D.13774;
  float D.13773;
  int values_offset.139;
  int values_offset.138;
  int D.13770;
  int values_offset.137;
  float D.13768;
  float phase.136;
  int values_offset.135;
  float refresh_time.134;
  float D.13763;
  bool retval.133;
  float refresh_time.132;
  float refresh_time.131;
  bool D.13757;
  bool animate.130;
  struct ImVec2 D.11551;
  bool retval.129;
  float D.13749;
  float D.13748;
  struct ImVec2 D.11548;
  bool read_only.128;
  int iftmp.127;
  struct ImVec2 D.11547;
  bool retval.126;
  bool retval.125;
  int D.13730;
  bool D.13727;
  bool D.13726;
  int D.13725;
  int D.13724;
  bool D.13720;
  bool D.13719;
  int D.13718;
  int D.13717;
  bool D.13713;
  bool D.13712;
  int D.13711;
  int D.13710;
  bool D.13706;
  bool D.13705;
  int D.13704;
  int D.13703;
  bool * D.13698;
  struct ImVec2 D.11529;
  bool retval.124;
  bool retval.123;
  bool * D.13687;
  struct ImVec2 D.11526;
  bool retval.122;
  bool retval.121;
  struct ImVec2 D.11522;
  struct ImVec2 D.11521;
  struct ImVec2 D.11520;
  bool retval.120;
  bool D.13674;
  bool D.13673;
  bool D.13669;
  struct ImGuiIO & D.13668;
  bool retval.119;
  int D.13664;
  bool D.13663;
  struct ImVec2 D.11518;
  bool retval.118;
  bool retval.117;
  int D.13652;
  bool D.13651;
  int selected.116;
  struct ImVec2 D.11514;
  bool retval.115;
  bool retval.114;
  bool D.13640;
  bool D.13639;
  bool retval.113;
  int D.13633;
  bool D.13632;
  struct ImVec2 D.11510;
  bool retval.112;
  struct ImVec2 D.11509;
  struct ImVec2 D.11508;
  struct ImVec2 D.11507;
  bool retval.111;
  bool retval.110;
  const char * item_current.109;
  const char * D.13615;
  int D.13614;
  struct ImVec2 D.11494;
  bool retval.108;
  const char * item_current.107;
  const char * D.13611;
  const char * item_current.106;
  int flags.105;
  bool retval.104;
  const char * item_current.103;
  bool D.11491;
  int D.13595;
  bool retval.102;
  unsigned char D.13591;
  bool retval.101;
  int flags.100;
  int flags.99;
  bool retval.98;
  int flags.97;
  int flags.96;
  bool retval.95;
  bool retval.94;
  int pressed_count.93;
  int pressed_count.92;
  int pressed_count.91;
  struct ImVec2 D.11478;
  struct ImVec2 D.11479;
  float D.13567;
  float D.13566;
  struct ImVec2 D.11480;
  struct ImColor D.11481;
  struct ImVec4 D.11482;
  struct ImVec4 D.11483;
  bool retval.90;
  float D.13561;
  float D.13560;
  struct ImVec2 D.11470;
  struct ImColor D.11471;
  struct ImVec4 D.11473;
  struct ImColor D.11472;
  struct ImVec4 D.11474;
  float D.13559;
  float D.13558;
  float region_x.89;
  float D.13556;
  float D.13555;
  float region_y.88;
  float D.13553;
  float region_x.87;
  float D.13551;
  float region_y.86;
  double D.13549;
  float D.13548;
  float region_x.85;
  double D.13546;
  float D.13545;
  float region_y.84;
  double D.13543;
  float region_x.83;
  double D.13541;
  float region_y.82;
  float region_y.81;
  float region_y.80;
  float D.13534;
  float region_y.79;
  float region_y.78;
  float D.13528;
  float D.13527;
  float D.13526;
  float D.13525;
  float region_x.77;
  float region_x.76;
  float D.13519;
  float region_x.75;
  float region_x.74;
  float D.13513;
  float D.13512;
  float D.13511;
  float D.13510;
  bool retval.73;
  struct ImVec2 D.11455;
  struct ImVec2 D.11456;
  struct ImVec2 D.11457;
  struct ImColor D.11458;
  struct ImVec4 D.11460;
  struct ImColor D.11459;
  struct ImVec4 D.11461;
  double D.13506;
  double D.13505;
  int D.13504;
  struct ImFontAtlas * D.13503;
  int D.13502;
  struct ImFontAtlas * D.13501;
  struct ImFontAtlas * D.13500;
  bool retval.72;
  bool retval.71;
  struct ImDrawList * D.13490;
  struct ImVec2 D.11446;
  struct ImVec2 D.11447;
  float D.13489;
  float wrap_width.70;
  float D.13487;
  struct ImVec2 D.11445;
  struct ImDrawList * D.13486;
  float D.13485;
  float wrap_width.69;
  float D.13483;
  float D.13482;
  struct ImVec2 D.11443;
  float D.13481;
  float D.13480;
  float wrap_width.68;
  float D.13478;
  float D.13477;
  float D.13476;
  float D.13475;
  struct ImVec2 D.11444;
  struct ImDrawList * D.13474;
  struct ImVec2 D.11440;
  struct ImVec2 D.11441;
  double D.13473;
  float wrap_width.67;
  float D.13471;
  float wrap_width.66;
  float D.13469;
  struct ImVec2 D.11439;
  struct ImDrawList * D.13468;
  float D.13467;
  float wrap_width.65;
  float D.13465;
  float D.13464;
  struct ImVec2 D.11437;
  float D.13463;
  float D.13462;
  float wrap_width.64;
  float D.13460;
  float D.13459;
  float D.13458;
  float D.13457;
  struct ImVec2 D.11438;
  bool retval.63;
  struct ImVec4 D.11433;
  struct ImVec4 D.11432;
  bool retval.62;
  bool retval.61;
  bool retval.60;
  int D.13438;
  bool D.13437;
  bool retval.59;
  int D.13430;
  bool D.13429;
  bool retval.58;
  bool retval.57;
  float D.13419;
  bool align_label_with_current_x_position.56;
  int selection_mask.55;
  int selection_mask.54;
  int selection_mask.53;
  int D.13410;
  struct ImGuiIO & D.13407;
  bool retval.52;
  bool retval.51;
  const void * D.13399;
  long int D.13398;
  bool retval.50;
  const void * D.13389;
  long int D.13388;
  int D.13385;
  int D.13384;
  int selection_mask.49;
  float D.13380;
  float D.13379;
  float D.13377;
  bool align_label_with_current_x_position.48;
  bool retval.47;
  bool retval.46;
  const void * D.13362;
  long int D.13361;
  bool retval.45;
  bool retval.44;
  bool retval.43;
  struct ImVec2 D.11402;
  bool retval.42;
  bool retval.41;
  bool retval.40;
  bool retval.39;
  struct ImGuiStyle & D.13334;
  struct ImVec2 D.11399;
  float D.13333;
  float D.13332;
  struct ImColor D.11397;
  struct ImVec4 D.11398;
  float D.13331;
  float D.13330;
  struct ImColor D.11395;
  struct ImVec4 D.11396;
  float D.13329;
  float D.13328;
  struct ImColor D.11393;
  struct ImVec4 D.11394;
  int D.13319;
  int clicked.38;
  int clicked.37;
  int clicked.36;
  struct ImVec2 D.11389;
  bool retval.35;
  bool retval.34;
  bool retval.33;
  bool retval.32;
  bool retval.31;
  bool retval.30;
  bool retval.29;
  bool retval.28;
  bool retval.27;
  bool retval.26;
  bool retval.25;
  bool D.13271;
  bool retval.24;
  struct ImVec2 D.11387;
  bool no_close.23;
  bool no_nav.22;
  bool no_collapse.21;
  bool no_resize.20;
  bool no_move.19;
  bool D.13246;
  bool no_menu.18;
  bool no_scrollbar.17;
  bool no_titlebar.16;
  const char * D.13235;
  bool show_app_about.15;
  bool show_app_style_editor.14;
  bool show_app_metrics.13;
  bool show_app_custom_rendering.12;
  bool show_app_window_titles.11;
  bool show_app_fixed_overlay.10;
  bool show_app_constrained_resize.9;
  bool show_app_auto_resize.8;
  bool show_app_long_text.7;
  bool show_app_property_editor.6;
  bool show_app_layout.5;
  bool show_app_log.4;
  bool show_app_console.3;
  bool show_app_main_menu_bar.2;
  struct ImVec4 * _23;
  long int _24;
  int iftmp.127_78;
  float (*<T6b3>) (void *, int) iftmp.145_79;
  float iftmp.160_80;
  float iftmp.162_81;
  int iftmp.168_82;
  int iftmp.170_83;
  int iftmp.172_84;
  int iftmp.174_85;
  const float * iftmp.201_86;
  bool iftmp.209_87;
  bool iftmp.211_88;
  int iftmp.214_89;
  int iftmp.218_90;
  int iftmp.220_91;
  bool iftmp.223_92;
  const char * iftmp.235_93;
  const char * iftmp.236_94;
  const char * iftmp.237_95;
  const char * iftmp.238_96;
  int iftmp.244_97;
  const char * iftmp.245_98;
  const char * iftmp.246_99;
  const char * iftmp.247_100;
  bool iftmp.256_101;
  const char * iftmp.260_102;
  bool iftmp.307_103;
  const char * iftmp.326_104;
  const char * iftmp.327_105;
  const char * iftmp.328_106;
  const char * iftmp.329_107;
  bool iftmp.347_108;
  bool show_app_main_menu_bar.2_422;
  bool show_app_console.3_424;
  bool show_app_log.4_426;
  bool show_app_layout.5_428;
  bool show_app_property_editor.6_430;
  bool show_app_long_text.7_432;
  bool show_app_auto_resize.8_434;
  bool show_app_constrained_resize.9_436;
  bool show_app_fixed_overlay.10_438;
  bool show_app_window_titles.11_440;
  bool show_app_custom_rendering.12_442;
  bool show_app_metrics.13_444;
  bool show_app_style_editor.14_446;
  bool show_app_about.15_450;
  const char * _453;
  const char * _454;
  bool no_titlebar.16_461;
  bool no_scrollbar.17_463;
  bool no_menu.18_465;
  bool _466;
  bool no_move.19_468;
  bool no_resize.20_470;
  bool no_collapse.21_472;
  bool no_nav.22_474;
  bool no_close.23_476;
  bool _483;
  bool _484;
  bool retval.24_485;
  bool _490;
  bool retval.25_491;
  bool _493;
  bool retval.26_494;
  bool _498;
  bool retval.27_499;
  bool _513;
  bool retval.28_514;
  bool _522;
  bool retval.29_523;
  bool _528;
  bool retval.30_529;
  bool _544;
  bool retval.31_545;
  bool _549;
  bool retval.32_550;
  bool _555;
  bool retval.33_556;
  bool _558;
  bool retval.34_559;
  bool _562;
  bool retval.35_563;
  int clicked.36_565;
  int clicked.37_566;
  int clicked.38_568;
  int _569;
  float _581;
  float _582;
  float _588;
  float _589;
  float _595;
  float _596;
  struct ImGuiStyle & _616;
  struct ImGuiStyle & _617;
  bool _620;
  bool retval.39_621;
  bool _624;
  bool retval.40_625;
  bool _628;
  bool retval.41_629;
  bool _634;
  bool retval.42_635;
  bool _706;
  bool retval.43_707;
  bool _709;
  bool retval.44_710;
  long int _712;
  const void * _713;
  bool _715;
  bool retval.45_716;
  bool _720;
  bool retval.46_721;
  bool _726;
  bool retval.47_727;
  bool align_label_with_current_x_position.48_731;
  float _733;
  float _734;
  float _738;
  float _739;
  float _740;
  int selection_mask.49_743;
  int _744;
  int _745;
  long int _747;
  const void * _748;
  bool _750;
  bool _753;
  bool retval.50_754;
  long int _759;
  const void * _760;
  bool _763;
  bool retval.51_764;
  struct ImGuiIO & _768;
  struct ImGuiIO & _769;
  bool retval.52_770;
  int _771;
  int selection_mask.53_772;
  int selection_mask.54_773;
  int selection_mask.55_775;
  bool align_label_with_current_x_position.56_778;
  float _780;
  float _781;
  bool _786;
  bool retval.57_787;
  bool _790;
  bool retval.58_791;
  bool _793;
  bool _794;
  int _795;
  bool _801;
  bool retval.59_802;
  bool _804;
  bool _805;
  int _806;
  bool _813;
  bool retval.60_814;
  bool _823;
  bool retval.61_824;
  bool _826;
  bool retval.62_827;
  bool _841;
  bool retval.63_842;
  float _848;
  float _850;
  float _851;
  float _852;
  float _853;
  float wrap_width.64_854;
  float _855;
  float _856;
  float _858;
  float _859;
  float wrap_width.65_860;
  float _861;
  struct ImDrawList * _864;
  struct ImDrawList * _865;
  float _870;
  float wrap_width.66_871;
  float _872;
  float wrap_width.67_874;
  double _875;
  struct ImDrawList * _880;
  struct ImDrawList * _881;
  float _888;
  float _890;
  float _891;
  float _892;
  float _893;
  float wrap_width.68_894;
  float _895;
  float _896;
  float _898;
  float _899;
  float wrap_width.69_900;
  float _901;
  struct ImDrawList * _904;
  struct ImDrawList * _905;
  float _910;
  float wrap_width.70_911;
  float _912;
  struct ImDrawList * _918;
  struct ImDrawList * _919;
  bool _936;
  bool retval.71_937;
  bool _945;
  bool retval.72_946;
  struct ImGuiIO & _948;
  struct ImFontAtlas * _951;
  struct ImFontAtlas * _953;
  int _954;
  struct ImFontAtlas * _956;
  int _957;
  double _959;
  double _960;
  bool _979;
  bool retval.73_980;
  float _983;
  float _984;
  float _985;
  float _986;
  float region_x.74_987;
  float region_x.75_989;
  float _991;
  float region_x.76_992;
  float region_x.77_993;
  float _995;
  float _996;
  float _997;
  float _998;
  float region_y.78_999;
  float region_y.79_1001;
  float _1003;
  float region_y.80_1004;
  float region_y.81_1005;
  float region_y.82_1008;
  double _1009;
  float region_x.83_1010;
  double _1011;
  float region_y.84_1013;
  float _1014;
  double _1015;
  float region_x.85_1016;
  float _1017;
  double _1018;
  float region_y.86_1020;
  float _1021;
  float region_x.87_1022;
  float _1023;
  float region_y.88_1025;
  float _1026;
  float _1027;
  float region_x.89_1028;
  float _1029;
  float _1030;
  float _1036;
  float _1037;
  float _1066;
  float _1067;
  bool _1072;
  bool retval.90_1073;
  int pressed_count.91_1080;
  int pressed_count.92_1081;
  int pressed_count.93_1093;
  bool _1106;
  bool retval.94_1107;
  bool _1110;
  bool retval.95_1111;
  int flags.96_1112;
  int flags.97_1113;
  bool _1116;
  bool retval.98_1117;
  int flags.99_1118;
  int flags.100_1119;
  unsigned char _1136;
  bool retval.101_1137;
  int _1139;
  bool retval.102_1140;
  bool _1141;
  const char * item_current.103_1142;
  bool _1144;
  int flags.105_1146;
  const char * item_current.106_1147;
  bool _1149;
  bool retval.104_1150;
  const char * _1152;
  const char * item_current.107_1153;
  int _1156;
  const char * _1157;
  bool _1159;
  bool retval.108_1160;
  const char * item_current.109_1162;
  bool _1175;
  bool retval.110_1176;
  bool _1178;
  bool retval.111_1179;
  bool _1191;
  int _1192;
  bool _1194;
  bool retval.112_1195;
  bool _1198;
  bool retval.113_1199;
  bool _1200;
  bool _1201;
  bool _1209;
  bool retval.114_1210;
  int selected.116_1214;
  bool _1215;
  int _1216;
  bool _1218;
  bool retval.115_1219;
  bool _1228;
  bool retval.117_1229;
  bool _1234;
  int _1235;
  bool _1237;
  bool retval.118_1238;
  struct ImGuiIO & _1241;
  struct ImGuiIO & _1242;
  bool _1243;
  bool retval.119_1244;
  bool _1246;
  bool _1247;
  bool _1255;
  bool retval.120_1256;
  bool _1277;
  bool retval.121_1278;
  bool * _1283;
  bool _1285;
  bool retval.122_1286;
  bool _1296;
  bool retval.123_1297;
  bool * _1301;
  bool _1303;
  bool retval.124_1304;
  int _1308;
  int _1309;
  bool _1310;
  bool _1311;
  int _1313;
  int _1314;
  bool _1315;
  bool _1316;
  int _1318;
  int _1319;
  bool _1320;
  bool _1321;
  int _1323;
  int _1324;
  bool _1325;
  bool _1326;
  int _1328;
  bool _1336;
  bool retval.125_1337;
  bool _1351;
  bool retval.126_1352;
  bool read_only.128_1358;
  int iftmp.127_1359;
  int iftmp.127_1360;
  float _1362;
  float _1363;
  float _1364;
  bool _1372;
  bool retval.129_1373;
  bool animate.130_1378;
  bool _1379;
  float refresh_time.131_1380;
  float _1382;
  float refresh_time.132_1383;
  float _1386;
  float _1387;
  float refresh_time.134_1388;
  bool retval.133_1389;
  int values_offset.135_1390;
  float phase.136_1391;
  float _1392;
  int values_offset.137_1394;
  int _1395;
  int values_offset.138_1396;
  int values_offset.139_1398;
  float _1399;
  float _1400;
  float phase.140_1401;
  float phase.141_1402;
  float refresh_time.142_1404;
  float refresh_time.143_1405;
  int values_offset.144_1408;
  int func_type.146_1420;
  float (*<T6b3>) (void *, int) iftmp.145_1421;
  float (*<T6b3>) (void *, int) iftmp.145_1422;
  int display_count.147_1425;
  int display_count.148_1429;
  bool animate.149_1433;
  float progress_dir.150_1434;
  float _1435;
  struct ImGuiIO & _1437;
  struct ImGuiIO & _1438;
  float _1439;
  float _1440;
  float progress.151_1441;
  float progress.152_1442;
  float progress.153_1444;
  float progress_dir.154_1446;
  float progress_dir.155_1447;
  float progress.156_1449;
  float progress_dir.157_1451;
  float progress_dir.158_1452;
  float progress.159_1455;
  struct ImGuiStyle & _1459;
  struct ImGuiStyle & _1460;
  float _1461;
  float progress.161_1464;
  float iftmp.160_1465;
  float progress.163_1466;
  float iftmp.162_1467;
  float iftmp.162_1468;
  float iftmp.160_1469;
  float _1471;
  int _1472;
  float progress.164_1475;
  bool _1489;
  bool retval.165_1490;
  unsigned char _1492;
  bool retval.166_1493;
  int _1495;
  bool retval.167_1496;
  bool _1497;
  bool _1500;
  bool hdr.169_1511;
  int iftmp.168_1512;
  int iftmp.168_1513;
  bool alpha_half_preview.171_1514;
  int iftmp.170_1515;
  bool alpha_preview.173_1516;
  int iftmp.172_1517;
  int iftmp.172_1518;
  int iftmp.170_1519;
  int _1520;
  bool options_menu.175_1521;
  int iftmp.174_1522;
  int iftmp.174_1523;
  int _1530;
  int _1533;
  int _1538;
  unsigned char _1542;
  bool retval.176_1543;
  int _1545;
  bool retval.177_1546;
  bool _1547;
  struct ImVec4 * _1548;
  struct ImVec4 * _1549;
  long int _1550;
  struct ImVec4 * _1552;
  long int _1553;
  struct ImVec4 * retval.178_1554;
  bool _1555;
  bool saved_palette_inited.179_1557;
  bool _1558;
  float * _1560;
  float * _1561;
  float * _1562;
  float _1563;
  float _1564;
  unsigned char _1570;
  bool retval.180_1571;
  int _1573;
  bool retval.181_1574;
  bool _1575;
  bool _1577;
  bool _1581;
  bool _1587;
  bool _1588;
  bool _1594;
  bool retval.182_1595;
  int _1598;
  bool _1609;
  bool retval.183_1610;
  unsigned int n.184_1617;
  unsigned int _1618;
  struct ImGuiStyle & _1620;
  struct ImGuiStyle & _1621;
  float _1622;
  struct ImVec4 * _1625;
  bool _1627;
  bool retval.185_1628;
  float _1630;
  float _1631;
  float _1632;
  float _1633;
  bool _1638;
  bool retval.187_1639;
  const struct ImGuiPayload * _1641;
  const void * _1643;
  struct ImVec4 * _1644;
  const struct ImGuiPayload * _1647;
  const void * _1649;
  struct ImVec4 * _1650;
  __int128 unsigned _1651;
  unsigned char _1667;
  bool retval.188_1668;
  int _1670;
  bool retval.189_1671;
  bool _1672;
  bool _1674;
  bool side_preview.190_1679;
  bool ref_color.191_1682;
  int _1684;
  bool alpha.192_1691;
  bool _1692;
  bool alpha_bar.193_1694;
  bool side_preview.194_1696;
  bool _1697;
  int picker_mode.195_1699;
  int picker_mode.196_1701;
  int inputs_mode.197_1703;
  int inputs_mode.198_1705;
  int inputs_mode.199_1707;
  int inputs_mode.200_1709;
  bool ref_color.202_1711;
  const float * iftmp.201_1712;
  const float * iftmp.201_1713;
  bool _1720;
  bool retval.203_1721;
  bool _1727;
  bool retval.204_1728;
  bool _1738;
  bool retval.205_1739;
  bool _1744;
  bool retval.206_1745;
  bool _1768;
  bool retval.207_1769;
  float _1782;
  float _1783;
  float _1789;
  float _1790;
  float _1796;
  float _1797;
  float _1803;
  float _1804;
  float * _1810;
  bool _1815;
  bool _1816;
  bool _1818;
  bool _1819;
  bool iftmp.209_1820;
  bool iftmp.209_1821;
  bool retval.208_1822;
  float _1823;
  double _1824;
  int _1847;
  int _1848;
  float * _1850;
  bool _1853;
  bool _1854;
  bool _1856;
  bool _1857;
  bool iftmp.211_1858;
  bool iftmp.211_1859;
  bool retval.210_1860;
  float _1861;
  double _1862;
  float * _1875;
  bool _1891;
  bool retval.212_1892;
  bool _1894;
  bool retval.213_1895;
  bool _1900;
  bool _1906;
  bool _1907;
  bool disable_mouse_wheel.215_1910;
  int iftmp.214_1911;
  int iftmp.214_1912;
  float _1914;
  float _1915;
  float _1916;
  int line.216_1922;
  int line.217_1925;
  bool disable_mouse_wheel.219_1930;
  int iftmp.218_1931;
  int iftmp.218_1932;
  bool disable_menu.221_1933;
  int iftmp.220_1934;
  int iftmp.220_1935;
  int _1936;
  bool disable_menu.224_1940;
  bool _1941;
  bool _1943;
  bool _1944;
  bool iftmp.223_1945;
  bool iftmp.223_1946;
  bool retval.222_1947;
  bool _1949;
  bool retval.225_1950;
  int _1957;
  bool _1973;
  bool retval.226_1974;
  float _1985;
  float _1986;
  float _1987;
  float _1995;
  float _1996;
  float _1997;
  bool _2015;
  bool retval.227_2016;
  int * _2082;
  bool _2104;
  bool retval.228_2105;
  bool _2131;
  bool retval.229_2132;
  float _2141;
  float _2142;
  struct ImGuiStyle & _2144;
  struct ImGuiStyle & _2145;
  float _2146;
  float _2147;
  float _2148;
  float _2153;
  float _2154;
  struct ImGuiStyle & _2156;
  struct ImGuiStyle & _2157;
  float _2158;
  float _2159;
  float _2160;
  bool _2191;
  bool retval.230_2192;
  struct ImGuiStyle & _2242;
  struct ImGuiStyle & _2243;
  bool _2250;
  bool retval.231_2251;
  bool _2258;
  bool _2290;
  bool retval.232_2291;
  bool _2297;
  bool _2298;
  bool track.233_2299;
  bool track.234_2300;
  bool _2304;
  bool _2309;
  bool _2310;
  const char * iftmp.238_2317;
  const char * iftmp.238_2318;
  const char * iftmp.237_2319;
  const char * iftmp.237_2320;
  const char * iftmp.236_2321;
  const char * iftmp.236_2322;
  const char * iftmp.235_2323;
  const char * iftmp.235_2324;
  float _2327;
  float _2328;
  float _2329;
  long int _2331;
  const void * _2332;
  unsigned int _2334;
  unsigned int _2335;
  float _2338;
  float _2339;
  float _2341;
  int scroll_to_px.239_2342;
  float _2343;
  float _2344;
  bool track.240_2347;
  int track_line.241_2348;
  float _2354;
  float _2355;
  float _2362;
  float _2365;
  double _2368;
  double _2369;
  bool _2377;
  bool retval.242_2378;
  float _2389;
  float _2390;
  float _2391;
  float _2392;
  int lines.243_2397;
  int _2398;
  int _2399;
  int iftmp.244_2400;
  int _2401;
  int iftmp.244_2402;
  int _2406;
  int _2407;
  int _2410;
  int _2411;
  int _2412;
  const char * iftmp.247_2413;
  const char * iftmp.247_2414;
  const char * iftmp.246_2415;
  const char * iftmp.246_2416;
  const char * iftmp.245_2417;
  const char * iftmp.245_2418;
  float _2420;
  int _2437;
  float _2438;
  float _2439;
  float _2440;
  float _2441;
  float _2459;
  float _2462;
  bool _2469;
  bool retval.248_2470;
  struct ImGuiIO & _2472;
  struct ImGuiIO & _2473;
  float _2474;
  float _2475;
  bool _2482;
  bool retval.249_2483;
  struct ImGuiIO & _2485;
  struct ImGuiIO & _2486;
  float _2487;
  double _2490;
  double _2491;
  float _2497;
  float _2498;
  float _2499;
  bool _2507;
  bool retval.250_2508;
  unsigned char _2510;
  bool retval.251_2511;
  int _2513;
  bool retval.252_2514;
  bool _2515;
  bool _2517;
  unsigned char _2520;
  bool retval.253_2521;
  int _2523;
  bool retval.254_2524;
  bool _2525;
  bool _2527;
  float _2533;
  float _2534;
  float _2535;
  float _2536;
  float _2537;
  float _2538;
  float _2539;
  float _2540;
  bool _2544;
  bool _2545;
  bool _2547;
  bool _2548;
  bool iftmp.256_2549;
  bool iftmp.256_2550;
  bool retval.255_2551;
  struct ImGuiIO & _2553;
  struct ImGuiIO & _2554;
  float _2555;
  float _2556;
  float _2557;
  struct ImGuiIO & _2560;
  struct ImGuiIO & _2561;
  float _2562;
  float _2563;
  float _2564;
  float _2566;
  float _2567;
  float _2568;
  float _2569;
  float _2570;
  float _2571;
  struct ImDrawList * _2574;
  struct ImDrawList * _2575;
  float _2578;
  float _2579;
  float _2580;
  float _2581;
  float _2582;
  float _2583;
  float _2586;
  float _2587;
  float _2588;
  struct ImFont * _2590;
  struct ImFont * _2591;
  struct ImDrawList * _2593;
  struct ImDrawList * _2594;
  bool _2605;
  bool retval.257_2606;
  bool _2608;
  bool retval.258_2609;
  bool _2618;
  bool retval.259_2619;
  int selected_fish.261_2623;
  int selected_fish.262_2624;
  const char * iftmp.260_2625;
  const char * iftmp.260_2626;
  bool _2629;
  bool retval.263_2630;
  const char * _2635;
  bool _2637;
  bool retval.264_2638;
  bool _2646;
  bool retval.265_2647;
  bool _2651;
  bool retval.266_2652;
  bool * _2654;
  const char * _2655;
  bool _2659;
  bool retval.267_2660;
  bool _2666;
  bool retval.268_2667;
  bool _2671;
  bool retval.269_2672;
  bool _2676;
  bool retval.270_2677;
  bool * _2679;
  const char * _2680;
  bool _2684;
  bool retval.271_2685;
  bool _2693;
  bool retval.272_2694;
  bool _2698;
  bool retval.273_2699;
  bool _2709;
  bool retval.274_2710;
  float value.275_2711;
  double _2712;
  bool _2715;
  bool retval.276_2716;
  bool _2719;
  bool retval.277_2720;
  bool _2725;
  bool retval.278_2726;
  bool _2740;
  bool retval.279_2741;
  bool _2746;
  bool retval.280_2747;
  bool _2759;
  bool retval.281_2760;
  bool _2764;
  bool retval.282_2765;
  bool _2769;
  bool retval.283_2770;
  bool _2780;
  bool retval.284_2781;
  bool _2788;
  bool retval.285_2789;
  bool _2798;
  bool retval.286_2799;
  bool _2803;
  bool retval.287_2804;
  bool _2810;
  bool retval.288_2811;
  bool _2815;
  bool retval.289_2816;
  bool _2820;
  bool retval.290_2821;
  bool _2828;
  bool retval.291_2829;
  bool _2839;
  bool retval.292_2840;
  bool _2846;
  bool retval.293_2847;
  bool _2854;
  bool retval.294_2855;
  bool _2858;
  bool retval.295_2859;
  bool _2867;
  bool retval.296_2868;
  int selected.298_2898;
  bool _2899;
  int _2900;
  bool _2902;
  bool retval.297_2903;
  bool _2907;
  const char * _2910;
  const char * _2913;
  int _2916;
  bool _2931;
  bool retval.299_2932;
  bool _2954;
  bool retval.300_2955;
  bool _2959;
  bool retval.301_2960;
  bool _2964;
  bool retval.302_2965;
  bool _2975;
  bool retval.303_2976;
  bool _2988;
  bool retval.304_2989;
  bool v_borders.305_2993;
  int _2994;
  bool h_borders.308_2997;
  int _2999;
  int _3000;
  bool iftmp.307_3001;
  bool iftmp.307_3002;
  bool retval.306_3003;
  int _3005;
  int _3006;
  int _3007;
  float _3010;
  float _3011;
  double _3012;
  float _3014;
  float _3015;
  double _3016;
  bool h_borders.309_3021;
  bool _3025;
  bool retval.310_3026;
  float _3031;
  float _3032;
  float _3033;
  bool _3041;
  bool retval.311_3042;
  int _3044;
  bool _3060;
  bool _3067;
  bool retval.312_3068;
  bool _3073;
  bool retval.313_3074;
  bool _3083;
  bool retval.314_3084;
  unsigned char _3086;
  bool retval.315_3087;
  int _3089;
  bool retval.316_3090;
  bool _3091;
  bool _3093;
  const char * _3108;
  bool _3110;
  bool retval.317_3111;
  const char * _3112;
  bool _3118;
  bool retval.318_3119;
  struct ImGuiIO & _3121;
  bool _3123;
  int _3124;
  bool _3126;
  int _3127;
  bool _3129;
  int _3130;
  bool _3132;
  int _3133;
  bool _3135;
  int _3136;
  bool _3137;
  int _3138;
  bool * _3140;
  ImGuiConfigFlags * _3144;
  ImGuiConfigFlags * _3146;
  ImGuiConfigFlags * _3148;
  ImGuiConfigFlags * _3152;
  bool _3157;
  bool retval.319_3158;
  bool _3160;
  bool retval.320_3161;
  float _3162;
  double _3163;
  float _3164;
  double _3165;
  float _3170;
  float _3172;
  double _3173;
  bool _3179;
  bool retval.321_3180;
  bool _3187;
  bool retval.322_3188;
  bool _3195;
  bool retval.323_3196;
  float _3200;
  double _3201;
  float _3205;
  float _3207;
  double _3208;
  bool _3214;
  bool retval.324_3215;
  bool _3222;
  bool retval.325_3223;
  bool _3227;
  const char * iftmp.326_3228;
  const char * iftmp.326_3229;
  bool _3230;
  const char * iftmp.327_3231;
  const char * iftmp.327_3232;
  bool _3233;
  const char * iftmp.328_3234;
  const char * iftmp.328_3235;
  bool _3236;
  const char * iftmp.329_3237;
  const char * iftmp.329_3238;
  float _3242;
  float _3244;
  double _3245;
  float _3250;
  float _3256;
  float _3258;
  double _3259;
  bool _3266;
  bool retval.330_3267;
  bool _3274;
  bool retval.331_3275;
  bool _3281;
  bool retval.332_3282;
  bool _3293;
  bool retval.333_3294;
  bool _3297;
  bool _3303;
  bool _3309;
  bool _3316;
  bool retval.334_3317;
  bool _3322;
  bool retval.335_3323;
  bool _3329;
  bool retval.336_3330;
  bool _3338;
  bool retval.337_3339;
  bool _3345;
  bool retval.338_3346;
  bool _3352;
  bool retval.339_3353;
  bool _3367;
  bool retval.340_3368;
  bool embed_all_inside_a_child_window.341_3370;
  float _3372;
  float _3373;
  float _3374;
  bool _3380;
  bool _3381;
  int _3382;
  bool _3384;
  bool _3385;
  int _3386;
  bool _3388;
  bool _3389;
  int _3390;
  bool _3392;
  bool _3393;
  int _3394;
  bool _3396;
  bool _3397;
  int _3398;
  bool _3401;
  bool _3402;
  int _3403;
  bool _3405;
  bool _3406;
  int _3407;
  bool _3409;
  bool _3410;
  int _3411;
  bool _3413;
  bool _3414;
  int _3415;
  bool _3417;
  bool _3418;
  int _3419;
  bool _3421;
  bool _3422;
  int _3423;
  bool _3425;
  bool _3426;
  int _3427;
  bool _3433;
  bool _3434;
  int _3435;
  bool _3437;
  bool _3438;
  int _3439;
  bool _3441;
  bool _3442;
  int _3443;
  bool _3445;
  bool _3446;
  int _3447;
  bool _3449;
  bool _3450;
  int _3451;
  bool embed_all_inside_a_child_window.342_3458;
  bool _3464;
  bool retval.343_3465;
  bool _3469;
  bool _3470;
  int _3471;
  bool _3473;
  bool _3474;
  int _3475;
  bool _3477;
  bool _3478;
  int _3479;
  bool _3486;
  bool retval.344_3487;
  struct ImDrawList * _3489;
  unsigned int _3493;
  unsigned int _3494;
  struct ImVec2 * _3495;
  struct ImVec2 * _3496;
  float _3503;
  double _3504;
  float _3505;
  double _3506;
  float _3507;
  double _3508;
  float _3509;
  double _3510;
  float _3511;
  double _3512;
  float _3513;
  double _3514;
  bool _3525;
  bool retval.345_3526;
  int _3535;
  int _3536;
  const char * _3537;
  int _3539;
  int _3540;
  const char * _3546;
  bool _3553;
  bool _3554;
  bool _3556;
  bool _3557;
  bool iftmp.347_3558;
  bool iftmp.347_3559;
  bool retval.346_3560;

  <bb 2>:
  show_app_main_menu_bar.2_422 = show_app_main_menu_bar;
  if (show_app_main_menu_bar.2_422 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ShowExampleAppMainMenuBar ();

  <bb 4>:
  show_app_console.3_424 = show_app_console;
  if (show_app_console.3_424 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ShowExampleAppConsole (&show_app_console);

  <bb 6>:
  show_app_log.4_426 = show_app_log;
  if (show_app_log.4_426 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ShowExampleAppLog (&show_app_log);

  <bb 8>:
  show_app_layout.5_428 = show_app_layout;
  if (show_app_layout.5_428 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  ShowExampleAppLayout (&show_app_layout);

  <bb 10>:
  show_app_property_editor.6_430 = show_app_property_editor;
  if (show_app_property_editor.6_430 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  ShowExampleAppPropertyEditor (&show_app_property_editor);

  <bb 12>:
  show_app_long_text.7_432 = show_app_long_text;
  if (show_app_long_text.7_432 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  ShowExampleAppLongText (&show_app_long_text);

  <bb 14>:
  show_app_auto_resize.8_434 = show_app_auto_resize;
  if (show_app_auto_resize.8_434 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  ShowExampleAppAutoResize (&show_app_auto_resize);

  <bb 16>:
  show_app_constrained_resize.9_436 = show_app_constrained_resize;
  if (show_app_constrained_resize.9_436 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  ShowExampleAppConstrainedResize (&show_app_constrained_resize);

  <bb 18>:
  show_app_fixed_overlay.10_438 = show_app_fixed_overlay;
  if (show_app_fixed_overlay.10_438 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  ShowExampleAppFixedOverlay (&show_app_fixed_overlay);

  <bb 20>:
  show_app_window_titles.11_440 = show_app_window_titles;
  if (show_app_window_titles.11_440 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  ShowExampleAppWindowTitles (&show_app_window_titles);

  <bb 22>:
  show_app_custom_rendering.12_442 = show_app_custom_rendering;
  if (show_app_custom_rendering.12_442 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  ShowExampleAppCustomRendering (&show_app_custom_rendering);

  <bb 24>:
  show_app_metrics.13_444 = show_app_metrics;
  if (show_app_metrics.13_444 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  ImGui::ShowMetricsWindow (&show_app_metrics);

  <bb 26>:
  show_app_style_editor.14_446 = show_app_style_editor;
  if (show_app_style_editor.14_446 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  ImGui::Begin ("Style Editor", &show_app_style_editor, 0);
  ImGui::ShowStyleEditor (0B);
  ImGui::End ();

  <bb 28>:
  show_app_about.15_450 = show_app_about;
  if (show_app_about.15_450 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  ImGui::Begin ("About Dear ImGui", &show_app_about, 64);
  _453 = ImGui::GetVersion ();
  _454 = _453;
  ImGui::Text ("Dear ImGui, %s", _454);
  ImGui::Separator ();
  ImGui::Text ("By Omar Cornut and all dear imgui contributors.");
  ImGui::Text ("Dear ImGui is licensed under the MIT License, see LICENSE for more information.");
  ImGui::End ();

  <bb 30>:
  window_flags_460 = 0;
  no_titlebar.16_461 = no_titlebar;
  if (no_titlebar.16_461 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  window_flags_462 = window_flags_460 | 1;

  <bb 32>:
  # window_flags_2 = PHI <window_flags_460(30), window_flags_462(31)>
  no_scrollbar.17_463 = no_scrollbar;
  if (no_scrollbar.17_463 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  window_flags_464 = window_flags_2 | 8;

  <bb 34>:
  # window_flags_3 = PHI <window_flags_2(32), window_flags_464(33)>
  no_menu.18_465 = no_menu;
  _466 = ~no_menu.18_465;
  if (_466 != 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  window_flags_467 = window_flags_3 | 1024;

  <bb 36>:
  # window_flags_4 = PHI <window_flags_3(34), window_flags_467(35)>
  no_move.19_468 = no_move;
  if (no_move.19_468 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  window_flags_469 = window_flags_4 | 4;

  <bb 38>:
  # window_flags_5 = PHI <window_flags_4(36), window_flags_469(37)>
  no_resize.20_470 = no_resize;
  if (no_resize.20_470 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  window_flags_471 = window_flags_5 | 2;

  <bb 40>:
  # window_flags_6 = PHI <window_flags_5(38), window_flags_471(39)>
  no_collapse.21_472 = no_collapse;
  if (no_collapse.21_472 != 0)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  window_flags_473 = window_flags_6 | 32;

  <bb 42>:
  # window_flags_7 = PHI <window_flags_6(40), window_flags_473(41)>
  no_nav.22_474 = no_nav;
  if (no_nav.22_474 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  window_flags_475 = window_flags_7 | 786432;

  <bb 44>:
  # window_flags_8 = PHI <window_flags_7(42), window_flags_475(43)>
  no_close.23_476 = no_close;
  if (no_close.23_476 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  p_open_478 = 0B;

  <bb 46>:
  # p_open_1 = PHI <p_open_477(D)(44), p_open_478(45)>
  ImVec2::ImVec2 (&D.11387, 5.5e+2, 6.8e+2);
  ImGui::SetNextWindowSize (&D.11387, 4);
  D.11387 ={v} {CLOBBER};
  _483 = ImGui::Begin ("ImGui Demo", p_open_1, window_flags_8);
  _484 = _483;
  retval.24_485 = ~_484;
  if (retval.24_485 != 0)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  ImGui::End ();
  goto <bb 774> (<L1036>);

  <bb 48>:
  ImGui::PushItemWidth (-1.4e+2);
  ImGui::Text ("dear imgui says hello. (%s)", "1.60");
  _490 = ImGui::BeginMenuBar ();
  retval.25_491 = _490;
  if (retval.25_491 != 0)
    goto <bb 49>;
  else
    goto <bb 56>;

  <bb 49>:
  _493 = ImGui::BeginMenu ("Menu", 1);
  retval.26_494 = _493;
  if (retval.26_494 != 0)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  ShowExampleMenuFile ();
  ImGui::EndMenu ();

  <bb 51>:
  _498 = ImGui::BeginMenu ("Examples", 1);
  retval.27_499 = _498;
  if (retval.27_499 != 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  ImGui::MenuItem ("Main menu bar", 0B, &show_app_main_menu_bar, 1);
  ImGui::MenuItem ("Console", 0B, &show_app_console, 1);
  ImGui::MenuItem ("Log", 0B, &show_app_log, 1);
  ImGui::MenuItem ("Simple layout", 0B, &show_app_layout, 1);
  ImGui::MenuItem ("Property editor", 0B, &show_app_property_editor, 1);
  ImGui::MenuItem ("Long text display", 0B, &show_app_long_text, 1);
  ImGui::MenuItem ("Auto-resizing window", 0B, &show_app_auto_resize, 1);
  ImGui::MenuItem ("Constrained-resizing window", 0B, &show_app_constrained_resize, 1);
  ImGui::MenuItem ("Simple overlay", 0B, &show_app_fixed_overlay, 1);
  ImGui::MenuItem ("Manipulating window titles", 0B, &show_app_window_titles, 1);
  ImGui::MenuItem ("Custom rendering", 0B, &show_app_custom_rendering, 1);
  ImGui::EndMenu ();

  <bb 53>:
  _513 = ImGui::BeginMenu ("Help", 1);
  retval.28_514 = _513;
  if (retval.28_514 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  ImGui::MenuItem ("Metrics", 0B, &show_app_metrics, 1);
  ImGui::MenuItem ("Style Editor", 0B, &show_app_style_editor, 1);
  ImGui::MenuItem ("About Dear ImGui", 0B, &show_app_about, 1);
  ImGui::EndMenu ();

  <bb 55>:
  ImGui::EndMenuBar ();

  <bb 56>:
  ImGui::Spacing ();
  _522 = ImGui::CollapsingHeader ("Help", 0);
  retval.29_523 = _522;
  if (retval.29_523 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  ImGui::TextWrapped ("This window is being created by the ShowDemoWindow() function. Please refer to the code in imgui_demo.cpp for reference.\n\n");
  ImGui::Text ("USER GUIDE:");
  ImGui::ShowUserGuide ();

  <bb 58>:
  _528 = ImGui::CollapsingHeader ("Window options", 0);
  retval.30_529 = _528;
  if (retval.30_529 != 0)
    goto <bb 59>;
  else
    goto <bb 63>;

  <bb 59>:
  ImGui::Checkbox ("No titlebar", &no_titlebar);
  ImGui::SameLine (1.5e+2, -1.0e+0);
  ImGui::Checkbox ("No scrollbar", &no_scrollbar);
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::Checkbox ("No menu", &no_menu);
  ImGui::Checkbox ("No move", &no_move);
  ImGui::SameLine (1.5e+2, -1.0e+0);
  ImGui::Checkbox ("No resize", &no_resize);
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::Checkbox ("No collapse", &no_collapse);
  ImGui::Checkbox ("No close", &no_close);
  ImGui::SameLine (1.5e+2, -1.0e+0);
  ImGui::Checkbox ("No nav", &no_nav);
  _544 = ImGui::TreeNode ("Style");
  retval.31_545 = _544;
  if (retval.31_545 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  ImGui::ShowStyleEditor (0B);
  ImGui::TreePop ();

  <bb 61>:
  _549 = ImGui::TreeNode ("Capture/Logging");
  retval.32_550 = _549;
  if (retval.32_550 != 0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  ImGui::TextWrapped ("The logging API redirects all text output so you can easily capture the content of a window or a block. Tree nodes can be automatically expanded. You can also call ImGui::LogText() to output directly to the log without a visual output.");
  ImGui::LogButtons ();
  ImGui::TreePop ();

  <bb 63>:
  _555 = ImGui::CollapsingHeader ("Widgets", 0);
  retval.33_556 = _555;
  if (retval.33_556 != 0)
    goto <bb 64>;
  else
    goto <bb 368>;

  <bb 64>:
  _558 = ImGui::TreeNode ("Basic");
  retval.34_559 = _558;
  if (retval.34_559 != 0)
    goto <bb 65>;
  else
    goto <bb 81>;

  <bb 65>:
  ImVec2::ImVec2 (&D.11389, 0.0, 0.0);
  _562 = ImGui::Button ("Button", &D.11389);
  retval.35_563 = _562;
  D.11389 ={v} {CLOBBER};
  if (retval.35_563 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  clicked.36_565 = clicked;
  clicked.37_566 = clicked.36_565 + 1;
  clicked = clicked.37_566;

  <bb 67>:
  clicked.38_568 = clicked;
  _569 = clicked.38_568 & 1;
  if (_569 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Thanks for clicking me!");

  <bb 69>:
  ImGui::Checkbox ("checkbox", &check);
  ImGui::RadioButton ("radio a", &e, 0);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::RadioButton ("radio b", &e, 1);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::RadioButton ("radio c", &e, 2);
  i_578 = 0;

  <bb 70>:
  # i_9 = PHI <i_578(69), i_607(73)>
  if (i_9 > 6)
    goto <bb 74>;
  else
    goto <bb 71>;

  <bb 71>:
  if (i_9 > 0)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 73>:
  ImGui::PushID (i_9);
  _581 = (float) i_9;
  _582 = _581 / 7.0e+0;
  D.11393 = ImColor::HSV (_582, 6.0000002384185791015625e-1, 6.0000002384185791015625e-1, 1.0e+0);
  D.11394 = ImColor::operator ImVec4 (&D.11393);
  ImGui::PushStyleColor (21, &D.11394);
  D.11394 ={v} {CLOBBER};
  D.11393 ={v} {CLOBBER};
  _588 = (float) i_9;
  _589 = _588 / 7.0e+0;
  D.11395 = ImColor::HSV (_589, 6.99999988079071044921875e-1, 6.99999988079071044921875e-1, 1.0e+0);
  D.11396 = ImColor::operator ImVec4 (&D.11395);
  ImGui::PushStyleColor (22, &D.11396);
  D.11396 ={v} {CLOBBER};
  D.11395 ={v} {CLOBBER};
  _595 = (float) i_9;
  _596 = _595 / 7.0e+0;
  D.11397 = ImColor::HSV (_596, 8.00000011920928955078125e-1, 8.00000011920928955078125e-1, 1.0e+0);
  D.11398 = ImColor::operator ImVec4 (&D.11397);
  ImGui::PushStyleColor (23, &D.11398);
  D.11398 ={v} {CLOBBER};
  D.11397 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11399, 0.0, 0.0);
  ImGui::Button ("Click", &D.11399);
  D.11399 ={v} {CLOBBER};
  ImGui::PopStyleColor (3);
  ImGui::PopID ();
  i_607 = i_9 + 1;
  goto <bb 70>;

  <bb 74>:
  _616 = ImGui::GetStyle ();
  _617 = _616;
  spacing_618 = _617->ItemInnerSpacing.x;
  _620 = ImGui::ArrowButton ("##left", 0);
  retval.39_621 = _620;

  <bb 75>:
  ImGui::SameLine (0.0, spacing_618);
  _624 = ImGui::ArrowButton ("##left", 1);
  retval.40_625 = _624;

  <bb 76>:
  ImGui::Text ("Hover over me");
  _628 = ImGui::IsItemHovered (0);
  retval.41_629 = _628;
  if (retval.41_629 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  ImGui::SetTooltip ("I am a tooltip");

  <bb 78>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("- or me");
  _634 = ImGui::IsItemHovered (0);
  retval.42_635 = _634;
  if (retval.42_635 != 0)
    goto <bb 79>;
  else
    goto <bb 80>;

  <bb 79>:
  ImGui::BeginTooltip ();
  ImGui::Text ("I am a fancy tooltip");
  ImVec2::ImVec2 (&D.11402, 0.0, 0.0);
  ImGui::PlotLines ("Curve", &arr, 7, 0, 0B, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38, D.11402, 4);
  D.11402 ={v} {CLOBBER};
  ImGui::EndTooltip ();

  <bb 80>:
  ImGui::Separator ();
  ImGui::LabelText ("label", "Value");
  items[0] = "AAAA";
  items[1] = "BBBB";
  items[2] = "CCCC";
  items[3] = "DDDD";
  items[4] = "EEEE";
  items[5] = "FFFF";
  items[6] = "GGGG";
  items[7] = "HHHH";
  items[8] = "IIII";
  items[9] = "JJJJ";
  items[10] = "KKKK";
  items[11] = "LLLLLLL";
  items[12] = "MMMM";
  items[13] = "OOOOOOO";
  ImGui::Combo ("combo", &item_current, &items, 14, -1);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Refer to the \"Combo\" section below for an explanation of the full BeginCombo/EndCombo API, and demonstration of various flags.\n");
  items ={v} {CLOBBER};
  ImGui::InputText ("input text", &str0, 128, 0, 0B, 0B);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Hold SHIFT or use mouse to select text.\nCTRL+Left/Right to word jump.\nCTRL+A or double-click to select all.\nCTRL+X,CTRL+C,CTRL+V clipboard.\nCTRL+Z,CTRL+Y undo/redo.\nESCAPE to revert.\n");
  ImGui::InputInt ("input int", &i0, 1, 100, 0);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("You can apply arithmetic operators +,*,/ on numerical values.\n  e.g. [ 100 ], input \'*2\', result becomes [ 200 ]\nUse +- to subtract.\n");
  ImGui::InputFloat ("input float", &f0, 9.99999977648258209228515625e-3, 1.0e+0, -1, 0);
  ImGui::InputDouble ("input double", &d0, 9.99999977648258209228515625e-3, 1.0e+0, "%.6f", 0);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("You can input value using the scientific notation,\n  e.g. \"1e+8\" becomes \"100000000\".\n");
  ImGui::InputFloat3 ("input float3", &vec4a, -1, 0);
  ImGui::DragInt ("drag int", &i1, 1.0e+0, 0, 0, "%.0f");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Click and drag to edit value.\nHold SHIFT/ALT for faster/slower edit.\nDouble-click or CTRL+click to input value.");
  ImGui::DragInt ("drag int 0..100", &i2, 1.0e+0, 0, 100, "%.0f%%");
  ImGui::DragFloat ("drag float", &f1, 4.999999888241291046142578125e-3, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::DragFloat ("drag small float", &f2, 9.99999974737875163555145263671875e-5, 0.0, 0.0, "%.06f ns", 1.0e+0);
  ImGui::SliderInt ("slider int", &i1, -1, 3, "%.0f");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("CTRL+click to input value.");
  ImGui::SliderFloat ("slider float", &f1, 0.0, 1.0e+0, "ratio = %.3f", 1.0e+0);
  ImGui::SliderFloat ("slider log float", &f2, -1.0e+1, 1.0e+1, "%.4f", 3.0e+0);
  ImGui::SliderAngle ("slider angle", &angle, -3.6e+2, 3.6e+2);
  ImGui::ColorEdit3 ("color 1", &col1, 0);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Click on the colored square to open a color picker.\nRight-click on the colored square to show options.\nCTRL+click on individual component to input value.\n");
  ImGui::ColorEdit4 ("color 2", &col2, 0);
  listbox_items[0] = "Apple";
  listbox_items[1] = "Banana";
  listbox_items[2] = "Cherry";
  listbox_items[3] = "Kiwi";
  listbox_items[4] = "Mango";
  listbox_items[5] = "Orange";
  listbox_items[6] = "Pineapple";
  listbox_items[7] = "Strawberry";
  listbox_items[8] = "Watermelon";
  ImGui::ListBox ("listbox\n(single select)", &listbox_item_current, &listbox_items, 9, 4);
  listbox_items ={v} {CLOBBER};
  ImGui::TreePop ();

  <bb 81>:
  _706 = ImGui::TreeNode ("Trees");
  retval.43_707 = _706;
  if (retval.43_707 != 0)
    goto <bb 82>;
  else
    goto <bb 113>;

  <bb 82>:
  _709 = ImGui::TreeNode ("Basic trees");
  retval.44_710 = _709;
  if (retval.44_710 != 0)
    goto <bb 83>;
  else
    goto <bb 90>;

  <bb 83>:
  i_711 = 0;

  <bb 84>:
  # i_10 = PHI <i_711(83), i_723(88)>
  if (i_10 > 4)
    goto <bb 89>;
  else
    goto <bb 85>;

  <bb 85>:
  _712 = (long int) i_10;
  _713 = (const void *) _712;
  _715 = ImGui::TreeNode (_713, "Child %d", i_10);
  retval.45_716 = _715;
  if (retval.45_716 != 0)
    goto <bb 86>;
  else
    goto <bb 88>;

  <bb 86>:
  ImGui::Text ("blah blah");
  ImGui::SameLine (0.0, -1.0e+0);
  _720 = ImGui::SmallButton ("button");
  retval.46_721 = _720;

  <bb 87>:
  ImGui::TreePop ();

  <bb 88>:
  i_723 = i_10 + 1;
  goto <bb 84>;

  <bb 89>:
  ImGui::TreePop ();

  <bb 90>:
  _726 = ImGui::TreeNode ("Advanced, with Selectable nodes");
  retval.47_727 = _726;
  if (retval.47_727 != 0)
    goto <bb 91>;
  else
    goto <bb 112>;

  <bb 91>:
  ShowHelpMarker ("This is a more standard looking tree with selectable nodes.\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.");
  ImGui::Checkbox ("Align label with current X position)", &align_label_with_current_x_position);
  ImGui::Text ("Hello!");
  align_label_with_current_x_position.48_731 = align_label_with_current_x_position;
  if (align_label_with_current_x_position.48_731 != 0)
    goto <bb 92>;
  else
    goto <bb 93>;

  <bb 92>:
  _733 = ImGui::GetTreeNodeToLabelSpacing ();
  _734 = _733;
  ImGui::Unindent (_734);

  <bb 93>:
  node_clicked_736 = -1;
  _738 = ImGui::GetFontSize ();
  _739 = _738;
  _740 = _739 * 3.0e+0;
  ImGui::PushStyleVar (15, _740);
  i_742 = 0;

  <bb 94>:
  # node_clicked_11 = PHI <node_clicked_736(93), node_clicked_13(103)>
  # i_14 = PHI <i_742(93), i_766(103)>
  if (i_14 > 5)
    goto <bb 104>;
  else
    goto <bb 95>;

  <bb 95>:
  selection_mask.49_743 = selection_mask;
  _744 = selection_mask.49_743 >> i_14;
  _745 = _744 & 1;
  node_flags_746 = _745 | 192;
  if (i_14 <= 2)
    goto <bb 96>;
  else
    goto <bb 101>;

  <bb 96>:
  _747 = (long int) i_14;
  _748 = (const void *) _747;
  _750 = ImGui::TreeNodeEx (_748, node_flags_746, "Selectable Node %d", i_14);
  node_open_751 = _750;
  _753 = ImGui::IsItemClicked (0);
  retval.50_754 = _753;
  if (retval.50_754 != 0)
    goto <bb 97>;
  else
    goto <bb 98>;

  <bb 97>:
  node_clicked_755 = i_14;

  <bb 98>:
  # node_clicked_12 = PHI <node_clicked_11(96), node_clicked_755(97)>
  if (node_open_751 != 0)
    goto <bb 99>;
  else
    goto <bb 100>;

  <bb 99>:
  ImGui::Text ("Blah blah\nBlah Blah");
  ImGui::TreePop ();

  <bb 100>:
  goto <bb 103>;

  <bb 101>:
  node_flags_758 = node_flags_746 | 264;
  _759 = (long int) i_14;
  _760 = (const void *) _759;
  ImGui::TreeNodeEx (_760, node_flags_758, "Selectable Leaf %d", i_14);
  _763 = ImGui::IsItemClicked (0);
  retval.51_764 = _763;
  if (retval.51_764 != 0)
    goto <bb 102>;
  else
    goto <bb 103>;

  <bb 102>:
  node_clicked_765 = i_14;

  <bb 103>:
  # node_clicked_13 = PHI <node_clicked_12(100), node_clicked_11(101), node_clicked_765(102)>
  i_766 = i_14 + 1;
  goto <bb 94>;

  <bb 104>:
  if (node_clicked_11 != -1)
    goto <bb 105>;
  else
    goto <bb 109>;

  <bb 105>:
  _768 = ImGui::GetIO ();
  _769 = _768;
  retval.52_770 = _769->KeyCtrl;
  if (retval.52_770 != 0)
    goto <bb 106>;
  else
    goto <bb 107>;

  <bb 106>:
  _771 = 1 << node_clicked_11;
  selection_mask.53_772 = selection_mask;
  selection_mask.54_773 = _771 ^ selection_mask.53_772;
  selection_mask = selection_mask.54_773;
  goto <bb 108>;

  <bb 107>:
  selection_mask.55_775 = 1 << node_clicked_11;
  selection_mask = selection_mask.55_775;

  <bb 108>:

  <bb 109>:
  ImGui::PopStyleVar (1);
  align_label_with_current_x_position.56_778 = align_label_with_current_x_position;
  if (align_label_with_current_x_position.56_778 != 0)
    goto <bb 110>;
  else
    goto <bb 111>;

  <bb 110>:
  _780 = ImGui::GetTreeNodeToLabelSpacing ();
  _781 = _780;
  ImGui::Indent (_781);

  <bb 111>:
  ImGui::TreePop ();

  <bb 112>:
  ImGui::TreePop ();

  <bb 113>:
  _786 = ImGui::TreeNode ("Collapsing Headers");
  retval.57_787 = _786;
  if (retval.57_787 != 0)
    goto <bb 114>;
  else
    goto <bb 125>;

  <bb 114>:
  ImGui::Checkbox ("Enable extra group", &closable_group);
  _790 = ImGui::CollapsingHeader ("Header", 0);
  retval.58_791 = _790;
  if (retval.58_791 != 0)
    goto <bb 115>;
  else
    goto <bb 119>;

  <bb 115>:
  _793 = ImGui::IsItemHovered (0);
  _794 = _793;
  _795 = (int) _794;
  ImGui::Text ("IsItemHovered: %d", _795);
  i_797 = 0;

  <bb 116>:
  # i_15 = PHI <i_797(115), i_799(117)>
  if (i_15 > 4)
    goto <bb 118>;
  else
    goto <bb 117>;

  <bb 117>:
  ImGui::Text ("Some content %d", i_15);
  i_799 = i_15 + 1;
  goto <bb 116>;

  <bb 118>:

  <bb 119>:
  _801 = ImGui::CollapsingHeader ("Header with a close button", &closable_group, 0);
  retval.59_802 = _801;
  if (retval.59_802 != 0)
    goto <bb 120>;
  else
    goto <bb 124>;

  <bb 120>:
  _804 = ImGui::IsItemHovered (0);
  _805 = _804;
  _806 = (int) _805;
  ImGui::Text ("IsItemHovered: %d", _806);
  i_808 = 0;

  <bb 121>:
  # i_16 = PHI <i_808(120), i_810(122)>
  if (i_16 > 4)
    goto <bb 123>;
  else
    goto <bb 122>;

  <bb 122>:
  ImGui::Text ("More content %d", i_16);
  i_810 = i_16 + 1;
  goto <bb 121>;

  <bb 123>:

  <bb 124>:
  ImGui::TreePop ();

  <bb 125>:
  _813 = ImGui::TreeNode ("Bullets");
  retval.60_814 = _813;
  if (retval.60_814 != 0)
    goto <bb 126>;
  else
    goto <bb 127>;

  <bb 126>:
  ImGui::BulletText ("Bullet point 1");
  ImGui::BulletText ("Bullet point 2\nOn multiple lines");
  ImGui::Bullet ();
  ImGui::Text ("Bullet point 3 (two calls)");
  ImGui::Bullet ();
  ImGui::SmallButton ("Button");
  ImGui::TreePop ();

  <bb 127>:
  _823 = ImGui::TreeNode ("Text");
  retval.61_824 = _823;
  if (retval.61_824 != 0)
    goto <bb 128>;
  else
    goto <bb 139>;

  <bb 128>:
  _826 = ImGui::TreeNode ("Colored Text");
  retval.62_827 = _826;
  if (retval.62_827 != 0)
    goto <bb 129>;
  else
    goto <bb 130>;

  <bb 129>:
  ImVec4::ImVec4 (&D.11432, 1.0e+0, 0.0, 1.0e+0, 1.0e+0);
  ImGui::TextColored (&D.11432, "Pink");
  D.11432 ={v} {CLOBBER};
  ImVec4::ImVec4 (&D.11433, 1.0e+0, 1.0e+0, 0.0, 1.0e+0);
  ImGui::TextColored (&D.11433, "Yellow");
  D.11433 ={v} {CLOBBER};
  ImGui::TextDisabled ("Disabled");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("The TextDisabled color is stored in ImGuiStyle.");
  ImGui::TreePop ();

  <bb 130>:
  _841 = ImGui::TreeNode ("Word Wrapping");
  retval.63_842 = _841;
  if (retval.63_842 != 0)
    goto <bb 131>;
  else
    goto <bb 136>;

  <bb 131>:
  ImGui::TextWrapped ("This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.");
  ImGui::Spacing ();
  ImGui::SliderFloat ("Wrap width", &wrap_width, -2.0e+1, 6.0e+2, "%.0f", 1.0e+0);
  ImGui::Text ("Test paragraph 1:");
  pos = ImGui::GetCursorScreenPos ();
  _848 = pos.y;
  _850 = ImGui::GetTextLineHeight ();
  _851 = _850;
  _852 = _848 + _851;
  _853 = pos.x;
  wrap_width.64_854 = wrap_width;
  _855 = _853 + wrap_width.64_854;
  _856 = _855 + 1.0e+1;
  ImVec2::ImVec2 (&D.11438, _856, _852);
  _858 = pos.y;
  _859 = pos.x;
  wrap_width.65_860 = wrap_width;
  _861 = _859 + wrap_width.65_860;
  ImVec2::ImVec2 (&D.11437, _861, _858);
  _864 = ImGui::GetWindowDrawList ();

  <bb 132>:
  _865 = _864;
  ImDrawList::AddRectFilled (_865, &D.11437, &D.11438, 4294902015, 0.0, 15);

  <bb 133>:
  D.11437 ={v} {CLOBBER};
  D.11438 ={v} {CLOBBER};
  D.11439 = ImGui::GetCursorPos ();
  _870 = D.11439.x;
  wrap_width.66_871 = wrap_width;
  _872 = _870 + wrap_width.66_871;
  ImGui::PushTextWrapPos (_872);
  wrap_width.67_874 = wrap_width;
  _875 = (double) wrap_width.67_874;
  ImGui::Text ("The lazy dog is a good dog. This paragraph is made to fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.", _875);
  D.11441 = ImGui::GetItemRectMax ();
  D.11440 = ImGui::GetItemRectMin ();
  _880 = ImGui::GetWindowDrawList ();
  _881 = _880;
  ImDrawList::AddRect (_881, &D.11440, &D.11441, 4278255615, 0.0, 15, 1.0e+0);
  D.11440 ={v} {CLOBBER};
  D.11441 ={v} {CLOBBER};
  ImGui::PopTextWrapPos ();
  ImGui::Text ("Test paragraph 2:");
  pos = ImGui::GetCursorScreenPos ();
  _888 = pos.y;
  _890 = ImGui::GetTextLineHeight ();
  _891 = _890;
  _892 = _888 + _891;
  _893 = pos.x;
  wrap_width.68_894 = wrap_width;
  _895 = _893 + wrap_width.68_894;
  _896 = _895 + 1.0e+1;
  ImVec2::ImVec2 (&D.11444, _896, _892);
  _898 = pos.y;
  _899 = pos.x;
  wrap_width.69_900 = wrap_width;
  _901 = _899 + wrap_width.69_900;
  ImVec2::ImVec2 (&D.11443, _901, _898);
  _904 = ImGui::GetWindowDrawList ();

  <bb 134>:
  _905 = _904;
  ImDrawList::AddRectFilled (_905, &D.11443, &D.11444, 4294902015, 0.0, 15);

  <bb 135>:
  D.11443 ={v} {CLOBBER};
  D.11444 ={v} {CLOBBER};
  D.11445 = ImGui::GetCursorPos ();
  _910 = D.11445.x;
  wrap_width.70_911 = wrap_width;
  _912 = _910 + wrap_width.70_911;
  ImGui::PushTextWrapPos (_912);
  ImGui::Text ("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");
  D.11447 = ImGui::GetItemRectMax ();
  D.11446 = ImGui::GetItemRectMin ();
  _918 = ImGui::GetWindowDrawList ();
  _919 = _918;
  ImDrawList::AddRect (_919, &D.11446, &D.11447, 4278255615, 0.0, 15, 1.0e+0);
  D.11446 ={v} {CLOBBER};
  D.11447 ={v} {CLOBBER};
  ImGui::PopTextWrapPos ();
  ImGui::TreePop ();
  pos ={v} {CLOBBER};

  <bb 136>:
  _936 = ImGui::TreeNode ("UTF-8 Text");
  retval.71_937 = _936;
  if (retval.71_937 != 0)
    goto <bb 137>;
  else
    goto <bb 138>;

  <bb 137>:
  ImGui::TextWrapped ("CJK text will only appears if the font was loaded with the appropriate CJK character ranges. Call io.Font->LoadFromFileTTF() manually to load extra character ranges.");
  ImGui::Text ("Hiragana: かきくけこ (kakikukeko)");
  ImGui::Text ("Kanjis: 日本語 (nihongo)");
  ImGui::InputText ("UTF-8 input", &buf, 32, 0, 0B, 0B);
  ImGui::TreePop ();

  <bb 138>:
  ImGui::TreePop ();

  <bb 139>:
  _945 = ImGui::TreeNode ("Images");
  retval.72_946 = _945;
  if (retval.72_946 != 0)
    goto <bb 140>;
  else
    goto <bb 156>;

  <bb 140>:
  _948 = ImGui::GetIO ();
  io_949 = _948;
  ImGui::TextWrapped ("Below we are displaying the font texture (which is the only texture we have access to in this demo). Use the \'ImTextureID\' type as storage to pass pointers or identifier to your own texture data. Hover the texture for a zoomed view!");
  _951 = io_949->Fonts;
  my_tex_id_952 = _951->TexID;
  _953 = io_949->Fonts;
  _954 = _953->TexWidth;
  my_tex_w_955 = (float) _954;
  _956 = io_949->Fonts;
  _957 = _956->TexHeight;
  my_tex_h_958 = (float) _957;
  _959 = (double) my_tex_h_958;
  _960 = (double) my_tex_w_955;
  ImGui::Text ("%.0fx%.0f", _960, _959);
  pos = ImGui::GetCursorScreenPos ();
  ImColor::ImColor (&D.11459, 255, 255, 255, 128);
  D.11461 = ImColor::operator ImVec4 (&D.11459);
  ImColor::ImColor (&D.11458, 255, 255, 255, 255);
  D.11460 = ImColor::operator ImVec4 (&D.11458);
  ImVec2::ImVec2 (&D.11457, 1.0e+0, 1.0e+0);
  ImVec2::ImVec2 (&D.11456, 0.0, 0.0);
  ImVec2::ImVec2 (&D.11455, my_tex_w_955, my_tex_h_958);
  ImGui::Image (my_tex_id_952, &D.11455, &D.11456, &D.11457, &D.11460, &D.11461);
  D.11455 ={v} {CLOBBER};
  D.11456 ={v} {CLOBBER};
  D.11457 ={v} {CLOBBER};
  D.11460 ={v} {CLOBBER};
  D.11458 ={v} {CLOBBER};
  D.11461 ={v} {CLOBBER};
  D.11459 ={v} {CLOBBER};
  _979 = ImGui::IsItemHovered (0);
  retval.73_980 = _979;
  if (retval.73_980 != 0)
    goto <bb 141>;
  else
    goto <bb 150>;

  <bb 141>:
  ImGui::BeginTooltip ();
  region_sz_982 = 3.2e+1;
  _983 = io_949->MousePos.x;
  _984 = pos.x;
  _985 = _983 - _984;
  _986 = region_sz_982 * 5.0e-1;
  region_x.74_987 = _985 - _986;
  region_x = region_x.74_987;
  region_x.75_989 = region_x;
  if (region_x.75_989 < 0.0)
    goto <bb 142>;
  else
    goto <bb 143>;

  <bb 142>:
  region_x = 0.0;
  goto <bb 145>;

  <bb 143>:
  _991 = my_tex_w_955 - region_sz_982;
  region_x.76_992 = region_x;
  if (_991 < region_x.76_992)
    goto <bb 144>;
  else
    goto <bb 145>;

  <bb 144>:
  region_x.77_993 = my_tex_w_955 - region_sz_982;
  region_x = region_x.77_993;

  <bb 145>:
  _995 = io_949->MousePos.y;
  _996 = pos.y;
  _997 = _995 - _996;
  _998 = region_sz_982 * 5.0e-1;
  region_y.78_999 = _997 - _998;
  region_y = region_y.78_999;
  region_y.79_1001 = region_y;
  if (region_y.79_1001 < 0.0)
    goto <bb 146>;
  else
    goto <bb 147>;

  <bb 146>:
  region_y = 0.0;
  goto <bb 149>;

  <bb 147>:
  _1003 = my_tex_h_958 - region_sz_982;
  region_y.80_1004 = region_y;
  if (_1003 < region_y.80_1004)
    goto <bb 148>;
  else
    goto <bb 149>;

  <bb 148>:
  region_y.81_1005 = my_tex_h_958 - region_sz_982;
  region_y = region_y.81_1005;

  <bb 149>:
  zoom_1007 = 4.0e+0;
  region_y.82_1008 = region_y;
  _1009 = (double) region_y.82_1008;
  region_x.83_1010 = region_x;
  _1011 = (double) region_x.83_1010;
  ImGui::Text ("Min: (%.2f, %.2f)", _1011, _1009);
  region_y.84_1013 = region_y;
  _1014 = region_y.84_1013 + region_sz_982;
  _1015 = (double) _1014;
  region_x.85_1016 = region_x;
  _1017 = region_x.85_1016 + region_sz_982;
  _1018 = (double) _1017;
  ImGui::Text ("Max: (%.2f, %.2f)", _1018, _1015);
  region_y.86_1020 = region_y;
  _1021 = region_y.86_1020 / my_tex_h_958;
  region_x.87_1022 = region_x;
  _1023 = region_x.87_1022 / my_tex_w_955;
  ImVec2::ImVec2 (&uv0, _1023, _1021);
  region_y.88_1025 = region_y;
  _1026 = region_y.88_1025 + region_sz_982;
  _1027 = _1026 / my_tex_h_958;
  region_x.89_1028 = region_x;
  _1029 = region_x.89_1028 + region_sz_982;
  _1030 = _1029 / my_tex_w_955;
  ImVec2::ImVec2 (&uv1, _1030, _1027);
  ImColor::ImColor (&D.11472, 255, 255, 255, 128);
  D.11474 = ImColor::operator ImVec4 (&D.11472);
  ImColor::ImColor (&D.11471, 255, 255, 255, 255);
  D.11473 = ImColor::operator ImVec4 (&D.11471);
  _1036 = region_sz_982 * zoom_1007;
  _1037 = region_sz_982 * zoom_1007;
  ImVec2::ImVec2 (&D.11470, _1037, _1036);
  ImGui::Image (my_tex_id_952, &D.11470, &uv0, &uv1, &D.11473, &D.11474);
  D.11470 ={v} {CLOBBER};
  D.11473 ={v} {CLOBBER};
  D.11471 ={v} {CLOBBER};
  D.11474 ={v} {CLOBBER};
  D.11472 ={v} {CLOBBER};
  ImGui::EndTooltip ();
  region_x ={v} {CLOBBER};
  region_y ={v} {CLOBBER};
  uv0 ={v} {CLOBBER};
  uv1 ={v} {CLOBBER};

  <bb 150>:
  ImGui::TextWrapped ("And now some textured buttons..");
  i_1060 = 0;

  <bb 151>:
  # i_17 = PHI <i_1060(150), i_1085(154)>
  if (i_17 > 7)
    goto <bb 155>;
  else
    goto <bb 152>;

  <bb 152>:
  ImGui::PushID (i_17);
  frame_padding_1062 = i_17 + -1;
  ImVec4::ImVec4 (&D.11483, 1.0e+0, 1.0e+0, 1.0e+0, 1.0e+0);
  ImColor::ImColor (&D.11481, 0, 0, 0, 255);
  D.11482 = ImColor::operator ImVec4 (&D.11481);
  _1066 = 3.2e+1 / my_tex_h_958;
  _1067 = 3.2e+1 / my_tex_w_955;
  ImVec2::ImVec2 (&D.11480, _1067, _1066);
  ImVec2::ImVec2 (&D.11479, 0.0, 0.0);
  ImVec2::ImVec2 (&D.11478, 3.2e+1, 3.2e+1);
  _1072 = ImGui::ImageButton (my_tex_id_952, &D.11478, &D.11479, &D.11480, frame_padding_1062, &D.11482, &D.11483);
  retval.90_1073 = _1072;
  D.11478 ={v} {CLOBBER};
  D.11479 ={v} {CLOBBER};
  D.11480 ={v} {CLOBBER};
  D.11482 ={v} {CLOBBER};
  D.11481 ={v} {CLOBBER};
  D.11483 ={v} {CLOBBER};
  if (retval.90_1073 != 0)
    goto <bb 153>;
  else
    goto <bb 154>;

  <bb 153>:
  pressed_count.91_1080 = pressed_count;
  pressed_count.92_1081 = pressed_count.91_1080 + 1;
  pressed_count = pressed_count.92_1081;

  <bb 154>:
  ImGui::PopID ();
  ImGui::SameLine (0.0, -1.0e+0);
  i_1085 = i_17 + 1;
  goto <bb 151>;

  <bb 155>:
  ImGui::NewLine ();
  pressed_count.93_1093 = pressed_count;
  ImGui::Text ("Pressed %d times.", pressed_count.93_1093);
  ImGui::TreePop ();
  pos ={v} {CLOBBER};

  <bb 156>:
  _1106 = ImGui::TreeNode ("Combo");
  retval.94_1107 = _1106;
  if (retval.94_1107 != 0)
    goto <bb 157>;
  else
    goto <bb 174>;

  <bb 157>:
  ImGui::CheckboxFlags ("ImGuiComboFlags_PopupAlignLeft", &flags, 1);
  _1110 = ImGui::CheckboxFlags ("ImGuiComboFlags_NoArrowButton", &flags, 32);
  retval.95_1111 = _1110;
  if (retval.95_1111 != 0)
    goto <bb 158>;
  else
    goto <bb 159>;

  <bb 158>:
  flags.96_1112 = flags;
  flags.97_1113 = flags.96_1112 & -65;
  flags = flags.97_1113;

  <bb 159>:
  _1116 = ImGui::CheckboxFlags ("ImGuiComboFlags_NoPreview", &flags, 64);
  retval.98_1117 = _1116;
  if (retval.98_1117 != 0)
    goto <bb 160>;
  else
    goto <bb 161>;

  <bb 160>:
  flags.99_1118 = flags;
  flags.100_1119 = flags.99_1118 & -33;
  flags = flags.100_1119;

  <bb 161>:
  items[0] = "AAAA";
  items[1] = "BBBB";
  items[2] = "CCCC";
  items[3] = "DDDD";
  items[4] = "EEEE";
  items[5] = "FFFF";
  items[6] = "GGGG";
  items[7] = "HHHH";
  items[8] = "IIII";
  items[9] = "JJJJ";
  items[10] = "KKKK";
  items[11] = "LLLLLLL";
  items[12] = "MMMM";
  items[13] = "OOOOOOO";
  _1136 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE12item_current_0, 2);
  retval.101_1137 = _1136 == 0;
  if (retval.101_1137 != 0)
    goto <bb 162>;
  else
    goto <bb 164>;

  <bb 162>:
  _1139 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE12item_current_0);
  retval.102_1140 = _1139 != 0;
  if (retval.102_1140 != 0)
    goto <bb 163>;
  else
    goto <bb 164>;

  <bb 163>:
  _1141 = 0;
  item_current.103_1142 = items[0];
  item_current = item_current.103_1142;
  _1144 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE12item_current_0);

  <bb 164>:
  flags.105_1146 = flags;
  item_current.106_1147 = item_current;
  _1149 = ImGui::BeginCombo ("combo 1", item_current.106_1147, flags.105_1146);
  retval.104_1150 = _1149;
  if (retval.104_1150 != 0)
    goto <bb 165>;
  else
    goto <bb 173>;

  <bb 165>:
  n_1151 = 0;

  <bb 166>:
  # n_18 = PHI <n_1151(165), n_1165(171)>
  if (n_18 > 13)
    goto <bb 172>;
  else
    goto <bb 167>;

  <bb 167>:
  _1152 = items[n_18];
  item_current.107_1153 = item_current;
  is_selected_1154 = _1152 == item_current.107_1153;
  ImVec2::ImVec2 (&D.11494, 0.0, 0.0);
  _1156 = (int) is_selected_1154;
  _1157 = items[n_18];
  _1159 = ImGui::Selectable (_1157, _1156, 0, &D.11494);
  retval.108_1160 = _1159;
  D.11494 ={v} {CLOBBER};
  if (retval.108_1160 != 0)
    goto <bb 168>;
  else
    goto <bb 169>;

  <bb 168>:
  item_current.109_1162 = items[n_18];
  item_current = item_current.109_1162;

  <bb 169>:
  if (is_selected_1154 != 0)
    goto <bb 170>;
  else
    goto <bb 171>;

  <bb 170>:
  ImGui::SetItemDefaultFocus ();

  <bb 171>:
  n_1165 = n_18 + 1;
  goto <bb 166>;

  <bb 172>:
  ImGui::EndCombo ();

  <bb 173>:
  ImGui::Combo ("combo 2 (one-liner)", &item_current_2, "aaaa", -1);
  ImGui::Combo ("combo 3 (array)", &item_current_3, &items, 14, -1);
  ImGui::Combo ("combo 4 (function)", &item_current_4, ItemGetter, &items, 14, -1);
  ImGui::TreePop ();
  items ={v} {CLOBBER};

  <bb 174>:
  _1175 = ImGui::TreeNode ("Selectables");
  retval.110_1176 = _1175;
  if (retval.110_1176 != 0)
    goto <bb 175>;
  else
    goto <bb 222>;

  <bb 175>:
  _1178 = ImGui::TreeNode ("Basic");
  retval.111_1179 = _1178;
  if (retval.111_1179 != 0)
    goto <bb 176>;
  else
    goto <bb 180>;

  <bb 176>:
  ImVec2::ImVec2 (&D.11507, 0.0, 0.0);
  ImGui::Selectable ("1. I am selectable", &selection[0], 0, &D.11507);
  D.11507 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11508, 0.0, 0.0);
  ImGui::Selectable ("2. I am selectable", &selection[1], 0, &D.11508);
  D.11508 ={v} {CLOBBER};
  ImGui::Text ("3. I am not selectable");
  ImVec2::ImVec2 (&D.11509, 0.0, 0.0);
  ImGui::Selectable ("4. I am selectable", &selection[3], 0, &D.11509);
  D.11509 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11510, 0.0, 0.0);
  _1191 = selection[4];
  _1192 = (int) _1191;
  _1194 = ImGui::Selectable ("5. I am double clickable", _1192, 4, &D.11510);
  retval.112_1195 = _1194;
  D.11510 ={v} {CLOBBER};
  if (retval.112_1195 != 0)
    goto <bb 177>;
  else
    goto <bb 179>;

  <bb 177>:
  _1198 = ImGui::IsMouseDoubleClicked (0);
  retval.113_1199 = _1198;
  if (retval.113_1199 != 0)
    goto <bb 178>;
  else
    goto <bb 179>;

  <bb 178>:
  _1200 = selection[4];
  _1201 = ~_1200;
  selection[4] = _1201;

  <bb 179>:
  ImGui::TreePop ();

  <bb 180>:
  _1209 = ImGui::TreeNode ("Selection State: Single Selection");
  retval.114_1210 = _1209;
  if (retval.114_1210 != 0)
    goto <bb 181>;
  else
    goto <bb 187>;

  <bb 181>:
  n_1211 = 0;

  <bb 182>:
  # n_19 = PHI <n_1211(181), n_1223(185)>
  if (n_19 > 4)
    goto <bb 186>;
  else
    goto <bb 183>;

  <bb 183>:
  sprintf (&buf, "Object %d", n_19);
  ImVec2::ImVec2 (&D.11514, 0.0, 0.0);
  selected.116_1214 = selected;
  _1215 = selected.116_1214 == n_19;
  _1216 = (int) _1215;
  _1218 = ImGui::Selectable (&buf, _1216, 0, &D.11514);
  retval.115_1219 = _1218;
  D.11514 ={v} {CLOBBER};
  if (retval.115_1219 != 0)
    goto <bb 184>;
  else
    goto <bb 185>;

  <bb 184>:
  selected = n_19;

  <bb 185>:
  buf ={v} {CLOBBER};
  n_1223 = n_19 + 1;
  goto <bb 182>;

  <bb 186>:
  ImGui::TreePop ();

  <bb 187>:
  _1228 = ImGui::TreeNode ("Selection State: Multiple Selection");
  retval.117_1229 = _1228;
  if (retval.117_1229 != 0)
    goto <bb 188>;
  else
    goto <bb 196>;

  <bb 188>:
  ShowHelpMarker ("Hold CTRL and click to select multiple items.");
  n_1231 = 0;

  <bb 189>:
  # n_20 = PHI <n_1231(188), n_1250(194)>
  if (n_20 > 4)
    goto <bb 195>;
  else
    goto <bb 190>;

  <bb 190>:
  sprintf (&buf, "Object %d", n_20);
  ImVec2::ImVec2 (&D.11518, 0.0, 0.0);
  _1234 = selection[n_20];
  _1235 = (int) _1234;
  _1237 = ImGui::Selectable (&buf, _1235, 0, &D.11518);
  retval.118_1238 = _1237;
  D.11518 ={v} {CLOBBER};
  if (retval.118_1238 != 0)
    goto <bb 191>;
  else
    goto <bb 194>;

  <bb 191>:
  _1241 = ImGui::GetIO ();
  _1242 = _1241;
  _1243 = _1242->KeyCtrl;
  retval.119_1244 = ~_1243;
  if (retval.119_1244 != 0)
    goto <bb 192>;
  else
    goto <bb 193>;

  <bb 192>:
  memset (&selection, 0, 5);

  <bb 193>:
  _1246 = selection[n_20];
  _1247 = ~_1246;
  selection[n_20] = _1247;

  <bb 194>:
  buf ={v} {CLOBBER};
  n_1250 = n_20 + 1;
  goto <bb 189>;

  <bb 195>:
  ImGui::TreePop ();

  <bb 196>:
  _1255 = ImGui::TreeNode ("Rendering more text into the same line");
  retval.120_1256 = _1255;
  if (retval.120_1256 != 0)
    goto <bb 197>;
  else
    goto <bb 198>;

  <bb 197>:
  ImVec2::ImVec2 (&D.11520, 0.0, 0.0);
  ImGui::Selectable ("main.c", &selected[0], 0, &D.11520);
  D.11520 ={v} {CLOBBER};
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::Text (" 2,345 bytes");
  ImVec2::ImVec2 (&D.11521, 0.0, 0.0);
  ImGui::Selectable ("Hello.cpp", &selected[1], 0, &D.11521);
  D.11521 ={v} {CLOBBER};
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::Text ("12,345 bytes");
  ImVec2::ImVec2 (&D.11522, 0.0, 0.0);
  ImGui::Selectable ("Hello.h", &selected[2], 0, &D.11522);
  D.11522 ={v} {CLOBBER};
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::Text (" 2,345 bytes");
  ImGui::TreePop ();

  <bb 198>:
  _1277 = ImGui::TreeNode ("In columns");
  retval.121_1278 = _1277;
  if (retval.121_1278 != 0)
    goto <bb 199>;
  else
    goto <bb 204>;

  <bb 199>:
  ImGui::Columns (3, 0B, 0);
  i_1280 = 0;

  <bb 200>:
  # i_21 = PHI <i_1280(199), i_1290(202)>
  if (i_21 > 15)
    goto <bb 203>;
  else
    goto <bb 201>;

  <bb 201>:
  sprintf (&label, "Item %d", i_21);
  ImVec2::ImVec2 (&D.11526, 0.0, 0.0);
  _1283 = &selected[i_21];
  _1285 = ImGui::Selectable (&label, _1283, 0, &D.11526);
  retval.122_1286 = _1285;
  D.11526 ={v} {CLOBBER};

  <bb 202>:
  ImGui::NextColumn ();
  label ={v} {CLOBBER};
  i_1290 = i_21 + 1;
  goto <bb 200>;

  <bb 203>:
  ImGui::Columns (1, 0B, 1);
  ImGui::TreePop ();

  <bb 204>:
  _1296 = ImGui::TreeNode ("Grid");
  retval.123_1297 = _1296;
  if (retval.123_1297 != 0)
    goto <bb 205>;
  else
    goto <bb 221>;

  <bb 205>:
  i_1298 = 0;

  <bb 206>:
  # i_22 = PHI <i_1298(205), i_1331(219)>
  if (i_22 > 15)
    goto <bb 220>;
  else
    goto <bb 207>;

  <bb 207>:
  ImGui::PushID (i_22);
  ImVec2::ImVec2 (&D.11529, 5.0e+1, 5.0e+1);
  _1301 = &selected[i_22];
  _1303 = ImGui::Selectable ("Sailor", _1301, 0, &D.11529);
  retval.124_1304 = _1303;
  D.11529 ={v} {CLOBBER};
  if (retval.124_1304 != 0)
    goto <bb 208>;
  else
    goto <bb 217>;

  <bb 208>:
  x_1306 = i_22 % 4;
  y_1307 = i_22 / 4;
  if (x_1306 > 0)
    goto <bb 209>;
  else
    goto <bb 210>;

  <bb 209>:
  _1308 = i_22 + -1;
  _1309 = i_22 + -1;
  _1310 = selected[_1309];
  _1311 = ~_1310;
  selected[_1308] = _1311;

  <bb 210>:
  if (x_1306 <= 2)
    goto <bb 211>;
  else
    goto <bb 212>;

  <bb 211>:
  _1313 = i_22 + 1;
  _1314 = i_22 + 1;
  _1315 = selected[_1314];
  _1316 = ~_1315;
  selected[_1313] = _1316;

  <bb 212>:
  if (y_1307 > 0)
    goto <bb 213>;
  else
    goto <bb 214>;

  <bb 213>:
  _1318 = i_22 + -4;
  _1319 = i_22 + -4;
  _1320 = selected[_1319];
  _1321 = ~_1320;
  selected[_1318] = _1321;

  <bb 214>:
  if (y_1307 <= 2)
    goto <bb 215>;
  else
    goto <bb 216>;

  <bb 215>:
  _1323 = i_22 + 4;
  _1324 = i_22 + 4;
  _1325 = selected[_1324];
  _1326 = ~_1325;
  selected[_1323] = _1326;

  <bb 216>:

  <bb 217>:
  _1328 = i_22 % 4;
  if (_1328 <= 2)
    goto <bb 218>;
  else
    goto <bb 219>;

  <bb 218>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 219>:
  ImGui::PopID ();
  i_1331 = i_22 + 1;
  goto <bb 206>;

  <bb 220>:
  ImGui::TreePop ();

  <bb 221>:
  ImGui::TreePop ();

  <bb 222>:
  _1336 = ImGui::TreeNode ("Filtered Text Input");
  retval.125_1337 = _1336;
  if (retval.125_1337 != 0)
    goto <bb 223>;
  else
    goto <bb 224>;

  <bb 223>:
  ImGui::InputText ("default", &buf1, 64, 0, 0B, 0B);
  ImGui::InputText ("decimal", &buf2, 64, 1, 0B, 0B);
  ImGui::InputText ("hexadecimal", &buf3, 64, 6, 0B, 0B);
  ImGui::InputText ("uppercase", &buf4, 64, 4, 0B, 0B);
  ImGui::InputText ("no blank", &buf5, 64, 8, 0B, 0B);
  ImGui::InputText ("\"imgui\" letters", &buf6, 64, 512, FilterImGuiLetters, 0B);
  ImGui::Text ("Password input");
  ImGui::InputText ("password", &bufpass, 64, 32776, 0B, 0B);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Display all characters as \'*\'.\nDisable clipboard cut and copy.\nDisable logging.\n");
  ImGui::InputText ("password (clear)", &bufpass, 64, 8, 0B, 0B);
  ImGui::TreePop ();

  <bb 224>:
  _1351 = ImGui::TreeNode ("Multi-line Text Input");
  retval.126_1352 = _1351;
  if (retval.126_1352 != 0)
    goto <bb 225>;
  else
    goto <bb 229>;

  <bb 225>:
  ImVec2::ImVec2 (&D.11547, 0.0, 0.0);
  ImGui::PushStyleVar (10, &D.11547);
  D.11547 ={v} {CLOBBER};
  ImGui::Checkbox ("Read-only", &read_only);
  ImGui::PopStyleVar (1);
  read_only.128_1358 = read_only;
  if (read_only.128_1358 != 0)
    goto <bb 226>;
  else
    goto <bb 227>;

  <bb 226>:
  iftmp.127_1359 = 17408;
  goto <bb 228>;

  <bb 227>:
  iftmp.127_1360 = 1024;

  <bb 228>:
  # iftmp.127_78 = PHI <iftmp.127_1359(226), iftmp.127_1360(227)>
  _1362 = ImGui::GetTextLineHeight ();
  _1363 = _1362;
  _1364 = _1363 * 1.6e+1;
  ImVec2::ImVec2 (&D.11548, -1.0e+0, _1364);
  ImGui::InputTextMultiline ("##source", &text, 16384, &D.11548, iftmp.127_78, 0B, 0B);
  D.11548 ={v} {CLOBBER};
  ImGui::TreePop ();

  <bb 229>:
  _1372 = ImGui::TreeNode ("Plots widgets");
  retval.129_1373 = _1372;
  if (retval.129_1373 != 0)
    goto <bb 230>;
  else
    goto <bb 250>;

  <bb 230>:
  ImGui::Checkbox ("Animate", &animate);
  ImVec2::ImVec2 (&D.11551, 0.0, 0.0);
  ImGui::PlotLines ("Frame Times", &arr, 7, 0, 0B, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38, D.11551, 4);
  D.11551 ={v} {CLOBBER};
  animate.130_1378 = animate;
  _1379 = ~animate.130_1378;
  if (_1379 != 0)
    goto <bb 232>;
  else
    goto <bb 231>;

  <bb 231>:
  refresh_time.131_1380 = refresh_time;
  if (refresh_time.131_1380 == 0.0)
    goto <bb 232>;
  else
    goto <bb 233>;

  <bb 232>:
  _1382 = ImGui::GetTime ();
  refresh_time.132_1383 = _1382;
  refresh_time = refresh_time.132_1383;

  <bb 233>:
  _1386 = ImGui::GetTime ();
  _1387 = _1386;
  refresh_time.134_1388 = refresh_time;
  retval.133_1389 = _1387 > refresh_time.134_1388;
  if (retval.133_1389 != 0)
    goto <bb 234>;
  else
    goto <bb 235>;

  <bb 234>:
  values_offset.135_1390 = values_offset;
  phase.136_1391 = phase;
  _1392 = cosf (phase.136_1391);
  values[values_offset.135_1390] = _1392;
  values_offset.137_1394 = values_offset;
  _1395 = values_offset.137_1394 + 1;
  values_offset.138_1396 = _1395 % 90;
  values_offset = values_offset.138_1396;
  values_offset.139_1398 = values_offset;
  _1399 = (float) values_offset.139_1398;
  _1400 = _1399 * 1.00000001490116119384765625e-1;
  phase.140_1401 = phase;
  phase.141_1402 = _1400 + phase.140_1401;
  phase = phase.141_1402;
  refresh_time.142_1404 = refresh_time;
  refresh_time.143_1405 = refresh_time.142_1404 + 1.666666753590106964111328125e-2;
  refresh_time = refresh_time.143_1405;
  goto <bb 233>;

  <bb 235>:
  ImVec2::ImVec2 (&D.11556, 0.0, 8.0e+1);
  values_offset.144_1408 = values_offset;
  ImGui::PlotLines ("Lines", &values, 90, values_offset.144_1408, "avg 0.0", -1.0e+0, 1.0e+0, D.11556, 4);
  D.11556 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11557, 0.0, 8.0e+1);
  ImGui::PlotHistogram ("Histogram", &arr, 7, 0, 0B, 0.0, 1.0e+0, D.11557, 4);
  D.11557 ={v} {CLOBBER};
  ImGui::Separator ();
  ImGui::PushItemWidth (1.0e+2);
  ImGui::Combo ("func", &func_type, "Sin", -1);
  ImGui::PopItemWidth ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SliderInt ("Sample count", &display_count, 1, 400, "%.0f");
  func_type.146_1420 = func_type;
  if (func_type.146_1420 == 0)
    goto <bb 236>;
  else
    goto <bb 237>;

  <bb 236>:
  iftmp.145_1421 = Sin;
  goto <bb 238>;

  <bb 237>:
  iftmp.145_1422 = Saw;

  <bb 238>:
  # iftmp.145_79 = PHI <iftmp.145_1421(236), iftmp.145_1422(237)>
  func_1423 = iftmp.145_79;
  ImVec2::ImVec2 (&D.11574, 0.0, 8.0e+1);
  display_count.147_1425 = display_count;
  ImGui::PlotLines ("Lines", func_1423, 0B, display_count.147_1425, 0, 0B, -1.0e+0, 1.0e+0, D.11574);
  D.11574 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11575, 0.0, 8.0e+1);
  display_count.148_1429 = display_count;
  ImGui::PlotHistogram ("Histogram", func_1423, 0B, display_count.148_1429, 0, 0B, -1.0e+0, 1.0e+0, D.11575);
  D.11575 ={v} {CLOBBER};
  ImGui::Separator ();
  animate.149_1433 = animate;
  if (animate.149_1433 != 0)
    goto <bb 239>;
  else
    goto <bb 243>;

  <bb 239>:
  progress_dir.150_1434 = progress_dir;
  _1435 = progress_dir.150_1434 * 4.000000059604644775390625e-1;
  _1437 = ImGui::GetIO ();
  _1438 = _1437;
  _1439 = _1438->DeltaTime;
  _1440 = _1435 * _1439;
  progress.151_1441 = progress;
  progress.152_1442 = progress.151_1441 + _1440;
  progress = progress.152_1442;
  progress.153_1444 = progress;
  if (progress.153_1444 >= 1.10000002384185791015625e+0)
    goto <bb 240>;
  else
    goto <bb 241>;

  <bb 240>:
  progress = 1.10000002384185791015625e+0;
  progress_dir.154_1446 = progress_dir;
  progress_dir.155_1447 = -progress_dir.154_1446;
  progress_dir = progress_dir.155_1447;

  <bb 241>:
  progress.156_1449 = progress;
  if (progress.156_1449 <= -1.00000001490116119384765625e-1)
    goto <bb 242>;
  else
    goto <bb 243>;

  <bb 242>:
  progress = -1.00000001490116119384765625e-1;
  progress_dir.157_1451 = progress_dir;
  progress_dir.158_1452 = -progress_dir.157_1451;
  progress_dir = progress_dir.158_1452;

  <bb 243>:
  ImVec2::ImVec2 (&D.11579, 0.0, 0.0);
  progress.159_1455 = progress;
  ImGui::ProgressBar (progress.159_1455, &D.11579, 0B);
  D.11579 ={v} {CLOBBER};
  _1459 = ImGui::GetStyle ();
  _1460 = _1459;
  _1461 = _1460->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _1461);
  ImGui::Text ("Progress Bar");
  progress.161_1464 = progress;
  if (progress.161_1464 < 0.0)
    goto <bb 244>;
  else
    goto <bb 245>;

  <bb 244>:
  iftmp.160_1465 = 0.0;
  goto <bb 249>;

  <bb 245>:
  progress.163_1466 = progress;
  if (progress.163_1466 > 1.0e+0)
    goto <bb 246>;
  else
    goto <bb 247>;

  <bb 246>:
  iftmp.162_1467 = 1.0e+0;
  goto <bb 248>;

  <bb 247>:
  iftmp.162_1468 = progress;

  <bb 248>:
  # iftmp.162_81 = PHI <iftmp.162_1467(246), iftmp.162_1468(247)>
  iftmp.160_1469 = iftmp.162_81;

  <bb 249>:
  # iftmp.160_80 = PHI <iftmp.160_1465(244), iftmp.160_1469(248)>
  progress_saturated_1470 = iftmp.160_80;
  _1471 = progress_saturated_1470 * 1.753e+3;
  _1472 = (int) _1471;
  sprintf (&buf, "%d/%d", _1472, 1753);
  ImVec2::ImVec2 (&D.11582, 0.0, 0.0);
  progress.164_1475 = progress;
  ImGui::ProgressBar (progress.164_1475, &D.11582, &buf);
  D.11582 ={v} {CLOBBER};
  ImGui::TreePop ();
  buf ={v} {CLOBBER};

  <bb 250>:
  _1489 = ImGui::TreeNode ("Color/Picker Widgets");
  retval.165_1490 = _1489;
  if (retval.165_1490 != 0)
    goto <bb 251>;
  else
    goto <bb 331>;

  <bb 251>:
  _1492 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE5color, 2);
  retval.166_1493 = _1492 == 0;
  if (retval.166_1493 != 0)
    goto <bb 252>;
  else
    goto <bb 254>;

  <bb 252>:
  _1495 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE5color);
  retval.167_1496 = _1495 != 0;
  if (retval.167_1496 != 0)
    goto <bb 253>;
  else
    goto <bb 254>;

  <bb 253>:
  _1497 = 0;
  ImColor::ImColor (&D.11584, 114, 144, 154, 200);
  color = ImColor::operator ImVec4 (&D.11584);
  _1500 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE5color);
  D.11584 ={v} {CLOBBER};

  <bb 254>:
  ImGui::Checkbox ("With Alpha Preview", &alpha_preview);
  ImGui::Checkbox ("With Half Alpha Preview", &alpha_half_preview);
  ImGui::Checkbox ("With Options Menu", &options_menu);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Right-click on the individual color widget to show options.");
  ImGui::Checkbox ("With HDR", &hdr);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Currently all this does is to lift the 0..1 limits on dragging widgets.");
  hdr.169_1511 = hdr;
  if (hdr.169_1511 != 0)
    goto <bb 255>;
  else
    goto <bb 256>;

  <bb 255>:
  iftmp.168_1512 = 4096;
  goto <bb 257>;

  <bb 256>:
  iftmp.168_1513 = 0;

  <bb 257>:
  # iftmp.168_82 = PHI <iftmp.168_1512(255), iftmp.168_1513(256)>
  alpha_half_preview.171_1514 = alpha_half_preview;
  if (alpha_half_preview.171_1514 != 0)
    goto <bb 258>;
  else
    goto <bb 259>;

  <bb 258>:
  iftmp.170_1515 = 2048;
  goto <bb 263>;

  <bb 259>:
  alpha_preview.173_1516 = alpha_preview;
  if (alpha_preview.173_1516 != 0)
    goto <bb 260>;
  else
    goto <bb 261>;

  <bb 260>:
  iftmp.172_1517 = 1024;
  goto <bb 262>;

  <bb 261>:
  iftmp.172_1518 = 0;

  <bb 262>:
  # iftmp.172_84 = PHI <iftmp.172_1517(260), iftmp.172_1518(261)>
  iftmp.170_1519 = iftmp.172_84;

  <bb 263>:
  # iftmp.170_83 = PHI <iftmp.170_1515(258), iftmp.170_1519(262)>
  _1520 = iftmp.168_82 | iftmp.170_83;
  options_menu.175_1521 = options_menu;
  if (options_menu.175_1521 != 0)
    goto <bb 264>;
  else
    goto <bb 265>;

  <bb 264>:
  iftmp.174_1522 = 0;
  goto <bb 266>;

  <bb 265>:
  iftmp.174_1523 = 8;

  <bb 266>:
  # iftmp.174_85 = PHI <iftmp.174_1522(264), iftmp.174_1523(265)>
  misc_flags_1524 = _1520 | iftmp.174_85;
  ImGui::Text ("Color widget:");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Click on the colored square to open a color picker.\nCTRL+click on individual component to input value.\n");
  ImGui::ColorEdit3 ("MyColor##1", &color, misc_flags_1524);
  ImGui::Text ("Color widget HSV with Alpha:");
  _1530 = misc_flags_1524 | 16384;
  ImGui::ColorEdit4 ("MyColor##2", &color, _1530);
  ImGui::Text ("Color widget with Float Display:");
  _1533 = misc_flags_1524 | 131072;
  ImGui::ColorEdit4 ("MyColor##2f", &color, _1533);
  ImGui::Text ("Color button with Picker:");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\nWith the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only be used for the tooltip and picker popup.");
  _1538 = misc_flags_1524 | 160;
  ImGui::ColorEdit4 ("MyColor##3", &color, _1538);
  ImGui::Text ("Color button with Custom Picker Popup:");
  _1542 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE13saved_palette, 2);
  retval.176_1543 = _1542 == 0;
  if (retval.176_1543 != 0)
    goto <bb 267>;
  else
    goto <bb 272>;

  <bb 267>:
  _1545 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE13saved_palette);
  retval.177_1546 = _1545 != 0;
  if (retval.177_1546 != 0)
    goto <bb 268>;
  else
    goto <bb 272>;

  <bb 268>:
  _1547 = 0;
  _1548 = &saved_palette;
  _1549 = _1548;
  _1550 = 31;

  <bb 269>:
  # _23 = PHI <_1549(268), _1552(270)>
  # _24 = PHI <_1550(268), _1553(270)>
  if (_24 < 0)
    goto <bb 271>;
  else
    goto <bb 270>;

  <bb 270>:
  ImVec4::ImVec4 (_23);
  _1552 = _23 + 16;
  _1553 = _24 + -1;
  goto <bb 269>;

  <bb 271>:
  retval.178_1554 = _1548;
  _1555 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE13saved_palette);

  <bb 272>:
  saved_palette_inited.179_1557 = saved_palette_inited;
  _1558 = ~saved_palette_inited.179_1557;
  if (_1558 != 0)
    goto <bb 273>;
  else
    goto <bb 277>;

  <bb 273>:
  n_1559 = 0;

  <bb 274>:
  # n_25 = PHI <n_1559(273), n_1567(275)>
  if (n_25 > 31)
    goto <bb 276>;
  else
    goto <bb 275>;

  <bb 275>:
  _1560 = &saved_palette[n_25].z;
  _1561 = &saved_palette[n_25].y;
  _1562 = &saved_palette[n_25].x;
  _1563 = (float) n_25;
  _1564 = _1563 / 3.1e+1;
  ImGui::ColorConvertHSVtoRGB (_1564, 8.00000011920928955078125e-1, 8.00000011920928955078125e-1, _1562, _1561, _1560);
  saved_palette[n_25].w = 1.0e+0;
  n_1567 = n_25 + 1;
  goto <bb 274>;

  <bb 276>:

  <bb 277>:
  saved_palette_inited = 1;
  _1570 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE12backup_color, 2);
  retval.180_1571 = _1570 == 0;
  if (retval.180_1571 != 0)
    goto <bb 278>;
  else
    goto <bb 280>;

  <bb 278>:
  _1573 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE12backup_color);
  retval.181_1574 = _1573 != 0;
  if (retval.181_1574 != 0)
    goto <bb 279>;
  else
    goto <bb 280>;

  <bb 279>:
  _1575 = 0;
  ImVec4::ImVec4 (&backup_color);
  _1577 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE12backup_color);

  <bb 280>:
  ImVec2::ImVec2 (&D.11605, 0.0, 0.0);
  _1581 = ImGui::ColorButton ("MyColor##3b", &color, misc_flags_1524, D.11605);
  open_popup_1582 = _1581;
  D.11605 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11606, 0.0, 0.0);
  _1587 = ImGui::Button ("Palette", &D.11606);
  _1588 = _1587;
  open_popup_1589 = open_popup_1582 | _1588;
  D.11606 ={v} {CLOBBER};
  if (open_popup_1589 != 0)
    goto <bb 281>;
  else
    goto <bb 282>;

  <bb 281>:
  ImGui::OpenPopup ("mypicker");
  backup_color = color;

  <bb 282>:
  _1594 = ImGui::BeginPopup ("mypicker", 0);
  retval.182_1595 = _1594;
  if (retval.182_1595 != 0)
    goto <bb 283>;
  else
    goto <bb 299>;

  <bb 283>:
  ImGui::Text ("MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!");
  ImGui::Separator ();
  _1598 = misc_flags_1524 | 272;
  ImGui::ColorPicker4 ("##picker", &color, _1598, 0B);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::BeginGroup ();
  ImGui::Text ("Current");
  ImVec2::ImVec2 (&D.11608, 6.0e+1, 4.0e+1);
  ImGui::ColorButton ("##current", &color, 2052, D.11608);
  D.11608 ={v} {CLOBBER};
  ImGui::Text ("Previous");
  ImVec2::ImVec2 (&D.11609, 6.0e+1, 4.0e+1);
  _1609 = ImGui::ColorButton ("##previous", &backup_color, 2052, D.11609);
  retval.183_1610 = _1609;
  D.11609 ={v} {CLOBBER};
  if (retval.183_1610 != 0)
    goto <bb 284>;
  else
    goto <bb 285>;

  <bb 284>:
  color = backup_color;

  <bb 285>:
  ImGui::Separator ();
  ImGui::Text ("Palette");
  n_1615 = 0;

  <bb 286>:
  # n_26 = PHI <n_1615(285), n_1655(297)>
  if (n_26 > 31)
    goto <bb 298>;
  else
    goto <bb 287>;

  <bb 287>:
  ImGui::PushID (n_26);
  n.184_1617 = (unsigned int) n_26;
  _1618 = n.184_1617 & 7;
  if (_1618 != 0)
    goto <bb 288>;
  else
    goto <bb 289>;

  <bb 288>:
  _1620 = ImGui::GetStyle ();
  _1621 = _1620;
  _1622 = _1621->ItemSpacing.y;
  ImGui::SameLine (0.0, _1622);

  <bb 289>:
  ImVec2::ImVec2 (&D.11611, 2.0e+1, 2.0e+1);
  _1625 = &saved_palette[n_26];
  _1627 = ImGui::ColorButton ("##palette", _1625, 70, D.11611);
  retval.185_1628 = _1627;
  D.11611 ={v} {CLOBBER};
  if (retval.185_1628 != 0)
    goto <bb 290>;
  else
    goto <bb 291>;

  <bb 290>:
  _1630 = color.w;
  _1631 = saved_palette[n_26].z;
  _1632 = saved_palette[n_26].y;
  _1633 = saved_palette[n_26].x;
  ImVec4::ImVec4 (&color.186, _1633, _1632, _1631, _1630);
  color = color.186;
  color.186 ={v} {CLOBBER};

  <bb 291>:
  _1638 = ImGui::BeginDragDropTarget ();
  retval.187_1639 = _1638;
  if (retval.187_1639 != 0)
    goto <bb 292>;
  else
    goto <bb 297>;

  <bb 292>:
  _1641 = ImGui::AcceptDragDropPayload ("_COL3F", 0);
  payload_1642 = _1641;
  if (payload_1642 != 0B)
    goto <bb 293>;
  else
    goto <bb 294>;

  <bb 293>:
  _1643 = payload_1642->Data;
  _1644 = &saved_palette[n_26];
  memcpy (_1644, _1643, 12);

  <bb 294>:
  _1647 = ImGui::AcceptDragDropPayload ("_COL4F", 0);
  payload_1648 = _1647;
  if (payload_1648 != 0B)
    goto <bb 295>;
  else
    goto <bb 296>;

  <bb 295>:
  _1649 = payload_1648->Data;
  _1650 = &saved_palette[n_26];
  _1651 = MEM[(char * {ref-all})_1649];
  MEM[(char * {ref-all})_1650] = _1651;

  <bb 296>:
  ImGui::EndDragDropTarget ();

  <bb 297>:
  ImGui::PopID ();
  n_1655 = n_26 + 1;
  goto <bb 286>;

  <bb 298>:
  ImGui::EndGroup ();
  ImGui::EndPopup ();

  <bb 299>:
  ImGui::Text ("Color button only:");
  ImVec2::ImVec2 (&D.11615, 8.0e+1, 8.0e+1);
  ImGui::ColorButton ("MyColor##3c", &color, misc_flags_1524, D.11615);
  D.11615 ={v} {CLOBBER};
  ImGui::Text ("Color picker:");
  _1667 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE11ref_color_v, 2);
  retval.188_1668 = _1667 == 0;
  if (retval.188_1668 != 0)
    goto <bb 300>;
  else
    goto <bb 302>;

  <bb 300>:
  _1670 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE11ref_color_v);
  retval.189_1671 = _1670 != 0;
  if (retval.189_1671 != 0)
    goto <bb 301>;
  else
    goto <bb 302>;

  <bb 301>:
  _1672 = 0;
  ImVec4::ImVec4 (&ref_color_v, 1.0e+0, 0.0, 1.0e+0, 5.0e-1);
  _1674 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE11ref_color_v);

  <bb 302>:
  ImGui::Checkbox ("With Alpha", &alpha);
  ImGui::Checkbox ("With Alpha Bar", &alpha_bar);
  ImGui::Checkbox ("With Side Preview", &side_preview);
  side_preview.190_1679 = side_preview;
  if (side_preview.190_1679 != 0)
    goto <bb 303>;
  else
    goto <bb 305>;

  <bb 303>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Checkbox ("With Ref Color", &ref_color);
  ref_color.191_1682 = ref_color;
  if (ref_color.191_1682 != 0)
    goto <bb 304>;
  else
    goto <bb 305>;

  <bb 304>:
  ImGui::SameLine (0.0, -1.0e+0);
  _1684 = misc_flags_1524 | 32;
  ImGui::ColorEdit4 ("##RefColor", &ref_color_v.x, _1684);

  <bb 305>:
  ImGui::Combo ("Inputs Mode", &inputs_mode, "All Inputs", -1);
  ImGui::Combo ("Picker Mode", &picker_mode, "Auto/Current", -1);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("User can right-click the picker to change mode.");
  flags_1690 = misc_flags_1524;
  alpha.192_1691 = alpha;
  _1692 = ~alpha.192_1691;
  if (_1692 != 0)
    goto <bb 306>;
  else
    goto <bb 307>;

  <bb 306>:
  flags_1693 = flags_1690 | 2;

  <bb 307>:
  # flags_27 = PHI <flags_1690(305), flags_1693(306)>
  alpha_bar.193_1694 = alpha_bar;
  if (alpha_bar.193_1694 != 0)
    goto <bb 308>;
  else
    goto <bb 309>;

  <bb 308>:
  flags_1695 = flags_27 | 512;

  <bb 309>:
  # flags_28 = PHI <flags_27(307), flags_1695(308)>
  side_preview.194_1696 = side_preview;
  _1697 = ~side_preview.194_1696;
  if (_1697 != 0)
    goto <bb 310>;
  else
    goto <bb 311>;

  <bb 310>:
  flags_1698 = flags_28 | 256;

  <bb 311>:
  # flags_29 = PHI <flags_28(309), flags_1698(310)>
  picker_mode.195_1699 = picker_mode;
  if (picker_mode.195_1699 == 1)
    goto <bb 312>;
  else
    goto <bb 313>;

  <bb 312>:
  flags_1700 = flags_29 | 262144;

  <bb 313>:
  # flags_30 = PHI <flags_29(311), flags_1700(312)>
  picker_mode.196_1701 = picker_mode;
  if (picker_mode.196_1701 == 2)
    goto <bb 314>;
  else
    goto <bb 315>;

  <bb 314>:
  flags_1702 = flags_30 | 524288;

  <bb 315>:
  # flags_31 = PHI <flags_30(313), flags_1702(314)>
  inputs_mode.197_1703 = inputs_mode;
  if (inputs_mode.197_1703 == 1)
    goto <bb 316>;
  else
    goto <bb 317>;

  <bb 316>:
  flags_1704 = flags_31 | 32;

  <bb 317>:
  # flags_32 = PHI <flags_31(315), flags_1704(316)>
  inputs_mode.198_1705 = inputs_mode;
  if (inputs_mode.198_1705 == 2)
    goto <bb 318>;
  else
    goto <bb 319>;

  <bb 318>:
  flags_1706 = flags_32 | 8192;

  <bb 319>:
  # flags_33 = PHI <flags_32(317), flags_1706(318)>
  inputs_mode.199_1707 = inputs_mode;
  if (inputs_mode.199_1707 == 3)
    goto <bb 320>;
  else
    goto <bb 321>;

  <bb 320>:
  flags_1708 = flags_33 | 16384;

  <bb 321>:
  # flags_34 = PHI <flags_33(319), flags_1708(320)>
  inputs_mode.200_1709 = inputs_mode;
  if (inputs_mode.200_1709 == 4)
    goto <bb 322>;
  else
    goto <bb 323>;

  <bb 322>:
  flags_1710 = flags_34 | 32768;

  <bb 323>:
  # flags_35 = PHI <flags_34(321), flags_1710(322)>
  ref_color.202_1711 = ref_color;
  if (ref_color.202_1711 != 0)
    goto <bb 324>;
  else
    goto <bb 325>;

  <bb 324>:
  iftmp.201_1712 = &ref_color_v.x;
  goto <bb 326>;

  <bb 325>:
  iftmp.201_1713 = 0B;

  <bb 326>:
  # iftmp.201_86 = PHI <iftmp.201_1712(324), iftmp.201_1713(325)>
  ImGui::ColorPicker4 ("MyColor##4", &color, flags_35, iftmp.201_86);
  ImGui::Text ("Programmatically set defaults/options:");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("SetColorEditOptions() is designed to allow you to set boot-time default.\nWe don\'t have Push/Pop functions because you can force options on a per-widget basis if needed, and the user can change non-forced ones with the options menu.\nWe don\'t have a getter to avoid encouraging you to persistently save values that aren\'t forward-compatible.");
  ImVec2::ImVec2 (&D.11626, 0.0, 0.0);
  _1720 = ImGui::Button ("Uint8 + HSV", &D.11626);
  retval.203_1721 = _1720;
  D.11626 ={v} {CLOBBER};
  if (retval.203_1721 != 0)
    goto <bb 327>;
  else
    goto <bb 328>;

  <bb 327>:
  ImGui::SetColorEditOptions (81920);

  <bb 328>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11627, 0.0, 0.0);
  _1727 = ImGui::Button ("Float + HDR", &D.11627);
  retval.204_1728 = _1727;
  D.11627 ={v} {CLOBBER};
  if (retval.204_1728 != 0)
    goto <bb 329>;
  else
    goto <bb 330>;

  <bb 329>:
  ImGui::SetColorEditOptions (139264);

  <bb 330>:
  ImGui::TreePop ();

  <bb 331>:
  _1738 = ImGui::TreeNode ("Range Widgets");
  retval.205_1739 = _1738;
  if (retval.205_1739 != 0)
    goto <bb 332>;
  else
    goto <bb 333>;

  <bb 332>:
  ImGui::DragFloatRange2 ("range", &begin, &end, 2.5e-1, 0.0, 1.0e+2, "Min: %.1f %%", "Max: %.1f %%", 1.0e+0);
  ImGui::DragIntRange2 ("range int (no bounds)", &begin_i, &end_i, 5.0e+0, 0, 0, "Min: %.0f units", "Max: %.0f units");
  ImGui::TreePop ();

  <bb 333>:
  _1744 = ImGui::TreeNode ("Multi-component Widgets");
  retval.206_1745 = _1744;
  if (retval.206_1745 != 0)
    goto <bb 334>;
  else
    goto <bb 335>;

  <bb 334>:
  ImGui::InputFloat2 ("input float2", &vec4f, -1, 0);
  ImGui::DragFloat2 ("drag float2", &vec4f, 9.99999977648258209228515625e-3, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::SliderFloat2 ("slider float2", &vec4f, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::DragInt2 ("drag int2", &vec4i, 1.0e+0, 0, 255, "%.0f");
  ImGui::InputInt2 ("input int2", &vec4i, 0);
  ImGui::SliderInt2 ("slider int2", &vec4i, 0, 255, "%.0f");
  ImGui::Spacing ();
  ImGui::InputFloat3 ("input float3", &vec4f, -1, 0);
  ImGui::DragFloat3 ("drag float3", &vec4f, 9.99999977648258209228515625e-3, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::SliderFloat3 ("slider float3", &vec4f, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::DragInt3 ("drag int3", &vec4i, 1.0e+0, 0, 255, "%.0f");
  ImGui::InputInt3 ("input int3", &vec4i, 0);
  ImGui::SliderInt3 ("slider int3", &vec4i, 0, 255, "%.0f");
  ImGui::Spacing ();
  ImGui::InputFloat4 ("input float4", &vec4f, -1, 0);
  ImGui::DragFloat4 ("drag float4", &vec4f, 9.99999977648258209228515625e-3, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::SliderFloat4 ("slider float4", &vec4f, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::InputInt4 ("input int4", &vec4i, 0);
  ImGui::DragInt4 ("drag int4", &vec4i, 1.0e+0, 0, 255, "%.0f");
  ImGui::SliderInt4 ("slider int4", &vec4i, 0, 255, "%.0f");
  ImGui::TreePop ();

  <bb 335>:
  _1768 = ImGui::TreeNode ("Vertical Sliders");
  retval.207_1769 = _1768;
  if (retval.207_1769 != 0)
    goto <bb 336>;
  else
    goto <bb 367>;

  <bb 336>:
  spacing_1770 = 4.0e+0;
  ImVec2::ImVec2 (&D.11635, 4.0e+0, 4.0e+0);
  ImGui::PushStyleVar (13, &D.11635);
  D.11635 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11637, 1.8e+1, 1.6e+2);
  ImGui::VSliderInt ("##int", &D.11637, &int_value, 0, 5, "%.0f");
  D.11637 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushID ("set1");
  i_1779 = 0;

  <bb 337>:
  # i_36 = PHI <i_1779(336), i_1828(346)>
  if (i_36 > 6)
    goto <bb 347>;
  else
    goto <bb 338>;

  <bb 338>:
  if (i_36 > 0)
    goto <bb 339>;
  else
    goto <bb 340>;

  <bb 339>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 340>:
  ImGui::PushID (i_36);
  _1782 = (float) i_36;
  _1783 = _1782 / 7.0e+0;
  D.11640 = ImColor::HSV (_1783, 5.0e-1, 5.0e-1, 1.0e+0);
  D.11641 = ImColor::operator ImVec4 (&D.11640);
  ImGui::PushStyleColor (7, &D.11641);
  D.11641 ={v} {CLOBBER};
  D.11640 ={v} {CLOBBER};
  _1789 = (float) i_36;
  _1790 = _1789 / 7.0e+0;
  D.11642 = ImColor::HSV (_1790, 6.0000002384185791015625e-1, 5.0e-1, 1.0e+0);
  D.11643 = ImColor::operator ImVec4 (&D.11642);
  ImGui::PushStyleColor (8, &D.11643);
  D.11643 ={v} {CLOBBER};
  D.11642 ={v} {CLOBBER};
  _1796 = (float) i_36;
  _1797 = _1796 / 7.0e+0;
  D.11644 = ImColor::HSV (_1797, 6.99999988079071044921875e-1, 5.0e-1, 1.0e+0);
  D.11645 = ImColor::operator ImVec4 (&D.11644);
  ImGui::PushStyleColor (9, &D.11645);
  D.11645 ={v} {CLOBBER};
  D.11644 ={v} {CLOBBER};
  _1803 = (float) i_36;
  _1804 = _1803 / 7.0e+0;
  D.11646 = ImColor::HSV (_1804, 8.9999997615814208984375e-1, 8.9999997615814208984375e-1, 1.0e+0);
  D.11647 = ImColor::operator ImVec4 (&D.11646);
  ImGui::PushStyleColor (19, &D.11647);
  D.11647 ={v} {CLOBBER};
  D.11646 ={v} {CLOBBER};
  _1810 = &values[i_36];
  ImVec2::ImVec2 (&D.11648, 1.8e+1, 1.6e+2);
  ImGui::VSliderFloat ("##v", &D.11648, _1810, 0.0, 1.0e+0, "", 1.0e+0);
  D.11648 ={v} {CLOBBER};
  _1815 = ImGui::IsItemActive ();
  _1816 = _1815;
  if (_1816 != 0)
    goto <bb 342>;
  else
    goto <bb 341>;

  <bb 341>:
  _1818 = ImGui::IsItemHovered (0);
  _1819 = _1818;
  if (_1819 != 0)
    goto <bb 342>;
  else
    goto <bb 343>;

  <bb 342>:
  iftmp.209_1821 = 1;
  goto <bb 344>;

  <bb 343>:
  iftmp.209_1820 = 0;

  <bb 344>:
  # iftmp.209_87 = PHI <iftmp.209_1821(342), iftmp.209_1820(343)>
  retval.208_1822 = iftmp.209_87;
  if (retval.208_1822 != 0)
    goto <bb 345>;
  else
    goto <bb 346>;

  <bb 345>:
  _1823 = values[i_36];
  _1824 = (double) _1823;
  ImGui::SetTooltip ("%.3f", _1824);

  <bb 346>:
  ImGui::PopStyleColor (4);
  ImGui::PopID ();
  i_1828 = i_36 + 1;
  goto <bb 337>;

  <bb 347>:
  ImGui::PopID ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushID ("set2");
  rows_1841 = 3;
  ImVec2::ImVec2 (&small_slider_size, 1.8e+1, 5.0666667938232421875e+1);
  nx_1843 = 0;

  <bb 348>:
  # nx_37 = PHI <nx_1843(347), nx_1867(360)>
  if (nx_37 > 3)
    goto <bb 361>;
  else
    goto <bb 349>;

  <bb 349>:
  if (nx_37 > 0)
    goto <bb 350>;
  else
    goto <bb 351>;

  <bb 350>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 351>:
  ImGui::BeginGroup ();
  ny_1846 = 0;

  <bb 352>:
  # ny_38 = PHI <ny_1846(351), ny_1865(359)>
  if (ny_38 > 2)
    goto <bb 360>;
  else
    goto <bb 353>;

  <bb 353>:
  _1847 = nx_37 * 3;
  _1848 = _1847 + ny_38;
  ImGui::PushID (_1848);
  _1850 = &values2[nx_37];
  ImGui::VSliderFloat ("##v", &small_slider_size, _1850, 0.0, 1.0e+0, "", 1.0e+0);
  _1853 = ImGui::IsItemActive ();
  _1854 = _1853;
  if (_1854 != 0)
    goto <bb 355>;
  else
    goto <bb 354>;

  <bb 354>:
  _1856 = ImGui::IsItemHovered (0);
  _1857 = _1856;
  if (_1857 != 0)
    goto <bb 355>;
  else
    goto <bb 356>;

  <bb 355>:
  iftmp.211_1859 = 1;
  goto <bb 357>;

  <bb 356>:
  iftmp.211_1858 = 0;

  <bb 357>:
  # iftmp.211_88 = PHI <iftmp.211_1859(355), iftmp.211_1858(356)>
  retval.210_1860 = iftmp.211_88;
  if (retval.210_1860 != 0)
    goto <bb 358>;
  else
    goto <bb 359>;

  <bb 358>:
  _1861 = values2[nx_37];
  _1862 = (double) _1861;
  ImGui::SetTooltip ("%.3f", _1862);

  <bb 359>:
  ImGui::PopID ();
  ny_1865 = ny_38 + 1;
  goto <bb 352>;

  <bb 360>:
  ImGui::EndGroup ();
  nx_1867 = nx_37 + 1;
  goto <bb 348>;

  <bb 361>:
  ImGui::PopID ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushID ("set3");
  i_1871 = 0;

  <bb 362>:
  # i_39 = PHI <i_1871(361), i_1881(365)>
  if (i_39 > 3)
    goto <bb 366>;
  else
    goto <bb 363>;

  <bb 363>:
  if (i_39 > 0)
    goto <bb 364>;
  else
    goto <bb 365>;

  <bb 364>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 365>:
  ImGui::PushID (i_39);
  ImGui::PushStyleVar (18, 4.0e+1);
  _1875 = &values[i_39];
  ImVec2::ImVec2 (&D.11655, 4.0e+1, 1.6e+2);
  ImGui::VSliderFloat ("##v", &D.11655, _1875, 0.0, 1.0e+0, "%.2f\nsec", 1.0e+0);
  D.11655 ={v} {CLOBBER};
  ImGui::PopStyleVar (1);
  ImGui::PopID ();
  i_1881 = i_39 + 1;
  goto <bb 362>;

  <bb 366>:
  ImGui::PopID ();
  ImGui::PopStyleVar (1);
  ImGui::TreePop ();
  small_slider_size ={v} {CLOBBER};

  <bb 367>:

  <bb 368>:
  _1891 = ImGui::CollapsingHeader ("Layout", 0);
  retval.212_1892 = _1891;
  if (retval.212_1892 != 0)
    goto <bb 369>;
  else
    goto <bb 500>;

  <bb 369>:
  _1894 = ImGui::TreeNode ("Child regions");
  retval.213_1895 = _1894;
  if (retval.213_1895 != 0)
    goto <bb 370>;
  else
    goto <bb 402>;

  <bb 370>:
  ImGui::Checkbox ("Disable Mouse Wheel", &disable_mouse_wheel);
  ImGui::Checkbox ("Disable Menu", &disable_menu);
  ImVec2::ImVec2 (&D.11660, 0.0, 0.0);
  _1900 = ImGui::Button ("Goto", &D.11660);
  goto_line_1901 = _1900;
  D.11660 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushItemWidth (1.0e+2);
  _1906 = ImGui::InputInt ("##Line", &line, 0, 0, 32);
  _1907 = _1906;
  goto_line_1908 = goto_line_1901 | _1907;
  ImGui::PopItemWidth ();
  disable_mouse_wheel.215_1910 = disable_mouse_wheel;
  if (disable_mouse_wheel.215_1910 != 0)
    goto <bb 371>;
  else
    goto <bb 372>;

  <bb 371>:
  iftmp.214_1911 = 2064;
  goto <bb 373>;

  <bb 372>:
  iftmp.214_1912 = 2048;

  <bb 373>:
  # iftmp.214_89 = PHI <iftmp.214_1911(371), iftmp.214_1912(372)>
  _1914 = ImGui::GetWindowContentRegionWidth ();
  _1915 = _1914;
  _1916 = _1915 * 5.0e-1;
  ImVec2::ImVec2 (&D.11662, _1916, 3.0e+2);
  ImGui::BeginChild ("Child1", &D.11662, 0, iftmp.214_89);
  D.11662 ={v} {CLOBBER};
  i_1920 = 0;

  <bb 374>:
  # i_40 = PHI <i_1920(373), i_1924(378)>
  if (i_40 > 99)
    goto <bb 379>;
  else
    goto <bb 375>;

  <bb 375>:
  ImGui::Text ("%04d: scrollable region", i_40);
  if (goto_line_1908 != 0)
    goto <bb 376>;
  else
    goto <bb 378>;

  <bb 376>:
  line.216_1922 = line;
  if (line.216_1922 == i_40)
    goto <bb 377>;
  else
    goto <bb 378>;

  <bb 377>:
  ImGui::SetScrollHere (5.0e-1);

  <bb 378>:
  i_1924 = i_40 + 1;
  goto <bb 374>;

  <bb 379>:
  if (goto_line_1908 != 0)
    goto <bb 380>;
  else
    goto <bb 382>;

  <bb 380>:
  line.217_1925 = line;
  if (line.217_1925 > 99)
    goto <bb 381>;
  else
    goto <bb 382>;

  <bb 381>:
  ImGui::SetScrollHere (5.0e-1);

  <bb 382>:
  ImGui::EndChild ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushStyleVar (6, 5.0e+0);
  disable_mouse_wheel.219_1930 = disable_mouse_wheel;
  if (disable_mouse_wheel.219_1930 != 0)
    goto <bb 383>;
  else
    goto <bb 384>;

  <bb 383>:
  iftmp.218_1931 = 16;
  goto <bb 385>;

  <bb 384>:
  iftmp.218_1932 = 0;

  <bb 385>:
  # iftmp.218_90 = PHI <iftmp.218_1931(383), iftmp.218_1932(384)>
  disable_menu.221_1933 = disable_menu;
  if (disable_menu.221_1933 != 0)
    goto <bb 386>;
  else
    goto <bb 387>;

  <bb 386>:
  iftmp.220_1934 = 0;
  goto <bb 388>;

  <bb 387>:
  iftmp.220_1935 = 1024;

  <bb 388>:
  # iftmp.220_91 = PHI <iftmp.220_1934(386), iftmp.220_1935(387)>
  _1936 = iftmp.218_90 | iftmp.220_91;
  ImVec2::ImVec2 (&D.11664, 0.0, 3.0e+2);
  ImGui::BeginChild ("Child2", &D.11664, 1, _1936);
  D.11664 ={v} {CLOBBER};
  disable_menu.224_1940 = disable_menu;
  _1941 = ~disable_menu.224_1940;
  if (_1941 != 0)
    goto <bb 389>;
  else
    goto <bb 391>;

  <bb 389>:
  _1943 = ImGui::BeginMenuBar ();
  _1944 = _1943;
  if (_1944 != 0)
    goto <bb 390>;
  else
    goto <bb 391>;

  <bb 390>:
  iftmp.223_1945 = 1;
  goto <bb 392>;

  <bb 391>:
  iftmp.223_1946 = 0;

  <bb 392>:
  # iftmp.223_92 = PHI <iftmp.223_1945(390), iftmp.223_1946(391)>
  retval.222_1947 = iftmp.223_92;
  if (retval.222_1947 != 0)
    goto <bb 393>;
  else
    goto <bb 396>;

  <bb 393>:
  _1949 = ImGui::BeginMenu ("Menu", 1);
  retval.225_1950 = _1949;
  if (retval.225_1950 != 0)
    goto <bb 394>;
  else
    goto <bb 395>;

  <bb 394>:
  ShowExampleMenuFile ();
  ImGui::EndMenu ();

  <bb 395>:
  ImGui::EndMenuBar ();

  <bb 396>:
  ImGui::Columns (2, 0B, 1);
  i_1955 = 0;

  <bb 397>:
  # i_41 = PHI <i_1955(396), i_1963(400)>
  if (i_41 > 99)
    goto <bb 401>;
  else
    goto <bb 398>;

  <bb 398>:
  if (i_41 == 50)
    goto <bb 399>;
  else
    goto <bb 400>;

  <bb 399>:
  ImGui::NextColumn ();

  <bb 400>:
  _1957 = i_41 * 5731;
  sprintf (&buf, "%08x", _1957);
  ImVec2::ImVec2 (&D.11667, -1.0e+0, 0.0);
  ImGui::Button (&buf, &D.11667);
  D.11667 ={v} {CLOBBER};
  buf ={v} {CLOBBER};
  i_1963 = i_41 + 1;
  goto <bb 397>;

  <bb 401>:
  ImGui::EndChild ();
  ImGui::PopStyleVar (1);
  ImGui::TreePop ();

  <bb 402>:
  _1973 = ImGui::TreeNode ("Widgets Width");
  retval.226_1974 = _1973;
  if (retval.226_1974 != 0)
    goto <bb 403>;
  else
    goto <bb 404>;

  <bb 403>:
  ImGui::Text ("PushItemWidth(100)");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Fixed width.");
  ImGui::PushItemWidth (1.0e+2);
  ImGui::DragFloat ("float##1", &f, 1.0e+0, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::Text ("PushItemWidth(GetWindowWidth() * 0.5f)");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Half of window width.");
  _1985 = ImGui::GetWindowWidth ();
  _1986 = _1985;
  _1987 = _1986 * 5.0e-1;
  ImGui::PushItemWidth (_1987);
  ImGui::DragFloat ("float##2", &f, 1.0e+0, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::Text ("PushItemWidth(GetContentRegionAvailWidth() * 0.5f)");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");
  _1995 = ImGui::GetContentRegionAvailWidth ();
  _1996 = _1995;
  _1997 = _1996 * 5.0e-1;
  ImGui::PushItemWidth (_1997);
  ImGui::DragFloat ("float##3", &f, 1.0e+0, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::Text ("PushItemWidth(-100)");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Align to right edge minus 100");
  ImGui::PushItemWidth (-1.0e+2);
  ImGui::DragFloat ("float##4", &f, 1.0e+0, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::Text ("PushItemWidth(-1)");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Align to right edge");
  ImGui::PushItemWidth (-1.0e+0);
  ImGui::DragFloat ("float##5", &f, 1.0e+0, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::TreePop ();

  <bb 404>:
  _2015 = ImGui::TreeNode ("Basic Horizontal Layout");
  retval.227_2016 = _2015;
  if (retval.227_2016 != 0)
    goto <bb 405>;
  else
    goto <bb 411>;

  <bb 405>:
  ImGui::TextWrapped ("(Use ImGui::SameLine() to keep adding items to the right of the preceding item)");
  ImGui::Text ("Two items: Hello");
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec4::ImVec4 (&D.11669, 1.0e+0, 1.0e+0, 0.0, 1.0e+0);
  ImGui::TextColored (&D.11669, "Sailor");
  D.11669 ={v} {CLOBBER};
  ImGui::Text ("More spacing: Hello");
  ImGui::SameLine (0.0, 2.0e+1);
  ImVec4::ImVec4 (&D.11670, 1.0e+0, 1.0e+0, 0.0, 1.0e+0);
  ImGui::TextColored (&D.11670, "Sailor");
  D.11670 ={v} {CLOBBER};
  ImGui::AlignTextToFramePadding ();
  ImGui::Text ("Normal buttons");
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11671, 0.0, 0.0);
  ImGui::Button ("Banana", &D.11671);
  D.11671 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11672, 0.0, 0.0);
  ImGui::Button ("Apple", &D.11672);
  D.11672 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11673, 0.0, 0.0);
  ImGui::Button ("Corniflower", &D.11673);
  D.11673 ={v} {CLOBBER};
  ImGui::Text ("Small buttons");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SmallButton ("Like this one");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("can fit within a text block.");
  ImGui::Text ("Aligned");
  ImGui::SameLine (1.5e+2, -1.0e+0);
  ImGui::Text ("x=150");
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::Text ("x=300");
  ImGui::Text ("Aligned");
  ImGui::SameLine (1.5e+2, -1.0e+0);
  ImGui::SmallButton ("x=150");
  ImGui::SameLine (3.0e+2, -1.0e+0);
  ImGui::SmallButton ("x=300");
  ImGui::Checkbox ("My", &c1);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Checkbox ("Tailor", &c2);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Checkbox ("Is", &c3);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Checkbox ("Rich", &c4);
  ImGui::PushItemWidth (8.0e+1);
  items[0] = "AAAA";
  items[1] = "BBBB";
  items[2] = "CCCC";
  items[3] = "DDDD";
  ImGui::Combo ("Combo", &item, &items, 4, -1);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SliderFloat ("X", &f0, 0.0, 5.0e+0, "%.3f", 1.0e+0);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SliderFloat ("Y", &f1, 0.0, 5.0e+0, "%.3f", 1.0e+0);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SliderFloat ("Z", &f2, 0.0, 5.0e+0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::PushItemWidth (8.0e+1);
  ImGui::Text ("Lists:");
  i_2079 = 0;

  <bb 406>:
  # i_42 = PHI <i_2079(405), i_2085(409)>
  if (i_42 > 3)
    goto <bb 410>;
  else
    goto <bb 407>;

  <bb 407>:
  if (i_42 > 0)
    goto <bb 408>;
  else
    goto <bb 409>;

  <bb 408>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 409>:
  ImGui::PushID (i_42);
  _2082 = &selection[i_42];
  ImGui::ListBox ("", _2082, &items, 4, -1);
  ImGui::PopID ();
  i_2085 = i_42 + 1;
  goto <bb 406>;

  <bb 410>:
  ImGui::PopItemWidth ();
  ImVec2::ImVec2 (&sz, 3.0e+1, 3.0e+1);
  ImGui::Button ("A", &sz);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Dummy (&sz);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Button ("B", &sz);
  ImGui::TreePop ();
  items ={v} {CLOBBER};
  sz ={v} {CLOBBER};

  <bb 411>:
  _2104 = ImGui::TreeNode ("Groups");
  retval.228_2105 = _2104;
  if (retval.228_2105 != 0)
    goto <bb 412>;
  else
    goto <bb 415>;

  <bb 412>:
  ImGui::TextWrapped ("(Using ImGui::BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.)");
  ImGui::BeginGroup ();
  ImGui::BeginGroup ();
  ImVec2::ImVec2 (&D.11686, 0.0, 0.0);
  ImGui::Button ("AAA", &D.11686);
  D.11686 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11687, 0.0, 0.0);
  ImGui::Button ("BBB", &D.11687);
  D.11687 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::BeginGroup ();
  ImVec2::ImVec2 (&D.11688, 0.0, 0.0);
  ImGui::Button ("CCC", &D.11688);
  D.11688 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11689, 0.0, 0.0);
  ImGui::Button ("DDD", &D.11689);
  D.11689 ={v} {CLOBBER};
  ImGui::EndGroup ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11690, 0.0, 0.0);
  ImGui::Button ("EEE", &D.11690);
  D.11690 ={v} {CLOBBER};
  ImGui::EndGroup ();
  _2131 = ImGui::IsItemHovered (0);
  retval.229_2132 = _2131;
  if (retval.229_2132 != 0)
    goto <bb 413>;
  else
    goto <bb 414>;

  <bb 413>:
  ImGui::SetTooltip ("First group hovered");

  <bb 414>:
  size = ImGui::GetItemRectSize ();
  values[0] = 5.0e-1;
  values[1] = 2.0000000298023223876953125e-1;
  values[2] = 8.00000011920928955078125e-1;
  values[3] = 6.0000002384185791015625e-1;
  values[4] = 2.5e-1;
  ImGui::PlotHistogram ("##values", &values, 5, 0, 0B, 0.0, 1.0e+0, size, 4);
  _2141 = size.y;
  _2142 = size.x;
  _2144 = ImGui::GetStyle ();
  _2145 = _2144;
  _2146 = _2145->ItemSpacing.x;
  _2147 = _2142 - _2146;
  _2148 = _2147 * 5.0e-1;
  ImVec2::ImVec2 (&D.11695, _2148, _2141);
  ImGui::Button ("ACTION", &D.11695);
  D.11695 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  _2153 = size.y;
  _2154 = size.x;
  _2156 = ImGui::GetStyle ();
  _2157 = _2156;
  _2158 = _2157->ItemSpacing.x;
  _2159 = _2154 - _2158;
  _2160 = _2159 * 5.0e-1;
  ImVec2::ImVec2 (&D.11696, _2160, _2153);
  ImGui::Button ("REACTION", &D.11696);
  D.11696 ={v} {CLOBBER};
  ImGui::EndGroup ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Button ("LEVERAGE\nBUZZWORD", &size);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::ListBoxHeader ("List", &size);
  ImVec2::ImVec2 (&D.11697, 0.0, 0.0);
  ImGui::Selectable ("Selected", 1, 0, &D.11697);
  D.11697 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11698, 0.0, 0.0);
  ImGui::Selectable ("Not Selected", 0, 0, &D.11698);
  D.11698 ={v} {CLOBBER};
  ImGui::ListBoxFooter ();
  ImGui::TreePop ();
  size ={v} {CLOBBER};
  values ={v} {CLOBBER};

  <bb 415>:
  _2191 = ImGui::TreeNode ("Text Baseline Alignment");
  retval.230_2192 = _2191;
  if (retval.230_2192 != 0)
    goto <bb 416>;
  else
    goto <bb 427>;

  <bb 416>:
  ImGui::TextWrapped ("(This is testing the vertical alignment that occurs on text to keep it at the same baseline as widgets. Lines only composed of text or \"small\" widgets fit in less vertical spaces than lines with normal widgets)");
  ImGui::Text ("One\nTwo\nThree");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Hello\nWorld");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Banana");
  ImGui::Text ("Banana");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Hello\nWorld");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("One\nTwo\nThree");
  ImVec2::ImVec2 (&D.11699, 0.0, 0.0);
  ImGui::Button ("HOP##1", &D.11699);
  D.11699 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Banana");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Hello\nWorld");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Banana");
  ImVec2::ImVec2 (&D.11700, 0.0, 0.0);
  ImGui::Button ("HOP##2", &D.11700);
  D.11700 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Hello\nWorld");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Banana");
  ImVec2::ImVec2 (&D.11701, 0.0, 0.0);
  ImGui::Button ("TEST##1", &D.11701);
  D.11701 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("TEST");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SmallButton ("TEST##2");
  ImGui::AlignTextToFramePadding ();
  ImGui::Text ("Text aligned to Widget");
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11702, 0.0, 0.0);
  ImGui::Button ("Widget##1", &D.11702);
  D.11702 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Widget");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SmallButton ("Widget##2");
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11703, 0.0, 0.0);
  ImGui::Button ("Widget##3", &D.11703);
  D.11703 ={v} {CLOBBER};
  _2242 = ImGui::GetStyle ();
  _2243 = _2242;
  spacing_2244 = _2243->ItemInnerSpacing.x;
  ImVec2::ImVec2 (&D.11705, 0.0, 0.0);
  ImGui::Button ("Button##1", &D.11705);
  D.11705 ={v} {CLOBBER};
  ImGui::SameLine (0.0, spacing_2244);
  _2250 = ImGui::TreeNode ("Node##1");
  retval.231_2251 = _2250;
  if (retval.231_2251 != 0)
    goto <bb 417>;
  else
    goto <bb 421>;

  <bb 417>:
  i_2252 = 0;

  <bb 418>:
  # i_43 = PHI <i_2252(417), i_2254(419)>
  if (i_43 > 5)
    goto <bb 420>;
  else
    goto <bb 419>;

  <bb 419>:
  ImGui::BulletText ("Item %d..", i_43);
  i_2254 = i_43 + 1;
  goto <bb 418>;

  <bb 420>:
  ImGui::TreePop ();

  <bb 421>:
  ImGui::AlignTextToFramePadding ();
  _2258 = ImGui::TreeNode ("Node##2");
  node_open_2259 = _2258;
  ImGui::SameLine (0.0, spacing_2244);
  ImVec2::ImVec2 (&D.11708, 0.0, 0.0);
  ImGui::Button ("Button##2", &D.11708);
  D.11708 ={v} {CLOBBER};
  if (node_open_2259 != 0)
    goto <bb 422>;
  else
    goto <bb 426>;

  <bb 422>:
  i_2264 = 0;

  <bb 423>:
  # i_44 = PHI <i_2264(422), i_2266(424)>
  if (i_44 > 5)
    goto <bb 425>;
  else
    goto <bb 424>;

  <bb 424>:
  ImGui::BulletText ("Item %d..", i_44);
  i_2266 = i_44 + 1;
  goto <bb 423>;

  <bb 425>:
  ImGui::TreePop ();

  <bb 426>:
  ImVec2::ImVec2 (&D.11710, 0.0, 0.0);
  ImGui::Button ("Button##3", &D.11710);
  D.11710 ={v} {CLOBBER};
  ImGui::SameLine (0.0, spacing_2244);
  ImGui::BulletText ("Bullet text");
  ImGui::AlignTextToFramePadding ();
  ImGui::BulletText ("Node");
  ImGui::SameLine (0.0, spacing_2244);
  ImVec2::ImVec2 (&D.11711, 0.0, 0.0);
  ImGui::Button ("Button##4", &D.11711);
  D.11711 ={v} {CLOBBER};
  ImGui::TreePop ();

  <bb 427>:
  _2290 = ImGui::TreeNode ("Scrolling");
  retval.232_2291 = _2290;
  if (retval.232_2291 != 0)
    goto <bb 428>;
  else
    goto <bb 457>;

  <bb 428>:
  ImGui::TextWrapped ("(Use SetScrollHere() or SetScrollFromPosY() to scroll to a given position.)");
  ImGui::Checkbox ("Track", &track);
  ImGui::PushItemWidth (1.0e+2);
  ImGui::SameLine (1.3e+2, -1.0e+0);
  _2297 = ImGui::DragInt ("##line", &track_line, 2.5e-1, 0, 99, "Line = %.0f");
  _2298 = _2297;
  track.233_2299 = track;
  track.234_2300 = track.233_2299 | _2298;
  track = track.234_2300;
  ImVec2::ImVec2 (&D.11717, 0.0, 0.0);
  _2304 = ImGui::Button ("Scroll To Pos", &D.11717);
  scroll_to_2305 = _2304;
  D.11717 ={v} {CLOBBER};
  ImGui::SameLine (1.3e+2, -1.0e+0);
  _2309 = ImGui::DragInt ("##pos_y", &scroll_to_px, 1.0e+0, 0, 9999, "Y = %.0f px");
  _2310 = _2309;
  scroll_to_2311 = scroll_to_2305 | _2310;
  ImGui::PopItemWidth ();
  if (scroll_to_2311 != 0)
    goto <bb 429>;
  else
    goto <bb 430>;

  <bb 429>:
  track = 0;

  <bb 430>:
  i_2314 = 0;

  <bb 431>:
  # i_45 = PHI <i_2314(430), i_2372(455)>
  if (i_45 > 4)
    goto <bb 456>;
  else
    goto <bb 432>;

  <bb 432>:
  if (i_45 > 0)
    goto <bb 433>;
  else
    goto <bb 434>;

  <bb 433>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 434>:
  ImGui::BeginGroup ();
  if (i_45 != 0)
    goto <bb 435>;
  else
    goto <bb 445>;

  <bb 435>:
  if (i_45 != 1)
    goto <bb 436>;
  else
    goto <bb 443>;

  <bb 436>:
  if (i_45 != 2)
    goto <bb 437>;
  else
    goto <bb 441>;

  <bb 437>:
  if (i_45 == 3)
    goto <bb 438>;
  else
    goto <bb 439>;

  <bb 438>:
  iftmp.238_2317 = "75%";
  goto <bb 440>;

  <bb 439>:
  iftmp.238_2318 = "Bottom";

  <bb 440>:
  # iftmp.238_96 = PHI <iftmp.238_2317(438), iftmp.238_2318(439)>
  iftmp.237_2319 = iftmp.238_96;
  goto <bb 442>;

  <bb 441>:
  iftmp.237_2320 = "Center";

  <bb 442>:
  # iftmp.237_95 = PHI <iftmp.237_2319(440), iftmp.237_2320(441)>
  iftmp.236_2321 = iftmp.237_95;
  goto <bb 444>;

  <bb 443>:
  iftmp.236_2322 = "25%";

  <bb 444>:
  # iftmp.236_94 = PHI <iftmp.236_2321(442), iftmp.236_2322(443)>
  iftmp.235_2323 = iftmp.236_94;
  goto <bb 446>;

  <bb 445>:
  iftmp.235_2324 = "Top";

  <bb 446>:
  # iftmp.235_93 = PHI <iftmp.235_2323(444), iftmp.235_2324(445)>
  ImGui::Text ("%s", iftmp.235_93);
  _2327 = ImGui::GetWindowWidth ();
  _2328 = _2327;
  _2329 = _2328 * 1.7000000178813934326171875e-1;
  ImVec2::ImVec2 (&D.11720, _2329, 2.0e+2);
  _2331 = (long int) i_45;
  _2332 = (const void *) _2331;
  _2334 = ImGui::GetID (_2332);
  _2335 = _2334;
  ImGui::BeginChild (_2335, &D.11720, 1, 0);
  D.11720 ={v} {CLOBBER};
  if (scroll_to_2311 != 0)
    goto <bb 447>;
  else
    goto <bb 448>;

  <bb 447>:
  _2338 = (float) i_45;
  _2339 = _2338 * 2.5e-1;
  D.11721 = ImGui::GetCursorStartPos ();
  _2341 = D.11721.y;
  scroll_to_px.239_2342 = scroll_to_px;
  _2343 = (float) scroll_to_px.239_2342;
  _2344 = _2341 + _2343;
  ImGui::SetScrollFromPosY (_2344, _2339);

  <bb 448>:
  line_2346 = 0;

  <bb 449>:
  # line_46 = PHI <line_2346(448), line_2360(454)>
  if (line_46 > 99)
    goto <bb 455>;
  else
    goto <bb 450>;

  <bb 450>:
  track.240_2347 = track;
  if (track.240_2347 != 0)
    goto <bb 451>;
  else
    goto <bb 453>;

  <bb 451>:
  track_line.241_2348 = track_line;
  if (line_46 == track_line.241_2348)
    goto <bb 452>;
  else
    goto <bb 453>;

  <bb 452>:
  ImColor::ImColor (&D.11723, 255, 255, 0, 255);
  D.11724 = ImColor::operator ImVec4 (&D.11723);
  ImGui::TextColored (&D.11724, "Line %d", line_46);
  D.11724 ={v} {CLOBBER};
  D.11723 ={v} {CLOBBER};
  _2354 = (float) i_45;
  _2355 = _2354 * 2.5e-1;
  ImGui::SetScrollHere (_2355);
  goto <bb 454>;

  <bb 453>:
  ImGui::Text ("Line %d", line_46);

  <bb 454>:
  line_2360 = line_46 + 1;
  goto <bb 449>;

  <bb 455>:
  _2362 = ImGui::GetScrollY ();
  scroll_y_2363 = _2362;
  _2365 = ImGui::GetScrollMaxY ();
  scroll_max_y_2366 = _2365;
  ImGui::EndChild ();
  _2368 = (double) scroll_max_y_2366;
  _2369 = (double) scroll_y_2363;
  ImGui::Text ("%.0f/%0.f", _2369, _2368);
  ImGui::EndGroup ();
  i_2372 = i_45 + 1;
  goto <bb 431>;

  <bb 456>:
  ImGui::TreePop ();

  <bb 457>:
  _2377 = ImGui::TreeNode ("Horizontal Scrolling");
  retval.242_2378 = _2377;
  if (retval.242_2378 != 0)
    goto <bb 458>;
  else
    goto <bb 485>;

  <bb 458>:
  ImGui::Bullet ();
  ImGui::TextWrapped ("Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.");
  ImGui::Bullet ();
  ImGui::TextWrapped ("You may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().");
  ImGui::SliderInt ("Lines", &lines, 1, 15, "%.0f");
  ImGui::PushStyleVar (11, 3.0e+0);
  ImVec2::ImVec2 (&D.11728, 2.0e+0, 1.0e+0);
  ImGui::PushStyleVar (10, &D.11728);
  D.11728 ={v} {CLOBBER};
  _2389 = ImGui::GetFrameHeightWithSpacing ();
  _2390 = _2389;
  _2391 = _2390 * 7.0e+0;
  _2392 = _2391 + 3.0e+1;
  ImVec2::ImVec2 (&D.11729, 0.0, _2392);
  ImGui::BeginChild ("scrolling", &D.11729, 1, 2048);
  D.11729 ={v} {CLOBBER};
  line_2396 = 0;

  <bb 459>:
  # line_47 = PHI <line_2396(458), line_2457(477)>
  lines.243_2397 = lines;
  if (line_47 >= lines.243_2397)
    goto <bb 478>;
  else
    goto <bb 460>;

  <bb 460>:
  _2398 = line_47 & 1;
  if (_2398 != 0)
    goto <bb 461>;
  else
    goto <bb 462>;

  <bb 461>:
  _2399 = line_47 * 9;
  iftmp.244_2400 = _2399 + 10;
  goto <bb 463>;

  <bb 462>:
  _2401 = line_47 * 3;
  iftmp.244_2402 = _2401 + 10;

  <bb 463>:
  # iftmp.244_97 = PHI <iftmp.244_2400(461), iftmp.244_2402(462)>
  num_buttons_2403 = iftmp.244_97;
  n_2404 = 0;

  <bb 464>:
  # n_48 = PHI <n_2404(463), n_2448(476)>
  if (n_48 >= num_buttons_2403)
    goto <bb 477>;
  else
    goto <bb 465>;

  <bb 465>:
  if (n_48 > 0)
    goto <bb 466>;
  else
    goto <bb 467>;

  <bb 466>:
  ImGui::SameLine (0.0, -1.0e+0);

  <bb 467>:
  _2406 = line_47 * 1000;
  _2407 = _2406 + n_48;
  ImGui::PushID (_2407);
  sprintf (&num_buf, "%d", n_48);
  _2410 = n_48 % 15;
  if (_2410 != 0)
    goto <bb 468>;
  else
    goto <bb 475>;

  <bb 468>:
  _2411 = n_48 % 3;
  if (_2411 != 0)
    goto <bb 469>;
  else
    goto <bb 473>;

  <bb 469>:
  _2412 = n_48 % 5;
  if (_2412 != 0)
    goto <bb 470>;
  else
    goto <bb 471>;

  <bb 470>:
  iftmp.247_2413 = &num_buf;
  goto <bb 472>;

  <bb 471>:
  iftmp.247_2414 = "Buzz";

  <bb 472>:
  # iftmp.247_100 = PHI <iftmp.247_2413(470), iftmp.247_2414(471)>
  iftmp.246_2415 = iftmp.247_100;
  goto <bb 474>;

  <bb 473>:
  iftmp.246_2416 = "Fizz";

  <bb 474>:
  # iftmp.246_99 = PHI <iftmp.246_2415(472), iftmp.246_2416(473)>
  iftmp.245_2417 = iftmp.246_99;
  goto <bb 476>;

  <bb 475>:
  iftmp.245_2418 = "FizzBuzz";

  <bb 476>:
  # iftmp.245_98 = PHI <iftmp.245_2417(474), iftmp.245_2418(475)>
  label_2419 = iftmp.245_98;
  _2420 = (float) n_48;
  hue_2421 = _2420 * 5.00000007450580596923828125e-2;
  D.11736 = ImColor::HSV (hue_2421, 6.0000002384185791015625e-1, 6.0000002384185791015625e-1, 1.0e+0);
  D.11737 = ImColor::operator ImVec4 (&D.11736);
  ImGui::PushStyleColor (21, &D.11737);
  D.11737 ={v} {CLOBBER};
  D.11736 ={v} {CLOBBER};
  D.11738 = ImColor::HSV (hue_2421, 6.99999988079071044921875e-1, 6.99999988079071044921875e-1, 1.0e+0);
  D.11739 = ImColor::operator ImVec4 (&D.11738);
  ImGui::PushStyleColor (22, &D.11739);
  D.11739 ={v} {CLOBBER};
  D.11738 ={v} {CLOBBER};
  D.11740 = ImColor::HSV (hue_2421, 8.00000011920928955078125e-1, 8.00000011920928955078125e-1, 1.0e+0);
  D.11741 = ImColor::operator ImVec4 (&D.11740);
  ImGui::PushStyleColor (23, &D.11741);
  D.11741 ={v} {CLOBBER};
  D.11740 ={v} {CLOBBER};
  _2437 = line_47 + n_48;
  _2438 = (float) _2437;
  _2439 = sinf (_2438);
  _2440 = _2439 * 2.0e+1;
  _2441 = _2440 + 4.0e+1;
  ImVec2::ImVec2 (&D.11742, _2441, 0.0);
  ImGui::Button (label_2419, &D.11742);
  D.11742 ={v} {CLOBBER};
  ImGui::PopStyleColor (3);
  ImGui::PopID ();
  num_buf ={v} {CLOBBER};
  n_2448 = n_48 + 1;
  goto <bb 464>;

  <bb 477>:
  line_2457 = line_47 + 1;
  goto <bb 459>;

  <bb 478>:
  _2459 = ImGui::GetScrollX ();
  scroll_x_2460 = _2459;
  _2462 = ImGui::GetScrollMaxX ();
  scroll_max_x_2463 = _2462;
  ImGui::EndChild ();
  ImGui::PopStyleVar (2);
  scroll_x_delta_2466 = 0.0;
  ImGui::SmallButton ("<<");
  _2469 = ImGui::IsItemActive ();
  retval.248_2470 = _2469;
  if (retval.248_2470 != 0)
    goto <bb 479>;
  else
    goto <bb 480>;

  <bb 479>:
  _2472 = ImGui::GetIO ();
  _2473 = _2472;
  _2474 = _2473->DeltaTime;
  _2475 = -_2474;
  scroll_x_delta_2476 = _2475 * 1.0e+3;

  <bb 480>:
  # scroll_x_delta_49 = PHI <scroll_x_delta_2466(478), scroll_x_delta_2476(479)>
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("Scroll from code");
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::SmallButton (">>");
  _2482 = ImGui::IsItemActive ();
  retval.249_2483 = _2482;
  if (retval.249_2483 != 0)
    goto <bb 481>;
  else
    goto <bb 482>;

  <bb 481>:
  _2485 = ImGui::GetIO ();
  _2486 = _2485;
  _2487 = _2486->DeltaTime;
  scroll_x_delta_2488 = _2487 * 1.0e+3;

  <bb 482>:
  # scroll_x_delta_50 = PHI <scroll_x_delta_49(480), scroll_x_delta_2488(481)>
  ImGui::SameLine (0.0, -1.0e+0);
  _2490 = (double) scroll_max_x_2463;
  _2491 = (double) scroll_x_2460;
  ImGui::Text ("%.0f/%.0f", _2491, _2490);
  if (scroll_x_delta_50 != 0.0)
    goto <bb 483>;
  else
    goto <bb 484>;

  <bb 483>:
  ImVec2::ImVec2 (&D.11746, 0.0, 0.0);
  ImGui::BeginChild ("scrolling", &D.11746, 0, 0);
  D.11746 ={v} {CLOBBER};
  _2497 = ImGui::GetScrollX ();
  _2498 = _2497;
  _2499 = _2498 + scroll_x_delta_50;
  ImGui::SetScrollX (_2499);
  ImGui::End ();

  <bb 484>:
  ImGui::TreePop ();

  <bb 485>:
  _2507 = ImGui::TreeNode ("Clipping");
  retval.250_2508 = _2507;
  if (retval.250_2508 != 0)
    goto <bb 486>;
  else
    goto <bb 499>;

  <bb 486>:
  _2510 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE4size, 2);
  retval.251_2511 = _2510 == 0;
  if (retval.251_2511 != 0)
    goto <bb 487>;
  else
    goto <bb 489>;

  <bb 487>:
  _2513 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE4size);
  retval.252_2514 = _2513 != 0;
  if (retval.252_2514 != 0)
    goto <bb 488>;
  else
    goto <bb 489>;

  <bb 488>:
  _2515 = 0;
  ImVec2::ImVec2 (&size, 1.0e+2, 1.0e+2);
  _2517 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE4size);

  <bb 489>:
  _2520 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE6offset, 2);
  retval.253_2521 = _2520 == 0;
  if (retval.253_2521 != 0)
    goto <bb 490>;
  else
    goto <bb 492>;

  <bb 490>:
  _2523 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE6offset);
  retval.254_2524 = _2523 != 0;
  if (retval.254_2524 != 0)
    goto <bb 491>;
  else
    goto <bb 492>;

  <bb 491>:
  _2525 = 0;
  ImVec2::ImVec2 (&offset, 5.0e+1, 2.0e+1);
  _2527 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE6offset);

  <bb 492>:
  ImGui::TextWrapped ("On a per-widget basis we are occasionally clipping text CPU-side if it won\'t fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.");
  ImGui::DragFloat2 ("size", &size, 5.0e-1, 0.0, 2.0e+2, "%.0f", 1.0e+0);
  ImGui::TextWrapped ("(Click and drag)");
  pos = ImGui::GetCursorScreenPos ();
  _2533 = pos.y;
  _2534 = size.y;
  _2535 = _2533 + _2534;
  _2536 = pos.x;
  _2537 = size.x;
  _2538 = _2536 + _2537;
  _2539 = pos.y;
  _2540 = pos.x;
  ImVec4::ImVec4 (&clip_rect, _2540, _2539, _2538, _2535);
  ImGui::InvisibleButton ("##dummy", &size);
  _2544 = ImGui::IsItemActive ();
  _2545 = _2544;
  if (_2545 != 0)
    goto <bb 493>;
  else
    goto <bb 495>;

  <bb 493>:
  _2547 = ImGui::IsMouseDragging (0, -1.0e+0);
  _2548 = _2547;
  if (_2548 != 0)
    goto <bb 494>;
  else
    goto <bb 495>;

  <bb 494>:
  iftmp.256_2549 = 1;
  goto <bb 496>;

  <bb 495>:
  iftmp.256_2550 = 0;

  <bb 496>:
  # iftmp.256_101 = PHI <iftmp.256_2549(494), iftmp.256_2550(495)>
  retval.255_2551 = iftmp.256_101;
  if (retval.255_2551 != 0)
    goto <bb 497>;
  else
    goto <bb 498>;

  <bb 497>:
  _2553 = ImGui::GetIO ();
  _2554 = _2553;
  _2555 = _2554->MouseDelta.x;
  _2556 = offset.x;
  _2557 = _2556 + _2555;
  offset.x = _2557;
  _2560 = ImGui::GetIO ();
  _2561 = _2560;
  _2562 = _2561->MouseDelta.y;
  _2563 = offset.y;
  _2564 = _2563 + _2562;
  offset.y = _2564;

  <bb 498>:
  _2566 = pos.y;
  _2567 = size.y;
  _2568 = _2566 + _2567;
  _2569 = pos.x;
  _2570 = size.x;
  _2571 = _2569 + _2570;
  ImVec2::ImVec2 (&D.11758, _2571, _2568);
  _2574 = ImGui::GetWindowDrawList ();
  _2575 = _2574;
  ImDrawList::AddRectFilled (_2575, &pos, &D.11758, 4286077530, 0.0, 15);
  D.11758 ={v} {CLOBBER};
  _2578 = pos.y;
  _2579 = offset.y;
  _2580 = _2578 + _2579;
  _2581 = pos.x;
  _2582 = offset.x;
  _2583 = _2581 + _2582;
  ImVec2::ImVec2 (&D.11759, _2583, _2580);
  _2586 = ImGui::GetFontSize ();
  _2587 = _2586;
  _2588 = _2587 * 2.0e+0;
  _2590 = ImGui::GetFont ();
  _2591 = _2590;
  _2593 = ImGui::GetWindowDrawList ();
  _2594 = _2593;
  ImDrawList::AddText (_2594, _2591, _2588, &D.11759, 4294967295, "Line 1 hello\nLine 2 clip me!", 0B, 0.0, &clip_rect);
  D.11759 ={v} {CLOBBER};
  ImGui::TreePop ();
  pos ={v} {CLOBBER};
  clip_rect ={v} {CLOBBER};

  <bb 499>:

  <bb 500>:
  _2605 = ImGui::CollapsingHeader ("Popups & Modal windows", 0);
  retval.257_2606 = _2605;
  if (retval.257_2606 != 0)
    goto <bb 501>;
  else
    goto <bb 578>;

  <bb 501>:
  _2608 = ImGui::TreeNode ("Popups");
  retval.258_2609 = _2608;
  if (retval.258_2609 != 0)
    goto <bb 502>;
  else
    goto <bb 539>;

  <bb 502>:
  ImGui::TextWrapped ("When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.");
  names[0] = "Bream";
  names[1] = "Haddock";
  names[2] = "Mackerel";
  names[3] = "Pollock";
  names[4] = "Tilefish";
  ImVec2::ImVec2 (&D.11763, 0.0, 0.0);
  _2618 = ImGui::Button ("Select..", &D.11763);
  retval.259_2619 = _2618;
  D.11763 ={v} {CLOBBER};
  if (retval.259_2619 != 0)
    goto <bb 503>;
  else
    goto <bb 504>;

  <bb 503>:
  ImGui::OpenPopup ("select");

  <bb 504>:
  ImGui::SameLine (0.0, -1.0e+0);
  selected_fish.261_2623 = selected_fish;
  if (selected_fish.261_2623 != -1)
    goto <bb 505>;
  else
    goto <bb 506>;

  <bb 505>:
  selected_fish.262_2624 = selected_fish;
  iftmp.260_2625 = names[selected_fish.262_2624];
  goto <bb 507>;

  <bb 506>:
  iftmp.260_2626 = "<None>";

  <bb 507>:
  # iftmp.260_102 = PHI <iftmp.260_2625(505), iftmp.260_2626(506)>
  ImGui::TextUnformatted (iftmp.260_102, 0B);
  _2629 = ImGui::BeginPopup ("select", 0);
  retval.263_2630 = _2629;
  if (retval.263_2630 != 0)
    goto <bb 508>;
  else
    goto <bb 514>;

  <bb 508>:
  ImGui::Text ("Aquarium");
  ImGui::Separator ();
  i_2633 = 0;

  <bb 509>:
  # i_51 = PHI <i_2633(508), i_2641(512)>
  if (i_51 > 4)
    goto <bb 513>;
  else
    goto <bb 510>;

  <bb 510>:
  ImVec2::ImVec2 (&D.11765, 0.0, 0.0);
  _2635 = names[i_51];
  _2637 = ImGui::Selectable (_2635, 0, 0, &D.11765);
  retval.264_2638 = _2637;
  D.11765 ={v} {CLOBBER};
  if (retval.264_2638 != 0)
    goto <bb 511>;
  else
    goto <bb 512>;

  <bb 511>:
  selected_fish = i_51;

  <bb 512>:
  i_2641 = i_51 + 1;
  goto <bb 509>;

  <bb 513>:
  ImGui::EndPopup ();

  <bb 514>:
  ImVec2::ImVec2 (&D.11766, 0.0, 0.0);
  _2646 = ImGui::Button ("Toggle..", &D.11766);
  retval.265_2647 = _2646;
  D.11766 ={v} {CLOBBER};
  if (retval.265_2647 != 0)
    goto <bb 515>;
  else
    goto <bb 516>;

  <bb 515>:
  ImGui::OpenPopup ("toggle");

  <bb 516>:
  _2651 = ImGui::BeginPopup ("toggle", 0);
  retval.266_2652 = _2651;
  if (retval.266_2652 != 0)
    goto <bb 517>;
  else
    goto <bb 534>;

  <bb 517>:
  i_2653 = 0;

  <bb 518>:
  # i_52 = PHI <i_2653(517), i_2657(519)>
  if (i_52 > 4)
    goto <bb 520>;
  else
    goto <bb 519>;

  <bb 519>:
  _2654 = &toggles[i_52];
  _2655 = names[i_52];
  ImGui::MenuItem (_2655, "", _2654, 1);
  i_2657 = i_52 + 1;
  goto <bb 518>;

  <bb 520>:
  _2659 = ImGui::BeginMenu ("Sub-menu", 1);
  retval.267_2660 = _2659;
  if (retval.267_2660 != 0)
    goto <bb 521>;
  else
    goto <bb 522>;

  <bb 521>:
  ImGui::MenuItem ("Click me", 0B, 0, 1);
  ImGui::EndMenu ();

  <bb 522>:
  ImGui::Separator ();
  ImGui::Text ("Tooltip here");
  _2666 = ImGui::IsItemHovered (0);
  retval.268_2667 = _2666;
  if (retval.268_2667 != 0)
    goto <bb 523>;
  else
    goto <bb 524>;

  <bb 523>:
  ImGui::SetTooltip ("I am a tooltip over a popup");

  <bb 524>:
  ImVec2::ImVec2 (&D.11768, 0.0, 0.0);
  _2671 = ImGui::Button ("Stacked Popup", &D.11768);
  retval.269_2672 = _2671;
  D.11768 ={v} {CLOBBER};
  if (retval.269_2672 != 0)
    goto <bb 525>;
  else
    goto <bb 526>;

  <bb 525>:
  ImGui::OpenPopup ("another popup");

  <bb 526>:
  _2676 = ImGui::BeginPopup ("another popup", 0);
  retval.270_2677 = _2676;
  if (retval.270_2677 != 0)
    goto <bb 527>;
  else
    goto <bb 533>;

  <bb 527>:
  i_2678 = 0;

  <bb 528>:
  # i_53 = PHI <i_2678(527), i_2682(529)>
  if (i_53 > 4)
    goto <bb 530>;
  else
    goto <bb 529>;

  <bb 529>:
  _2679 = &toggles[i_53];
  _2680 = names[i_53];
  ImGui::MenuItem (_2680, "", _2679, 1);
  i_2682 = i_53 + 1;
  goto <bb 528>;

  <bb 530>:
  _2684 = ImGui::BeginMenu ("Sub-menu", 1);
  retval.271_2685 = _2684;
  if (retval.271_2685 != 0)
    goto <bb 531>;
  else
    goto <bb 532>;

  <bb 531>:
  ImGui::MenuItem ("Click me", 0B, 0, 1);
  ImGui::EndMenu ();

  <bb 532>:
  ImGui::EndPopup ();

  <bb 533>:
  ImGui::EndPopup ();

  <bb 534>:
  ImVec2::ImVec2 (&D.11770, 0.0, 0.0);
  _2693 = ImGui::Button ("Popup Menu..", &D.11770);
  retval.272_2694 = _2693;
  D.11770 ={v} {CLOBBER};
  if (retval.272_2694 != 0)
    goto <bb 535>;
  else
    goto <bb 536>;

  <bb 535>:
  ImGui::OpenPopup ("FilePopup");

  <bb 536>:
  _2698 = ImGui::BeginPopup ("FilePopup", 0);
  retval.273_2699 = _2698;
  if (retval.273_2699 != 0)
    goto <bb 537>;
  else
    goto <bb 538>;

  <bb 537>:
  ShowExampleMenuFile ();
  ImGui::EndPopup ();

  <bb 538>:
  ImGui::TreePop ();
  names ={v} {CLOBBER};

  <bb 539>:
  _2709 = ImGui::TreeNode ("Context menus");
  retval.274_2710 = _2709;
  if (retval.274_2710 != 0)
    goto <bb 540>;
  else
    goto <bb 551>;

  <bb 540>:
  value.275_2711 = value;
  _2712 = (double) value.275_2711;
  ImGui::Text ("Value = %.3f (<-- right-click here)", _2712);
  _2715 = ImGui::BeginPopupContextItem ("item context menu", 1);
  retval.276_2716 = _2715;
  if (retval.276_2716 != 0)
    goto <bb 541>;
  else
    goto <bb 546>;

  <bb 541>:
  ImVec2::ImVec2 (&D.11772, 0.0, 0.0);
  _2719 = ImGui::Selectable ("Set to zero", 0, 0, &D.11772);
  retval.277_2720 = _2719;
  D.11772 ={v} {CLOBBER};
  if (retval.277_2720 != 0)
    goto <bb 542>;
  else
    goto <bb 543>;

  <bb 542>:
  value = 0.0;

  <bb 543>:
  ImVec2::ImVec2 (&D.11773, 0.0, 0.0);
  _2725 = ImGui::Selectable ("Set to PI", 0, 0, &D.11773);
  retval.278_2726 = _2725;
  D.11773 ={v} {CLOBBER};
  if (retval.278_2726 != 0)
    goto <bb 544>;
  else
    goto <bb 545>;

  <bb 544>:
  value = 3.141499996185302734375e+0;

  <bb 545>:
  ImGui::PushItemWidth (-1.0e+0);
  ImGui::DragFloat ("##Value", &value, 1.00000001490116119384765625e-1, 0.0, 0.0, "%.3f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::EndPopup ();

  <bb 546>:
  sprintf (&buf, "Button: %s###Button", &name);
  ImVec2::ImVec2 (&D.11776, 0.0, 0.0);
  ImGui::Button (&buf, &D.11776);
  D.11776 ={v} {CLOBBER};
  _2740 = ImGui::BeginPopupContextItem (0B, 1);
  retval.279_2741 = _2740;
  if (retval.279_2741 != 0)
    goto <bb 547>;
  else
    goto <bb 550>;

  <bb 547>:
  ImGui::Text ("Edit name:");
  ImGui::InputText ("##edit", &name, 32, 0, 0B, 0B);
  ImVec2::ImVec2 (&D.11777, 0.0, 0.0);
  _2746 = ImGui::Button ("Close", &D.11777);
  retval.280_2747 = _2746;
  D.11777 ={v} {CLOBBER};
  if (retval.280_2747 != 0)
    goto <bb 548>;
  else
    goto <bb 549>;

  <bb 548>:
  ImGui::CloseCurrentPopup ();

  <bb 549>:
  ImGui::EndPopup ();

  <bb 550>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("(<-- right-click here)");
  ImGui::TreePop ();
  buf ={v} {CLOBBER};

  <bb 551>:
  _2759 = ImGui::TreeNode ("Modals");
  retval.281_2760 = _2759;
  if (retval.281_2760 != 0)
    goto <bb 552>;
  else
    goto <bb 573>;

  <bb 552>:
  ImGui::TextWrapped ("Modal windows are like popups but the user cannot close them by clicking outside the window.");
  ImVec2::ImVec2 (&D.11778, 0.0, 0.0);
  _2764 = ImGui::Button ("Delete..", &D.11778);
  retval.282_2765 = _2764;
  D.11778 ={v} {CLOBBER};
  if (retval.282_2765 != 0)
    goto <bb 553>;
  else
    goto <bb 554>;

  <bb 553>:
  ImGui::OpenPopup ("Delete?");

  <bb 554>:
  _2769 = ImGui::BeginPopupModal ("Delete?", 0B, 64);
  retval.283_2770 = _2769;
  if (retval.283_2770 != 0)
    goto <bb 555>;
  else
    goto <bb 560>;

  <bb 555>:
  ImGui::Text ("All those beautiful files will be deleted.\nThis operation cannot be undone!\n\n");
  ImGui::Separator ();
  ImVec2::ImVec2 (&D.11780, 0.0, 0.0);
  ImGui::PushStyleVar (10, &D.11780);
  D.11780 ={v} {CLOBBER};
  ImGui::Checkbox ("Don\'t ask me next time", &dont_ask_me_next_time);
  ImGui::PopStyleVar (1);
  ImVec2::ImVec2 (&D.11781, 1.2e+2, 0.0);
  _2780 = ImGui::Button ("OK", &D.11781);
  retval.284_2781 = _2780;
  D.11781 ={v} {CLOBBER};
  if (retval.284_2781 != 0)
    goto <bb 556>;
  else
    goto <bb 557>;

  <bb 556>:
  ImGui::CloseCurrentPopup ();

  <bb 557>:
  ImGui::SetItemDefaultFocus ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11782, 1.2e+2, 0.0);
  _2788 = ImGui::Button ("Cancel", &D.11782);
  retval.285_2789 = _2788;
  D.11782 ={v} {CLOBBER};
  if (retval.285_2789 != 0)
    goto <bb 558>;
  else
    goto <bb 559>;

  <bb 558>:
  ImGui::CloseCurrentPopup ();

  <bb 559>:
  ImGui::EndPopup ();

  <bb 560>:
  ImVec2::ImVec2 (&D.11783, 0.0, 0.0);
  _2798 = ImGui::Button ("Stacked modals..", &D.11783);
  retval.286_2799 = _2798;
  D.11783 ={v} {CLOBBER};
  if (retval.286_2799 != 0)
    goto <bb 561>;
  else
    goto <bb 562>;

  <bb 561>:
  ImGui::OpenPopup ("Stacked 1");

  <bb 562>:
  _2803 = ImGui::BeginPopupModal ("Stacked 1", 0B, 0);
  retval.287_2804 = _2803;
  if (retval.287_2804 != 0)
    goto <bb 563>;
  else
    goto <bb 572>;

  <bb 563>:
  ImGui::Text ("Hello from Stacked The First\nUsing style.Colors[ImGuiCol_ModalWindowDarkening] for darkening.");
  ImGui::Combo ("Combo", &item, "aaaa", -1);
  ImGui::ColorEdit4 ("color", &color, 0);
  ImVec2::ImVec2 (&D.11786, 0.0, 0.0);
  _2810 = ImGui::Button ("Add another modal..", &D.11786);
  retval.288_2811 = _2810;
  D.11786 ={v} {CLOBBER};
  if (retval.288_2811 != 0)
    goto <bb 564>;
  else
    goto <bb 565>;

  <bb 564>:
  ImGui::OpenPopup ("Stacked 2");

  <bb 565>:
  _2815 = ImGui::BeginPopupModal ("Stacked 2", 0B, 0);
  retval.289_2816 = _2815;
  if (retval.289_2816 != 0)
    goto <bb 566>;
  else
    goto <bb 569>;

  <bb 566>:
  ImGui::Text ("Hello from Stacked The Second!");
  ImVec2::ImVec2 (&D.11787, 0.0, 0.0);
  _2820 = ImGui::Button ("Close", &D.11787);
  retval.290_2821 = _2820;
  D.11787 ={v} {CLOBBER};
  if (retval.290_2821 != 0)
    goto <bb 567>;
  else
    goto <bb 568>;

  <bb 567>:
  ImGui::CloseCurrentPopup ();

  <bb 568>:
  ImGui::EndPopup ();

  <bb 569>:
  ImVec2::ImVec2 (&D.11788, 0.0, 0.0);
  _2828 = ImGui::Button ("Close", &D.11788);
  retval.291_2829 = _2828;
  D.11788 ={v} {CLOBBER};
  if (retval.291_2829 != 0)
    goto <bb 570>;
  else
    goto <bb 571>;

  <bb 570>:
  ImGui::CloseCurrentPopup ();

  <bb 571>:
  ImGui::EndPopup ();

  <bb 572>:
  ImGui::TreePop ();

  <bb 573>:
  _2839 = ImGui::TreeNode ("Menus inside a regular window");
  retval.292_2840 = _2839;
  if (retval.292_2840 != 0)
    goto <bb 574>;
  else
    goto <bb 577>;

  <bb 574>:
  ImGui::TextWrapped ("Below we are testing adding menu items to a regular window. It\'s rather unusual but should work!");
  ImGui::Separator ();
  ImGui::PushID ("foo");
  ImGui::MenuItem ("Menu item", "CTRL+M", 0, 1);
  _2846 = ImGui::BeginMenu ("Menu inside a regular window", 1);
  retval.293_2847 = _2846;
  if (retval.293_2847 != 0)
    goto <bb 575>;
  else
    goto <bb 576>;

  <bb 575>:
  ShowExampleMenuFile ();
  ImGui::EndMenu ();

  <bb 576>:
  ImGui::PopID ();
  ImGui::Separator ();
  ImGui::TreePop ();

  <bb 577>:

  <bb 578>:
  _2854 = ImGui::CollapsingHeader ("Columns", 0);
  retval.294_2855 = _2854;
  if (retval.294_2855 != 0)
    goto <bb 579>;
  else
    goto <bb 637>;

  <bb 579>:
  ImGui::PushID ("Columns");
  _2858 = ImGui::TreeNode ("Basic");
  retval.295_2859 = _2858;
  if (retval.295_2859 != 0)
    goto <bb 580>;
  else
    goto <bb 590>;

  <bb 580>:
  ImGui::Text ("Without border:");
  ImGui::Columns (3, "mycolumns3", 0);
  ImGui::Separator ();
  n_2863 = 0;

  <bb 581>:
  # n_54 = PHI <n_2863(580), n_2872(583)>
  if (n_54 > 13)
    goto <bb 584>;
  else
    goto <bb 582>;

  <bb 582>:
  sprintf (&label, "Item %d", n_54);
  ImVec2::ImVec2 (&D.11791, 0.0, 0.0);
  _2867 = ImGui::Selectable (&label, 0, 0, &D.11791);
  retval.296_2868 = _2867;
  D.11791 ={v} {CLOBBER};

  <bb 583>:
  ImGui::NextColumn ();
  label ={v} {CLOBBER};
  n_2872 = n_54 + 1;
  goto <bb 581>;

  <bb 584>:
  ImGui::Columns (1, 0B, 1);
  ImGui::Separator ();
  ImGui::Text ("With border:");
  ImGui::Columns (4, "mycolumns", 1);
  ImGui::Separator ();
  ImGui::Text ("ID");
  ImGui::NextColumn ();
  ImGui::Text ("Name");
  ImGui::NextColumn ();
  ImGui::Text ("Path");
  ImGui::NextColumn ();
  ImGui::Text ("Hovered");
  ImGui::NextColumn ();
  ImGui::Separator ();
  names[0] = "One";
  names[1] = "Two";
  names[2] = "Three";
  paths[0] = "/path/one";
  paths[1] = "/path/two";
  paths[2] = "/path/three";
  i_2895 = 0;

  <bb 585>:
  # i_55 = PHI <i_2895(584), i_2920(588)>
  if (i_55 > 2)
    goto <bb 589>;
  else
    goto <bb 586>;

  <bb 586>:
  sprintf (&label, "%04d", i_55);
  ImVec2::ImVec2 (&D.11797, 0.0, 0.0);
  selected.298_2898 = selected;
  _2899 = selected.298_2898 == i_55;
  _2900 = (int) _2899;
  _2902 = ImGui::Selectable (&label, _2900, 2, &D.11797);
  retval.297_2903 = _2902;
  D.11797 ={v} {CLOBBER};
  if (retval.297_2903 != 0)
    goto <bb 587>;
  else
    goto <bb 588>;

  <bb 587>:
  selected = i_55;

  <bb 588>:
  _2907 = ImGui::IsItemHovered (0);
  hovered_2908 = _2907;
  ImGui::NextColumn ();
  _2910 = names[i_55];
  ImGui::Text (_2910);
  ImGui::NextColumn ();
  _2913 = paths[i_55];
  ImGui::Text (_2913);
  ImGui::NextColumn ();
  _2916 = (int) hovered_2908;
  ImGui::Text ("%d", _2916);
  ImGui::NextColumn ();
  label ={v} {CLOBBER};
  i_2920 = i_55 + 1;
  goto <bb 585>;

  <bb 589>:
  ImGui::Columns (1, 0B, 1);
  ImGui::Separator ();
  ImGui::TreePop ();
  names ={v} {CLOBBER};
  paths ={v} {CLOBBER};

  <bb 590>:
  _2931 = ImGui::TreeNode ("Mixed items");
  retval.299_2932 = _2931;
  if (retval.299_2932 != 0)
    goto <bb 591>;
  else
    goto <bb 598>;

  <bb 591>:
  ImGui::Columns (3, "mixed", 1);
  ImGui::Separator ();
  ImGui::Text ("Hello");
  ImVec2::ImVec2 (&D.11799, 0.0, 0.0);
  ImGui::Button ("Banana", &D.11799);
  D.11799 ={v} {CLOBBER};
  ImGui::NextColumn ();
  ImGui::Text ("ImGui");
  ImVec2::ImVec2 (&D.11800, 0.0, 0.0);
  ImGui::Button ("Apple", &D.11800);
  D.11800 ={v} {CLOBBER};
  ImGui::InputFloat ("red", &foo, 5.00000007450580596923828125e-2, 0.0, 3, 0);
  ImGui::Text ("An extra line here.");
  ImGui::NextColumn ();
  ImGui::Text ("Sailor");
  ImVec2::ImVec2 (&D.11802, 0.0, 0.0);
  ImGui::Button ("Corniflower", &D.11802);
  D.11802 ={v} {CLOBBER};
  ImGui::InputFloat ("blue", &bar, 5.00000007450580596923828125e-2, 0.0, 3, 0);
  ImGui::NextColumn ();
  _2954 = ImGui::CollapsingHeader ("Category A", 0);
  retval.300_2955 = _2954;
  if (retval.300_2955 != 0)
    goto <bb 592>;
  else
    goto <bb 593>;

  <bb 592>:
  ImGui::Text ("Blah blah blah");

  <bb 593>:
  ImGui::NextColumn ();
  _2959 = ImGui::CollapsingHeader ("Category B", 0);
  retval.301_2960 = _2959;
  if (retval.301_2960 != 0)
    goto <bb 594>;
  else
    goto <bb 595>;

  <bb 594>:
  ImGui::Text ("Blah blah blah");

  <bb 595>:
  ImGui::NextColumn ();
  _2964 = ImGui::CollapsingHeader ("Category C", 0);
  retval.302_2965 = _2964;
  if (retval.302_2965 != 0)
    goto <bb 596>;
  else
    goto <bb 597>;

  <bb 596>:
  ImGui::Text ("Blah blah blah");

  <bb 597>:
  ImGui::NextColumn ();
  ImGui::Columns (1, 0B, 1);
  ImGui::Separator ();
  ImGui::TreePop ();

  <bb 598>:
  _2975 = ImGui::TreeNode ("Word-wrapping");
  retval.303_2976 = _2975;
  if (retval.303_2976 != 0)
    goto <bb 599>;
  else
    goto <bb 600>;

  <bb 599>:
  ImGui::Columns (2, "word-wrapping", 1);
  ImGui::Separator ();
  ImGui::TextWrapped ("The quick brown fox jumps over the lazy dog.");
  ImGui::TextWrapped ("Hello Left");
  ImGui::NextColumn ();
  ImGui::TextWrapped ("The quick brown fox jumps over the lazy dog.");
  ImGui::TextWrapped ("Hello Right");
  ImGui::Columns (1, 0B, 1);
  ImGui::Separator ();
  ImGui::TreePop ();

  <bb 600>:
  _2988 = ImGui::TreeNode ("Borders");
  retval.304_2989 = _2988;
  if (retval.304_2989 != 0)
    goto <bb 601>;
  else
    goto <bb 613>;

  <bb 601>:
  ImGui::Checkbox ("horizontal", &h_borders);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Checkbox ("vertical", &v_borders);
  v_borders.305_2993 = v_borders;
  _2994 = (int) v_borders.305_2993;
  ImGui::Columns (4, 0B, _2994);
  i_2996 = 0;

  <bb 602>:
  # i_56 = PHI <i_2996(601), i_3019(609)>
  if (i_56 > 11)
    goto <bb 610>;
  else
    goto <bb 603>;

  <bb 603>:
  h_borders.308_2997 = h_borders;
  if (h_borders.308_2997 != 0)
    goto <bb 604>;
  else
    goto <bb 606>;

  <bb 604>:
  _2999 = ImGui::GetColumnIndex ();
  _3000 = _2999;
  if (_3000 == 0)
    goto <bb 605>;
  else
    goto <bb 606>;

  <bb 605>:
  iftmp.307_3001 = 1;
  goto <bb 607>;

  <bb 606>:
  iftmp.307_3002 = 0;

  <bb 607>:
  # iftmp.307_103 = PHI <iftmp.307_3001(605), iftmp.307_3002(606)>
  retval.306_3003 = iftmp.307_103;
  if (retval.306_3003 != 0)
    goto <bb 608>;
  else
    goto <bb 609>;

  <bb 608>:
  ImGui::Separator ();

  <bb 609>:
  _3005 = i_56 + 97;
  _3006 = i_56 + 97;
  _3007 = i_56 + 97;
  ImGui::Text ("%c%c%c", _3007, _3006, _3005);
  _3010 = ImGui::GetColumnOffset (-1);
  _3011 = _3010;
  _3012 = (double) _3011;
  _3014 = ImGui::GetColumnWidth (-1);
  _3015 = _3014;
  _3016 = (double) _3015;
  ImGui::Text ("Width %.2f\nOffset %.2f", _3016, _3012);
  ImGui::NextColumn ();
  i_3019 = i_56 + 1;
  goto <bb 602>;

  <bb 610>:
  ImGui::Columns (1, 0B, 1);
  h_borders.309_3021 = h_borders;
  if (h_borders.309_3021 != 0)
    goto <bb 611>;
  else
    goto <bb 612>;

  <bb 611>:
  ImGui::Separator ();

  <bb 612>:
  ImGui::TreePop ();

  <bb 613>:
  _3025 = ImGui::TreeNode ("Horizontal Scrolling");
  retval.310_3026 = _3025;
  if (retval.310_3026 != 0)
    goto <bb 614>;
  else
    goto <bb 630>;

  <bb 614>:
  ImVec2::ImVec2 (&D.11807, 1.5e+3, 0.0);
  ImGui::SetNextWindowContentSize (&D.11807);
  D.11807 ={v} {CLOBBER};
  _3031 = ImGui::GetFontSize ();
  _3032 = _3031;
  _3033 = _3032 * 2.0e+1;
  ImVec2::ImVec2 (&D.11808, 0.0, _3033);
  ImGui::BeginChild ("##ScrollingRegion", &D.11808, 0, 2048);
  D.11808 ={v} {CLOBBER};
  ImGui::Columns (10, 0B, 1);
  ITEMS_COUNT_3038 = 2000;
  ImGuiListClipper::ImGuiListClipper (&clipper, ITEMS_COUNT_3038, -1.0e+0);

  <bb 615>:
  _3041 = ImGuiListClipper::Step (&clipper);

  <bb 616>:
  retval.311_3042 = _3041;
  if (retval.311_3042 != 0)
    goto <bb 617>;
  else
    goto <bb 626>;

  <bb 617>:
  i_3043 = clipper.DisplayStart;

  <bb 618>:
  # i_57 = PHI <i_3043(617), i_3049(624)>
  _3044 = clipper.DisplayEnd;
  if (_3044 <= i_57)
    goto <bb 625>;
  else
    goto <bb 619>;

  <bb 619>:
  j_3045 = 0;

  <bb 620>:
  # j_58 = PHI <j_3045(619), j_3048(623)>
  if (j_58 > 9)
    goto <bb 624>;
  else
    goto <bb 621>;

  <bb 621>:
  ImGui::Text ("Line %d Column %d...", i_57, j_58);

  <bb 622>:
  ImGui::NextColumn ();

  <bb 623>:
  j_3048 = j_58 + 1;
  goto <bb 620>;

  <bb 624>:
  i_3049 = i_57 + 1;
  goto <bb 618>;

  <bb 625>:
  goto <bb 615>;

  <bb 626>:
  ImGui::Columns (1, 0B, 1);

  <bb 627>:
  ImGui::EndChild ();

  <bb 628>:
  ImGui::TreePop ();

  <bb 629>:
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  clipper ={v} {CLOBBER};

  <bb 630>:
  _3060 = ImGui::TreeNode ("Tree within single cell");
  node_open_3061 = _3060;
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("NB: Tree node must be poped before ending the cell. There\'s no storage of state per-cell.");
  if (node_open_3061 != 0)
    goto <bb 631>;
  else
    goto <bb 636>;

  <bb 631>:
  ImGui::Columns (2, "tree items", 1);
  ImGui::Separator ();
  _3067 = ImGui::TreeNode ("Hello");
  retval.312_3068 = _3067;
  if (retval.312_3068 != 0)
    goto <bb 632>;
  else
    goto <bb 633>;

  <bb 632>:
  ImGui::BulletText ("Sailor");
  ImGui::TreePop ();

  <bb 633>:
  ImGui::NextColumn ();
  _3073 = ImGui::TreeNode ("Bonjour");
  retval.313_3074 = _3073;
  if (retval.313_3074 != 0)
    goto <bb 634>;
  else
    goto <bb 635>;

  <bb 634>:
  ImGui::BulletText ("Marin");
  ImGui::TreePop ();

  <bb 635>:
  ImGui::NextColumn ();
  ImGui::Columns (1, 0B, 1);
  ImGui::Separator ();
  ImGui::TreePop ();

  <bb 636>:
  ImGui::PopID ();

  <bb 637>:
  _3083 = ImGui::CollapsingHeader ("Filtering", 0);
  retval.314_3084 = _3083;
  if (retval.314_3084 != 0)
    goto <bb 638>;
  else
    goto <bb 648>;

  <bb 638>:
  _3086 = __atomic_load_1 (&_ZGVZN5ImGui14ShowDemoWindowEPbE6filter, 2);
  retval.315_3087 = _3086 == 0;
  if (retval.315_3087 != 0)
    goto <bb 639>;
  else
    goto <bb 642>;

  <bb 639>:
  _3089 = __cxa_guard_acquire (&_ZGVZN5ImGui14ShowDemoWindowEPbE6filter);
  retval.316_3090 = _3089 != 0;
  if (retval.316_3090 != 0)
    goto <bb 640>;
  else
    goto <bb 642>;

  <bb 640>:
  _3091 = 0;
  ImGuiTextFilter::ImGuiTextFilter (&filter, "");

  <bb 641>:
  _3093 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui14ShowDemoWindowEPbE6filter);
  __cxa_atexit (__comp_dtor , &filter, &__dso_handle);

  <bb 642>:
  ImGui::Text ("Filter usage:\n  \"\"         display all lines\n  \"xxx\"      display lines containing \"xxx\"\n  \"xxx,yyy\"  display lines containing \"xxx\" or \"yyy\"\n  \"-xxx\"     hide lines containing \"xxx\"");
  ImGuiTextFilter::Draw (&filter, "Filter (inc,-exc)", 0.0);
  lines[0] = "aaa1.c";
  lines[1] = "bbb1.c";
  lines[2] = "ccc1.c";
  lines[3] = "aaa2.cpp";
  lines[4] = "bbb2.cpp";
  lines[5] = "ccc2.cpp";
  lines[6] = "abc.h";
  lines[7] = "hello, world";
  i_3107 = 0;

  <bb 643>:
  # i_59 = PHI <i_3107(642), i_3114(646)>
  if (i_59 > 7)
    goto <bb 647>;
  else
    goto <bb 644>;

  <bb 644>:
  _3108 = lines[i_59];
  _3110 = ImGuiTextFilter::PassFilter (&filter, _3108, 0B);
  retval.317_3111 = _3110;
  if (retval.317_3111 != 0)
    goto <bb 645>;
  else
    goto <bb 646>;

  <bb 645>:
  _3112 = lines[i_59];
  ImGui::BulletText ("%s", _3112);

  <bb 646>:
  i_3114 = i_59 + 1;
  goto <bb 643>;

  <bb 647>:
  lines ={v} {CLOBBER};

  <bb 648>:
  _3118 = ImGui::CollapsingHeader ("Inputs, Navigation & Focus", 0);
  retval.318_3119 = _3118;
  if (retval.318_3119 != 0)
    goto <bb 649>;
  else
    goto <bb 773>;

  <bb 649>:
  _3121 = ImGui::GetIO ();
  io_3122 = _3121;
  _3123 = io_3122->WantCaptureMouse;
  _3124 = (int) _3123;
  ImGui::Text ("WantCaptureMouse: %d", _3124);
  _3126 = io_3122->WantCaptureKeyboard;
  _3127 = (int) _3126;
  ImGui::Text ("WantCaptureKeyboard: %d", _3127);
  _3129 = io_3122->WantTextInput;
  _3130 = (int) _3129;
  ImGui::Text ("WantTextInput: %d", _3130);
  _3132 = io_3122->WantSetMousePos;
  _3133 = (int) _3132;
  ImGui::Text ("WantSetMousePos: %d", _3133);
  _3135 = io_3122->NavVisible;
  _3136 = (int) _3135;
  _3137 = io_3122->NavActive;
  _3138 = (int) _3137;
  ImGui::Text ("NavActive: %d, NavVisible: %d", _3138, _3136);
  _3140 = &io_3122->MouseDrawCursor;
  ImGui::Checkbox ("io.MouseDrawCursor", _3140);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Instruct ImGui to render a mouse cursor for you in software. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\n\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).");
  _3144 = &io_3122->ConfigFlags;
  ImGui::CheckboxFlags ("io.ConfigFlags: NavEnableGamepad", _3144, 2);
  _3146 = &io_3122->ConfigFlags;
  ImGui::CheckboxFlags ("io.ConfigFlags: NavEnableKeyboard", _3146, 1);
  _3148 = &io_3122->ConfigFlags;
  ImGui::CheckboxFlags ("io.ConfigFlags: NavEnableSetMousePos", _3148, 4);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Instruct navigation to move the mouse cursor. See comment for ImGuiConfigFlags_NavEnableSetMousePos.");
  _3152 = &io_3122->ConfigFlags;
  ImGui::CheckboxFlags ("io.ConfigFlags: NoMouseCursorChange", _3152, 32);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Instruct back-end to not alter mouse cursor shape and visibility.");
  _3157 = ImGui::TreeNode ("Keyboard, Mouse & Navigation State");
  retval.319_3158 = _3157;
  if (retval.319_3158 != 0)
    goto <bb 650>;
  else
    goto <bb 720>;

  <bb 650>:
  _3160 = ImGui::IsMousePosValid (0B);
  retval.320_3161 = _3160;
  if (retval.320_3161 != 0)
    goto <bb 651>;
  else
    goto <bb 652>;

  <bb 651>:
  _3162 = io_3122->MousePos.y;
  _3163 = (double) _3162;
  _3164 = io_3122->MousePos.x;
  _3165 = (double) _3164;
  ImGui::Text ("Mouse pos: (%g, %g)", _3165, _3163);
  goto <bb 653>;

  <bb 652>:
  ImGui::Text ("Mouse pos: <INVALID>");

  <bb 653>:
  ImGui::Text ("Mouse down:");
  i_3169 = 0;

  <bb 654>:
  # i_60 = PHI <i_3169(653), i_3175(657)>
  if (i_60 > 4)
    goto <bb 658>;
  else
    goto <bb 655>;

  <bb 655>:
  _3170 = io_3122->MouseDownDuration[i_60];
  if (_3170 >= 0.0)
    goto <bb 656>;
  else
    goto <bb 657>;

  <bb 656>:
  ImGui::SameLine (0.0, -1.0e+0);
  _3172 = io_3122->MouseDownDuration[i_60];
  _3173 = (double) _3172;
  ImGui::Text ("b%d (%.02f secs)", i_60, _3173);

  <bb 657>:
  i_3175 = i_60 + 1;
  goto <bb 654>;

  <bb 658>:
  ImGui::Text ("Mouse clicked:");
  i_3177 = 0;

  <bb 659>:
  # i_61 = PHI <i_3177(658), i_3183(662)>
  if (i_61 > 4)
    goto <bb 663>;
  else
    goto <bb 660>;

  <bb 660>:
  _3179 = ImGui::IsMouseClicked (i_61, 0);
  retval.321_3180 = _3179;
  if (retval.321_3180 != 0)
    goto <bb 661>;
  else
    goto <bb 662>;

  <bb 661>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("b%d", i_61);

  <bb 662>:
  i_3183 = i_61 + 1;
  goto <bb 659>;

  <bb 663>:
  ImGui::Text ("Mouse dbl-clicked:");
  i_3185 = 0;

  <bb 664>:
  # i_62 = PHI <i_3185(663), i_3191(667)>
  if (i_62 > 4)
    goto <bb 668>;
  else
    goto <bb 665>;

  <bb 665>:
  _3187 = ImGui::IsMouseDoubleClicked (i_62);
  retval.322_3188 = _3187;
  if (retval.322_3188 != 0)
    goto <bb 666>;
  else
    goto <bb 667>;

  <bb 666>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("b%d", i_62);

  <bb 667>:
  i_3191 = i_62 + 1;
  goto <bb 664>;

  <bb 668>:
  ImGui::Text ("Mouse released:");
  i_3193 = 0;

  <bb 669>:
  # i_63 = PHI <i_3193(668), i_3199(672)>
  if (i_63 > 4)
    goto <bb 673>;
  else
    goto <bb 670>;

  <bb 670>:
  _3195 = ImGui::IsMouseReleased (i_63);
  retval.323_3196 = _3195;
  if (retval.323_3196 != 0)
    goto <bb 671>;
  else
    goto <bb 672>;

  <bb 671>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("b%d", i_63);

  <bb 672>:
  i_3199 = i_63 + 1;
  goto <bb 669>;

  <bb 673>:
  _3200 = io_3122->MouseWheel;
  _3201 = (double) _3200;
  ImGui::Text ("Mouse wheel: %.1f", _3201);
  ImGui::Text ("Keys down:");
  i_3204 = 0;

  <bb 674>:
  # i_64 = PHI <i_3204(673), i_3210(677)>
  if (i_64 > 511)
    goto <bb 678>;
  else
    goto <bb 675>;

  <bb 675>:
  _3205 = io_3122->KeysDownDuration[i_64];
  if (_3205 >= 0.0)
    goto <bb 676>;
  else
    goto <bb 677>;

  <bb 676>:
  ImGui::SameLine (0.0, -1.0e+0);
  _3207 = io_3122->KeysDownDuration[i_64];
  _3208 = (double) _3207;
  ImGui::Text ("%d (%.02f secs)", i_64, _3208);

  <bb 677>:
  i_3210 = i_64 + 1;
  goto <bb 674>;

  <bb 678>:
  ImGui::Text ("Keys pressed:");
  i_3212 = 0;

  <bb 679>:
  # i_65 = PHI <i_3212(678), i_3218(682)>
  if (i_65 > 511)
    goto <bb 683>;
  else
    goto <bb 680>;

  <bb 680>:
  _3214 = ImGui::IsKeyPressed (i_65, 1);
  retval.324_3215 = _3214;
  if (retval.324_3215 != 0)
    goto <bb 681>;
  else
    goto <bb 682>;

  <bb 681>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("%d", i_65);

  <bb 682>:
  i_3218 = i_65 + 1;
  goto <bb 679>;

  <bb 683>:
  ImGui::Text ("Keys release:");
  i_3220 = 0;

  <bb 684>:
  # i_66 = PHI <i_3220(683), i_3226(687)>
  if (i_66 > 511)
    goto <bb 688>;
  else
    goto <bb 685>;

  <bb 685>:
  _3222 = ImGui::IsKeyReleased (i_66);
  retval.325_3223 = _3222;
  if (retval.325_3223 != 0)
    goto <bb 686>;
  else
    goto <bb 687>;

  <bb 686>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("%d", i_66);

  <bb 687>:
  i_3226 = i_66 + 1;
  goto <bb 684>;

  <bb 688>:
  _3227 = io_3122->KeySuper;
  if (_3227 != 0)
    goto <bb 689>;
  else
    goto <bb 690>;

  <bb 689>:
  iftmp.326_3228 = "SUPER ";
  goto <bb 691>;

  <bb 690>:
  iftmp.326_3229 = "";

  <bb 691>:
  # iftmp.326_104 = PHI <iftmp.326_3228(689), iftmp.326_3229(690)>
  _3230 = io_3122->KeyAlt;
  if (_3230 != 0)
    goto <bb 692>;
  else
    goto <bb 693>;

  <bb 692>:
  iftmp.327_3231 = "ALT ";
  goto <bb 694>;

  <bb 693>:
  iftmp.327_3232 = "";

  <bb 694>:
  # iftmp.327_105 = PHI <iftmp.327_3231(692), iftmp.327_3232(693)>
  _3233 = io_3122->KeyShift;
  if (_3233 != 0)
    goto <bb 695>;
  else
    goto <bb 696>;

  <bb 695>:
  iftmp.328_3234 = "SHIFT ";
  goto <bb 697>;

  <bb 696>:
  iftmp.328_3235 = "";

  <bb 697>:
  # iftmp.328_106 = PHI <iftmp.328_3234(695), iftmp.328_3235(696)>
  _3236 = io_3122->KeyCtrl;
  if (_3236 != 0)
    goto <bb 698>;
  else
    goto <bb 699>;

  <bb 698>:
  iftmp.329_3237 = "CTRL ";
  goto <bb 700>;

  <bb 699>:
  iftmp.329_3238 = "";

  <bb 700>:
  # iftmp.329_107 = PHI <iftmp.329_3237(698), iftmp.329_3238(699)>
  ImGui::Text ("Keys mods: %s%s%s%s", iftmp.329_107, iftmp.328_106, iftmp.327_105, iftmp.326_104);
  ImGui::Text ("NavInputs down:");
  i_3241 = 0;

  <bb 701>:
  # i_67 = PHI <i_3241(700), i_3247(704)>
  if (i_67 > 20)
    goto <bb 705>;
  else
    goto <bb 702>;

  <bb 702>:
  _3242 = io_3122->NavInputs[i_67];
  if (_3242 > 0.0)
    goto <bb 703>;
  else
    goto <bb 704>;

  <bb 703>:
  ImGui::SameLine (0.0, -1.0e+0);
  _3244 = io_3122->NavInputs[i_67];
  _3245 = (double) _3244;
  ImGui::Text ("[%d] %.2f", i_67, _3245);

  <bb 704>:
  i_3247 = i_67 + 1;
  goto <bb 701>;

  <bb 705>:
  ImGui::Text ("NavInputs pressed:");
  i_3249 = 0;

  <bb 706>:
  # i_68 = PHI <i_3249(705), i_3253(709)>
  if (i_68 > 20)
    goto <bb 710>;
  else
    goto <bb 707>;

  <bb 707>:
  _3250 = io_3122->NavInputsDownDuration[i_68];
  if (_3250 == 0.0)
    goto <bb 708>;
  else
    goto <bb 709>;

  <bb 708>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Text ("[%d]", i_68);

  <bb 709>:
  i_3253 = i_68 + 1;
  goto <bb 706>;

  <bb 710>:
  ImGui::Text ("NavInputs duration:");
  i_3255 = 0;

  <bb 711>:
  # i_69 = PHI <i_3255(710), i_3261(714)>
  if (i_69 > 20)
    goto <bb 715>;
  else
    goto <bb 712>;

  <bb 712>:
  _3256 = io_3122->NavInputsDownDuration[i_69];
  if (_3256 >= 0.0)
    goto <bb 713>;
  else
    goto <bb 714>;

  <bb 713>:
  ImGui::SameLine (0.0, -1.0e+0);
  _3258 = io_3122->NavInputsDownDuration[i_69];
  _3259 = (double) _3258;
  ImGui::Text ("[%d] %.2f", i_69, _3259);

  <bb 714>:
  i_3261 = i_69 + 1;
  goto <bb 711>;

  <bb 715>:
  ImVec2::ImVec2 (&D.11875, 0.0, 0.0);
  ImGui::Button ("Hovering me sets the\nkeyboard capture flag", &D.11875);
  D.11875 ={v} {CLOBBER};
  _3266 = ImGui::IsItemHovered (0);
  retval.330_3267 = _3266;
  if (retval.330_3267 != 0)
    goto <bb 716>;
  else
    goto <bb 717>;

  <bb 716>:
  ImGui::CaptureKeyboardFromApp (1);

  <bb 717>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11876, 0.0, 0.0);
  ImGui::Button ("Holding me clears the\nthe keyboard capture flag", &D.11876);
  D.11876 ={v} {CLOBBER};
  _3274 = ImGui::IsItemActive ();
  retval.331_3275 = _3274;
  if (retval.331_3275 != 0)
    goto <bb 718>;
  else
    goto <bb 719>;

  <bb 718>:
  ImGui::CaptureKeyboardFromApp (0);

  <bb 719>:
  ImGui::TreePop ();

  <bb 720>:
  _3281 = ImGui::TreeNode ("Tabbing");
  retval.332_3282 = _3281;
  if (retval.332_3282 != 0)
    goto <bb 721>;
  else
    goto <bb 722>;

  <bb 721>:
  ImGui::Text ("Use TAB/SHIFT+TAB to cycle through keyboard editable fields.");
  ImGui::InputText ("1", &buf, 32, 0, 0B, 0B);
  ImGui::InputText ("2", &buf, 32, 0, 0B, 0B);
  ImGui::InputText ("3", &buf, 32, 0, 0B, 0B);
  ImGui::PushAllowKeyboardFocus (0);
  ImGui::InputText ("4 (tab skip)", &buf, 32, 0, 0B, 0B);
  ImGui::PopAllowKeyboardFocus ();
  ImGui::InputText ("5", &buf, 32, 0, 0B, 0B);
  ImGui::TreePop ();

  <bb 722>:
  _3293 = ImGui::TreeNode ("Focus from code");
  retval.333_3294 = _3293;
  if (retval.333_3294 != 0)
    goto <bb 723>;
  else
    goto <bb 747>;

  <bb 723>:
  ImVec2::ImVec2 (&D.11879, 0.0, 0.0);
  _3297 = ImGui::Button ("Focus on 1", &D.11879);
  focus_1_3298 = _3297;
  D.11879 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11881, 0.0, 0.0);
  _3303 = ImGui::Button ("Focus on 2", &D.11881);
  focus_2_3304 = _3303;
  D.11881 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11883, 0.0, 0.0);
  _3309 = ImGui::Button ("Focus on 3", &D.11883);
  focus_3_3310 = _3309;
  D.11883 ={v} {CLOBBER};
  has_focus_3312 = 0;
  if (focus_1_3298 != 0)
    goto <bb 724>;
  else
    goto <bb 725>;

  <bb 724>:
  ImGui::SetKeyboardFocusHere (0);

  <bb 725>:
  ImGui::InputText ("1", &buf, 128, 0, 0B, 0B);
  _3316 = ImGui::IsItemActive ();
  retval.334_3317 = _3316;
  if (retval.334_3317 != 0)
    goto <bb 726>;
  else
    goto <bb 727>;

  <bb 726>:
  has_focus_3318 = 1;

  <bb 727>:
  # has_focus_70 = PHI <has_focus_3312(725), has_focus_3318(726)>
  if (focus_2_3304 != 0)
    goto <bb 728>;
  else
    goto <bb 729>;

  <bb 728>:
  ImGui::SetKeyboardFocusHere (0);

  <bb 729>:
  ImGui::InputText ("2", &buf, 128, 0, 0B, 0B);
  _3322 = ImGui::IsItemActive ();
  retval.335_3323 = _3322;
  if (retval.335_3323 != 0)
    goto <bb 730>;
  else
    goto <bb 731>;

  <bb 730>:
  has_focus_3324 = 2;

  <bb 731>:
  # has_focus_71 = PHI <has_focus_70(729), has_focus_3324(730)>
  ImGui::PushAllowKeyboardFocus (0);
  if (focus_3_3310 != 0)
    goto <bb 732>;
  else
    goto <bb 733>;

  <bb 732>:
  ImGui::SetKeyboardFocusHere (0);

  <bb 733>:
  ImGui::InputText ("3 (tab skip)", &buf, 128, 0, 0B, 0B);
  _3329 = ImGui::IsItemActive ();
  retval.336_3330 = _3329;
  if (retval.336_3330 != 0)
    goto <bb 734>;
  else
    goto <bb 735>;

  <bb 734>:
  has_focus_3331 = 3;

  <bb 735>:
  # has_focus_72 = PHI <has_focus_71(733), has_focus_3331(734)>
  ImGui::PopAllowKeyboardFocus ();
  if (has_focus_72 != 0)
    goto <bb 736>;
  else
    goto <bb 737>;

  <bb 736>:
  ImGui::Text ("Item with focus: %d", has_focus_72);
  goto <bb 738>;

  <bb 737>:
  ImGui::Text ("Item with focus: <none>");

  <bb 738>:
  focus_ahead_3335 = -1;
  ImVec2::ImVec2 (&D.11888, 0.0, 0.0);
  _3338 = ImGui::Button ("Focus on X", &D.11888);
  retval.337_3339 = _3338;
  D.11888 ={v} {CLOBBER};
  if (retval.337_3339 != 0)
    goto <bb 739>;
  else
    goto <bb 740>;

  <bb 739>:
  focus_ahead_3341 = 0;

  <bb 740>:
  # focus_ahead_73 = PHI <focus_ahead_3335(738), focus_ahead_3341(739)>
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11889, 0.0, 0.0);
  _3345 = ImGui::Button ("Focus on Y", &D.11889);
  retval.338_3346 = _3345;
  D.11889 ={v} {CLOBBER};
  if (retval.338_3346 != 0)
    goto <bb 741>;
  else
    goto <bb 742>;

  <bb 741>:
  focus_ahead_3348 = 1;

  <bb 742>:
  # focus_ahead_74 = PHI <focus_ahead_73(740), focus_ahead_3348(741)>
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.11890, 0.0, 0.0);
  _3352 = ImGui::Button ("Focus on Z", &D.11890);
  retval.339_3353 = _3352;
  D.11890 ={v} {CLOBBER};
  if (retval.339_3353 != 0)
    goto <bb 743>;
  else
    goto <bb 744>;

  <bb 743>:
  focus_ahead_3355 = 2;

  <bb 744>:
  # focus_ahead_75 = PHI <focus_ahead_74(742), focus_ahead_3355(743)>
  if (focus_ahead_75 != -1)
    goto <bb 745>;
  else
    goto <bb 746>;

  <bb 745>:
  ImGui::SetKeyboardFocusHere (focus_ahead_75);

  <bb 746>:
  ImGui::SliderFloat3 ("Float3", &f3[0], 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::TextWrapped ("NB: Cursor & selection are preserved when refocusing last used item in code.");
  ImGui::TreePop ();

  <bb 747>:
  _3367 = ImGui::TreeNode ("Focused & Hovered Test");
  retval.340_3368 = _3367;
  if (retval.340_3368 != 0)
    goto <bb 748>;
  else
    goto <bb 753>;

  <bb 748>:
  ImGui::Checkbox ("Embed everything inside a child window (for additional testing)", &embed_all_inside_a_child_window);
  embed_all_inside_a_child_window.341_3370 = embed_all_inside_a_child_window;
  if (embed_all_inside_a_child_window.341_3370 != 0)
    goto <bb 749>;
  else
    goto <bb 750>;

  <bb 749>:
  _3372 = ImGui::GetFontSize ();
  _3373 = _3372;
  _3374 = _3373 * 2.5e+1;
  ImVec2::ImVec2 (&D.11892, 0.0, _3374);
  ImGui::BeginChild ("embeddingchild", &D.11892, 1, 0);
  D.11892 ={v} {CLOBBER};

  <bb 750>:
  _3380 = ImGui::IsWindowFocused (4);
  _3381 = _3380;
  _3382 = (int) _3381;
  _3384 = ImGui::IsWindowFocused (2);
  _3385 = _3384;
  _3386 = (int) _3385;
  _3388 = ImGui::IsWindowFocused (3);
  _3389 = _3388;
  _3390 = (int) _3389;
  _3392 = ImGui::IsWindowFocused (1);
  _3393 = _3392;
  _3394 = (int) _3393;
  _3396 = ImGui::IsWindowFocused (0);
  _3397 = _3396;
  _3398 = (int) _3397;
  ImGui::BulletText ("IsWindowFocused() = %d\nIsWindowFocused(_ChildWindows) = %d\nIsWindowFocused(_ChildWindows|_RootWindow) = %d\nIsWindowFocused(_RootWindow) = %d\nIsWindowFocused(_AnyWindow) = %d\n", _3398, _3394, _3390, _3386, _3382);
  _3401 = ImGui::IsWindowHovered (4);
  _3402 = _3401;
  _3403 = (int) _3402;
  _3405 = ImGui::IsWindowHovered (2);
  _3406 = _3405;
  _3407 = (int) _3406;
  _3409 = ImGui::IsWindowHovered (3);
  _3410 = _3409;
  _3411 = (int) _3410;
  _3413 = ImGui::IsWindowHovered (1);
  _3414 = _3413;
  _3415 = (int) _3414;
  _3417 = ImGui::IsWindowHovered (32);
  _3418 = _3417;
  _3419 = (int) _3418;
  _3421 = ImGui::IsWindowHovered (8);
  _3422 = _3421;
  _3423 = (int) _3422;
  _3425 = ImGui::IsWindowHovered (0);
  _3426 = _3425;
  _3427 = (int) _3426;
  ImGui::BulletText ("IsWindowHovered() = %d\nIsWindowHovered(_AllowWhenBlockedByPopup) = %d\nIsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\nIsWindowHovered(_ChildWindows) = %d\nIsWindowHovered(_ChildWindows|_RootWindow) = %d\nIsWindowHovered(_RootWindow) = %d\nIsWindowHovered(_AnyWindow) = %d\n", _3427, _3423, _3419, _3415, _3411, _3407, _3403);
  ImVec2::ImVec2 (&D.11893, 0.0, 0.0);
  ImGui::Button ("ITEM", &D.11893);
  D.11893 ={v} {CLOBBER};
  _3433 = ImGui::IsItemHovered (104);
  _3434 = _3433;
  _3435 = (int) _3434;
  _3437 = ImGui::IsItemHovered (64);
  _3438 = _3437;
  _3439 = (int) _3438;
  _3441 = ImGui::IsItemHovered (32);
  _3442 = _3441;
  _3443 = (int) _3442;
  _3445 = ImGui::IsItemHovered (8);
  _3446 = _3445;
  _3447 = (int) _3446;
  _3449 = ImGui::IsItemHovered (0);
  _3450 = _3449;
  _3451 = (int) _3450;
  ImGui::BulletText ("IsItemHovered() = %d\nIsItemHovered(_AllowWhenBlockedByPopup) = %d\nIsItemHovered(_AllowWhenBlockedByActiveItem) = %d\nIsItemHovered(_AllowWhenOverlapped) = %d\nIsItemhovered(_RectOnly) = %d\n", _3451, _3447, _3443, _3439, _3435);
  ImVec2::ImVec2 (&D.11894, 0.0, 5.0e+1);
  ImGui::BeginChild ("child", &D.11894, 1, 0);
  D.11894 ={v} {CLOBBER};
  ImGui::Text ("This is another child window for testing IsWindowHovered() flags.");
  ImGui::EndChild ();
  embed_all_inside_a_child_window.342_3458 = embed_all_inside_a_child_window;
  if (embed_all_inside_a_child_window.342_3458 != 0)
    goto <bb 751>;
  else
    goto <bb 752>;

  <bb 751>:
  ImGui::EndChild ();

  <bb 752>:
  ImGui::TreePop ();

  <bb 753>:
  _3464 = ImGui::TreeNode ("Dragging");
  retval.343_3465 = _3464;
  if (retval.343_3465 != 0)
    goto <bb 754>;
  else
    goto <bb 760>;

  <bb 754>:
  ImGui::TextWrapped ("You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.");
  button_3467 = 0;

  <bb 755>:
  # button_76 = PHI <button_3467(754), button_3481(756)>
  if (button_76 > 2)
    goto <bb 757>;
  else
    goto <bb 756>;

  <bb 756>:
  _3469 = ImGui::IsMouseDragging (button_76, 2.0e+1);
  _3470 = _3469;
  _3471 = (int) _3470;
  _3473 = ImGui::IsMouseDragging (button_76, 0.0);
  _3474 = _3473;
  _3475 = (int) _3474;
  _3477 = ImGui::IsMouseDragging (button_76, -1.0e+0);
  _3478 = _3477;
  _3479 = (int) _3478;
  ImGui::Text ("IsMouseDragging(%d):\n  w/ default threshold: %d,\n  w/ zero threshold: %d\n  w/ large threshold: %d", button_76, _3479, _3475, _3471);
  button_3481 = button_76 + 1;
  goto <bb 755>;

  <bb 757>:
  ImVec2::ImVec2 (&D.11896, 0.0, 0.0);
  ImGui::Button ("Drag Me", &D.11896);
  D.11896 ={v} {CLOBBER};
  _3486 = ImGui::IsItemActive ();
  retval.344_3487 = _3486;
  if (retval.344_3487 != 0)
    goto <bb 758>;
  else
    goto <bb 759>;

  <bb 758>:
  _3489 = ImGui::GetWindowDrawList ();
  draw_list_3490 = _3489;
  ImDrawList::PushClipRectFullScreen (draw_list_3490);
  _3493 = ImGui::GetColorU32 (21, 1.0e+0);
  _3494 = _3493;
  _3495 = &io_3122->MousePos;
  _3496 = &io_3122->MouseClickedPos[0];
  ImDrawList::AddLine (draw_list_3490, _3496, _3495, _3494, 4.0e+0);
  ImDrawList::PopClipRect (draw_list_3490);
  value_raw = ImGui::GetMouseDragDelta (0, 0.0);
  value_with_lock_threshold = ImGui::GetMouseDragDelta (0, -1.0e+0);
  mouse_delta = io_3122->MouseDelta;
  ImGui::SameLine (0.0, -1.0e+0);
  _3503 = mouse_delta.y;
  _3504 = (double) _3503;
  _3505 = mouse_delta.x;
  _3506 = (double) _3505;
  _3507 = value_with_lock_threshold.y;
  _3508 = (double) _3507;
  _3509 = value_with_lock_threshold.x;
  _3510 = (double) _3509;
  _3511 = value_raw.y;
  _3512 = (double) _3511;
  _3513 = value_raw.x;
  _3514 = (double) _3513;
  ImGui::Text ("Raw (%.1f, %.1f), WithLockThresold (%.1f, %.1f), MouseDelta (%.1f, %.1f)", _3514, _3512, _3510, _3508, _3506, _3504);
  value_raw ={v} {CLOBBER};
  value_with_lock_threshold ={v} {CLOBBER};
  mouse_delta ={v} {CLOBBER};

  <bb 759>:
  ImGui::TreePop ();

  <bb 760>:
  _3525 = ImGui::TreeNode ("Mouse cursors");
  retval.345_3526 = _3525;
  if (retval.345_3526 != 0)
    goto <bb 761>;
  else
    goto <bb 772>;

  <bb 761>:
  mouse_cursors_names[0] = "Arrow";
  mouse_cursors_names[1] = "TextInput";
  mouse_cursors_names[2] = "Move";
  mouse_cursors_names[3] = "ResizeNS";
  mouse_cursors_names[4] = "ResizeEW";
  mouse_cursors_names[5] = "ResizeNESW";
  mouse_cursors_names[6] = "ResizeNWSE";

  <bb 762>:
  _3535 = ImGui::GetMouseCursor ();
  _3536 = _3535;
  _3537 = mouse_cursors_names[_3536];
  _3539 = ImGui::GetMouseCursor ();
  _3540 = _3539;
  ImGui::Text ("Current mouse cursor = %d: %s", _3540, _3537);
  ImGui::Text ("Hover to see mouse cursors:");
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, otherwise your backend needs to handle it.");
  i_3545 = 0;

  <bb 763>:
  # i_77 = PHI <i_3545(762), i_3563(770)>
  if (i_77 > 6)
    goto <bb 771>;
  else
    goto <bb 764>;

  <bb 764>:
  _3546 = mouse_cursors_names[i_77];
  sprintf (&label, "Mouse cursor %d: %s", i_77, _3546);
  ImGui::Bullet ();
  ImVec2::ImVec2 (&D.11908, 0.0, 0.0);
  ImGui::Selectable (&label, 0, 0, &D.11908);
  D.11908 ={v} {CLOBBER};
  _3553 = ImGui::IsItemHovered (0);
  _3554 = _3553;
  if (_3554 != 0)
    goto <bb 766>;
  else
    goto <bb 765>;

  <bb 765>:
  _3556 = ImGui::IsItemFocused ();
  _3557 = _3556;
  if (_3557 != 0)
    goto <bb 766>;
  else
    goto <bb 767>;

  <bb 766>:
  iftmp.347_3559 = 1;
  goto <bb 768>;

  <bb 767>:
  iftmp.347_3558 = 0;

  <bb 768>:
  # iftmp.347_108 = PHI <iftmp.347_3559(766), iftmp.347_3558(767)>
  retval.346_3560 = iftmp.347_108;
  if (retval.346_3560 != 0)
    goto <bb 769>;
  else
    goto <bb 770>;

  <bb 769>:
  ImGui::SetMouseCursor (i_77);

  <bb 770>:
  label ={v} {CLOBBER};
  i_3563 = i_77 + 1;
  goto <bb 763>;

  <bb 771>:
  ImGui::TreePop ();
  mouse_cursors_names ={v} {CLOBBER};

  <bb 772>:

  <bb 773>:
  ImGui::End ();

<L1036>:
  return;

<L1051>:
  _386 = __builtin_eh_pointer (30);
  __builtin_unwind_resume (_386);

<L1055>:
  _388 = __builtin_eh_pointer (38);
  __builtin_unwind_resume (_388);

<L1204>:
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  _389 = __builtin_eh_pointer (345);
  __builtin_unwind_resume (_389);

<L1206>:
  if (_3091 != 0)
    goto <bb 780>;
  else
    goto <bb 779>;

  <bb 779>:
  __cxa_guard_abort (&_ZGVZN5ImGui14ShowDemoWindowEPbE6filter);

  <bb 780>:
  _391 = __builtin_eh_pointer (349);
  __builtin_unwind_resume (_391);

}



;; Function bool ImGui::ShowStyleSelector(const char*) (_ZN5ImGui17ShowStyleSelectorEPKc, funcdef_no=414, decl_uid=2440, cgraph_uid=313, symbol_order=461)

bool ImGui::ShowStyleSelector(const char*) (const char * label)
{
  bool D.15469;
  static int style_idx = -1;
  bool D.15467;
  int style_idx.353;
  bool retval.352;
  bool _1;
  bool _7;
  bool retval.352_8;
  int style_idx.353_9;
  bool _13;
  bool _14;

  <bb 2>:
  _7 = ImGui::Combo (label_5(D), &style_idx, "Classic", -1);
  retval.352_8 = _7;
  if (retval.352_8 != 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  style_idx.353_9 = style_idx;
  switch (style_idx.353_9) <default: <L4>, case 0: <L1>, case 1: <L2>, case 2: <L3>>

<L1>:
  ImGui::StyleColorsClassic (0B);
  goto <bb 7> (<L4>);

<L2>:
  ImGui::StyleColorsDark (0B);
  goto <bb 7> (<L4>);

<L3>:
  ImGui::StyleColorsLight (0B);

<L4>:
  _13 = 1;
  goto <bb 9> (<L7>);

  <bb 8>:
  _14 = 0;

  # _1 = PHI <_13(7), _14(8)>
<L7>:
  return _1;

}



;; Function void ImGui::ShowFontSelector(const char*) (_ZN5ImGui16ShowFontSelectorEPKc, funcdef_no=415, decl_uid=2442, cgraph_uid=314, symbol_order=462)

void ImGui::ShowFontSelector(const char*) (const char * label)
{
  bool D.15501;
  bool D.15500;
  struct ImFont * D.15499;
  struct ImGuiIO & D.15498;
  int n;
  struct ImFont * font_current;
  struct ImGuiIO & io;
  struct ImFont * D.15495;
  struct ImFont * & D.15494;
  struct ImVector * D.15493;
  struct ImFontAtlas * D.15492;
  const char * D.15489;
  struct ImFont * D.15488;
  struct ImFont * & D.15487;
  struct ImVector * D.15486;
  struct ImFontAtlas * D.15485;
  int D.15484;
  bool D.15483;
  struct ImFont * D.15482;
  struct ImFont * & D.15481;
  struct ImVector * D.15480;
  struct ImFontAtlas * D.15479;
  struct ImVec2 D.12023;
  bool retval.355;
  int D.15476;
  struct ImFontAtlas * D.15475;
  const char * D.15471;
  bool retval.354;
  struct ImGuiIO & _7;
  struct ImFont * _10;
  const char * _13;
  bool _16;
  bool retval.354_17;
  struct ImFontAtlas * _19;
  int _20;
  struct ImFontAtlas * _22;
  struct ImVector * _23;
  struct ImFont * & _25;
  struct ImFont * _26;
  bool _27;
  int _28;
  struct ImFontAtlas * _29;
  struct ImVector * _30;
  struct ImFont * & _32;
  struct ImFont * _33;
  const char * _35;
  bool _37;
  bool retval.355_38;
  struct ImFontAtlas * _40;
  struct ImVector * _41;
  struct ImFont * & _43;
  struct ImFont * _44;

  <bb 2>:
  _7 = ImGui::GetIO ();
  io_8 = _7;
  _10 = ImGui::GetFont ();
  font_current_11 = _10;
  _13 = ImFont::GetDebugName (font_current_11);
  _16 = ImGui::BeginCombo (label_14(D), _13, 0);
  retval.354_17 = _16;
  if (retval.354_17 != 0)
    goto <bb 3>;
  else
    goto <bb 9>;

  <bb 3>:
  n_18 = 0;

  <bb 4>:
  # n_1 = PHI <n_18(3), n_46(7)>
  _19 = io_8->Fonts;
  _20 = _19->Fonts.Size;
  if (_20 <= n_1)
    goto <bb 8>;
  else
    goto <bb 5>;

  <bb 5>:
  ImVec2::ImVec2 (&D.12023, 0.0, 0.0);
  _22 = io_8->Fonts;
  _23 = &_22->Fonts;
  _25 = ImVector<ImFont*>::operator[] (_23, n_1);
  _26 = *_25;
  _27 = _26 == font_current_11;
  _28 = (int) _27;
  _29 = io_8->Fonts;
  _30 = &_29->Fonts;
  _32 = ImVector<ImFont*>::operator[] (_30, n_1);
  _33 = *_32;
  _35 = ImFont::GetDebugName (_33);
  _37 = ImGui::Selectable (_35, _28, 0, &D.12023);
  retval.355_38 = _37;
  D.12023 ={v} {CLOBBER};
  if (retval.355_38 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _40 = io_8->Fonts;
  _41 = &_40->Fonts;
  _43 = ImVector<ImFont*>::operator[] (_41, n_1);
  _44 = *_43;
  io_8->FontDefault = _44;

  <bb 7>:
  n_46 = n_1 + 1;
  goto <bb 4>;

  <bb 8>:
  ImGui::EndCombo ();

  <bb 9>:
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("- Load additional fonts with io.Fonts->AddFontFromFileTTF().\n- The font atlas is built when calling io.Fonts->GetTexDataAsXXXX() or io.Fonts->Build().\n- Read FAQ and documentation in misc/fonts/ for more details.\n- If you need to add/remove fonts at runtime (e.g. for DPI change), do it before calling NewFrame().");
  return;

}



;; Function void ImGui::ShowStyleEditor(ImGuiStyle*) (_ZN5ImGui15ShowStyleEditorEP10ImGuiStyle, funcdef_no=416, decl_uid=2438, cgraph_uid=315, symbol_order=472)

void ImGui::ShowStyleEditor(ImGuiStyle*) (struct ImGuiStyle * ref)
{
  void * D.18482;
  void * D.18481;
  struct ImGuiIO & D.15936;
  bool D.15932;
  unsigned int D.15931;
  const struct ImFontGlyph * D.15930;
  struct ImDrawList * D.15929;
  bool D.15928;
  const struct ImFontGlyph * D.15927;
  bool D.15926;
  struct ImGuiIO & D.15925;
  bool D.15924;
  bool D.15923;
  bool D.15915;
  struct ImGuiIO & D.15914;
  bool D.15913;
  struct ImGuiIO & D.15912;
  bool D.15910;
  bool D.15908;
  bool D.15907;
  const char * D.15906;
  const char * D.15903;
  bool D.15901;
  bool D.15900;
  bool D.15899;
  bool D.15898;
  bool D.15896;
  bool D.15894;
  bool D.15892;
  bool D.15890;
  bool D.15888;
  bool D.15887;
  bool D.15886;
  float D.15885;
  struct ImGuiStyle & D.15883;
  const struct ImFontGlyph * glyph;
  struct ImVec2 cell_p2;
  struct ImVec2 cell_p1;
  int n;
  struct ImDrawList * draw_list;
  struct ImVec2 base_pos;
  float cell_spacing;
  float cell_size;
  int n;
  int count;
  int base;
  struct ImFontConfig * cfg;
  int config_i;
  bool font_details_opened;
  struct ImFont * font;
  int i;
  static float window_scale = 1.0e+0;
  struct ImFontAtlas * atlas;
  const char * name;
  int i;
  const char * name;
  const struct ImVec4 & col;
  int i;
  static ImGuiColorEditFlags alpha_flags = 0;
  static struct ImGuiTextFilter filter;
  static bool output_only_modified = 1;
  static int output_dest = 0;
  bool popup_border;
  bool frame_border;
  bool window_border;
  bool fonts_opened;
  static bool init = 1;
  static struct ImGuiStyle ref_saved_style;
  struct ImGuiStyle & style;
  float window_scale.400;
  float * D.15880;
  struct ImGuiIO & D.15879;
  float D.15875;
  float D.15874;
  float D.15873;
  float D.15872;
  struct ImVec2 D.12115;
  double D.15870;
  float D.15869;
  double D.15868;
  float D.15867;
  double D.15866;
  float D.15865;
  double D.15864;
  float D.15863;
  double D.15862;
  float D.15861;
  double D.15860;
  float D.15859;
  double D.15858;
  float D.15857;
  double D.15856;
  float D.15855;
  double D.15854;
  float D.15853;
  int D.15852;
  bool D.15848;
  bool iftmp.399;
  bool retval.398;
  unsigned int D.15842;
  int D.15841;
  short unsigned int D.15840;
  short unsigned int D.15839;
  short unsigned int D.15838;
  ImU32 iftmp.397;
  int D.15833;
  short unsigned int D.15832;
  short unsigned int D.15831;
  short unsigned int D.15830;
  float D.15829;
  float D.15828;
  float D.15827;
  float D.15826;
  float D.15825;
  float D.15824;
  float D.15823;
  float D.15822;
  int D.15821;
  float D.15820;
  float D.15819;
  float D.15818;
  float D.15817;
  float D.15816;
  int D.15815;
  float D.15814;
  bool D.15808;
  const void * D.15807;
  long int D.15806;
  int D.15805;
  const char * iftmp.396;
  bool iftmp.395;
  bool retval.394;
  const struct ImFontGlyph * D.15792;
  int D.15791;
  short unsigned int D.15790;
  short unsigned int D.15789;
  short unsigned int D.15788;
  int iftmp.393;
  int D.12104;
  int D.15780;
  bool retval.392;
  char[40] * D.15777;
  int D.15776;
  int D.15775;
  int D.15774;
  bool D.15773;
  long unsigned int D.15770;
  long unsigned int D.15769;
  struct ImFontConfig * D.15768;
  int D.15766;
  short int D.15765;
  int D.15763;
  int D.15762;
  float D.15761;
  float D.15760;
  int D.15759;
  int D.15758;
  float D.15757;
  float D.15756;
  int D.15755;
  int D.15754;
  short unsigned int D.15753;
  int D.15752;
  short unsigned int D.15751;
  double D.15750;
  float D.15749;
  double D.15748;
  float D.15747;
  double D.15746;
  float D.15745;
  float D.15744;
  float D.15743;
  float * D.15742;
  float * D.15741;
  struct ImGuiIO & D.15737;
  bool retval.391;
  struct ImFontConfig * D.15732;
  struct ImFontConfig * D.15729;
  const char * iftmp.390;
  double D.15727;
  float D.15726;
  int D.15725;
  struct ImFont * & D.15724;
  struct ImVector * D.15723;
  int D.15721;
  void * D.15718;
  float D.15717;
  int D.15716;
  float D.15715;
  int D.15714;
  struct ImVec2 D.12089;
  struct ImVec2 D.12090;
  struct ImVec2 D.12091;
  struct ImColor D.12092;
  struct ImVec4 D.12094;
  struct ImColor D.12093;
  struct ImVec4 D.12095;
  int D.15711;
  int D.15710;
  bool retval.389;
  struct ImGuiIO & D.15708;
  int D.15705;
  struct ImFontAtlas * D.15704;
  struct ImGuiIO & D.15703;
  float D.15701;
  struct ImVec2 D.12086;
  bool retval.388;
  float D.15695;
  struct ImVec2 D.12085;
  bool retval.387;
  float D.15690;
  int D.15687;
  struct ImVec4 * D.15686;
  struct ImVec4 * D.15685;
  struct ImVec4 * D.15684;
  int D.15683;
  int alpha_flags.386;
  bool D.15679;
  bool retval.385;
  struct ImVec2 D.12082;
  bool D.12080;
  int D.15668;
  bool retval.384;
  unsigned char D.15664;
  bool retval.383;
  int D.15661;
  int D.15660;
  long unsigned int D.15659;
  double D.15658;
  float D.15657;
  double D.15656;
  float D.15655;
  double D.15654;
  float D.15653;
  double D.15652;
  float D.15651;
  int D.15650;
  struct ImVec4 * D.15649;
  bool D.15647;
  bool output_only_modified.382;
  int output_dest.381;
  struct ImVec2 D.12074;
  bool retval.380;
  bool retval.379;
  struct ImVec2 * D.15630;
  struct ImVec2 * D.15629;
  float * D.15628;
  float * D.15627;
  float * D.15626;
  float * D.15625;
  float * D.15624;
  float * D.15623;
  float * D.15622;
  float * D.15621;
  float * D.15620;
  float * D.15619;
  float * D.15618;
  float * D.15617;
  struct ImVec2 * D.15616;
  struct ImVec2 * D.15615;
  struct ImVec2 * D.15614;
  struct ImVec2 * D.15613;
  float * D.15612;
  struct ImVec2 * D.15611;
  bool retval.378;
  float * D.15606;
  float D.15602;
  float * D.15601;
  bool * D.15600;
  bool * D.15599;
  bool retval.377;
  struct ImVec2 D.12071;
  bool retval.376;
  struct ImGuiStyle * ref_saved_style.375;
  struct ImVec2 D.12070;
  bool retval.374;
  bool popup_border.373;
  float iftmp.372;
  bool retval.371;
  bool popup_border.370;
  float D.15576;
  bool frame_border.369;
  float iftmp.368;
  bool retval.367;
  bool frame_border.366;
  float D.15565;
  bool window_border.365;
  float iftmp.364;
  bool retval.363;
  bool window_border.362;
  float D.15554;
  float D.15552;
  float * D.15549;
  bool retval.361;
  bool retval.360;
  float D.15543;
  float D.15542;
  bool init.359;
  bool D.12059;
  int D.15525;
  bool retval.358;
  unsigned char D.15521;
  bool retval.357;
  float iftmp.364_10;
  float iftmp.368_11;
  float iftmp.372_12;
  const char * iftmp.390_13;
  int iftmp.393_14;
  bool iftmp.395_15;
  const char * iftmp.396_16;
  ImU32 iftmp.397_17;
  bool iftmp.399_18;
  struct ImGuiStyle & _62;
  unsigned char _65;
  bool retval.357_66;
  int _68;
  bool retval.358_69;
  bool _70;
  bool _72;
  bool init.359_75;
  float _81;
  float _82;
  float _83;
  bool _86;
  bool retval.360_87;
  float * _90;
  bool _92;
  bool retval.361_93;
  float _94;
  float _96;
  bool window_border.362_97;
  bool _100;
  bool retval.363_101;
  bool window_border.365_102;
  float iftmp.364_103;
  float iftmp.364_104;
  float _108;
  bool frame_border.366_109;
  bool _112;
  bool retval.367_113;
  bool frame_border.369_114;
  float iftmp.368_115;
  float iftmp.368_116;
  float _120;
  bool popup_border.370_121;
  bool _124;
  bool retval.371_125;
  bool popup_border.373_126;
  float iftmp.372_127;
  float iftmp.372_128;
  bool _133;
  bool retval.374_134;
  struct ImGuiStyle * ref_saved_style.375_137;
  bool _142;
  bool retval.376_143;
  bool _149;
  bool retval.377_150;
  bool * _151;
  bool * _155;
  float * _158;
  float _160;
  float * _162;
  bool _167;
  bool retval.378_168;
  struct ImVec2 * _169;
  float * _171;
  struct ImVec2 * _173;
  struct ImVec2 * _175;
  struct ImVec2 * _177;
  struct ImVec2 * _179;
  float * _181;
  float * _183;
  float * _185;
  float * _188;
  float * _190;
  float * _192;
  float * _194;
  float * _197;
  float * _199;
  float * _201;
  float * _203;
  float * _205;
  struct ImVec2 * _208;
  struct ImVec2 * _210;
  bool _216;
  bool retval.379_217;
  bool _220;
  bool retval.380_221;
  int output_dest.381_223;
  const char * _230;
  bool output_only_modified.382_232;
  bool _233;
  struct ImVec4 * _234;
  int _235;
  float _236;
  double _237;
  float _238;
  double _239;
  float _240;
  double _241;
  float _242;
  double _243;
  long unsigned int _244;
  int _245;
  int _246;
  unsigned char _258;
  bool retval.383_259;
  int _261;
  bool retval.384_262;
  bool _263;
  bool _265;
  const char * _281;
  bool _284;
  bool _285;
  bool retval.385_286;
  int alpha_flags.386_288;
  int _289;
  struct ImVec4 * _290;
  struct ImVec4 * _292;
  struct ImVec4 * _293;
  int _294;
  float _295;
  bool _299;
  bool retval.387_300;
  float _303;
  bool _307;
  bool retval.388_308;
  float _313;
  struct ImGuiIO & _324;
  struct ImGuiIO & _325;
  struct ImFontAtlas * _326;
  int _327;
  bool _329;
  struct ImGuiIO & _332;
  struct ImGuiIO & _333;
  int _335;
  int _336;
  bool _338;
  bool retval.389_339;
  int _346;
  float _347;
  int _348;
  float _349;
  void * _351;
  int _370;
  struct ImVector * _371;
  struct ImFont * & _373;
  int _376;
  float _377;
  double _378;
  struct ImFontConfig * _379;
  struct ImFontConfig * _380;
  const char * iftmp.390_381;
  const char * iftmp.390_382;
  bool _384;
  bool _388;
  bool retval.391_389;
  struct ImGuiIO & _391;
  struct ImGuiIO & _392;
  float * _397;
  float * _399;
  float _403;
  float _404;
  float _405;
  double _406;
  float _407;
  double _408;
  float _409;
  double _410;
  short unsigned int _412;
  int _413;
  short unsigned int _414;
  int _415;
  int _417;
  float _418;
  float _420;
  int _421;
  int _422;
  float _423;
  float _425;
  int _426;
  int _427;
  short int _430;
  int _431;
  struct ImFontConfig * _432;
  long unsigned int _433;
  long unsigned int _434;
  bool _436;
  int _437;
  int _438;
  int _439;
  char[40] * _440;
  int _443;
  bool _445;
  bool retval.392_446;
  short unsigned int _450;
  short unsigned int _451;
  short unsigned int _452;
  int _453;
  const struct ImFontGlyph * _455;
  const struct ImFontGlyph * _456;
  int iftmp.393_457;
  int iftmp.393_458;
  int _459;
  const char * iftmp.396_462;
  const char * iftmp.396_463;
  int _464;
  long int _465;
  const void * _466;
  bool _468;
  bool _469;
  bool iftmp.395_470;
  bool iftmp.395_471;
  bool retval.394_472;
  struct ImDrawList * _477;
  float _480;
  int _481;
  float _482;
  float _483;
  float _484;
  float _485;
  float _486;
  int _487;
  float _488;
  float _489;
  float _490;
  float _491;
  float _493;
  float _494;
  float _495;
  float _496;
  short unsigned int _498;
  short unsigned int _499;
  short unsigned int _500;
  int _501;
  const struct ImFontGlyph * _503;
  ImU32 iftmp.397_505;
  ImU32 iftmp.397_506;
  short unsigned int _508;
  short unsigned int _509;
  short unsigned int _510;
  int _511;
  unsigned int _513;
  unsigned int _514;
  bool _517;
  bool _518;
  bool iftmp.399_519;
  bool iftmp.399_520;
  bool retval.398_521;
  int _523;
  float _526;
  double _527;
  float _529;
  double _530;
  float _531;
  double _532;
  float _533;
  double _534;
  float _535;
  double _536;
  float _538;
  double _539;
  float _540;
  double _541;
  float _542;
  double _543;
  float _544;
  double _545;
  float _553;
  float _554;
  float _555;
  float _556;
  struct ImGuiIO & _571;
  struct ImGuiIO & _572;
  float * _573;
  float window_scale.400_576;

  <bb 2>:
  _62 = ImGui::GetStyle ();
  style_63 = _62;
  _65 = __atomic_load_1 (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE15ref_saved_style, 2);
  retval.357_66 = _65 == 0;
  if (retval.357_66 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _68 = __cxa_guard_acquire (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE15ref_saved_style);
  retval.358_69 = _68 != 0;
  if (retval.358_69 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _70 = 0;
  ImGuiStyle::ImGuiStyle (&ref_saved_style);

  <bb 5>:
  _72 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE15ref_saved_style);

  <bb 6>:
  init.359_75 = init;
  if (init.359_75 != 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  if (ref_76(D) == 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  ref_saved_style = MEM[(const struct ImGuiStyle &)style_63];

  <bb 9>:
  init = 0;
  if (ref_76(D) == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  ref_79 = &ref_saved_style;

  <bb 11>:
  # ref_1 = PHI <ref_76(D)(9), ref_79(10)>
  _81 = ImGui::GetWindowWidth ();
  _82 = _81;
  _83 = _82 * 5.0e-1;
  ImGui::PushItemWidth (_83);
  _86 = ImGui::ShowStyleSelector ("Colors##Selector");
  retval.360_87 = _86;
  if (retval.360_87 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  ref_saved_style = MEM[(const struct ImGuiStyle &)style_63];

  <bb 13>:
  ImGui::ShowFontSelector ("Fonts##Selector");
  _90 = &style_63->FrameRounding;
  _92 = ImGui::SliderFloat ("FrameRounding", _90, 0.0, 1.2e+1, "%.0f", 1.0e+0);
  retval.361_93 = _92;
  if (retval.361_93 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _94 = style_63->FrameRounding;
  style_63->GrabRounding = _94;

  <bb 15>:
  _96 = style_63->WindowBorderSize;
  window_border.362_97 = _96 > 0.0;
  window_border = window_border.362_97;
  _100 = ImGui::Checkbox ("WindowBorder", &window_border);
  retval.363_101 = _100;
  if (retval.363_101 != 0)
    goto <bb 16>;
  else
    goto <bb 20>;

  <bb 16>:
  window_border.365_102 = window_border;
  if (window_border.365_102 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.364_103 = 1.0e+0;
  goto <bb 19>;

  <bb 18>:
  iftmp.364_104 = 0.0;

  <bb 19>:
  # iftmp.364_10 = PHI <iftmp.364_103(17), iftmp.364_104(18)>
  style_63->WindowBorderSize = iftmp.364_10;

  <bb 20>:
  window_border ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  _108 = style_63->FrameBorderSize;
  frame_border.366_109 = _108 > 0.0;
  frame_border = frame_border.366_109;
  _112 = ImGui::Checkbox ("FrameBorder", &frame_border);
  retval.367_113 = _112;
  if (retval.367_113 != 0)
    goto <bb 21>;
  else
    goto <bb 25>;

  <bb 21>:
  frame_border.369_114 = frame_border;
  if (frame_border.369_114 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  iftmp.368_115 = 1.0e+0;
  goto <bb 24>;

  <bb 23>:
  iftmp.368_116 = 0.0;

  <bb 24>:
  # iftmp.368_11 = PHI <iftmp.368_115(22), iftmp.368_116(23)>
  style_63->FrameBorderSize = iftmp.368_11;

  <bb 25>:
  frame_border ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  _120 = style_63->PopupBorderSize;
  popup_border.370_121 = _120 > 0.0;
  popup_border = popup_border.370_121;
  _124 = ImGui::Checkbox ("PopupBorder", &popup_border);
  retval.371_125 = _124;
  if (retval.371_125 != 0)
    goto <bb 26>;
  else
    goto <bb 30>;

  <bb 26>:
  popup_border.373_126 = popup_border;
  if (popup_border.373_126 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  iftmp.372_127 = 1.0e+0;
  goto <bb 29>;

  <bb 28>:
  iftmp.372_128 = 0.0;

  <bb 29>:
  # iftmp.372_12 = PHI <iftmp.372_127(27), iftmp.372_128(28)>
  style_63->PopupBorderSize = iftmp.372_12;

  <bb 30>:
  popup_border ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.12070, 0.0, 0.0);
  _133 = ImGui::Button ("Save Ref", &D.12070);
  retval.374_134 = _133;
  D.12070 ={v} {CLOBBER};
  if (retval.374_134 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  ref_saved_style = MEM[(const struct ImGuiStyle &)style_63];
  ref_saved_style.375_137 = &ref_saved_style;
  *ref_1 = MEM[(const struct ImGuiStyle &)ref_saved_style.375_137];

  <bb 32>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12071, 0.0, 0.0);
  _142 = ImGui::Button ("Revert Ref", &D.12071);
  retval.376_143 = _142;
  D.12071 ={v} {CLOBBER};
  if (retval.376_143 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  *style_63 = MEM[(const struct ImGuiStyle &)ref_1];

  <bb 34>:
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Save/Revert in local non-persistent storage. Default Colors definition are not affected. Use \"Export Colors\" below to save them somewhere.");
  _149 = ImGui::TreeNode ("Rendering");
  retval.377_150 = _149;
  if (retval.377_150 != 0)
    goto <bb 35>;
  else
    goto <bb 38>;

  <bb 35>:
  _151 = &style_63->AntiAliasedLines;
  ImGui::Checkbox ("Anti-aliased lines", _151);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("When disabling anti-aliasing lines, you\'ll probably want to disable borders in your style as well.");
  _155 = &style_63->AntiAliasedFill;
  ImGui::Checkbox ("Anti-aliased fill", _155);
  ImGui::PushItemWidth (1.0e+2);
  _158 = &style_63->CurveTessellationTol;
  ImGui::DragFloat ("Curve Tessellation Tolerance", _158, 1.99999995529651641845703125e-2, 1.00000001490116119384765625e-1, 3.4028234663852885981170418348451692544e+38, 0B, 2.0e+0);
  _160 = style_63->CurveTessellationTol;
  if (_160 < 0.0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  style_63->CurveTessellationTol = 1.00000001490116119384765625e-1;

  <bb 37>:
  _162 = &style_63->Alpha;
  ImGui::DragFloat ("Global Alpha", _162, 4.999999888241291046142578125e-3, 2.0000000298023223876953125e-1, 1.0e+0, "%.2f", 1.0e+0);
  ImGui::PopItemWidth ();
  ImGui::TreePop ();

  <bb 38>:
  _167 = ImGui::TreeNode ("Settings");
  retval.378_168 = _167;
  if (retval.378_168 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _169 = &style_63->WindowPadding;
  ImGui::SliderFloat2 ("WindowPadding", _169, 0.0, 2.0e+1, "%.0f", 1.0e+0);
  _171 = &style_63->PopupRounding;
  ImGui::SliderFloat ("PopupRounding", _171, 0.0, 1.6e+1, "%.0f", 1.0e+0);
  _173 = &style_63->FramePadding;
  ImGui::SliderFloat2 ("FramePadding", _173, 0.0, 2.0e+1, "%.0f", 1.0e+0);
  _175 = &style_63->ItemSpacing;
  ImGui::SliderFloat2 ("ItemSpacing", _175, 0.0, 2.0e+1, "%.0f", 1.0e+0);
  _177 = &style_63->ItemInnerSpacing;
  ImGui::SliderFloat2 ("ItemInnerSpacing", _177, 0.0, 2.0e+1, "%.0f", 1.0e+0);
  _179 = &style_63->TouchExtraPadding;
  ImGui::SliderFloat2 ("TouchExtraPadding", _179, 0.0, 1.0e+1, "%.0f", 1.0e+0);
  _181 = &style_63->IndentSpacing;
  ImGui::SliderFloat ("IndentSpacing", _181, 0.0, 3.0e+1, "%.0f", 1.0e+0);
  _183 = &style_63->ScrollbarSize;
  ImGui::SliderFloat ("ScrollbarSize", _183, 1.0e+0, 2.0e+1, "%.0f", 1.0e+0);
  _185 = &style_63->GrabMinSize;
  ImGui::SliderFloat ("GrabMinSize", _185, 1.0e+0, 2.0e+1, "%.0f", 1.0e+0);
  ImGui::Text ("BorderSize");
  _188 = &style_63->WindowBorderSize;
  ImGui::SliderFloat ("WindowBorderSize", _188, 0.0, 1.0e+0, "%.0f", 1.0e+0);
  _190 = &style_63->ChildBorderSize;
  ImGui::SliderFloat ("ChildBorderSize", _190, 0.0, 1.0e+0, "%.0f", 1.0e+0);
  _192 = &style_63->PopupBorderSize;
  ImGui::SliderFloat ("PopupBorderSize", _192, 0.0, 1.0e+0, "%.0f", 1.0e+0);
  _194 = &style_63->FrameBorderSize;
  ImGui::SliderFloat ("FrameBorderSize", _194, 0.0, 1.0e+0, "%.0f", 1.0e+0);
  ImGui::Text ("Rounding");
  _197 = &style_63->WindowRounding;
  ImGui::SliderFloat ("WindowRounding", _197, 0.0, 1.4e+1, "%.0f", 1.0e+0);
  _199 = &style_63->ChildRounding;
  ImGui::SliderFloat ("ChildRounding", _199, 0.0, 1.6e+1, "%.0f", 1.0e+0);
  _201 = &style_63->FrameRounding;
  ImGui::SliderFloat ("FrameRounding", _201, 0.0, 1.2e+1, "%.0f", 1.0e+0);
  _203 = &style_63->ScrollbarRounding;
  ImGui::SliderFloat ("ScrollbarRounding", _203, 0.0, 1.2e+1, "%.0f", 1.0e+0);
  _205 = &style_63->GrabRounding;
  ImGui::SliderFloat ("GrabRounding", _205, 0.0, 1.2e+1, "%.0f", 1.0e+0);
  ImGui::Text ("Alignment");
  _208 = &style_63->WindowTitleAlign;
  ImGui::SliderFloat2 ("WindowTitleAlign", _208, 0.0, 1.0e+0, "%.2f", 1.0e+0);
  _210 = &style_63->ButtonTextAlign;
  ImGui::SliderFloat2 ("ButtonTextAlign", _210, 0.0, 1.0e+0, "%.2f", 1.0e+0);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Alignment applies when a button is larger than its text content.");
  ImGui::TreePop ();

  <bb 40>:
  _216 = ImGui::TreeNode ("Colors");
  retval.379_217 = _216;
  if (retval.379_217 != 0)
    goto <bb 41>;
  else
    goto <bb 68>;

  <bb 41>:
  ImVec2::ImVec2 (&D.12074, 0.0, 0.0);
  _220 = ImGui::Button ("Export Unsaved", &D.12074);
  retval.380_221 = _220;
  D.12074 ={v} {CLOBBER};
  if (retval.380_221 != 0)
    goto <bb 42>;
  else
    goto <bb 52>;

  <bb 42>:
  output_dest.381_223 = output_dest;
  if (output_dest.381_223 == 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  ImGui::LogToClipboard (-1);
  goto <bb 45>;

  <bb 44>:
  ImGui::LogToTTY (-1);

  <bb 45>:
  ImGui::LogText ("ImVec4* colors = ImGui::GetStyle().Colors;\n");
  i_227 = 0;

  <bb 46>:
  # i_2 = PHI <i_227(45), i_248(50)>
  if (i_2 > 41)
    goto <bb 51>;
  else
    goto <bb 47>;

  <bb 47>:
  col_228 = &style_63->Colors[i_2];
  _230 = ImGui::GetStyleColorName (i_2);
  name_231 = _230;
  output_only_modified.382_232 = output_only_modified;
  _233 = ~output_only_modified.382_232;
  if (_233 != 0)
    goto <bb 49>;
  else
    goto <bb 48>;

  <bb 48>:
  _234 = &ref_1->Colors[i_2];
  _235 = memcmp (col_228, _234, 16);
  if (_235 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  _236 = col_228->w;
  _237 = (double) _236;
  _238 = col_228->z;
  _239 = (double) _238;
  _240 = col_228->y;
  _241 = (double) _240;
  _242 = col_228->x;
  _243 = (double) _242;
  _244 = strlen (name_231);
  _245 = (int) _244;
  _246 = 23 - _245;
  ImGui::LogText ("colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);\n", name_231, _246, "", _243, _241, _239, _237);

  <bb 50>:
  i_248 = i_2 + 1;
  goto <bb 46>;

  <bb 51>:
  ImGui::LogFinish ();

  <bb 52>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushItemWidth (1.2e+2);
  ImGui::Combo ("##output_type", &output_dest, "To Clipboard", -1);
  ImGui::PopItemWidth ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::Checkbox ("Only Modified Colors", &output_only_modified);
  ImGui::Text ("Tip: Left-click on colored square to open color picker,\nRight-click to open edit options menu.");
  _258 = __atomic_load_1 (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE6filter, 2);
  retval.383_259 = _258 == 0;
  if (retval.383_259 != 0)
    goto <bb 53>;
  else
    goto <bb 56>;

  <bb 53>:
  _261 = __cxa_guard_acquire (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE6filter);
  retval.384_262 = _261 != 0;
  if (retval.384_262 != 0)
    goto <bb 54>;
  else
    goto <bb 56>;

  <bb 54>:
  _263 = 0;
  ImGuiTextFilter::ImGuiTextFilter (&filter, "");

  <bb 55>:
  _265 = 1;
  __cxa_guard_release (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE6filter);
  __cxa_atexit (__comp_dtor , &filter, &__dso_handle);

  <bb 56>:
  ImGuiTextFilter::Draw (&filter, "Filter colors", 2.0e+2);
  ImGui::RadioButton ("Opaque", &alpha_flags, 0);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::RadioButton ("Alpha", &alpha_flags, 1024);
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::RadioButton ("Both", &alpha_flags, 2048);
  ImVec2::ImVec2 (&D.12082, 0.0, 3.0e+2);
  ImGui::BeginChild ("#colors", &D.12082, 1, 8437760);
  D.12082 ={v} {CLOBBER};
  ImGui::PushItemWidth (-1.6e+2);
  i_279 = 0;

  <bb 57>:
  # i_3 = PHI <i_279(56), i_317(66)>
  if (i_3 > 41)
    goto <bb 67>;
  else
    goto <bb 58>;

  <bb 58>:
  _281 = ImGui::GetStyleColorName (i_3);
  name_282 = _281;
  _284 = ImGuiTextFilter::PassFilter (&filter, name_282, 0B);
  _285 = _284;
  retval.385_286 = ~_285;
  if (retval.385_286 != 0)
    goto <bb 59>;
  else
    goto <bb 60>;

  <bb 59>:
  goto <bb 66>;

  <bb 60>:
  ImGui::PushID (i_3);
  alpha_flags.386_288 = alpha_flags;
  _289 = alpha_flags.386_288 | 512;
  _290 = &style_63->Colors[i_3];
  ImGui::ColorEdit4 ("##color", _290, _289);
  _292 = &ref_1->Colors[i_3];
  _293 = &style_63->Colors[i_3];
  _294 = memcmp (_293, _292, 16);
  if (_294 != 0)
    goto <bb 61>;
  else
    goto <bb 65>;

  <bb 61>:
  _295 = style_63->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _295);
  ImVec2::ImVec2 (&D.12085, 0.0, 0.0);
  _299 = ImGui::Button ("Save", &D.12085);
  retval.387_300 = _299;
  D.12085 ={v} {CLOBBER};
  if (retval.387_300 != 0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  ref_1->Colors[i_3] = style_63->Colors[i_3];

  <bb 63>:
  _303 = style_63->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _303);
  ImVec2::ImVec2 (&D.12086, 0.0, 0.0);
  _307 = ImGui::Button ("Revert", &D.12086);
  retval.388_308 = _307;
  D.12086 ={v} {CLOBBER};
  if (retval.388_308 != 0)
    goto <bb 64>;
  else
    goto <bb 65>;

  <bb 64>:
  style_63->Colors[i_3] = ref_1->Colors[i_3];

  <bb 65>:
  _313 = style_63->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _313);
  ImGui::TextUnformatted (name_282, 0B);
  ImGui::PopID ();

  <bb 66>:
  i_317 = i_3 + 1;
  goto <bb 57>;

  <bb 67>:
  ImGui::PopItemWidth ();
  ImGui::EndChild ();
  ImGui::TreePop ();

  <bb 68>:
  _324 = ImGui::GetIO ();
  _325 = _324;
  _326 = _325->Fonts;
  _327 = _326->Fonts.Size;
  _329 = ImGui::TreeNode ("Fonts", "Fonts (%d)", _327);
  fonts_opened_330 = _329;
  if (fonts_opened_330 != 0)
    goto <bb 69>;
  else
    goto <bb 119>;

  <bb 69>:
  _332 = ImGui::GetIO ();
  _333 = _332;
  atlas_334 = _333->Fonts;
  _335 = atlas_334->TexHeight;
  _336 = atlas_334->TexWidth;
  _338 = ImGui::TreeNode ("Atlas texture", "Atlas texture (%dx%d pixels)", _336, _335);
  retval.389_339 = _338;
  if (retval.389_339 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  ImColor::ImColor (&D.12093, 255, 255, 255, 128);
  D.12095 = ImColor::operator ImVec4 (&D.12093);
  ImColor::ImColor (&D.12092, 255, 255, 255, 255);
  D.12094 = ImColor::operator ImVec4 (&D.12092);
  ImVec2::ImVec2 (&D.12091, 1.0e+0, 1.0e+0);
  ImVec2::ImVec2 (&D.12090, 0.0, 0.0);
  _346 = atlas_334->TexHeight;
  _347 = (float) _346;
  _348 = atlas_334->TexWidth;
  _349 = (float) _348;
  ImVec2::ImVec2 (&D.12089, _349, _347);
  _351 = atlas_334->TexID;
  ImGui::Image (_351, &D.12089, &D.12090, &D.12091, &D.12094, &D.12095);
  D.12089 ={v} {CLOBBER};
  D.12090 ={v} {CLOBBER};
  D.12091 ={v} {CLOBBER};
  D.12094 ={v} {CLOBBER};
  D.12092 ={v} {CLOBBER};
  D.12095 ={v} {CLOBBER};
  D.12093 ={v} {CLOBBER};
  ImGui::TreePop ();

  <bb 71>:
  ImGui::PushItemWidth (1.0e+2);
  i_369 = 0;

  <bb 72>:
  # i_4 = PHI <i_369(71), i_568(117)>
  _370 = atlas_334->Fonts.Size;
  if (_370 <= i_4)
    goto <bb 118>;
  else
    goto <bb 73>;

  <bb 73>:
  _371 = &atlas_334->Fonts;
  _373 = ImVector<ImFont*>::operator[] (_371, i_4);
  font_374 = *_373;
  ImGui::PushID (font_374);
  _376 = font_374->Glyphs.Size;
  _377 = font_374->FontSize;
  _378 = (double) _377;
  _379 = font_374->ConfigData;
  if (_379 != 0B)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  _380 = font_374->ConfigData;
  iftmp.390_381 = &_380->Name;
  goto <bb 76>;

  <bb 75>:
  iftmp.390_382 = "";

  <bb 76>:
  # iftmp.390_13 = PHI <iftmp.390_381(74), iftmp.390_382(75)>
  _384 = ImGui::TreeNode (font_374, "Font %d: \'%s\', %.2f px, %d glyphs", i_4, iftmp.390_13, _378, _376);
  font_details_opened_385 = _384;
  ImGui::SameLine (0.0, -1.0e+0);
  _388 = ImGui::SmallButton ("Set as default");
  retval.391_389 = _388;
  if (retval.391_389 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  _391 = ImGui::GetIO ();
  _392 = _391;
  _392->FontDefault = font_374;

  <bb 78>:
  if (font_details_opened_385 != 0)
    goto <bb 79>;
  else
    goto <bb 117>;

  <bb 79>:
  ImGui::PushFont (font_374);
  ImGui::Text ("The quick brown fox jumps over the lazy dog");
  ImGui::PopFont ();
  _397 = &font_374->Scale;
  ImGui::DragFloat ("Font scale", _397, 4.999999888241291046142578125e-3, 3.00000011920928955078125e-1, 2.0e+0, "%.1f", 1.0e+0);
  _399 = &font_374->DisplayOffset.y;
  ImGui::InputFloat ("Font offset", _399, 1.0e+0, 1.0e+0, 0, 0);
  ImGui::SameLine (0.0, -1.0e+0);
  ShowHelpMarker ("Note than the default embedded font is NOT meant to be scaled.\n\nFont are currently rendered into bitmaps at a given size at the time of building the atlas. You may oversample them to get some flexibility with scaling. You can also render at multiple sizes and select which one to use at runtime.\n\n(Glimmer of hope: the atlas system should hopefully be rewritten in the future to make scaling more natural and automatic.)");
  _403 = font_374->Ascent;
  _404 = font_374->Descent;
  _405 = _403 - _404;
  _406 = (double) _405;
  _407 = font_374->Descent;
  _408 = (double) _407;
  _409 = font_374->Ascent;
  _410 = (double) _409;
  ImGui::Text ("Ascent: %f, Descent: %f, Height: %f", _410, _408, _406);
  _412 = font_374->FallbackChar;
  _413 = (int) _412;
  _414 = font_374->FallbackChar;
  _415 = (int) _414;
  ImGui::Text ("Fallback character: \'%c\' (%d)", _415, _413);
  _417 = font_374->MetricsTotalSurface;
  _418 = (float) _417;
  _420 = sqrtf (_418);
  _421 = (int) _420;
  _422 = font_374->MetricsTotalSurface;
  _423 = (float) _422;
  _425 = sqrtf (_423);
  _426 = (int) _425;
  _427 = font_374->MetricsTotalSurface;
  ImGui::Text ("Texture surface: %d pixels (approx) ~ %dx%d", _427, _426, _421);
  config_i_429 = 0;

  <bb 80>:
  # config_i_5 = PHI <config_i_429(79), config_i_442(83)>
  _430 = font_374->ConfigDataCount;
  _431 = (int) _430;
  if (_431 <= config_i_5)
    goto <bb 84>;
  else
    goto <bb 81>;

  <bb 81>:
  _432 = font_374->ConfigData;
  _433 = (long unsigned int) config_i_5;
  _434 = _433 * 128;
  cfg_435 = _432 + _434;
  if (cfg_435 != 0B)
    goto <bb 82>;
  else
    goto <bb 83>;

  <bb 82>:
  _436 = cfg_435->PixelSnapH;
  _437 = (int) _436;
  _438 = cfg_435->OversampleV;
  _439 = cfg_435->OversampleH;
  _440 = &cfg_435->Name;
  ImGui::BulletText ("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d", config_i_5, _440, _439, _438, _437);

  <bb 83>:
  config_i_442 = config_i_5 + 1;
  goto <bb 80>;

  <bb 84>:
  _443 = font_374->Glyphs.Size;
  _445 = ImGui::TreeNode ("Glyphs", "Glyphs (%d)", _443);
  retval.392_446 = _445;
  if (retval.392_446 != 0)
    goto <bb 85>;
  else
    goto <bb 116>;

  <bb 85>:
  base_447 = 0;

  <bb 86>:
  # base_6 = PHI <base_447(85), base_564(114)>
  if (base_6 > 65535)
    goto <bb 115>;
  else
    goto <bb 87>;

  <bb 87>:
  count_448 = 0;
  n_449 = 0;

  <bb 88>:
  # count_7 = PHI <count_448(87), count_460(92)>
  # n_8 = PHI <n_449(87), n_461(92)>
  if (n_8 > 255)
    goto <bb 93>;
  else
    goto <bb 89>;

  <bb 89>:
  _450 = (short unsigned int) base_6;
  _451 = (short unsigned int) n_8;
  _452 = _450 + _451;
  _453 = (int) _452;
  _455 = ImFont::FindGlyphNoFallback (font_374, _453);
  _456 = _455;
  if (_456 != 0B)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  iftmp.393_457 = 1;
  goto <bb 92>;

  <bb 91>:
  iftmp.393_458 = 0;

  <bb 92>:
  # iftmp.393_14 = PHI <iftmp.393_457(90), iftmp.393_458(91)>
  _459 = iftmp.393_14;
  count_460 = count_7 + _459;
  n_461 = n_8 + 1;
  goto <bb 88>;

  <bb 93>:
  if (count_7 > 0)
    goto <bb 94>;
  else
    goto <bb 99>;

  <bb 94>:
  if (count_7 > 1)
    goto <bb 95>;
  else
    goto <bb 96>;

  <bb 95>:
  iftmp.396_462 = "glyphs";
  goto <bb 97>;

  <bb 96>:
  iftmp.396_463 = "glyph";

  <bb 97>:
  # iftmp.396_16 = PHI <iftmp.396_462(95), iftmp.396_463(96)>
  _464 = base_6 + 255;
  _465 = (long int) base_6;
  _466 = (const void *) _465;
  _468 = ImGui::TreeNode (_466, "U+%04X..U+%04X (%d %s)", base_6, _464, count_7, iftmp.396_16);
  _469 = _468;
  if (_469 != 0)
    goto <bb 98>;
  else
    goto <bb 99>;

  <bb 98>:
  iftmp.395_470 = 1;
  goto <bb 100>;

  <bb 99>:
  iftmp.395_471 = 0;

  <bb 100>:
  # iftmp.395_15 = PHI <iftmp.395_470(98), iftmp.395_471(99)>
  retval.394_472 = iftmp.395_15;
  if (retval.394_472 != 0)
    goto <bb 101>;
  else
    goto <bb 114>;

  <bb 101>:
  cell_size_473 = font_374->FontSize;
  cell_spacing_474 = style_63->ItemSpacing.y;
  base_pos = ImGui::GetCursorScreenPos ();
  _477 = ImGui::GetWindowDrawList ();
  draw_list_478 = _477;
  n_479 = 0;

  <bb 102>:
  # n_9 = PHI <n_479(101), n_550(112)>
  if (n_9 > 255)
    goto <bb 113>;
  else
    goto <bb 103>;

  <bb 103>:
  _480 = base_pos.y;
  _481 = n_9 / 16;
  _482 = (float) _481;
  _483 = cell_size_473 + cell_spacing_474;
  _484 = _482 * _483;
  _485 = _480 + _484;
  _486 = base_pos.x;
  _487 = n_9 % 16;
  _488 = (float) _487;
  _489 = cell_size_473 + cell_spacing_474;
  _490 = _488 * _489;
  _491 = _486 + _490;
  ImVec2::ImVec2 (&cell_p1, _491, _485);
  _493 = cell_p1.y;
  _494 = _493 + cell_size_473;
  _495 = cell_p1.x;
  _496 = _495 + cell_size_473;
  ImVec2::ImVec2 (&cell_p2, _496, _494);
  _498 = (short unsigned int) base_6;
  _499 = (short unsigned int) n_9;
  _500 = _498 + _499;
  _501 = (int) _500;
  _503 = ImFont::FindGlyphNoFallback (font_374, _501);
  glyph_504 = _503;
  if (glyph_504 != 0B)
    goto <bb 104>;
  else
    goto <bb 105>;

  <bb 104>:
  iftmp.397_505 = 1694498815;
  goto <bb 106>;

  <bb 105>:
  iftmp.397_506 = 855638015;

  <bb 106>:
  # iftmp.397_17 = PHI <iftmp.397_505(104), iftmp.397_506(105)>
  ImDrawList::AddRect (draw_list_478, &cell_p1, &cell_p2, iftmp.397_17, 0.0, 15, 1.0e+0);
  _508 = (short unsigned int) base_6;
  _509 = (short unsigned int) n_9;
  _510 = _508 + _509;
  _511 = (int) _510;
  _513 = ImGui::GetColorU32 (0, 1.0e+0);
  _514 = _513;
  ImFont::RenderChar (font_374, draw_list_478, cell_size_473, cell_p1, _514, _511);
  if (glyph_504 != 0B)
    goto <bb 107>;
  else
    goto <bb 109>;

  <bb 107>:
  _517 = ImGui::IsMouseHoveringRect (&cell_p1, &cell_p2, 1);
  _518 = _517;
  if (_518 != 0)
    goto <bb 108>;
  else
    goto <bb 109>;

  <bb 108>:
  iftmp.399_519 = 1;
  goto <bb 110>;

  <bb 109>:
  iftmp.399_520 = 0;

  <bb 110>:
  # iftmp.399_18 = PHI <iftmp.399_519(108), iftmp.399_520(109)>
  retval.398_521 = iftmp.399_18;
  if (retval.398_521 != 0)
    goto <bb 111>;
  else
    goto <bb 112>;

  <bb 111>:
  ImGui::BeginTooltip ();
  _523 = base_6 + n_9;
  ImGui::Text ("Codepoint: U+%04X", _523);
  ImGui::Separator ();
  _526 = glyph_504->AdvanceX;
  _527 = (double) _526;
  ImGui::Text ("AdvanceX: %.1f", _527);
  _529 = glyph_504->Y1;
  _530 = (double) _529;
  _531 = glyph_504->X1;
  _532 = (double) _531;
  _533 = glyph_504->Y0;
  _534 = (double) _533;
  _535 = glyph_504->X0;
  _536 = (double) _535;
  ImGui::Text ("Pos: (%.2f,%.2f)->(%.2f,%.2f)", _536, _534, _532, _530);
  _538 = glyph_504->V1;
  _539 = (double) _538;
  _540 = glyph_504->U1;
  _541 = (double) _540;
  _542 = glyph_504->V0;
  _543 = (double) _542;
  _544 = glyph_504->U0;
  _545 = (double) _544;
  ImGui::Text ("UV: (%.3f,%.3f)->(%.3f,%.3f)", _545, _543, _541, _539);
  ImGui::EndTooltip ();

  <bb 112>:
  cell_p1 ={v} {CLOBBER};
  cell_p2 ={v} {CLOBBER};
  n_550 = n_9 + 1;
  goto <bb 102>;

  <bb 113>:
  _553 = cell_size_473 + cell_spacing_474;
  _554 = _553 * 1.6e+1;
  _555 = cell_size_473 + cell_spacing_474;
  _556 = _555 * 1.6e+1;
  ImVec2::ImVec2 (&D.12115, _556, _554);
  ImGui::Dummy (&D.12115);
  D.12115 ={v} {CLOBBER};
  ImGui::TreePop ();
  base_pos ={v} {CLOBBER};

  <bb 114>:
  base_564 = base_6 + 256;
  goto <bb 86>;

  <bb 115>:
  ImGui::TreePop ();

  <bb 116>:
  ImGui::TreePop ();

  <bb 117>:
  ImGui::PopID ();
  i_568 = i_4 + 1;
  goto <bb 72>;

  <bb 118>:
  ImGui::DragFloat ("this window scale", &window_scale, 4.999999888241291046142578125e-3, 3.00000011920928955078125e-1, 2.0e+0, "%.1f", 1.0e+0);
  _571 = ImGui::GetIO ();
  _572 = _571;
  _573 = &_572->FontGlobalScale;
  ImGui::DragFloat ("global scale", _573, 4.999999888241291046142578125e-3, 3.00000011920928955078125e-1, 2.0e+0, "%.1f", 1.0e+0);
  ImGui::PopItemWidth ();
  window_scale.400_576 = window_scale;
  ImGui::SetWindowFontScale (window_scale.400_576);
  ImGui::TreePop ();

  <bb 119>:
  ImGui::PopItemWidth ();
  return;

<L148>:
  if (_70 != 0)
    goto <bb 122>;
  else
    goto <bb 121>;

  <bb 121>:
  __cxa_guard_abort (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE15ref_saved_style);

  <bb 122>:
  _58 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_58);

<L158>:
  if (_263 != 0)
    goto <bb 125>;
  else
    goto <bb 124>;

  <bb 124>:
  __cxa_guard_abort (&_ZGVZN5ImGui15ShowStyleEditorEP10ImGuiStyleE6filter);

  <bb 125>:
  _59 = __builtin_eh_pointer (15);
  __builtin_unwind_resume (_59);

}



;; Function void ShowExampleAppMainMenuBar() (_ZL25ShowExampleAppMainMenuBarv, funcdef_no=417, decl_uid=11354, cgraph_uid=316, symbol_order=473)

void ShowExampleAppMainMenuBar() ()
{
  bool D.15976;
  bool D.15975;
  bool D.15974;
  bool D.15973;
  bool D.15972;
  bool D.15971;
  bool D.15970;
  bool D.15969;
  bool retval.408;
  bool retval.407;
  bool retval.406;
  bool retval.405;
  bool retval.404;
  bool retval.403;
  bool retval.402;
  bool retval.401;
  bool _6;
  bool retval.401_7;
  bool _9;
  bool retval.402_10;
  bool _14;
  bool retval.403_15;
  bool _17;
  bool retval.404_18;
  bool _20;
  bool retval.405_21;
  bool _24;
  bool retval.406_25;
  bool _27;
  bool retval.407_28;
  bool _30;
  bool retval.408_31;

  <bb 2>:
  _6 = ImGui::BeginMainMenuBar ();
  retval.401_7 = _6;
  if (retval.401_7 != 0)
    goto <bb 3>;
  else
    goto <bb 13>;

  <bb 3>:
  _9 = ImGui::BeginMenu ("File", 1);
  retval.402_10 = _9;
  if (retval.402_10 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  ShowExampleMenuFile ();
  ImGui::EndMenu ();

  <bb 5>:
  _14 = ImGui::BeginMenu ("Edit", 1);
  retval.403_15 = _14;
  if (retval.403_15 != 0)
    goto <bb 6>;
  else
    goto <bb 12>;

  <bb 6>:
  _17 = ImGui::MenuItem ("Undo", "CTRL+Z", 0, 1);
  retval.404_18 = _17;

  <bb 7>:
  _20 = ImGui::MenuItem ("Redo", "CTRL+Y", 0, 0);
  retval.405_21 = _20;

  <bb 8>:
  ImGui::Separator ();
  _24 = ImGui::MenuItem ("Cut", "CTRL+X", 0, 1);
  retval.406_25 = _24;

  <bb 9>:
  _27 = ImGui::MenuItem ("Copy", "CTRL+C", 0, 1);
  retval.407_28 = _27;

  <bb 10>:
  _30 = ImGui::MenuItem ("Paste", "CTRL+V", 0, 1);
  retval.408_31 = _30;

  <bb 11>:
  ImGui::EndMenu ();

  <bb 12>:
  ImGui::EndMainMenuBar ();

  <bb 13>:
  return;

}



;; Function void ShowExampleMenuFile() (_ZL19ShowExampleMenuFilev, funcdef_no=418, decl_uid=11355, cgraph_uid=317, symbol_order=478)

void ShowExampleMenuFile() ()
{
  bool D.16057;
  bool D.16056;
  bool D.16055;
  struct ImDrawList * D.16051;
  unsigned int D.16050;
  const char * D.16049;
  float D.16048;
  bool D.16047;
  bool D.16045;
  bool D.16044;
  bool D.16043;
  bool D.16042;
  bool D.16041;
  bool D.16040;
  bool D.16039;
  bool D.16038;
  struct ImVec2 p;
  const char * name;
  int i;
  float sz;
  int i;
  static bool b = 1;
  static int n = 0;
  static float f = 5.0e-1;
  static bool enabled = 1;
  static const char __PRETTY_FUNCTION__[27] = "void ShowExampleMenuFile()";
  bool retval.420;
  bool retval.419;
  bool retval.418;
  struct ImVec2 D.12147;
  struct ImDrawList * D.16021;
  float D.16020;
  float D.16019;
  float D.16018;
  float D.16017;
  struct ImVec2 D.12146;
  unsigned int D.16016;
  bool retval.417;
  struct ImVec2 D.12136;
  bool retval.416;
  bool retval.415;
  bool retval.414;
  bool retval.413;
  bool retval.412;
  bool retval.411;
  bool retval.410;
  bool retval.409;
  bool _15;
  bool retval.409_16;
  bool _18;
  bool retval.410_19;
  bool _21;
  bool retval.411_22;
  bool _27;
  bool retval.412_28;
  bool _32;
  bool retval.413_33;
  bool _39;
  bool retval.414_40;
  bool _42;
  bool retval.415_43;
  bool _46;
  bool retval.416_47;
  bool _63;
  bool retval.417_64;
  float _66;
  const char * _70;
  unsigned int _74;
  unsigned int _75;
  float _76;
  float _77;
  float _78;
  float _79;
  struct ImDrawList * _82;
  struct ImDrawList * _83;
  bool _98;
  bool retval.418_99;
  bool _101;
  bool retval.419_102;
  bool _104;
  bool retval.420_105;

  <bb 2>:
  ImGui::MenuItem ("(dummy menu)", 0B, 0, 0);
  _15 = ImGui::MenuItem ("New", 0B, 0, 1);
  retval.409_16 = _15;

  <bb 3>:
  _18 = ImGui::MenuItem ("Open", "Ctrl+O", 0, 1);
  retval.410_19 = _18;

  <bb 4>:
  _21 = ImGui::BeginMenu ("Open Recent", 1);
  retval.411_22 = _21;
  if (retval.411_22 != 0)
    goto <bb 5>;
  else
    goto <bb 10>;

  <bb 5>:
  ImGui::MenuItem ("fish_hat.c", 0B, 0, 1);
  ImGui::MenuItem ("fish_hat.inl", 0B, 0, 1);
  ImGui::MenuItem ("fish_hat.h", 0B, 0, 1);
  _27 = ImGui::BeginMenu ("More..", 1);
  retval.412_28 = _27;
  if (retval.412_28 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

  <bb 6>:
  ImGui::MenuItem ("Hello", 0B, 0, 1);
  ImGui::MenuItem ("Sailor", 0B, 0, 1);
  _32 = ImGui::BeginMenu ("Recurse..", 1);
  retval.413_33 = _32;
  if (retval.413_33 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ShowExampleMenuFile ();
  ImGui::EndMenu ();

  <bb 8>:
  ImGui::EndMenu ();

  <bb 9>:
  ImGui::EndMenu ();

  <bb 10>:
  _39 = ImGui::MenuItem ("Save", "Ctrl+S", 0, 1);
  retval.414_40 = _39;

  <bb 11>:
  _42 = ImGui::MenuItem ("Save As..", 0B, 0, 1);
  retval.415_43 = _42;

  <bb 12>:
  ImGui::Separator ();
  _46 = ImGui::BeginMenu ("Options", 1);
  retval.416_47 = _46;
  if (retval.416_47 != 0)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:
  ImGui::MenuItem ("Enabled", "", &enabled, 1);
  ImVec2::ImVec2 (&D.12136, 0.0, 6.0e+1);
  ImGui::BeginChild ("child", &D.12136, 1, 0);
  D.12136 ={v} {CLOBBER};
  i_52 = 0;

  <bb 14>:
  # i_1 = PHI <i_52(13), i_54(15)>
  if (i_1 > 9)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  ImGui::Text ("Scrolling Text %d", i_1);
  i_54 = i_1 + 1;
  goto <bb 14>;

  <bb 16>:
  ImGui::EndChild ();
  ImGui::SliderFloat ("Value", &f, 0.0, 1.0e+0, "%.3f", 1.0e+0);
  ImGui::InputFloat ("Input", &f, 1.00000001490116119384765625e-1, 0.0, -1, 0);
  ImGui::Combo ("Combo", &n, "Yes", -1);
  ImGui::Checkbox ("Check", &b);
  ImGui::EndMenu ();

  <bb 17>:
  _63 = ImGui::BeginMenu ("Colors", 1);
  retval.417_64 = _63;
  if (retval.417_64 != 0)
    goto <bb 18>;
  else
    goto <bb 22>;

  <bb 18>:
  _66 = ImGui::GetTextLineHeight ();
  sz_67 = _66;
  i_68 = 0;

  <bb 19>:
  # i_2 = PHI <i_68(18), i_92(20)>
  if (i_2 > 41)
    goto <bb 21>;
  else
    goto <bb 20>;

  <bb 20>:
  _70 = ImGui::GetStyleColorName (i_2);
  name_71 = _70;
  p = ImGui::GetCursorScreenPos ();
  _74 = ImGui::GetColorU32 (i_2, 1.0e+0);
  _75 = _74;
  _76 = p.y;
  _77 = _76 + sz_67;
  _78 = p.x;
  _79 = _78 + sz_67;
  ImVec2::ImVec2 (&D.12146, _79, _77);
  _82 = ImGui::GetWindowDrawList ();
  _83 = _82;
  ImDrawList::AddRectFilled (_83, &p, &D.12146, _75, 0.0, 15);
  D.12146 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.12147, sz_67, sz_67);
  ImGui::Dummy (&D.12147);
  D.12147 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::MenuItem (name_71, 0B, 0, 1);
  p ={v} {CLOBBER};
  i_92 = i_2 + 1;
  goto <bb 19>;

  <bb 21>:
  ImGui::EndMenu ();

  <bb 22>:
  _98 = ImGui::BeginMenu ("Disabled", 0);
  retval.418_99 = _98;
  if (retval.418_99 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui_demo.cpp", 2400, &__PRETTY_FUNCTION__);

  <bb 24>:
  _101 = ImGui::MenuItem ("Checked", 0B, 1, 1);
  retval.419_102 = _101;

  <bb 25>:
  _104 = ImGui::MenuItem ("Quit", "Alt+F4", 0, 1);
  retval.420_105 = _104;

  <bb 26>:
  return;

}



;; Function void ShowExampleAppAutoResize(bool*) (_ZL24ShowExampleAppAutoResizePb, funcdef_no=419, decl_uid=11345, cgraph_uid=318, symbol_order=480)

void ShowExampleAppAutoResize(bool*) (bool * p_open)
{
  bool D.16067;
  int i;
  static int lines = 10;
  int D.16065;
  int lines.422;
  bool D.16059;
  bool retval.421;
  bool _7;
  bool _8;
  bool retval.421_9;
  int lines.422_14;
  int _15;

  <bb 2>:
  _7 = ImGui::Begin ("Example: Auto-resizing window", p_open_5(D), 64);
  _8 = _7;
  retval.421_9 = ~_8;
  if (retval.421_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::End ();
  goto <bb 8> (<L5>);

  <bb 4>:
  ImGui::Text ("Window will resize every-frame to the size of its content.\nNote that you probably don\'t want to query the window size to\noutput your content because that would create a feedback loop.");
  ImGui::SliderInt ("Number of lines", &lines, 1, 20, "%.0f");
  i_13 = 0;

  <bb 5>:
  # i_1 = PHI <i_13(4), i_17(6)>
  lines.422_14 = lines;
  if (i_1 >= lines.422_14)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _15 = i_1 * 4;
  ImGui::Text ("%*sThis is line %d", _15, "", i_1);
  i_17 = i_1 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::End ();

<L5>:
  return;

}



;; Function static void ShowExampleAppConstrainedResize(bool*)::CustomConstraints::Square(ImGuiSizeCallbackData*) (_ZZL31ShowExampleAppConstrainedResizePbEN17CustomConstraints6SquareEP21ImGuiSizeCallbackData, funcdef_no=421, decl_uid=12166, cgraph_uid=319, symbol_order=481)

static void ShowExampleAppConstrainedResize(bool*)::CustomConstraints::Square(ImGuiSizeCallbackData*) (struct ImGuiSizeCallbackData * data)
{
  float D.16169;
  float D.16168;
  float iftmp.438;
  float D.16163;
  float D.16162;
  float iftmp.437;
  struct ImVec2 D.12171;
  float iftmp.437_1;
  float iftmp.438_2;
  float _5;
  float _6;
  float iftmp.437_7;
  float iftmp.437_8;
  float _9;
  float _10;
  float iftmp.438_11;
  float iftmp.438_12;

  <bb 2>:
  _5 = data_4(D)->DesiredSize.x;
  _6 = data_4(D)->DesiredSize.y;
  if (_5 >= _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.437_7 = data_4(D)->DesiredSize.x;
  goto <bb 5>;

  <bb 4>:
  iftmp.437_8 = data_4(D)->DesiredSize.y;

  <bb 5>:
  # iftmp.437_1 = PHI <iftmp.437_7(3), iftmp.437_8(4)>
  _9 = data_4(D)->DesiredSize.x;
  _10 = data_4(D)->DesiredSize.y;
  if (_9 >= _10)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.438_11 = data_4(D)->DesiredSize.x;
  goto <bb 8>;

  <bb 7>:
  iftmp.438_12 = data_4(D)->DesiredSize.y;

  <bb 8>:
  # iftmp.438_2 = PHI <iftmp.438_11(6), iftmp.438_12(7)>
  ImVec2::ImVec2 (&D.12171, iftmp.438_2, iftmp.437_1);
  data_4(D)->DesiredSize = D.12171;
  D.12171 ={v} {CLOBBER};
  return;

}



;; Function static void ShowExampleAppConstrainedResize(bool*)::CustomConstraints::Step(ImGuiSizeCallbackData*) (_ZZL31ShowExampleAppConstrainedResizePbEN17CustomConstraints4StepEP21ImGuiSizeCallbackData, funcdef_no=422, decl_uid=12168, cgraph_uid=320, symbol_order=482)

static void ShowExampleAppConstrainedResize(bool*)::CustomConstraints::Step(ImGuiSizeCallbackData*) (struct ImGuiSizeCallbackData * data)
{
  float step;
  float D.16160;
  float D.16159;
  int D.16158;
  float D.16157;
  float D.16156;
  float D.16155;
  float D.16154;
  float D.16153;
  int D.16152;
  float D.16151;
  float D.16150;
  float D.16149;
  struct ImVec2 D.12174;
  int D.16148;
  long int D.16147;
  void * D.16146;
  void * _3;
  long int _4;
  int _5;
  float _7;
  float _8;
  float _9;
  int _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  int _16;
  float _17;
  float _18;

  <bb 2>:
  _3 = data_2(D)->UserData;
  _4 = (long int) _3;
  _5 = (int) _4;
  step_6 = (float) _5;
  _7 = data_2(D)->DesiredSize.y;
  _8 = _7 / step_6;
  _9 = _8 + 5.0e-1;
  _10 = (int) _9;
  _11 = (float) _10;
  _12 = _11 * step_6;
  _13 = data_2(D)->DesiredSize.x;
  _14 = _13 / step_6;
  _15 = _14 + 5.0e-1;
  _16 = (int) _15;
  _17 = (float) _16;
  _18 = _17 * step_6;
  ImVec2::ImVec2 (&D.12174, _18, _12);
  data_2(D)->DesiredSize = D.12174;
  D.12174 ={v} {CLOBBER};
  return;

}



;; Function void ShowExampleAppConstrainedResize(bool*) (_ZL31ShowExampleAppConstrainedResizePb, funcdef_no=420, decl_uid=11347, cgraph_uid=321, symbol_order=486)

void ShowExampleAppConstrainedResize(bool*) (bool * p_open)
{
  bool D.16142;
  bool D.16139;
  bool D.16136;
  bool D.16135;
  int i;
  const char * desc[7];
  ImGuiWindowFlags flags;
  static int display_lines = 10;
  static int type = 0;
  static bool auto_resize = 0;
  int D.16119;
  int display_lines.436;
  struct ImVec2 D.12199;
  struct ImVec2 D.12198;
  bool retval.435;
  struct ImVec2 D.12197;
  struct ImVec2 D.12196;
  bool retval.434;
  struct ImVec2 D.12195;
  struct ImVec2 D.12194;
  bool retval.433;
  bool retval.432;
  bool auto_resize.431;
  int iftmp.430;
  struct ImVec2 D.12190;
  struct ImVec2 D.12191;
  int type.429;
  struct ImVec2 D.12188;
  struct ImVec2 D.12189;
  int type.428;
  struct ImVec2 D.12186;
  struct ImVec2 D.12187;
  int type.427;
  struct ImVec2 D.12184;
  struct ImVec2 D.12185;
  int type.426;
  struct ImVec2 D.12182;
  struct ImVec2 D.12183;
  int type.425;
  struct ImVec2 D.12180;
  struct ImVec2 D.12181;
  int type.424;
  struct ImVec2 D.12178;
  struct ImVec2 D.12179;
  int type.423;
  int iftmp.430_2;
  int type.423_17;
  int type.424_25;
  int type.425_33;
  int type.426_41;
  int type.427_49;
  int type.428_57;
  int type.429_65;
  bool auto_resize.431_73;
  int iftmp.430_74;
  int iftmp.430_75;
  bool _79;
  bool retval.432_80;
  bool _90;
  bool retval.433_91;
  bool _100;
  bool retval.434_101;
  bool _110;
  bool retval.435_111;
  int display_lines.436_123;
  int _124;

  <bb 2>:
  type.423_17 = type;
  if (type.423_17 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImVec2::ImVec2 (&D.12179, -1.0e+0, 3.4028234663852885981170418348451692544e+38);
  ImVec2::ImVec2 (&D.12178, -1.0e+0, 0.0);
  ImGui::SetNextWindowSizeConstraints (&D.12178, &D.12179, 0B, 0B);
  D.12178 ={v} {CLOBBER};
  D.12179 ={v} {CLOBBER};

  <bb 4>:
  type.424_25 = type;
  if (type.424_25 == 1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImVec2::ImVec2 (&D.12181, 3.4028234663852885981170418348451692544e+38, -1.0e+0);
  ImVec2::ImVec2 (&D.12180, 0.0, -1.0e+0);
  ImGui::SetNextWindowSizeConstraints (&D.12180, &D.12181, 0B, 0B);
  D.12180 ={v} {CLOBBER};
  D.12181 ={v} {CLOBBER};

  <bb 6>:
  type.425_33 = type;
  if (type.425_33 == 2)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImVec2::ImVec2 (&D.12183, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  ImVec2::ImVec2 (&D.12182, 1.0e+2, 1.0e+2);
  ImGui::SetNextWindowSizeConstraints (&D.12182, &D.12183, 0B, 0B);
  D.12182 ={v} {CLOBBER};
  D.12183 ={v} {CLOBBER};

  <bb 8>:
  type.426_41 = type;
  if (type.426_41 == 3)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  ImVec2::ImVec2 (&D.12185, 5.0e+2, -1.0e+0);
  ImVec2::ImVec2 (&D.12184, 4.0e+2, -1.0e+0);
  ImGui::SetNextWindowSizeConstraints (&D.12184, &D.12185, 0B, 0B);
  D.12184 ={v} {CLOBBER};
  D.12185 ={v} {CLOBBER};

  <bb 10>:
  type.427_49 = type;
  if (type.427_49 == 4)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  ImVec2::ImVec2 (&D.12187, -1.0e+0, 5.0e+2);
  ImVec2::ImVec2 (&D.12186, -1.0e+0, 4.0e+2);
  ImGui::SetNextWindowSizeConstraints (&D.12186, &D.12187, 0B, 0B);
  D.12186 ={v} {CLOBBER};
  D.12187 ={v} {CLOBBER};

  <bb 12>:
  type.428_57 = type;
  if (type.428_57 == 5)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  ImVec2::ImVec2 (&D.12189, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  ImVec2::ImVec2 (&D.12188, 0.0, 0.0);
  ImGui::SetNextWindowSizeConstraints (&D.12188, &D.12189, Square, 0B);
  D.12188 ={v} {CLOBBER};
  D.12189 ={v} {CLOBBER};

  <bb 14>:
  type.429_65 = type;
  if (type.429_65 == 6)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  ImVec2::ImVec2 (&D.12191, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  ImVec2::ImVec2 (&D.12190, 0.0, 0.0);
  ImGui::SetNextWindowSizeConstraints (&D.12190, &D.12191, Step, 100B);
  D.12190 ={v} {CLOBBER};
  D.12191 ={v} {CLOBBER};

  <bb 16>:
  auto_resize.431_73 = auto_resize;
  if (auto_resize.431_73 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.430_74 = 64;
  goto <bb 19>;

  <bb 18>:
  iftmp.430_75 = 0;

  <bb 19>:
  # iftmp.430_2 = PHI <iftmp.430_74(17), iftmp.430_75(18)>
  flags_76 = iftmp.430_2;
  _79 = ImGui::Begin ("Example: Constrained Resize", p_open_77(D), flags_76);
  retval.432_80 = _79;
  if (retval.432_80 != 0)
    goto <bb 20>;
  else
    goto <bb 30>;

  <bb 20>:
  desc[0] = "Resize vertical only";
  desc[1] = "Resize horizontal only";
  desc[2] = "Width > 100, Height > 100";
  desc[3] = "Width 400-500";
  desc[4] = "Height 400-500";
  desc[5] = "Custom: Always Square";
  desc[6] = "Custom: Fixed Steps (100)";
  ImVec2::ImVec2 (&D.12194, 0.0, 0.0);
  _90 = ImGui::Button ("200x200", &D.12194);
  retval.433_91 = _90;
  D.12194 ={v} {CLOBBER};
  if (retval.433_91 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  ImVec2::ImVec2 (&D.12195, 2.0e+2, 2.0e+2);
  ImGui::SetWindowSize (&D.12195, 0);
  D.12195 ={v} {CLOBBER};

  <bb 22>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12196, 0.0, 0.0);
  _100 = ImGui::Button ("500x500", &D.12196);
  retval.434_101 = _100;
  D.12196 ={v} {CLOBBER};
  if (retval.434_101 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  ImVec2::ImVec2 (&D.12197, 5.0e+2, 5.0e+2);
  ImGui::SetWindowSize (&D.12197, 0);
  D.12197 ={v} {CLOBBER};

  <bb 24>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12198, 0.0, 0.0);
  _110 = ImGui::Button ("800x200", &D.12198);
  retval.435_111 = _110;
  D.12198 ={v} {CLOBBER};
  if (retval.435_111 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  ImVec2::ImVec2 (&D.12199, 8.0e+2, 2.0e+2);
  ImGui::SetWindowSize (&D.12199, 0);
  D.12199 ={v} {CLOBBER};

  <bb 26>:
  ImGui::PushItemWidth (2.0e+2);
  ImGui::Combo ("Constraint", &type, &desc, 7, -1);
  ImGui::DragInt ("Lines", &display_lines, 2.0000000298023223876953125e-1, 1, 100, "%.0f");
  ImGui::PopItemWidth ();
  ImGui::Checkbox ("Auto-resize", &auto_resize);
  i_122 = 0;

  <bb 27>:
  # i_1 = PHI <i_122(26), i_126(28)>
  display_lines.436_123 = display_lines;
  if (i_1 >= display_lines.436_123)
    goto <bb 29>;
  else
    goto <bb 28>;

  <bb 28>:
  _124 = i_1 * 4;
  ImGui::Text ("%*sHello, sailor! Making this line long enough for the example.", _124, "");
  i_126 = i_1 + 1;
  goto <bb 27>;

  <bb 29>:
  desc ={v} {CLOBBER};

  <bb 30>:
  ImGui::End ();
  return;

}



;; Function void ShowExampleAppFixedOverlay(bool*) (_ZL26ShowExampleAppFixedOverlayPb, funcdef_no=423, decl_uid=11349, cgraph_uid=322, symbol_order=488)

void ShowExampleAppFixedOverlay(bool*) (bool * p_open)
{
  bool D.16263;
  bool D.16262;
  bool D.16261;
  bool D.16260;
  bool D.16259;
  bool D.16258;
  struct ImGuiIO & D.16257;
  struct ImGuiIO & D.16256;
  bool D.16255;
  struct ImGuiIO & D.16254;
  struct ImGuiIO & D.16253;
  struct ImVec2 window_pos_pivot;
  struct ImVec2 window_pos;
  static int corner = 0;
  const float DISTANCE;
  bool D.16246;
  bool iftmp.458;
  bool retval.457;
  int D.16237;
  bool D.16236;
  int corner.456;
  bool retval.455;
  int D.16230;
  bool D.16229;
  int corner.454;
  bool retval.453;
  int D.16223;
  bool D.16222;
  int corner.452;
  bool retval.451;
  int D.16216;
  bool D.16215;
  int corner.450;
  bool retval.449;
  bool retval.448;
  double D.16209;
  float D.16208;
  struct ImGuiIO & D.16207;
  double D.16206;
  float D.16205;
  struct ImGuiIO & D.16204;
  bool retval.447;
  int D.16197;
  int corner.446;
  float iftmp.445;
  int D.16191;
  int corner.444;
  float iftmp.443;
  float D.16187;
  struct ImGuiIO & D.16186;
  int D.16183;
  int corner.442;
  float iftmp.441;
  float D.16179;
  struct ImGuiIO & D.16178;
  int D.16175;
  int corner.440;
  float iftmp.439;
  float iftmp.439_1;
  float iftmp.441_2;
  float iftmp.443_3;
  float iftmp.445_4;
  bool iftmp.458_5;
  int corner.440_20;
  int _21;
  struct ImGuiIO & _23;
  struct ImGuiIO & _24;
  float _25;
  float iftmp.439_26;
  float iftmp.439_27;
  int corner.442_28;
  int _29;
  struct ImGuiIO & _31;
  struct ImGuiIO & _32;
  float _33;
  float iftmp.441_34;
  float iftmp.441_35;
  int corner.444_37;
  int _38;
  float iftmp.443_39;
  float iftmp.443_40;
  int corner.446_41;
  int _42;
  float iftmp.445_43;
  float iftmp.445_44;
  bool _50;
  bool retval.447_51;
  struct ImGuiIO & _55;
  struct ImGuiIO & _56;
  float _57;
  double _58;
  struct ImGuiIO & _60;
  struct ImGuiIO & _61;
  float _62;
  double _63;
  bool _66;
  bool retval.448_67;
  int corner.450_68;
  bool _69;
  int _70;
  bool _72;
  bool retval.449_73;
  int corner.452_75;
  bool _76;
  int _77;
  bool _79;
  bool retval.451_80;
  int corner.454_82;
  bool _83;
  int _84;
  bool _86;
  bool retval.453_87;
  int corner.456_89;
  bool _90;
  int _91;
  bool _93;
  bool retval.455_94;
  bool _97;
  bool _98;
  bool iftmp.458_99;
  bool iftmp.458_100;
  bool retval.457_101;

  <bb 2>:
  DISTANCE_18 = 1.0e+1;
  corner.440_20 = corner;
  _21 = corner.440_20 & 2;
  if (_21 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _23 = ImGui::GetIO ();
  _24 = _23;
  _25 = _24->DisplaySize.y;
  iftmp.439_26 = _25 - 1.0e+1;
  goto <bb 5>;

  <bb 4>:
  iftmp.439_27 = 1.0e+1;

  <bb 5>:
  # iftmp.439_1 = PHI <iftmp.439_26(3), iftmp.439_27(4)>
  corner.442_28 = corner;
  _29 = corner.442_28 & 1;
  if (_29 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _31 = ImGui::GetIO ();
  _32 = _31;
  _33 = _32->DisplaySize.x;
  iftmp.441_34 = _33 - 1.0e+1;
  goto <bb 8>;

  <bb 7>:
  iftmp.441_35 = 1.0e+1;

  <bb 8>:
  # iftmp.441_2 = PHI <iftmp.441_34(6), iftmp.441_35(7)>
  ImVec2::ImVec2 (&window_pos, iftmp.441_2, iftmp.439_1);
  corner.444_37 = corner;
  _38 = corner.444_37 & 2;
  if (_38 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.443_39 = 1.0e+0;
  goto <bb 11>;

  <bb 10>:
  iftmp.443_40 = 0.0;

  <bb 11>:
  # iftmp.443_3 = PHI <iftmp.443_39(9), iftmp.443_40(10)>
  corner.446_41 = corner;
  _42 = corner.446_41 & 1;
  if (_42 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.445_43 = 1.0e+0;
  goto <bb 14>;

  <bb 13>:
  iftmp.445_44 = 0.0;

  <bb 14>:
  # iftmp.445_4 = PHI <iftmp.445_43(12), iftmp.445_44(13)>
  ImVec2::ImVec2 (&window_pos_pivot, iftmp.445_4, iftmp.443_3);
  ImGui::SetNextWindowPos (&window_pos, 1, &window_pos_pivot);
  ImGui::SetNextWindowBgAlpha (3.00000011920928955078125e-1);
  _50 = ImGui::Begin ("Example: Fixed Overlay", p_open_48(D), 790855);
  retval.447_51 = _50;
  if (retval.447_51 != 0)
    goto <bb 15>;
  else
    goto <bb 32>;

  <bb 15>:
  ImGui::Text ("Simple overlay\nin the corner of the screen.\n(right-click to change position)");
  ImGui::Separator ();
  _55 = ImGui::GetIO ();
  _56 = _55;
  _57 = _56->MousePos.y;
  _58 = (double) _57;
  _60 = ImGui::GetIO ();
  _61 = _60;
  _62 = _61->MousePos.x;
  _63 = (double) _62;
  ImGui::Text ("Mouse Position: (%.1f,%.1f)", _63, _58);
  _66 = ImGui::BeginPopupContextWindow (0B, 1, 1);
  retval.448_67 = _66;
  if (retval.448_67 != 0)
    goto <bb 16>;
  else
    goto <bb 31>;

  <bb 16>:
  corner.450_68 = corner;
  _69 = corner.450_68 == 0;
  _70 = (int) _69;
  _72 = ImGui::MenuItem ("Top-left", 0B, _70, 1);
  retval.449_73 = _72;
  if (retval.449_73 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  corner = 0;

  <bb 18>:
  corner.452_75 = corner;
  _76 = corner.452_75 == 1;
  _77 = (int) _76;
  _79 = ImGui::MenuItem ("Top-right", 0B, _77, 1);
  retval.451_80 = _79;
  if (retval.451_80 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  corner = 1;

  <bb 20>:
  corner.454_82 = corner;
  _83 = corner.454_82 == 2;
  _84 = (int) _83;
  _86 = ImGui::MenuItem ("Bottom-left", 0B, _84, 1);
  retval.453_87 = _86;
  if (retval.453_87 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  corner = 2;

  <bb 22>:
  corner.456_89 = corner;
  _90 = corner.456_89 == 3;
  _91 = (int) _90;
  _93 = ImGui::MenuItem ("Bottom-right", 0B, _91, 1);
  retval.455_94 = _93;
  if (retval.455_94 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  corner = 3;

  <bb 24>:
  if (p_open_48(D) != 0B)
    goto <bb 25>;
  else
    goto <bb 27>;

  <bb 25>:
  _97 = ImGui::MenuItem ("Close", 0B, 0, 1);
  _98 = _97;
  if (_98 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  iftmp.458_99 = 1;
  goto <bb 28>;

  <bb 27>:
  iftmp.458_100 = 0;

  <bb 28>:
  # iftmp.458_5 = PHI <iftmp.458_99(26), iftmp.458_100(27)>
  retval.457_101 = iftmp.458_5;
  if (retval.457_101 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  *p_open_48(D) = 0;

  <bb 30>:
  ImGui::EndPopup ();

  <bb 31>:
  ImGui::End ();

  <bb 32>:
  window_pos ={v} {CLOBBER};
  window_pos_pivot ={v} {CLOBBER};
  return;

}



;; Function void ShowExampleAppWindowTitles(bool*) (_ZL26ShowExampleAppWindowTitlesPb, funcdef_no=424, decl_uid=11351, cgraph_uid=323, symbol_order=489)

void ShowExampleAppWindowTitles(bool*) (bool * D.12212)
{
  float D.16277;
  int D.16276;
  char buf[128];
  struct ImVec2 D.12220;
  struct ImVec2 D.12221;
  int D.16271;
  char D.16270;
  int D.16269;
  int D.16268;
  float D.16267;
  float D.16266;
  int D.16265;
  struct ImVec2 D.12217;
  struct ImVec2 D.12218;
  struct ImVec2 D.12215;
  struct ImVec2 D.12216;
  int _20;
  int _21;
  float _23;
  float _24;
  float _25;
  int _26;
  int _27;
  char _28;
  int _29;

  <bb 2>:
  ImVec2::ImVec2 (&D.12216, 0.0, 0.0);
  ImVec2::ImVec2 (&D.12215, 1.0e+2, 1.0e+2);
  ImGui::SetNextWindowPos (&D.12215, 4, &D.12216);
  D.12215 ={v} {CLOBBER};
  D.12216 ={v} {CLOBBER};
  ImGui::Begin ("Same title as another window##1", 0B, 0);
  ImGui::Text ("This is window 1.\nMy title is the same as window 2, but my identifier is unique.");
  ImGui::End ();
  ImVec2::ImVec2 (&D.12218, 0.0, 0.0);
  ImVec2::ImVec2 (&D.12217, 1.0e+2, 2.0e+2);
  ImGui::SetNextWindowPos (&D.12217, 4, &D.12218);
  D.12217 ={v} {CLOBBER};
  D.12218 ={v} {CLOBBER};
  ImGui::Begin ("Same title as another window##2", 0B, 0);
  ImGui::Text ("This is window 2.\nMy title is the same as window 1, but my identifier is unique.");
  ImGui::End ();
  _20 = ImGui::GetFrameCount ();
  _21 = _20;
  _23 = ImGui::GetTime ();
  _24 = _23;
  _25 = _24 / 2.5e-1;
  _26 = (int) _25;
  _27 = _26 & 3;
  _28 = "|/-\\"[_27];
  _29 = (int) _28;
  sprintf (&buf, "Animated title %c %d###AnimatedTitle", _29, _21);
  ImVec2::ImVec2 (&D.12221, 0.0, 0.0);
  ImVec2::ImVec2 (&D.12220, 1.0e+2, 3.0e+2);
  ImGui::SetNextWindowPos (&D.12220, 4, &D.12221);
  D.12220 ={v} {CLOBBER};
  D.12221 ={v} {CLOBBER};
  ImGui::Begin (&buf, 0B, 0);
  ImGui::Text ("This window has a changing title.");
  ImGui::End ();
  buf ={v} {CLOBBER};
  return;

}



;; Function void ShowExampleAppCustomRendering(bool*) (_ZL29ShowExampleAppCustomRenderingPb, funcdef_no=425, decl_uid=11353, cgraph_uid=324, symbol_order=496)

void ShowExampleAppCustomRendering(bool*) (bool * p_open)
{
  bool D.16605;
  bool D.16604;
  bool D.16603;
  bool D.16602;
  struct ImGuiIO & D.16601;
  struct ImGuiIO & D.16600;
  bool D.16596;
  bool D.16594;
  const ImU32 D.16558;
  struct ImDrawList * D.16557;
  bool D.16556;
  int i;
  struct ImVec2 mouse_pos_in_canvas;
  bool adding_preview;
  struct ImVec2 canvas_size;
  struct ImVec2 canvas_pos;
  static bool adding_line = 0;
  static struct ImVector points;
  float thickness;
  int n;
  float spacing;
  float y;
  float x;
  const ImU32 col32;
  const struct ImVec2 p;
  static struct ImVec4 col;
  static float sz = 3.6e+1;
  struct ImDrawList * draw_list;
  float D.16550;
  float D.16549;
  struct value_type & D.16548;
  float D.16547;
  float D.16546;
  float D.16545;
  struct value_type & D.16544;
  float D.16543;
  struct ImVec2 D.12292;
  float D.16542;
  float D.16541;
  struct value_type & D.16540;
  int D.16539;
  float D.16538;
  float D.16537;
  float D.16536;
  struct value_type & D.16535;
  int D.16534;
  float D.16533;
  struct ImVec2 D.12293;
  int D.16531;
  int D.16530;
  float D.16528;
  float D.16527;
  float D.16526;
  float D.16525;
  float D.16524;
  float D.16523;
  struct ImVec2 D.12289;
  bool D.16517;
  bool D.16516;
  bool D.16514;
  bool iftmp.529;
  bool retval.528;
  bool D.16505;
  bool D.16503;
  bool adding_line.527;
  bool iftmp.526;
  bool retval.525;
  bool retval.524;
  bool D.16490;
  bool retval.523;
  bool adding_line.522;
  float D.16485;
  float D.16484;
  float D.16483;
  struct ImGuiIO & D.16482;
  float D.16481;
  float D.16480;
  float D.16479;
  struct ImGuiIO & D.16478;
  float D.16477;
  float D.16476;
  float D.16475;
  float D.16474;
  float D.16473;
  float D.16472;
  struct ImVec2 D.12285;
  float D.16471;
  float D.16470;
  float D.16469;
  float D.16468;
  float D.16467;
  float D.16466;
  struct ImVec2 D.12284;
  float D.16462;
  float D.16458;
  struct ImVec2 D.12279;
  bool retval.521;
  int D.16450;
  struct ImVec2 D.12278;
  bool retval.520;
  bool D.12276;
  int D.16438;
  bool retval.519;
  unsigned char D.16434;
  bool retval.518;
  float D.16432;
  float D.16431;
  float sz.517;
  float D.16429;
  float D.16428;
  float sz.516;
  struct ImVec2 D.12273;
  struct ImVec2 D.12271;
  float D.16426;
  float sz.515;
  float D.16424;
  float sz.514;
  struct ImVec2 D.12272;
  float D.16422;
  float sz.513;
  float D.16420;
  float D.16419;
  float sz.512;
  struct ImVec2 D.12268;
  float D.16417;
  float sz.511;
  float D.16415;
  float D.16414;
  float sz.510;
  struct ImVec2 D.12269;
  float D.16412;
  float D.16411;
  float sz.509;
  struct ImVec2 D.12270;
  float D.16409;
  float sz.508;
  struct ImVec2 D.12266;
  float D.16407;
  float sz.507;
  float D.16405;
  float sz.506;
  struct ImVec2 D.12267;
  float D.16403;
  float sz.505;
  struct ImVec2 D.12264;
  float D.16401;
  float sz.504;
  float D.16399;
  float sz.503;
  struct ImVec2 D.12265;
  float D.16397;
  float sz.502;
  struct ImVec2 D.12262;
  float D.16395;
  float sz.501;
  float D.16393;
  float sz.500;
  struct ImVec2 D.12263;
  float D.16391;
  float sz.499;
  float D.16389;
  float D.16388;
  float sz.498;
  float D.16386;
  float D.16385;
  float sz.497;
  struct ImVec2 D.12261;
  float D.16383;
  float sz.496;
  float D.16381;
  float sz.495;
  float D.16379;
  struct ImVec2 D.12257;
  float D.16378;
  float D.16377;
  float sz.494;
  float D.16375;
  float D.16374;
  float sz.493;
  struct ImVec2 D.12258;
  float D.16372;
  float D.16371;
  float sz.492;
  float D.16369;
  float sz.491;
  float D.16367;
  float D.16366;
  float sz.490;
  float D.16364;
  float sz.489;
  struct ImVec2 D.12259;
  float D.16362;
  float sz.488;
  float D.16360;
  float sz.487;
  struct ImVec2 D.12260;
  struct ImVec2 D.12255;
  float D.16358;
  float sz.486;
  struct ImVec2 D.12256;
  float D.16356;
  float sz.485;
  struct ImVec2 D.12253;
  float D.16354;
  float sz.484;
  float D.16352;
  float sz.483;
  struct ImVec2 D.12254;
  float D.16350;
  float sz.482;
  struct ImVec2 D.12251;
  float D.16348;
  float sz.481;
  struct ImVec2 D.12252;
  float D.16346;
  float sz.480;
  float D.16344;
  float D.16343;
  float sz.479;
  struct ImVec2 D.12248;
  float D.16341;
  float sz.478;
  float D.16339;
  float D.16338;
  float sz.477;
  struct ImVec2 D.12249;
  float D.16336;
  float D.16335;
  float sz.476;
  struct ImVec2 D.12250;
  float D.16333;
  float sz.475;
  struct ImVec2 D.12246;
  float D.16331;
  float sz.474;
  float D.16329;
  float sz.473;
  struct ImVec2 D.12247;
  float D.16327;
  float sz.472;
  struct ImVec2 D.12244;
  float D.16325;
  float sz.471;
  float D.16323;
  float sz.470;
  struct ImVec2 D.12245;
  float D.16321;
  float sz.469;
  struct ImVec2 D.12242;
  float D.16319;
  float sz.468;
  float D.16317;
  float sz.467;
  struct ImVec2 D.12243;
  float D.16315;
  float sz.466;
  float D.16313;
  float D.16312;
  float sz.465;
  float D.16310;
  float D.16309;
  float sz.464;
  struct ImVec2 D.12241;
  float D.16307;
  float sz.463;
  float iftmp.462;
  float D.16299;
  float D.16298;
  struct ImColor D.12235;
  bool D.12231;
  int D.16290;
  bool retval.461;
  unsigned char D.16286;
  bool retval.460;
  bool D.16282;
  bool retval.459;
  struct ImVec2 D.12225;
  float iftmp.462_7;
  bool iftmp.526_8;
  bool iftmp.529_9;
  bool _35;
  bool _36;
  bool retval.459_37;
  struct ImDrawList * _40;
  unsigned char _44;
  bool retval.460_45;
  int _47;
  bool retval.461_48;
  bool _49;
  bool _51;
  const ImU32 _58;
  float _61;
  float _63;
  float iftmp.462_67;
  float iftmp.462_68;
  float sz.463_70;
  float _71;
  float sz.464_72;
  float _73;
  float _74;
  float sz.465_75;
  float _76;
  float _77;
  float sz.466_81;
  float _82;
  float sz.467_84;
  float _85;
  float sz.468_86;
  float _87;
  float sz.469_93;
  float _94;
  float sz.470_96;
  float _97;
  float sz.471_98;
  float _99;
  float sz.472_105;
  float _106;
  float sz.473_108;
  float _109;
  float sz.474_110;
  float _111;
  float sz.475_117;
  float _118;
  float sz.476_120;
  float _121;
  float _122;
  float sz.477_124;
  float _125;
  float _126;
  float sz.478_127;
  float _128;
  float sz.479_130;
  float _131;
  float _132;
  float sz.480_138;
  float _139;
  float sz.481_141;
  float _142;
  float sz.482_148;
  float _149;
  float sz.483_151;
  float _152;
  float sz.484_153;
  float _154;
  float sz.485_160;
  float _161;
  float sz.486_163;
  float _164;
  float sz.487_171;
  float _172;
  float sz.488_173;
  float _174;
  float sz.489_176;
  float _177;
  float sz.490_178;
  float _179;
  float _180;
  float sz.491_181;
  float _182;
  float sz.492_183;
  float _184;
  float _185;
  float sz.493_187;
  float _188;
  float _189;
  float sz.494_190;
  float _191;
  float _192;
  float _200;
  float sz.495_202;
  float _203;
  float sz.496_226;
  float _227;
  float sz.497_228;
  float _229;
  float _230;
  float sz.498_231;
  float _232;
  float _233;
  float sz.499_237;
  float _238;
  float sz.500_240;
  float _241;
  float sz.501_242;
  float _243;
  float sz.502_249;
  float _250;
  float sz.503_252;
  float _253;
  float sz.504_254;
  float _255;
  float sz.505_261;
  float _262;
  float sz.506_264;
  float _265;
  float sz.507_266;
  float _267;
  float sz.508_273;
  float _274;
  float sz.509_276;
  float _277;
  float _278;
  float sz.510_280;
  float _281;
  float _282;
  float sz.511_283;
  float _284;
  float sz.512_286;
  float _287;
  float _288;
  float sz.513_294;
  float _295;
  float sz.514_297;
  float _298;
  float sz.515_299;
  float _300;
  float sz.516_306;
  float _307;
  float _308;
  float sz.517_309;
  float _310;
  float _311;
  unsigned char _318;
  bool retval.518_319;
  int _321;
  bool retval.519_322;
  bool _323;
  bool _325;
  bool _331;
  bool retval.520_332;
  int _335;
  bool _339;
  bool retval.521_340;
  float _348;
  float _350;
  float _352;
  float _353;
  float _354;
  float _355;
  float _356;
  float _357;
  float _361;
  float _362;
  float _363;
  float _364;
  float _365;
  float _366;
  struct ImGuiIO & _373;
  struct ImGuiIO & _374;
  float _375;
  float _376;
  float _377;
  struct ImGuiIO & _379;
  struct ImGuiIO & _380;
  float _381;
  float _382;
  float _383;
  bool adding_line.522_385;
  bool _389;
  bool _390;
  bool retval.523_391;
  bool _395;
  bool retval.524_396;
  bool adding_line.527_397;
  bool _398;
  bool _400;
  bool _401;
  bool iftmp.526_402;
  bool iftmp.526_403;
  bool retval.525_404;
  bool _408;
  bool _409;
  bool _411;
  bool _412;
  bool iftmp.529_413;
  bool iftmp.529_414;
  bool retval.528_415;
  float _420;
  float _421;
  float _422;
  float _423;
  float _424;
  float _425;
  int _430;
  int _431;
  float _432;
  int _433;
  struct value_type & _435;
  float _436;
  float _437;
  float _438;
  int _439;
  struct value_type & _441;
  float _442;
  float _443;
  float _445;
  struct value_type & _447;
  float _448;
  float _449;
  float _450;
  struct value_type & _452;
  float _453;
  float _454;

  <bb 2>:
  ImVec2::ImVec2 (&D.12225, 3.5e+2, 5.6e+2);
  ImGui::SetNextWindowSize (&D.12225, 4);
  D.12225 ={v} {CLOBBER};
  _35 = ImGui::Begin ("Example: Custom rendering", p_open_33(D), 0);
  _36 = _35;
  retval.459_37 = ~_36;
  if (retval.459_37 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::End ();
  goto <bb 47> (<L64>);

  <bb 4>:
  _40 = ImGui::GetWindowDrawList ();
  draw_list_41 = _40;
  ImGui::Text ("Primitives");
  _44 = __atomic_load_1 (&_ZGVZL29ShowExampleAppCustomRenderingPbE3col, 2);
  retval.460_45 = _44 == 0;
  if (retval.460_45 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _47 = __cxa_guard_acquire (&_ZGVZL29ShowExampleAppCustomRenderingPbE3col);
  retval.461_48 = _47 != 0;
  if (retval.461_48 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _49 = 0;
  ImVec4::ImVec4 (&col, 1.0e+0, 1.0e+0, 4.000000059604644775390625e-1, 1.0e+0);
  _51 = 1;
  __cxa_guard_release (&_ZGVZL29ShowExampleAppCustomRenderingPbE3col);

  <bb 7>:
  ImGui::DragFloat ("Size", &sz, 2.0000000298023223876953125e-1, 2.0e+0, 7.2e+1, "%.0f", 1.0e+0);
  ImGui::ColorEdit3 ("Color", &col.x, 0);
  p = ImGui::GetCursorScreenPos ();
  ImColor::ImColor (&D.12235, &col);
  _58 = ImColor::operator ImU32 (&D.12235);
  col32_59 = _58;
  D.12235 ={v} {CLOBBER};
  _61 = p.x;
  x_62 = _61 + 4.0e+0;
  _63 = p.y;
  y_64 = _63 + 4.0e+0;
  spacing_65 = 8.0e+0;
  n_66 = 0;

  <bb 8>:
  # x_1 = PHI <x_62(7), x_201(12)>
  # y_2 = PHI <y_64(7), y_204(12)>
  # n_3 = PHI <n_66(7), n_205(12)>
  if (n_3 > 1)
    goto <bb 13>;
  else
    goto <bb 9>;

  <bb 9>:
  if (n_3 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.462_67 = 1.0e+0;
  goto <bb 12>;

  <bb 11>:
  iftmp.462_68 = 4.0e+0;

  <bb 12>:
  # iftmp.462_7 = PHI <iftmp.462_67(10), iftmp.462_68(11)>
  thickness_69 = iftmp.462_7;
  sz.463_70 = sz;
  _71 = sz.463_70 * 5.0e-1;
  sz.464_72 = sz;
  _73 = sz.464_72 * 5.0e-1;
  _74 = _73 + y_2;
  sz.465_75 = sz;
  _76 = sz.465_75 * 5.0e-1;
  _77 = _76 + x_1;
  ImVec2::ImVec2 (&D.12241, _77, _74);
  ImDrawList::AddCircle (draw_list_41, &D.12241, _71, col32_59, 20, thickness_69);
  D.12241 ={v} {CLOBBER};
  sz.466_81 = sz;
  _82 = sz.466_81 + spacing_65;
  x_83 = _82 + x_1;
  sz.467_84 = sz;
  _85 = y_2 + sz.467_84;
  sz.468_86 = sz;
  _87 = x_83 + sz.468_86;
  ImVec2::ImVec2 (&D.12243, _87, _85);
  ImVec2::ImVec2 (&D.12242, x_83, y_2);
  ImDrawList::AddRect (draw_list_41, &D.12242, &D.12243, col32_59, 0.0, 15, thickness_69);
  D.12242 ={v} {CLOBBER};
  D.12243 ={v} {CLOBBER};
  sz.469_93 = sz;
  _94 = sz.469_93 + spacing_65;
  x_95 = _94 + x_83;
  sz.470_96 = sz;
  _97 = y_2 + sz.470_96;
  sz.471_98 = sz;
  _99 = x_95 + sz.471_98;
  ImVec2::ImVec2 (&D.12245, _99, _97);
  ImVec2::ImVec2 (&D.12244, x_95, y_2);
  ImDrawList::AddRect (draw_list_41, &D.12244, &D.12245, col32_59, 1.0e+1, 15, thickness_69);
  D.12244 ={v} {CLOBBER};
  D.12245 ={v} {CLOBBER};
  sz.472_105 = sz;
  _106 = sz.472_105 + spacing_65;
  x_107 = _106 + x_95;
  sz.473_108 = sz;
  _109 = y_2 + sz.473_108;
  sz.474_110 = sz;
  _111 = x_107 + sz.474_110;
  ImVec2::ImVec2 (&D.12247, _111, _109);
  ImVec2::ImVec2 (&D.12246, x_107, y_2);
  ImDrawList::AddRect (draw_list_41, &D.12246, &D.12247, col32_59, 1.0e+1, 9, thickness_69);
  D.12246 ={v} {CLOBBER};
  D.12247 ={v} {CLOBBER};
  sz.475_117 = sz;
  _118 = sz.475_117 + spacing_65;
  x_119 = _118 + x_107;
  sz.476_120 = sz;
  _121 = y_2 + sz.476_120;
  _122 = _121 - 5.0e-1;
  ImVec2::ImVec2 (&D.12250, x_119, _122);
  sz.477_124 = sz;
  _125 = y_2 + sz.477_124;
  _126 = _125 - 5.0e-1;
  sz.478_127 = sz;
  _128 = x_119 + sz.478_127;
  ImVec2::ImVec2 (&D.12249, _128, _126);
  sz.479_130 = sz;
  _131 = sz.479_130 * 5.0e-1;
  _132 = _131 + x_119;
  ImVec2::ImVec2 (&D.12248, _132, y_2);
  ImDrawList::AddTriangle (draw_list_41, &D.12248, &D.12249, &D.12250, col32_59, thickness_69);
  D.12248 ={v} {CLOBBER};
  D.12249 ={v} {CLOBBER};
  D.12250 ={v} {CLOBBER};
  sz.480_138 = sz;
  _139 = sz.480_138 + spacing_65;
  x_140 = _139 + x_119;
  sz.481_141 = sz;
  _142 = x_140 + sz.481_141;
  ImVec2::ImVec2 (&D.12252, _142, y_2);
  ImVec2::ImVec2 (&D.12251, x_140, y_2);
  ImDrawList::AddLine (draw_list_41, &D.12251, &D.12252, col32_59, thickness_69);
  D.12251 ={v} {CLOBBER};
  D.12252 ={v} {CLOBBER};
  sz.482_148 = sz;
  _149 = sz.482_148 + spacing_65;
  x_150 = _149 + x_140;
  sz.483_151 = sz;
  _152 = y_2 + sz.483_151;
  sz.484_153 = sz;
  _154 = x_150 + sz.484_153;
  ImVec2::ImVec2 (&D.12254, _154, _152);
  ImVec2::ImVec2 (&D.12253, x_150, y_2);
  ImDrawList::AddLine (draw_list_41, &D.12253, &D.12254, col32_59, thickness_69);
  D.12253 ={v} {CLOBBER};
  D.12254 ={v} {CLOBBER};
  sz.485_160 = sz;
  _161 = sz.485_160 + spacing_65;
  x_162 = _161 + x_150;
  sz.486_163 = sz;
  _164 = y_2 + sz.486_163;
  ImVec2::ImVec2 (&D.12256, x_162, _164);
  ImVec2::ImVec2 (&D.12255, x_162, y_2);
  ImDrawList::AddLine (draw_list_41, &D.12255, &D.12256, col32_59, thickness_69);
  D.12255 ={v} {CLOBBER};
  D.12256 ={v} {CLOBBER};
  x_170 = x_162 + spacing_65;
  sz.487_171 = sz;
  _172 = y_2 + sz.487_171;
  sz.488_173 = sz;
  _174 = x_170 + sz.488_173;
  ImVec2::ImVec2 (&D.12260, _174, _172);
  sz.489_176 = sz;
  _177 = y_2 + sz.489_176;
  sz.490_178 = sz;
  _179 = sz.490_178 * 3.00000011920928955078125e-1;
  _180 = _177 - _179;
  sz.491_181 = sz;
  _182 = x_170 + sz.491_181;
  sz.492_183 = sz;
  _184 = sz.492_183 * 1.2999999523162841796875e+0;
  _185 = _182 - _184;
  ImVec2::ImVec2 (&D.12259, _185, _180);
  sz.493_187 = sz;
  _188 = sz.493_187 * 3.00000011920928955078125e-1;
  _189 = _188 + y_2;
  sz.494_190 = sz;
  _191 = sz.494_190 * 1.2999999523162841796875e+0;
  _192 = _191 + x_170;
  ImVec2::ImVec2 (&D.12258, _192, _189);
  ImVec2::ImVec2 (&D.12257, x_170, y_2);
  ImDrawList::AddBezierCurve (draw_list_41, &D.12257, &D.12258, &D.12259, &D.12260, col32_59, thickness_69, 0);
  D.12257 ={v} {CLOBBER};
  D.12258 ={v} {CLOBBER};
  D.12259 ={v} {CLOBBER};
  D.12260 ={v} {CLOBBER};
  _200 = p.x;
  x_201 = _200 + 4.0e+0;
  sz.495_202 = sz;
  _203 = sz.495_202 + spacing_65;
  y_204 = _203 + y_2;
  n_205 = n_3 + 1;
  goto <bb 8>;

  <bb 13>:
  sz.496_226 = sz;
  _227 = sz.496_226 * 5.0e-1;
  sz.497_228 = sz;
  _229 = sz.497_228 * 5.0e-1;
  _230 = _229 + y_2;
  sz.498_231 = sz;
  _232 = sz.498_231 * 5.0e-1;
  _233 = _232 + x_1;
  ImVec2::ImVec2 (&D.12261, _233, _230);
  ImDrawList::AddCircleFilled (draw_list_41, &D.12261, _227, col32_59, 32);
  D.12261 ={v} {CLOBBER};
  sz.499_237 = sz;
  _238 = sz.499_237 + spacing_65;
  x_239 = _238 + x_1;
  sz.500_240 = sz;
  _241 = y_2 + sz.500_240;
  sz.501_242 = sz;
  _243 = x_239 + sz.501_242;
  ImVec2::ImVec2 (&D.12263, _243, _241);
  ImVec2::ImVec2 (&D.12262, x_239, y_2);
  ImDrawList::AddRectFilled (draw_list_41, &D.12262, &D.12263, col32_59, 0.0, 15);
  D.12262 ={v} {CLOBBER};
  D.12263 ={v} {CLOBBER};
  sz.502_249 = sz;
  _250 = sz.502_249 + spacing_65;
  x_251 = _250 + x_239;
  sz.503_252 = sz;
  _253 = y_2 + sz.503_252;
  sz.504_254 = sz;
  _255 = x_251 + sz.504_254;
  ImVec2::ImVec2 (&D.12265, _255, _253);
  ImVec2::ImVec2 (&D.12264, x_251, y_2);
  ImDrawList::AddRectFilled (draw_list_41, &D.12264, &D.12265, col32_59, 1.0e+1, 15);
  D.12264 ={v} {CLOBBER};
  D.12265 ={v} {CLOBBER};
  sz.505_261 = sz;
  _262 = sz.505_261 + spacing_65;
  x_263 = _262 + x_251;
  sz.506_264 = sz;
  _265 = y_2 + sz.506_264;
  sz.507_266 = sz;
  _267 = x_263 + sz.507_266;
  ImVec2::ImVec2 (&D.12267, _267, _265);
  ImVec2::ImVec2 (&D.12266, x_263, y_2);
  ImDrawList::AddRectFilled (draw_list_41, &D.12266, &D.12267, col32_59, 1.0e+1, 9);
  D.12266 ={v} {CLOBBER};
  D.12267 ={v} {CLOBBER};
  sz.508_273 = sz;
  _274 = sz.508_273 + spacing_65;
  x_275 = _274 + x_263;
  sz.509_276 = sz;
  _277 = y_2 + sz.509_276;
  _278 = _277 - 5.0e-1;
  ImVec2::ImVec2 (&D.12270, x_275, _278);
  sz.510_280 = sz;
  _281 = y_2 + sz.510_280;
  _282 = _281 - 5.0e-1;
  sz.511_283 = sz;
  _284 = x_275 + sz.511_283;
  ImVec2::ImVec2 (&D.12269, _284, _282);
  sz.512_286 = sz;
  _287 = sz.512_286 * 5.0e-1;
  _288 = _287 + x_275;
  ImVec2::ImVec2 (&D.12268, _288, y_2);
  ImDrawList::AddTriangleFilled (draw_list_41, &D.12268, &D.12269, &D.12270, col32_59);
  D.12268 ={v} {CLOBBER};
  D.12269 ={v} {CLOBBER};
  D.12270 ={v} {CLOBBER};
  sz.513_294 = sz;
  _295 = sz.513_294 + spacing_65;
  x_296 = _295 + x_275;
  sz.514_297 = sz;
  _298 = y_2 + sz.514_297;
  sz.515_299 = sz;
  _300 = x_296 + sz.515_299;
  ImVec2::ImVec2 (&D.12272, _300, _298);
  ImVec2::ImVec2 (&D.12271, x_296, y_2);
  ImDrawList::AddRectFilledMultiColor (draw_list_41, &D.12271, &D.12272, 4278190080, 4278190335, 4278255615, 4278255360);
  D.12271 ={v} {CLOBBER};
  D.12272 ={v} {CLOBBER};
  sz.516_306 = sz;
  _307 = sz.516_306 + spacing_65;
  _308 = _307 * 3.0e+0;
  sz.517_309 = sz;
  _310 = sz.517_309 + spacing_65;
  _311 = _310 * 8.0e+0;
  ImVec2::ImVec2 (&D.12273, _311, _308);
  ImGui::Dummy (&D.12273);
  D.12273 ={v} {CLOBBER};
  p ={v} {CLOBBER};
  ImGui::Separator ();
  _318 = __atomic_load_1 (&_ZGVZL29ShowExampleAppCustomRenderingPbE6points, 2);
  retval.518_319 = _318 == 0;
  if (retval.518_319 != 0)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  _321 = __cxa_guard_acquire (&_ZGVZL29ShowExampleAppCustomRenderingPbE6points);
  retval.519_322 = _321 != 0;
  if (retval.519_322 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _323 = 0;
  ImVector<ImVec2>::ImVector (&points);
  _325 = 1;
  __cxa_guard_release (&_ZGVZL29ShowExampleAppCustomRenderingPbE6points);
  __cxa_atexit (__comp_dtor , &points, &__dso_handle);

  <bb 16>:
  ImGui::Text ("Canvas example");
  ImVec2::ImVec2 (&D.12278, 0.0, 0.0);
  _331 = ImGui::Button ("Clear", &D.12278);
  retval.520_332 = _331;
  D.12278 ={v} {CLOBBER};
  if (retval.520_332 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  ImVector<ImVec2>::clear (&points);

  <bb 18>:
  _335 = points.Size;
  if (_335 > 1)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12279, 0.0, 0.0);
  _339 = ImGui::Button ("Undo", &D.12279);
  retval.521_340 = _339;
  D.12279 ={v} {CLOBBER};
  if (retval.521_340 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  ImVector<ImVec2>::pop_back (&points);
  ImVector<ImVec2>::pop_back (&points);

  <bb 21>:
  ImGui::Text ("Left-click and drag to add lines,\nRight-click to undo");
  canvas_pos = ImGui::GetCursorScreenPos ();
  canvas_size = ImGui::GetContentRegionAvail ();
  _348 = canvas_size.x;
  if (_348 < 5.0e+1)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  canvas_size.x = 5.0e+1;

  <bb 23>:
  _350 = canvas_size.y;
  if (_350 < 5.0e+1)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  canvas_size.y = 5.0e+1;

  <bb 25>:
  _352 = canvas_pos.y;
  _353 = canvas_size.y;
  _354 = _352 + _353;
  _355 = canvas_pos.x;
  _356 = canvas_size.x;
  _357 = _355 + _356;
  ImVec2::ImVec2 (&D.12284, _357, _354);
  ImDrawList::AddRectFilledMultiColor (draw_list_41, &canvas_pos, &D.12284, 4281479730, 4282135090, 4282793020, 4282135090);
  D.12284 ={v} {CLOBBER};
  _361 = canvas_pos.y;
  _362 = canvas_size.y;
  _363 = _361 + _362;
  _364 = canvas_pos.x;
  _365 = canvas_size.x;
  _366 = _364 + _365;
  ImVec2::ImVec2 (&D.12285, _366, _363);
  ImDrawList::AddRect (draw_list_41, &canvas_pos, &D.12285, 4294967295, 0.0, 15, 1.0e+0);
  D.12285 ={v} {CLOBBER};
  adding_preview_370 = 0;
  ImGui::InvisibleButton ("canvas", &canvas_size);
  _373 = ImGui::GetIO ();
  _374 = _373;
  _375 = _374->MousePos.y;
  _376 = canvas_pos.y;
  _377 = _375 - _376;
  _379 = ImGui::GetIO ();
  _380 = _379;
  _381 = _380->MousePos.x;
  _382 = canvas_pos.x;
  _383 = _381 - _382;
  ImVec2::ImVec2 (&mouse_pos_in_canvas, _383, _377);
  adding_line.522_385 = adding_line;
  if (adding_line.522_385 != 0)
    goto <bb 26>;
  else
    goto <bb 28>;

  <bb 26>:
  adding_preview_386 = 1;
  ImVector<ImVec2>::push_back (&points, &mouse_pos_in_canvas);
  _389 = ImGui::IsMouseDown (0);
  _390 = _389;
  retval.523_391 = ~_390;
  if (retval.523_391 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  adding_preview_392 = 0;
  adding_line = adding_preview_392;

  <bb 28>:
  # adding_preview_4 = PHI <adding_preview_370(25), adding_preview_392(27), adding_preview_386(26)>
  _395 = ImGui::IsItemHovered (0);
  retval.524_396 = _395;
  if (retval.524_396 != 0)
    goto <bb 29>;
  else
    goto <bb 41>;

  <bb 29>:
  adding_line.527_397 = adding_line;
  _398 = ~adding_line.527_397;
  if (_398 != 0)
    goto <bb 30>;
  else
    goto <bb 32>;

  <bb 30>:
  _400 = ImGui::IsMouseClicked (0, 0);
  _401 = _400;
  if (_401 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  iftmp.526_402 = 1;
  goto <bb 33>;

  <bb 32>:
  iftmp.526_403 = 0;

  <bb 33>:
  # iftmp.526_8 = PHI <iftmp.526_402(31), iftmp.526_403(32)>
  retval.525_404 = iftmp.526_8;
  if (retval.525_404 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  ImVector<ImVec2>::push_back (&points, &mouse_pos_in_canvas);
  adding_line = 1;

  <bb 35>:
  _408 = ImGui::IsMouseClicked (1, 0);
  _409 = _408;
  if (_409 != 0)
    goto <bb 36>;
  else
    goto <bb 38>;

  <bb 36>:
  _411 = ImVector<ImVec2>::empty (&points);
  _412 = ~_411;
  if (_412 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  iftmp.529_413 = 1;
  goto <bb 39>;

  <bb 38>:
  iftmp.529_414 = 0;

  <bb 39>:
  # iftmp.529_9 = PHI <iftmp.529_413(37), iftmp.529_414(38)>
  retval.528_415 = iftmp.529_9;
  if (retval.528_415 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  adding_preview_416 = 0;
  adding_line = adding_preview_416;
  ImVector<ImVec2>::pop_back (&points);
  ImVector<ImVec2>::pop_back (&points);

  <bb 41>:
  # adding_preview_5 = PHI <adding_preview_4(28), adding_preview_416(40), adding_preview_4(39)>
  _420 = canvas_pos.y;
  _421 = canvas_size.y;
  _422 = _420 + _421;
  _423 = canvas_pos.x;
  _424 = canvas_size.x;
  _425 = _423 + _424;
  ImVec2::ImVec2 (&D.12289, _425, _422);
  ImDrawList::PushClipRect (draw_list_41, canvas_pos, D.12289, 1);
  D.12289 ={v} {CLOBBER};
  i_429 = 0;

  <bb 42>:
  # i_6 = PHI <i_429(41), i_459(43)>
  _430 = points.Size;
  _431 = _430 + -1;
  if (_431 <= i_6)
    goto <bb 44>;
  else
    goto <bb 43>;

  <bb 43>:
  _432 = canvas_pos.y;
  _433 = i_6 + 1;
  _435 = ImVector<ImVec2>::operator[] (&points, _433);
  _436 = _435->y;
  _437 = _432 + _436;
  _438 = canvas_pos.x;
  _439 = i_6 + 1;
  _441 = ImVector<ImVec2>::operator[] (&points, _439);
  _442 = _441->x;
  _443 = _438 + _442;
  ImVec2::ImVec2 (&D.12293, _443, _437);
  _445 = canvas_pos.y;
  _447 = ImVector<ImVec2>::operator[] (&points, i_6);
  _448 = _447->y;
  _449 = _445 + _448;
  _450 = canvas_pos.x;
  _452 = ImVector<ImVec2>::operator[] (&points, i_6);
  _453 = _452->x;
  _454 = _450 + _453;
  ImVec2::ImVec2 (&D.12292, _454, _449);
  ImDrawList::AddLine (draw_list_41, &D.12292, &D.12293, 4278255615, 2.0e+0);
  D.12292 ={v} {CLOBBER};
  D.12293 ={v} {CLOBBER};
  i_459 = i_6 + 2;
  goto <bb 42>;

  <bb 44>:
  ImDrawList::PopClipRect (draw_list_41);
  if (adding_preview_5 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  ImVector<ImVec2>::pop_back (&points);

  <bb 46>:
  canvas_pos ={v} {CLOBBER};
  canvas_size ={v} {CLOBBER};
  mouse_pos_in_canvas ={v} {CLOBBER};
  ImGui::End ();

<L64>:
  return;

}



;; Function ExampleAppConsole::ExampleAppConsole() (_ZN17ExampleAppConsoleC2Ev, funcdef_no=427, decl_uid=12543, cgraph_uid=326, symbol_order=498)

Merging blocks 9 and 10
Merging blocks 9 and 11
ExampleAppConsole::ExampleAppConsole() (struct ExampleAppConsole * const this)
{
  void * D.18653;
  struct ImVector * D.16756;
  struct ImVector * D.16755;
  struct ImVector * D.16754;
  struct ImVector * D.16753;
  const char * const D.12566;
  struct ImVector * D.16752;
  const char * const D.12565;
  struct ImVector * D.16751;
  const char * const D.12564;
  struct ImVector * D.16750;
  const char * const D.12563;
  char[256] * D.16749;
  struct ImVector * D.16748;
  struct ImVector * D.16747;
  struct ImVector * D.16746;
  struct ImVector * _5;
  struct ImVector * _7;
  struct ImVector * _9;
  char[256] * _12;
  struct ImVector * _16;
  struct ImVector * _20;
  struct ImVector * _24;
  struct ImVector * _28;
  struct ImVector * _36;
  struct ImVector * _38;
  struct ImVector * _40;

  <bb 2>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  _5 = &this_3(D)->Items;
  ImVector<char*>::ImVector (_5);
  _7 = &this_3(D)->History;
  ImVector<char*>::ImVector (_7);
  _9 = &this_3(D)->Commands;
  ImVector<const char*>::ImVector (_9);
  ExampleAppConsole::ClearLog (this_3(D));

  <bb 3>:
  _12 = &this_3(D)->InputBuf;
  memset (_12, 0, 256);
  this_3(D)->HistoryPos = -1;
  D.12563 = "HELP";
  _16 = &this_3(D)->Commands;
  ImVector<const char*>::push_back (_16, &D.12563);

  <bb 4>:
  D.12563 ={v} {CLOBBER};
  D.12564 = "HISTORY";
  _20 = &this_3(D)->Commands;
  ImVector<const char*>::push_back (_20, &D.12564);

  <bb 5>:
  D.12564 ={v} {CLOBBER};
  D.12565 = "CLEAR";
  _24 = &this_3(D)->Commands;
  ImVector<const char*>::push_back (_24, &D.12565);

  <bb 6>:
  D.12565 ={v} {CLOBBER};
  D.12566 = "CLASSIFY";
  _28 = &this_3(D)->Commands;
  ImVector<const char*>::push_back (_28, &D.12566);

  <bb 7>:
  D.12566 ={v} {CLOBBER};
  ExampleAppConsole::AddLog (this_3(D), "Welcome to ImGui!");

  <bb 8>:
  return;

<L4>:
  D.12566 ={v} {CLOBBER};
  D.12565 ={v} {CLOBBER};
  D.12564 ={v} {CLOBBER};
  D.12563 ={v} {CLOBBER};
  _36 = &this_3(D)->Commands;
  ImVector<const char*>::~ImVector (_36);
  __builtin_eh_copy_values (2, 3);
  _38 = &this_3(D)->History;
  ImVector<char*>::~ImVector (_38);
  __builtin_eh_copy_values (1, 2);
  _40 = &this_3(D)->Items;
  ImVector<char*>::~ImVector (_40);
  _42 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_42);

}



;; Function ExampleAppConsole::~ExampleAppConsole() (_ZN17ExampleAppConsoleD2Ev, funcdef_no=430, decl_uid=12548, cgraph_uid=329, symbol_order=501)

ExampleAppConsole::~ExampleAppConsole() (struct ExampleAppConsole * const this)
{
  int i;
  struct ImVector * D.16713;
  struct ImVector * D.16712;
  struct ImVector * D.16711;
  char * D.16710;
  char * & D.16709;
  struct ImVector * D.16708;
  int D.16706;
  int _7;
  struct ImVector * _8;
  char * & _10;
  char * _11;
  struct ImVector * _14;
  struct ImVector * _16;
  struct ImVector * _18;

  <bb 2>:
  ExampleAppConsole::ClearLog (this_4(D));
  i_6 = 0;

  <bb 3>:
  # i_1 = PHI <i_6(2), i_13(4)>
  _7 = this_4(D)->History.Size;
  if (_7 <= i_1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _8 = &this_4(D)->History;
  _10 = ImVector<char*>::operator[] (_8, i_1);
  _11 = *_10;
  free (_11);
  i_13 = i_1 + 1;
  goto <bb 3>;

  <bb 5>:
  _14 = &this_4(D)->Commands;
  ImVector<const char*>::~ImVector (_14);
  _16 = &this_4(D)->History;
  ImVector<char*>::~ImVector (_16);
  _18 = &this_4(D)->Items;
  ImVector<char*>::~ImVector (_18);
  MEM[(struct  &)this_4(D)] ={v} {CLOBBER};
  return;

}



;; Function static int ExampleAppConsole::Stricmp(const char*, const char*) (_ZN17ExampleAppConsole7StricmpEPKcS1_, funcdef_no=432, decl_uid=12517, cgraph_uid=331, symbol_order=503)

static int ExampleAppConsole::Stricmp(const char*, const char*) (const char * str1, const char * str2)
{
  int d;
  int D.17304;
  char D.17301;
  int D.17299;
  int D.17298;
  char D.17297;
  int D.17296;
  int D.17295;
  char D.17294;
  bool iftmp.580;
  bool retval.579;
  bool iftmp.580_3;
  char _7;
  int _8;
  int _9;
  char _10;
  int _11;
  int _12;
  char _14;
  bool iftmp.580_15;
  bool iftmp.580_16;
  bool retval.579_17;
  int _20;

  <bb 2>:
  # str1_1 = PHI <str1_4(D)(0), str1_18(7)>
  # str2_2 = PHI <str2_5(D)(0), str2_19(7)>
  _7 = *str2_2;
  _8 = (int) _7;
  _9 = toupper (_8);
  _10 = *str1_1;
  _11 = (int) _10;
  _12 = toupper (_11);
  d_13 = _9 - _12;
  if (d_13 == 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _14 = *str1_1;
  if (_14 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.580_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.580_16 = 0;

  <bb 6>:
  # iftmp.580_3 = PHI <iftmp.580_15(4), iftmp.580_16(5)>
  retval.579_17 = iftmp.580_3;
  if (retval.579_17 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  str1_18 = str1_1 + 1;
  str2_19 = str2_2 + 1;
  goto <bb 2>;

  <bb 8>:
  _20 = d_13;

<L7>:
  return _20;

}



;; Function static int ExampleAppConsole::Strnicmp(const char*, const char*, int) (_ZN17ExampleAppConsole8StrnicmpEPKcS1_i, funcdef_no=433, decl_uid=12521, cgraph_uid=332, symbol_order=504)

static int ExampleAppConsole::Strnicmp(const char*, const char*, int) (const char * str1, const char * str2, int n)
{
  int d;
  int D.17190;
  char D.17187;
  int D.17185;
  int D.17184;
  char D.17183;
  int D.17182;
  int D.17181;
  char D.17180;
  bool iftmp.569;
  bool retval.568;
  bool iftmp.569_7;
  char _13;
  int _14;
  int _15;
  char _16;
  int _17;
  int _18;
  char _20;
  bool iftmp.569_21;
  bool iftmp.569_22;
  bool retval.568_23;
  int _27;

  <bb 2>:
  d_8 = 0;

  <bb 3>:
  # str1_1 = PHI <str1_9(D)(2), str1_24(9)>
  # str2_2 = PHI <str2_10(D)(2), str2_25(9)>
  # n_3 = PHI <n_11(D)(2), n_26(9)>
  # d_4 = PHI <d_8(2), d_6(9)>
  if (n_3 > 0)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _13 = *str2_2;
  _14 = (int) _13;
  _15 = toupper (_14);
  _16 = *str1_1;
  _17 = (int) _16;
  _18 = toupper (_17);
  d_19 = _15 - _18;
  if (d_19 == 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _20 = *str1_1;
  if (_20 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.569_21 = 1;
  goto <bb 8>;

  <bb 7>:
  # d_5 = PHI <d_4(3), d_19(4), d_19(5)>
  iftmp.569_22 = 0;

  <bb 8>:
  # d_6 = PHI <d_19(6), d_5(7)>
  # iftmp.569_7 = PHI <iftmp.569_21(6), iftmp.569_22(7)>
  retval.568_23 = iftmp.569_7;
  if (retval.568_23 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  str1_24 = str1_1 + 1;
  str2_25 = str2_2 + 1;
  n_26 = n_3 + -1;
  goto <bb 3>;

  <bb 10>:
  _27 = d_6;

<L8>:
  return _27;

}



;; Function static char* ExampleAppConsole::Strdup(const char*) (_ZN17ExampleAppConsole6StrdupEPKc, funcdef_no=434, decl_uid=12523, cgraph_uid=333, symbol_order=505)

static char* ExampleAppConsole::Strdup(const char*) (const char * str)
{
  void * buff;
  size_t len;
  char * D.16817;
  long unsigned int D.16816;
  long unsigned int _3;
  char * _8;

  <bb 2>:
  _3 = strlen (str_2(D));
  len_4 = _3 + 1;
  buff_6 = malloc (len_4);
  _8 = memcpy (buff_6, str_2(D), len_4);

<L0>:
  return _8;

}



;; Function void ExampleAppConsole::ClearLog() (_ZN17ExampleAppConsole8ClearLogEv, funcdef_no=435, decl_uid=12524, cgraph_uid=334, symbol_order=506)

void ExampleAppConsole::ClearLog() (struct ExampleAppConsole * const this)
{
  int i;
  struct ImVector * D.16720;
  char * D.16719;
  char * & D.16718;
  struct ImVector * D.16717;
  int D.16715;
  int _6;
  struct ImVector * _7;
  char * & _9;
  char * _10;
  struct ImVector * _13;

  <bb 2>:
  i_3 = 0;

  <bb 3>:
  # i_1 = PHI <i_3(2), i_12(4)>
  _6 = this_5(D)->Items.Size;
  if (_6 <= i_1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _7 = &this_5(D)->Items;
  _9 = ImVector<char*>::operator[] (_7, i_1);
  _10 = *_9;
  free (_10);
  i_12 = i_1 + 1;
  goto <bb 3>;

  <bb 5>:
  _13 = &this_5(D)->Items;
  ImVector<char*>::clear (_13);
  this_5(D)->ScrollToBottom = 1;
  return;

}



;; Function void ExampleAppConsole::AddLog(const char*, ...) (_ZN17ExampleAppConsole6AddLogEPKcz, funcdef_no=436, decl_uid=12527, cgraph_uid=335, symbol_order=507)

void ExampleAppConsole::AddLog(const char*, ...) (struct ExampleAppConsole * const this, const char * fmt)
{
  struct  args[1];
  char buf[1024];
  struct ImVector * D.16813;
  char * D.16812;
  char * const D.12598;
  char * _8;
  struct ImVector * _11;

  <bb 2>:
  __builtin_va_start (&args, 0);
  vsnprintf (&buf, 1024, fmt_3(D), &args);
  buf[1023] = 0;
  __builtin_va_end (&args);
  _8 = ExampleAppConsole::Strdup (&buf);
  D.12598 = _8;
  _11 = &this_10(D)->Items;
  ImVector<char*>::push_back (_11, &D.12598);
  D.12598 ={v} {CLOBBER};
  this_10(D)->ScrollToBottom = 1;
  buf ={v} {CLOBBER};
  args ={v} {CLOBBER};
  return;

}



;; Function void ExampleAppConsole::Draw(const char*, bool*) (_ZN17ExampleAppConsole4DrawEPKcPb, funcdef_no=437, decl_uid=12531, cgraph_uid=336, symbol_order=510)

void ExampleAppConsole::Draw(const char*, bool*) (struct ExampleAppConsole * const this, const char * title, bool * p_open)
{
  void * D.18664;
  bool D.16994;
  bool D.16990;
  const struct ImVec4 & D.16989;
  bool D.16986;
  bool D.16985;
  float D.16983;
  struct ImGuiStyle & D.16982;
  bool D.16979;
  bool D.16978;
  bool D.16977;
  bool D.16976;
  bool D.16975;
  bool D.16974;
  bool D.16973;
  bool D.16972;
  char * input_end;
  struct ImVec4 col;
  const char * item;
  int i;
  bool reclaim_focus;
  struct ImVec4 col_default_text;
  const float footer_height_to_reserve;
  static struct ImGuiTextFilter filter;
  bool copy_to_clipboard;
  char[256] * D.16965;
  char[256] * D.16963;
  char D.16960;
  char D.16958;
  char * D.16957;
  char[256] * D.16955;
  long unsigned int D.16953;
  char[256] * D.16952;
  char[256] * D.16951;
  char[256] * D.16948;
  bool retval.550;
  bool D.16943;
  struct ImColor D.12618;
  int D.16936;
  struct ImColor D.12616;
  const char * D.16932;
  bool D.16929;
  bool retval.549;
  char * & D.16927;
  struct ImVector * D.16926;
  int D.16924;
  const struct ImVec4 & D.16922;
  struct ImVec2 D.12609;
  struct ImVec2 D.12608;
  bool retval.548;
  bool retval.547;
  float D.16910;
  struct ImVec2 D.12607;
  float D.16909;
  float D.16908;
  struct ImGuiStyle & D.16907;
  bool D.12605;
  int D.16899;
  bool retval.546;
  unsigned char D.16895;
  bool retval.545;
  struct ImVec2 D.12602;
  bool retval.544;
  bool retval.543;
  bool retval.542;
  int D.16880;
  bool retval.541;
  bool retval.540;
  bool retval.539;
  bool D.16866;
  bool retval.538;
  struct ImVec2 D.12600;
  bool _33;
  bool _34;
  bool retval.538_35;
  bool _37;
  bool retval.539_38;
  bool _40;
  bool retval.540_41;
  bool _47;
  bool retval.541_48;
  int _50;
  bool _56;
  bool retval.542_57;
  bool _61;
  bool retval.543_62;
  bool _66;
  bool _70;
  bool retval.544_71;
  unsigned char _78;
  bool retval.545_79;
  int _81;
  bool retval.546_82;
  bool _83;
  bool _85;
  struct ImGuiStyle & _93;
  struct ImGuiStyle & _94;
  float _95;
  float _97;
  float _98;
  float _100;
  bool _105;
  bool retval.547_106;
  bool _109;
  bool retval.548_110;
  const struct ImVec4 & _120;
  const struct ImVec4 & _121;
  int _124;
  struct ImVector * _125;
  char * & _127;
  bool _130;
  bool _131;
  bool retval.549_132;
  const char * _134;
  int _138;
  bool _150;
  char[256] * _157;
  bool _159;
  bool retval.550_160;
  char[256] * _161;
  char[256] * _162;
  long unsigned int _163;
  char[256] * _165;
  char * _166;
  char _167;
  char _170;
  char[256] * _171;
  char[256] * _173;

  <bb 2>:
  ImVec2::ImVec2 (&D.12600, 5.2e+2, 6.0e+2);
  ImGui::SetNextWindowSize (&D.12600, 4);
  D.12600 ={v} {CLOBBER};
  _33 = ImGui::Begin (title_30(D), p_open_31(D), 0);
  _34 = _33;
  retval.538_35 = ~_34;
  if (retval.538_35 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::End ();
  col_default_text ={v} {CLOBBER};
  goto <bb 51> (<L70>);

  <bb 4>:
  _37 = ImGui::BeginPopupContextItem (0B, 1);
  retval.539_38 = _37;
  if (retval.539_38 != 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _40 = ImGui::MenuItem ("Close", 0B, 0, 1);
  retval.540_41 = _40;
  if (retval.540_41 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  *p_open_31(D) = 0;

  <bb 7>:
  ImGui::EndPopup ();

  <bb 8>:
  ImGui::TextWrapped ("This example implements a console with basic coloring, completion and history. A more elaborate implementation may want to store entries along with extra data such as timestamp, emitter, etc.");
  ImGui::TextWrapped ("Enter \'HELP\' for help, press TAB to use text completion.");
  _47 = ImGui::SmallButton ("Add Dummy Text");
  retval.541_48 = _47;
  if (retval.541_48 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _50 = this_49(D)->Items.Size;
  ExampleAppConsole::AddLog (this_49(D), "%d some text", _50);
  ExampleAppConsole::AddLog (this_49(D), "some more text");
  ExampleAppConsole::AddLog (this_49(D), "display very important message here!");

  <bb 10>:
  ImGui::SameLine (0.0, -1.0e+0);
  _56 = ImGui::SmallButton ("Add Dummy Error");
  retval.542_57 = _56;
  if (retval.542_57 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  ExampleAppConsole::AddLog (this_49(D), "[error] something went wrong");

  <bb 12>:
  ImGui::SameLine (0.0, -1.0e+0);
  _61 = ImGui::SmallButton ("Clear");
  retval.543_62 = _61;
  if (retval.543_62 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  ExampleAppConsole::ClearLog (this_49(D));

  <bb 14>:
  ImGui::SameLine (0.0, -1.0e+0);
  _66 = ImGui::SmallButton ("Copy");
  copy_to_clipboard_67 = _66;
  ImGui::SameLine (0.0, -1.0e+0);
  _70 = ImGui::SmallButton ("Scroll to bottom");
  retval.544_71 = _70;
  if (retval.544_71 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  this_49(D)->ScrollToBottom = 1;

  <bb 16>:
  ImGui::Separator ();
  ImVec2::ImVec2 (&D.12602, 0.0, 0.0);
  ImGui::PushStyleVar (10, &D.12602);
  D.12602 ={v} {CLOBBER};
  _78 = __atomic_load_1 (&_ZGVZN17ExampleAppConsole4DrawEPKcPbE6filter, 2);
  retval.545_79 = _78 == 0;
  if (retval.545_79 != 0)
    goto <bb 17>;
  else
    goto <bb 20>;

  <bb 17>:
  _81 = __cxa_guard_acquire (&_ZGVZN17ExampleAppConsole4DrawEPKcPbE6filter);
  retval.546_82 = _81 != 0;
  if (retval.546_82 != 0)
    goto <bb 18>;
  else
    goto <bb 20>;

  <bb 18>:
  _83 = 0;
  ImGuiTextFilter::ImGuiTextFilter (&filter, "");

  <bb 19>:
  _85 = 1;
  __cxa_guard_release (&_ZGVZN17ExampleAppConsole4DrawEPKcPbE6filter);
  __cxa_atexit (__comp_dtor , &filter, &__dso_handle);

  <bb 20>:
  ImGuiTextFilter::Draw (&filter, "Filter (\"incl,-excl\") (\"error\")", 1.8e+2);
  ImGui::PopStyleVar (1);
  ImGui::Separator ();
  _93 = ImGui::GetStyle ();
  _94 = _93;
  _95 = _94->ItemSpacing.y;
  _97 = ImGui::GetFrameHeightWithSpacing ();
  _98 = _97;
  footer_height_to_reserve_99 = _95 + _98;
  _100 = -footer_height_to_reserve_99;
  ImVec2::ImVec2 (&D.12607, 0.0, _100);
  ImGui::BeginChild ("ScrollingRegion", &D.12607, 0, 2048);
  D.12607 ={v} {CLOBBER};
  _105 = ImGui::BeginPopupContextWindow (0B, 1, 1);
  retval.547_106 = _105;
  if (retval.547_106 != 0)
    goto <bb 21>;
  else
    goto <bb 24>;

  <bb 21>:
  ImVec2::ImVec2 (&D.12608, 0.0, 0.0);
  _109 = ImGui::Selectable ("Clear", 0, 0, &D.12608);
  retval.548_110 = _109;
  D.12608 ={v} {CLOBBER};
  if (retval.548_110 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  ExampleAppConsole::ClearLog (this_49(D));

  <bb 23>:
  ImGui::EndPopup ();

  <bb 24>:
  ImVec2::ImVec2 (&D.12609, 4.0e+0, 1.0e+0);
  ImGui::PushStyleVar (13, &D.12609);
  D.12609 ={v} {CLOBBER};
  if (copy_to_clipboard_67 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  ImGui::LogToClipboard (-1);

  <bb 26>:
  _120 = ImGui::GetStyleColorVec4 (0);
  _121 = _120;
  col_default_text = *_121;
  i_123 = 0;

  <bb 27>:
  # i_1 = PHI <i_123(26), i_147(35)>
  _124 = this_49(D)->Items.Size;
  if (_124 <= i_1)
    goto <bb 36>;
  else
    goto <bb 28>;

  <bb 28>:
  _125 = &this_49(D)->Items;
  _127 = ImVector<char*>::operator[] (_125, i_1);
  item_128 = *_127;
  _130 = ImGuiTextFilter::PassFilter (&filter, item_128, 0B);
  _131 = _130;
  retval.549_132 = ~_131;
  if (retval.549_132 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  col ={v} {CLOBBER};
  goto <bb 35>;

  <bb 30>:
  col = col_default_text;
  _134 = strstr (item_128, "[error]");
  if (_134 != 0B)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  ImColor::ImColor (&D.12616, 1.0e+0, 4.000000059604644775390625e-1, 4.000000059604644775390625e-1, 1.0e+0);
  col = ImColor::operator ImVec4 (&D.12616);
  D.12616 ={v} {CLOBBER};
  goto <bb 34>;

  <bb 32>:
  _138 = strncmp (item_128, "# ", 2);
  if (_138 == 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  ImColor::ImColor (&D.12618, 1.0e+0, 7.799999713897705078125e-1, 5.79999983310699462890625e-1, 1.0e+0);
  col = ImColor::operator ImVec4 (&D.12618);
  D.12618 ={v} {CLOBBER};

  <bb 34>:
  ImGui::PushStyleColor (0, &col);
  ImGui::TextUnformatted (item_128, 0B);
  ImGui::PopStyleColor (1);
  col ={v} {CLOBBER};

  <bb 35>:
  i_147 = i_1 + 1;
  goto <bb 27>;

  <bb 36>:
  if (copy_to_clipboard_67 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  ImGui::LogFinish ();

  <bb 38>:
  _150 = this_49(D)->ScrollToBottom;
  if (_150 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  ImGui::SetScrollHere (5.0e-1);

  <bb 40>:
  this_49(D)->ScrollToBottom = 0;
  ImGui::PopStyleVar (1);
  ImGui::EndChild ();
  ImGui::Separator ();
  reclaim_focus_156 = 0;
  _157 = &this_49(D)->InputBuf;
  _159 = ImGui::InputText ("Input", _157, 256, 224, TextEditCallbackStub, this_49(D));
  retval.550_160 = _159;
  if (retval.550_160 != 0)
    goto <bb 41>;
  else
    goto <bb 48>;

  <bb 41>:
  _161 = &this_49(D)->InputBuf;
  _162 = &this_49(D)->InputBuf;
  _163 = strlen (_162);
  input_end_164 = _161 + _163;

  <bb 42>:
  # input_end_3 = PHI <input_end_164(41), input_end_168(44)>
  _165 = &this_49(D)->InputBuf;
  if (_165 >= input_end_3)
    goto <bb 45>;
  else
    goto <bb 43>;

  <bb 43>:
  _166 = input_end_3 + 18446744073709551615;
  _167 = *_166;
  if (_167 != 32)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  input_end_168 = input_end_3 + 18446744073709551615;
  goto <bb 42>;

  <bb 45>:
  *input_end_3 = 0;
  _170 = this_49(D)->InputBuf[0];
  if (_170 != 0)
    goto <bb 46>;
  else
    goto <bb 47>;

  <bb 46>:
  _171 = &this_49(D)->InputBuf;
  ExampleAppConsole::ExecCommand (this_49(D), _171);

  <bb 47>:
  _173 = &this_49(D)->InputBuf;
  __builtin_memcpy (_173, "", 1);
  reclaim_focus_175 = 1;

  <bb 48>:
  # reclaim_focus_2 = PHI <reclaim_focus_156(40), reclaim_focus_175(47)>
  ImGui::SetItemDefaultFocus ();
  if (reclaim_focus_2 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  ImGui::SetKeyboardFocusHere (-1);

  <bb 50>:
  ImGui::End ();
  col_default_text ={v} {CLOBBER};

<L70>:
  return;

<L73>:
  if (_83 != 0)
    goto <bb 54>;
  else
    goto <bb 53>;

  <bb 53>:
  __cxa_guard_abort (&_ZGVZN17ExampleAppConsole4DrawEPKcPbE6filter);

  <bb 54>:
  _24 = __builtin_eh_pointer (6);
  __builtin_unwind_resume (_24);

}



;; Function void ExampleAppConsole::ExecCommand(const char*) (_ZN17ExampleAppConsole11ExecCommandEPKc, funcdef_no=438, decl_uid=12534, cgraph_uid=337, symbol_order=511)

void ExampleAppConsole::ExecCommand(const char*) (struct ExampleAppConsole * const this, const char * command_line)
{
  int i;
  int first;
  int i;
  int i;
  char * D.17248;
  char * & D.17247;
  struct ImVector * D.17246;
  int D.17244;
  int D.17242;
  int D.17239;
  bool retval.573;
  const char * D.17236;
  const char * & D.17235;
  struct ImVector * D.17234;
  int D.17232;
  int D.17228;
  bool retval.572;
  int D.17223;
  bool retval.571;
  struct ImVector * D.17221;
  char * D.17220;
  char * const D.12628;
  struct ImVector * D.17219;
  char * * D.17218;
  long unsigned int D.17217;
  long unsigned int D.17216;
  char * * D.17215;
  struct ImVector * D.17214;
  char * D.17213;
  char * & D.17212;
  struct ImVector * D.17211;
  int D.17208;
  char * D.17207;
  char * & D.17206;
  struct ImVector * D.17205;
  bool retval.570;
  int D.17201;
  int _14;
  struct ImVector * _16;
  char * & _18;
  char * _19;
  int _21;
  bool retval.570_22;
  struct ImVector * _24;
  char * & _26;
  char * _27;
  struct ImVector * _29;
  char * * _31;
  long unsigned int _32;
  long unsigned int _33;
  char * * _34;
  struct ImVector * _35;
  char * _38;
  struct ImVector * _40;
  int _44;
  bool retval.571_45;
  int _48;
  bool retval.572_49;
  int _52;
  struct ImVector * _53;
  const char * & _55;
  const char * _56;
  int _60;
  bool retval.573_61;
  int _62;
  int _65;
  struct ImVector * _66;
  char * & _68;
  char * _69;

  <bb 2>:
  ExampleAppConsole::AddLog (this_10(D), "# %s\n", command_line_11(D));
  this_10(D)->HistoryPos = -1;
  _14 = this_10(D)->History.Size;
  i_15 = _14 + -1;

  <bb 3>:
  # i_1 = PHI <i_15(2), i_23(6)>
  if (i_1 < 0)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _16 = &this_10(D)->History;
  _18 = ImVector<char*>::operator[] (_16, i_1);
  _19 = *_18;
  _21 = ExampleAppConsole::Stricmp (_19, command_line_11(D));
  retval.570_22 = _21 == 0;
  if (retval.570_22 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _24 = &this_10(D)->History;
  _26 = ImVector<char*>::operator[] (_24, i_1);
  _27 = *_26;
  free (_27);
  _29 = &this_10(D)->History;
  _31 = ImVector<char*>::begin (_29);
  _32 = (long unsigned int) i_1;
  _33 = _32 * 8;
  _34 = _31 + _33;
  _35 = &this_10(D)->History;
  ImVector<char*>::erase (_35, _34);
  goto <bb 7>;

  <bb 6>:
  i_23 = i_1 + -1;
  goto <bb 3>;

  <bb 7>:
  _38 = ExampleAppConsole::Strdup (command_line_11(D));
  D.12628 = _38;
  _40 = &this_10(D)->History;
  ImVector<char*>::push_back (_40, &D.12628);
  D.12628 ={v} {CLOBBER};
  _44 = ExampleAppConsole::Stricmp (command_line_11(D), "CLEAR");
  retval.571_45 = _44 == 0;
  if (retval.571_45 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  ExampleAppConsole::ClearLog (this_10(D));
  goto <bb 20>;

  <bb 9>:
  _48 = ExampleAppConsole::Stricmp (command_line_11(D), "HELP");
  retval.572_49 = _48 == 0;
  if (retval.572_49 != 0)
    goto <bb 10>;
  else
    goto <bb 14>;

  <bb 10>:
  ExampleAppConsole::AddLog (this_10(D), "Commands:");
  i_51 = 0;

  <bb 11>:
  # i_2 = PHI <i_51(10), i_58(12)>
  _52 = this_10(D)->Commands.Size;
  if (_52 <= i_2)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  _53 = &this_10(D)->Commands;
  _55 = ImVector<const char*>::operator[] (_53, i_2);
  _56 = *_55;
  ExampleAppConsole::AddLog (this_10(D), "- %s", _56);
  i_58 = i_2 + 1;
  goto <bb 11>;

  <bb 13>:
  goto <bb 20>;

  <bb 14>:
  _60 = ExampleAppConsole::Stricmp (command_line_11(D), "HISTORY");
  retval.573_61 = _60 == 0;
  if (retval.573_61 != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

  <bb 15>:
  _62 = this_10(D)->History.Size;
  first_63 = _62 + -10;
  i_64 = MAX_EXPR <first_63, 0>;

  <bb 16>:
  # i_3 = PHI <i_64(15), i_71(17)>
  _65 = this_10(D)->History.Size;
  if (_65 <= i_3)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  _66 = &this_10(D)->History;
  _68 = ImVector<char*>::operator[] (_66, i_3);
  _69 = *_68;
  ExampleAppConsole::AddLog (this_10(D), "%3d: %s\n", i_3, _69);
  i_71 = i_3 + 1;
  goto <bb 16>;

  <bb 18>:
  goto <bb 20>;

  <bb 19>:
  ExampleAppConsole::AddLog (this_10(D), "Unknown command: \'%s\'\n", command_line_11(D));

  <bb 20>:
  return;

}



;; Function static int ExampleAppConsole::TextEditCallbackStub(ImGuiTextEditCallbackData*) (_ZN17ExampleAppConsole20TextEditCallbackStubEP25ImGuiTextEditCallbackData, funcdef_no=439, decl_uid=12537, cgraph_uid=338, symbol_order=512)

static int ExampleAppConsole::TextEditCallbackStub(ImGuiTextEditCallbackData*) (struct ImGuiTextEditCallbackData * data)
{
  int D.17000;
  struct ExampleAppConsole * console;
  int D.16998;
  int _5;
  int _6;

  <bb 2>:
  console_3 = data_2(D)->UserData;
  _5 = ExampleAppConsole::TextEditCallback (console_3, data_2(D));
  _6 = _5;

<L0>:
  return _6;

}



;; Function int ExampleAppConsole::TextEditCallback(ImGuiTextEditCallbackData*) (_ZN17ExampleAppConsole16TextEditCallbackEP25ImGuiTextEditCallbackData, funcdef_no=440, decl_uid=12539, cgraph_uid=339, symbol_order=513)

int ExampleAppConsole::TextEditCallback(ImGuiTextEditCallbackData*) (struct ExampleAppConsole * const this, struct ImGuiTextEditCallbackData * data)
{
  void * D.18686;
  const int prev_history_pos;
  int i;
  int i;
  bool all_candidates_matches;
  int c;
  int match_len;
  int i;
  const char c;
  struct ImVector candidates;
  const char * word_start;
  const char * word_end;
  int D.17168;
  int D.17165;
  int D.17164;
  int D.17163;
  int D.17162;
  char * D.17161;
  long unsigned int D.17160;
  int D.17159;
  char * & D.17157;
  struct ImVector * D.17156;
  int D.17155;
  int D.17152;
  const char * iftmp.567;
  int D.17148;
  int D.17142;
  int D.17141;
  int D.17140;
  int D.17139;
  bool retval.566;
  int D.17135;
  int D.17132;
  int D.17129;
  int D.17128;
  int D.17125;
  int D.17123;
  int D.17122;
  int D.17119;
  int D.17116;
  const char * D.17115;
  const char * & D.17114;
  int D.17112;
  int D.17109;
  const char * D.17108;
  const char * & D.17107;
  const char * D.17106;
  sizetype D.17105;
  const char * D.17104;
  const char * & D.17103;
  int D.17102;
  long int D.17101;
  long int D.17100;
  char * D.17099;
  long int word_start.565;
  int D.17097;
  long int D.17096;
  long int word_start.564;
  long int word_end.563;
  bool D.17089;
  int D.17085;
  int D.17084;
  char D.17083;
  const char * D.17082;
  sizetype D.17081;
  const char * D.17080;
  const char * & D.17079;
  bool iftmp.562;
  bool retval.561;
  int D.17071;
  char D.17070;
  const char * D.17069;
  sizetype D.17068;
  const char * D.17067;
  const char * & D.17066;
  bool D.17062;
  int D.17060;
  long int D.17057;
  long int word_start.560;
  long int word_end.559;
  int D.17053;
  int D.17052;
  const char * D.17051;
  const char * & D.17050;
  int D.17049;
  long int D.17048;
  long int D.17047;
  char * D.17046;
  long int word_start.558;
  int D.17044;
  long int D.17043;
  long int word_start.557;
  long int word_end.556;
  int D.17038;
  int D.17036;
  long int D.17035;
  long int word_start.555;
  long int word_end.554;
  int D.17030;
  const char * & D.17028;
  struct ImVector * D.17027;
  int D.17024;
  const char * D.17023;
  const char * & D.17022;
  struct ImVector * D.17021;
  int D.17020;
  long int D.17019;
  long int word_start.553;
  long int word_end.552;
  bool retval.551;
  int D.17014;
  const char * D.17008;
  char * D.17006;
  sizetype D.17004;
  int D.17003;
  char * D.17002;
  int D.17001;
  bool iftmp.562_10;
  const char * iftmp.567_11;
  int _28;
  char * _29;
  int _30;
  sizetype _31;
  char * _34;
  const char * _35;
  int _41;
  long int word_end.552_42;
  long int word_start.553_43;
  long int _44;
  int _45;
  struct ImVector * _46;
  const char * & _48;
  const char * _49;
  int _51;
  bool retval.551_52;
  struct ImVector * _53;
  const char * & _55;
  int _58;
  long int word_end.554_59;
  long int word_start.555_60;
  long int _61;
  int _62;
  int _64;
  long int word_end.556_65;
  long int word_start.557_66;
  long int _67;
  int _68;
  long int word_start.558_69;
  char * _70;
  long int _71;
  long int _72;
  int _73;
  const char * & _76;
  const char * _77;
  int _78;
  int _80;
  long int word_end.559_82;
  long int word_start.560_83;
  long int _84;
  int _89;
  bool _90;
  const char * & _92;
  const char * _93;
  sizetype _94;
  const char * _95;
  char _96;
  int _97;
  const char * & _100;
  const char * _101;
  sizetype _102;
  const char * _103;
  char _104;
  int _105;
  int _106;
  bool iftmp.562_107;
  bool iftmp.562_108;
  bool retval.561_109;
  bool _112;
  long int word_end.563_114;
  long int word_start.564_115;
  long int _116;
  int _117;
  long int word_start.565_118;
  char * _119;
  long int _120;
  long int _121;
  int _122;
  const char * & _125;
  const char * _126;
  sizetype _127;
  const char * _128;
  const char * & _130;
  const char * _131;
  int _132;
  int _136;
  const char * & _138;
  const char * _139;
  int _147;
  int _148;
  int _149;
  int _150;
  int _151;
  int _153;
  int _154;
  int _156;
  int _157;
  int _158;
  int _159;
  int _161;
  int _162;
  bool retval.566_163;
  int _165;
  int _166;
  int _167;
  struct ImVector * _168;
  char * & _170;
  const char * iftmp.567_171;
  const char * iftmp.567_172;
  int _173;
  long unsigned int _174;
  char * _175;
  int _177;
  int _179;
  int _181;
  int _183;
  int _186;

  <bb 2>:
  _28 = data_27(D)->EventFlag;
  switch (_28) <default: <L69>, case 64: <L0>, case 128: <L46>>

<L0>:
  _29 = data_27(D)->Buf;
  _30 = data_27(D)->CursorPos;
  _31 = (sizetype) _30;
  word_end_32 = _29 + _31;
  word_start_33 = word_end_32;

  <bb 4>:
  # word_start_1 = PHI <word_start_33(3), word_start_37(9)>
  _34 = data_27(D)->Buf;
  if (_34 >= word_start_1)
    goto <bb 10>;
  else
    goto <bb 5>;

  <bb 5>:
  _35 = word_start_1 + 18446744073709551615;
  c_36 = *_35;
  if (c_36 == 32)
    goto <bb 10>;
  else
    goto <bb 6>;

  <bb 6>:
  if (c_36 == 9)
    goto <bb 10>;
  else
    goto <bb 7>;

  <bb 7>:
  if (c_36 == 44)
    goto <bb 10>;
  else
    goto <bb 8>;

  <bb 8>:
  if (c_36 == 59)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  word_start_37 = word_start_1 + 18446744073709551615;
  goto <bb 4>;

  <bb 10>:
  ImVector<const char*>::ImVector (&candidates);
  i_39 = 0;

  <bb 11>:
  # i_2 = PHI <i_39(10), i_57(15)>
  _41 = this_40(D)->Commands.Size;
  if (_41 <= i_2)
    goto <bb 16>;
  else
    goto <bb 12>;

  <bb 12>:
  word_end.552_42 = (long int) word_end_32;
  word_start.553_43 = (long int) word_start_1;
  _44 = word_end.552_42 - word_start.553_43;
  _45 = (int) _44;
  _46 = &this_40(D)->Commands;
  _48 = ImVector<const char*>::operator[] (_46, i_2);
  _49 = *_48;
  _51 = ExampleAppConsole::Strnicmp (_49, word_start_1, _45);
  retval.551_52 = _51 == 0;
  if (retval.551_52 != 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  _53 = &this_40(D)->Commands;
  _55 = ImVector<const char*>::operator[] (_53, i_2);
  ImVector<const char*>::push_back (&candidates, _55);

  <bb 14>:

  <bb 15>:
  i_57 = i_2 + 1;
  goto <bb 11>;

  <bb 16>:
  _58 = candidates.Size;
  if (_58 == 0)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  word_end.554_59 = (long int) word_end_32;
  word_start.555_60 = (long int) word_start_1;
  _61 = word_end.554_59 - word_start.555_60;
  _62 = (int) _61;
  ExampleAppConsole::AddLog (this_40(D), "No match for \"%.*s\"!\n", _62, word_start_1);

  <bb 18>:
  goto <bb 49>;

  <bb 19>:
  _64 = candidates.Size;
  if (_64 == 1)
    goto <bb 20>;
  else
    goto <bb 24>;

  <bb 20>:
  word_end.556_65 = (long int) word_end_32;
  word_start.557_66 = (long int) word_start_1;
  _67 = word_end.556_65 - word_start.557_66;
  _68 = (int) _67;
  word_start.558_69 = (long int) word_start_1;
  _70 = data_27(D)->Buf;
  _71 = (long int) _70;
  _72 = word_start.558_69 - _71;
  _73 = (int) _72;
  ImGuiTextEditCallbackData::DeleteChars (data_27(D), _73, _68);

  <bb 21>:
  _76 = ImVector<const char*>::operator[] (&candidates, 0);
  _77 = *_76;
  _78 = data_27(D)->CursorPos;
  ImGuiTextEditCallbackData::InsertChars (data_27(D), _78, _77, 0B);

  <bb 22>:
  _80 = data_27(D)->CursorPos;
  ImGuiTextEditCallbackData::InsertChars (data_27(D), _80, " ", 0B);

  <bb 23>:
  goto <bb 49>;

  <bb 24>:
  word_end.559_82 = (long int) word_end_32;
  word_start.560_83 = (long int) word_start_1;
  _84 = word_end.559_82 - word_start.560_83;
  match_len_85 = (int) _84;

  <bb 25>:
  # match_len_3 = PHI <match_len_85(24), match_len_113(39)>
  c_86 = 0;
  all_candidates_matches_87 = 1;
  i_88 = 0;

  <bb 26>:
  # c_4 = PHI <c_86(25), c_5(36)>
  # all_candidates_matches_6 = PHI <all_candidates_matches_87(25), all_candidates_matches_7(36)>
  # i_8 = PHI <i_88(25), i_111(36)>
  _89 = candidates.Size;
  if (_89 <= i_8)
    goto <bb 37>;
  else
    goto <bb 27>;

  <bb 27>:
  _90 = ~all_candidates_matches_6;
  if (_90 != 0)
    goto <bb 37>;
  else
    goto <bb 28>;

  <bb 28>:
  if (i_8 == 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  _92 = ImVector<const char*>::operator[] (&candidates, i_8);
  _93 = *_92;
  _94 = (sizetype) match_len_3;
  _95 = _93 + _94;
  _96 = *_95;
  _97 = (int) _96;
  c_98 = toupper (_97);
  goto <bb 36>;

  <bb 30>:
  if (c_4 == 0)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  _100 = ImVector<const char*>::operator[] (&candidates, i_8);
  _101 = *_100;
  _102 = (sizetype) match_len_3;
  _103 = _101 + _102;
  _104 = *_103;
  _105 = (int) _104;
  _106 = toupper (_105);
  if (_106 != c_4)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  iftmp.562_108 = 1;
  goto <bb 34>;

  <bb 33>:
  iftmp.562_107 = 0;

  <bb 34>:
  # iftmp.562_10 = PHI <iftmp.562_108(32), iftmp.562_107(33)>
  retval.561_109 = iftmp.562_10;
  if (retval.561_109 != 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  all_candidates_matches_110 = 0;

  <bb 36>:
  # c_5 = PHI <c_98(29), c_4(34), c_4(35)>
  # all_candidates_matches_7 = PHI <all_candidates_matches_6(29), all_candidates_matches_6(34), all_candidates_matches_110(35)>
  i_111 = i_8 + 1;
  goto <bb 26>;

  <bb 37>:
  _112 = ~all_candidates_matches_6;
  if (_112 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  goto <bb 40>;

  <bb 39>:
  match_len_113 = match_len_3 + 1;
  goto <bb 25>;

  <bb 40>:
  if (match_len_3 > 0)
    goto <bb 41>;
  else
    goto <bb 44>;

  <bb 41>:
  word_end.563_114 = (long int) word_end_32;
  word_start.564_115 = (long int) word_start_1;
  _116 = word_end.563_114 - word_start.564_115;
  _117 = (int) _116;
  word_start.565_118 = (long int) word_start_1;
  _119 = data_27(D)->Buf;
  _120 = (long int) _119;
  _121 = word_start.565_118 - _120;
  _122 = (int) _121;
  ImGuiTextEditCallbackData::DeleteChars (data_27(D), _122, _117);

  <bb 42>:
  _125 = ImVector<const char*>::operator[] (&candidates, 0);
  _126 = *_125;
  _127 = (sizetype) match_len_3;
  _128 = _126 + _127;
  _130 = ImVector<const char*>::operator[] (&candidates, 0);
  _131 = *_130;
  _132 = data_27(D)->CursorPos;
  ImGuiTextEditCallbackData::InsertChars (data_27(D), _132, _131, _128);

  <bb 43>:

  <bb 44>:
  ExampleAppConsole::AddLog (this_40(D), "Possible matches:\n");

  <bb 45>:
  i_135 = 0;

  <bb 46>:
  # i_9 = PHI <i_135(45), i_141(48)>
  _136 = candidates.Size;
  if (_136 <= i_9)
    goto <bb 49>;
  else
    goto <bb 47>;

  <bb 47>:
  _138 = ImVector<const char*>::operator[] (&candidates, i_9);
  _139 = *_138;
  ExampleAppConsole::AddLog (this_40(D), "- %s\n", _139);

  <bb 48>:
  i_141 = i_9 + 1;
  goto <bb 46>;

  <bb 49>:

  <bb 50>:
  ImVector<const char*>::~ImVector (&candidates);
  candidates ={v} {CLOBBER};
  goto <bb 65> (<L69>);

<L46>:
  prev_history_pos_146 = this_40(D)->HistoryPos;
  _147 = data_27(D)->EventKey;
  if (_147 == 3)
    goto <bb 52>;
  else
    goto <bb 56>;

  <bb 52>:
  _148 = this_40(D)->HistoryPos;
  if (_148 == -1)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  _153 = this_40(D)->History.Size;
  _154 = _153 + -1;
  this_40(D)->HistoryPos = _154;
  goto <bb 60>;

  <bb 54>:
  _149 = this_40(D)->HistoryPos;
  if (_149 > 0)
    goto <bb 55>;
  else
    goto <bb 60>;

  <bb 55>:
  _150 = this_40(D)->HistoryPos;
  _151 = _150 + -1;
  this_40(D)->HistoryPos = _151;
  goto <bb 60>;

  <bb 56>:
  _156 = data_27(D)->EventKey;
  if (_156 == 4)
    goto <bb 57>;
  else
    goto <bb 60>;

  <bb 57>:
  _157 = this_40(D)->HistoryPos;
  if (_157 != -1)
    goto <bb 58>;
  else
    goto <bb 60>;

  <bb 58>:
  _158 = this_40(D)->HistoryPos;
  _159 = _158 + 1;
  this_40(D)->HistoryPos = _159;
  _161 = this_40(D)->HistoryPos;
  _162 = this_40(D)->History.Size;
  retval.566_163 = _161 >= _162;
  if (retval.566_163 != 0)
    goto <bb 59>;
  else
    goto <bb 60>;

  <bb 59>:
  this_40(D)->HistoryPos = -1;

  <bb 60>:
  _165 = this_40(D)->HistoryPos;
  if (_165 != prev_history_pos_146)
    goto <bb 61>;
  else
    goto <bb 65> (<L69>);

  <bb 61>:
  _166 = this_40(D)->HistoryPos;
  if (_166 >= 0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  _167 = this_40(D)->HistoryPos;
  _168 = &this_40(D)->History;
  _170 = ImVector<char*>::operator[] (_168, _167);
  iftmp.567_171 = *_170;
  goto <bb 64>;

  <bb 63>:
  iftmp.567_172 = "";

  <bb 64>:
  # iftmp.567_11 = PHI <iftmp.567_171(62), iftmp.567_172(63)>
  _173 = data_27(D)->BufSize;
  _174 = (long unsigned int) _173;
  _175 = data_27(D)->Buf;
  _177 = snprintf (_175, _174, "%s", iftmp.567_11);
  data_27(D)->BufTextLen = _177;
  _179 = data_27(D)->BufTextLen;
  data_27(D)->SelectionEnd = _179;
  _181 = data_27(D)->SelectionEnd;
  data_27(D)->SelectionStart = _181;
  _183 = data_27(D)->SelectionStart;
  data_27(D)->CursorPos = _183;
  data_27(D)->BufDirty = 1;

<L69>:
  _186 = 0;

<L73>:
  return _186;

<L74>:
  ImVector<const char*>::~ImVector (&candidates);
  _145 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_145);

}



;; Function void ShowExampleAppConsole(bool*) (_ZL21ShowExampleAppConsolePb, funcdef_no=441, decl_uid=11335, cgraph_uid=340, symbol_order=516)

void ShowExampleAppConsole(bool*) (bool * p_open)
{
  void * D.18692;
  static struct ExampleAppConsole console;
  bool D.12679;
  int D.16696;
  bool retval.533;
  unsigned char D.16692;
  bool retval.532;
  unsigned char _4;
  bool retval.532_5;
  int _7;
  bool retval.533_8;
  bool _9;
  bool _11;

  <bb 2>:
  _4 = __atomic_load_1 (&_ZGVZL21ShowExampleAppConsolePbE7console, 2);
  retval.532_5 = _4 == 0;
  if (retval.532_5 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _7 = __cxa_guard_acquire (&_ZGVZL21ShowExampleAppConsolePbE7console);
  retval.533_8 = _7 != 0;
  if (retval.533_8 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _9 = 0;
  ExampleAppConsole::ExampleAppConsole (&console);

  <bb 5>:
  _11 = 1;
  __cxa_guard_release (&_ZGVZL21ShowExampleAppConsolePbE7console);
  __cxa_atexit (__comp_dtor , &console, &__dso_handle);

  <bb 6>:
  ExampleAppConsole::Draw (&console, "Example: Console", p_open_15(D));
  return;

<L6>:
  if (_9 != 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  __cxa_guard_abort (&_ZGVZL21ShowExampleAppConsolePbE7console);

  <bb 9>:
  _17 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_17);

}



;; Function void ExampleAppLog::Clear() (_ZN13ExampleAppLog5ClearEv, funcdef_no=442, decl_uid=12788, cgraph_uid=341, symbol_order=517)

void ExampleAppLog::Clear() (struct ExampleAppLog * const this)
{
  struct ImVector * D.17540;
  struct ImGuiTextBuffer * D.17539;
  struct ImGuiTextBuffer * _2;
  struct ImVector * _5;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImGuiTextBuffer::clear (_2);
  _5 = &this_1(D)->LineOffsets;
  ImVector<int>::clear (_5);
  return;

}



;; Function void ExampleAppLog::AddLog(const char*, ...) (_ZN13ExampleAppLog6AddLogEPKcz, funcdef_no=443, decl_uid=12791, cgraph_uid=342, symbol_order=518)

void ExampleAppLog::AddLog(const char*, ...) (struct ExampleAppLog * const this, const char * fmt)
{
  int new_size;
  struct  args[1];
  int old_size;
  int old_size.593;
  int old_size.592;
  struct ImVector * D.17427;
  char D.17424;
  struct ImGuiTextBuffer * D.17423;
  int old_size.591;
  bool retval.590;
  int old_size.589;
  struct ImGuiTextBuffer * D.17417;
  struct ImGuiTextBuffer * D.17416;
  int old_size.588;
  struct ImGuiTextBuffer * D.17414;
  struct ImGuiTextBuffer * _5;
  int old_size.588_8;
  struct ImGuiTextBuffer * _11;
  struct ImGuiTextBuffer * _15;
  int old_size.589_18;
  int old_size.591_19;
  struct ImGuiTextBuffer * _20;
  char _22;
  bool retval.590_23;
  struct ImVector * _24;
  int old_size.592_26;
  int old_size.593_27;

  <bb 2>:
  _5 = &this_4(D)->Buf;
  old_size.588_8 = ImGuiTextBuffer::size (_5);
  old_size = old_size.588_8;
  __builtin_va_start (&args, 0);
  _11 = &this_4(D)->Buf;
  ImGuiTextBuffer::appendfv (_11, fmt_12(D), &args);
  __builtin_va_end (&args);
  _15 = &this_4(D)->Buf;
  new_size_17 = ImGuiTextBuffer::size (_15);

  <bb 3>:
  old_size.589_18 = old_size;
  if (old_size.589_18 >= new_size_17)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  old_size.591_19 = old_size;
  _20 = &this_4(D)->Buf;
  _22 = ImGuiTextBuffer::operator[] (_20, old_size.591_19);
  retval.590_23 = _22 == 10;
  if (retval.590_23 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _24 = &this_4(D)->LineOffsets;
  ImVector<int>::push_back (_24, &old_size);

  <bb 6>:
  old_size.592_26 = old_size;
  old_size.593_27 = old_size.592_26 + 1;
  old_size = old_size.593_27;
  goto <bb 3>;

  <bb 7>:
  this_4(D)->ScrollToBottom = 1;
  old_size ={v} {CLOBBER};
  args ={v} {CLOBBER};
  return;

}



;; Function void ExampleAppLog::Draw(const char*, bool*) (_ZN13ExampleAppLog4DrawEPKcPb, funcdef_no=444, decl_uid=12795, cgraph_uid=343, symbol_order=519)

void ExampleAppLog::Draw(const char*, bool*) (struct ExampleAppLog * const this, const char * title, bool * p_open)
{
  const char * D.17538;
  bool D.17537;
  const char * D.17536;
  bool D.17535;
  bool D.17532;
  bool D.17530;
  const char * line_end;
  int line_no;
  const char * line;
  const char * buf_begin;
  bool copy;
  bool D.17525;
  const char * D.17524;
  struct ImGuiTextBuffer * D.17523;
  char D.17520;
  const char * D.17519;
  const char * iftmp.600;
  struct ImGuiTextFilter * D.17511;
  bool retval.599;
  sizetype D.17508;
  int D.17507;
  value_type & D.17506;
  struct ImVector * D.17505;
  int D.17502;
  const char * iftmp.598;
  struct ImGuiTextBuffer * D.17498;
  struct ImGuiTextFilter * D.17495;
  bool retval.597;
  struct ImVec2 D.12813;
  struct ImGuiTextFilter * D.17490;
  struct ImVec2 D.12812;
  struct ImVec2 D.12810;
  bool retval.596;
  struct ImVec2 D.12809;
  const char * iftmp.598_3;
  const char * iftmp.600_4;
  bool _21;
  bool retval.596_22;
  bool _29;
  struct ImGuiTextFilter * _33;
  struct ImGuiTextFilter * _40;
  bool _42;
  bool retval.597_43;
  struct ImGuiTextBuffer * _44;
  const char * _46;
  int _50;
  struct ImVector * _51;
  value_type & _53;
  int _54;
  sizetype _55;
  const char * iftmp.598_56;
  const char * iftmp.598_57;
  struct ImGuiTextFilter * _59;
  bool _61;
  bool retval.599_62;
  const char * _64;
  char _65;
  const char * iftmp.600_66;
  const char * iftmp.600_67;
  struct ImGuiTextBuffer * _70;
  const char * _72;
  const char * _73;
  bool _75;

  <bb 2>:
  ImVec2::ImVec2 (&D.12809, 5.0e+2, 4.0e+2);
  ImGui::SetNextWindowSize (&D.12809, 4);
  D.12809 ={v} {CLOBBER};
  ImGui::Begin (title_16(D), p_open_17(D), 0);
  ImVec2::ImVec2 (&D.12810, 0.0, 0.0);
  _21 = ImGui::Button ("Clear", &D.12810);
  retval.596_22 = _21;
  D.12810 ={v} {CLOBBER};
  if (retval.596_22 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ExampleAppLog::Clear (this_24(D));

  <bb 4>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12812, 0.0, 0.0);
  _29 = ImGui::Button ("Copy", &D.12812);
  copy_30 = _29;
  D.12812 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  _33 = &this_24(D)->Filter;
  ImGuiTextFilter::Draw (_33, "Filter", -1.0e+2);
  ImGui::Separator ();
  ImVec2::ImVec2 (&D.12813, 0.0, 0.0);
  ImGui::BeginChild ("scrolling", &D.12813, 0, 2048);
  D.12813 ={v} {CLOBBER};
  if (copy_30 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::LogToClipboard (-1);

  <bb 6>:
  _40 = &this_24(D)->Filter;
  _42 = ImGuiTextFilter::IsActive (_40);
  retval.597_43 = _42;
  if (retval.597_43 != 0)
    goto <bb 7>;
  else
    goto <bb 20>;

  <bb 7>:
  _44 = &this_24(D)->Buf;
  _46 = ImGuiTextBuffer::begin (_44);
  buf_begin_47 = _46;
  line_48 = buf_begin_47;
  line_no_49 = 0;

  <bb 8>:
  # line_1 = PHI <line_48(7), line_68(18)>
  # line_no_2 = PHI <line_no_49(7), line_no_69(18)>
  if (line_1 == 0B)
    goto <bb 19>;
  else
    goto <bb 9>;

  <bb 9>:
  _50 = this_24(D)->LineOffsets.Size;
  if (_50 > line_no_2)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _51 = &this_24(D)->LineOffsets;
  _53 = ImVector<int>::operator[] (_51, line_no_2);
  _54 = *_53;
  _55 = (sizetype) _54;
  iftmp.598_56 = buf_begin_47 + _55;
  goto <bb 12>;

  <bb 11>:
  iftmp.598_57 = 0B;

  <bb 12>:
  # iftmp.598_3 = PHI <iftmp.598_56(10), iftmp.598_57(11)>
  line_end_58 = iftmp.598_3;
  _59 = &this_24(D)->Filter;
  _61 = ImGuiTextFilter::PassFilter (_59, line_1, line_end_58);
  retval.599_62 = _61;
  if (retval.599_62 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  ImGui::TextUnformatted (line_1, line_end_58);

  <bb 14>:
  if (line_end_58 != 0B)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  _64 = line_end_58 + 1;
  _65 = *_64;
  if (_65 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.600_66 = line_end_58 + 1;
  goto <bb 18>;

  <bb 17>:
  iftmp.600_67 = 0B;

  <bb 18>:
  # iftmp.600_4 = PHI <iftmp.600_66(16), iftmp.600_67(17)>
  line_68 = iftmp.600_4;
  line_no_69 = line_no_2 + 1;
  goto <bb 8>;

  <bb 19>:
  goto <bb 21>;

  <bb 20>:
  _70 = &this_24(D)->Buf;
  _72 = ImGuiTextBuffer::begin (_70);
  _73 = _72;
  ImGui::TextUnformatted (_73, 0B);

  <bb 21>:
  _75 = this_24(D)->ScrollToBottom;
  if (_75 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  ImGui::SetScrollHere (1.0e+0);

  <bb 23>:
  this_24(D)->ScrollToBottom = 0;
  ImGui::EndChild ();
  ImGui::End ();
  return;

}



;; Function ImGuiTextBuffer::~ImGuiTextBuffer() (_ZN15ImGuiTextBufferD2Ev, funcdef_no=448, decl_uid=12848, cgraph_uid=345, symbol_order=522)

ImGuiTextBuffer::~ImGuiTextBuffer() (struct ImGuiTextBuffer * const this)
{
  struct ImVector * D.17351;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImVector<char>::~ImVector (_2);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function ExampleAppLog::ExampleAppLog() (_ZN13ExampleAppLogC2Ev, funcdef_no=450, decl_uid=12855, cgraph_uid=348, symbol_order=525)

ExampleAppLog::ExampleAppLog() (struct ExampleAppLog * const this)
{
  void * D.18700;
  struct ImGuiTextBuffer * D.17362;
  struct ImGuiTextFilter * D.17361;
  struct ImVector * D.17360;
  struct ImVector * D.17359;
  struct ImGuiTextFilter * D.17358;
  struct ImGuiTextBuffer * D.17357;
  struct ImGuiTextBuffer * _2;
  struct ImGuiTextFilter * _5;
  struct ImVector * _7;
  struct ImGuiTextBuffer * _9;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImGuiTextBuffer::ImGuiTextBuffer (_2);
  _5 = &this_1(D)->Filter;
  ImGuiTextFilter::ImGuiTextFilter (_5, "");

  <bb 3>:
  _7 = &this_1(D)->LineOffsets;
  ImVector<int>::ImVector (_7);
  return;

<L0>:
  _9 = &this_1(D)->Buf;
  ImGuiTextBuffer::~ImGuiTextBuffer (_9);
  _11 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_11);

}



;; Function ExampleAppLog::~ExampleAppLog() (_ZN13ExampleAppLogD2Ev, funcdef_no=453, decl_uid=12893, cgraph_uid=351, symbol_order=529)

ExampleAppLog::~ExampleAppLog() (struct ExampleAppLog * const this)
{
  struct ImGuiTextBuffer * D.17345;
  struct ImGuiTextFilter * D.17344;
  struct ImVector * D.17343;
  struct ImVector * _2;
  struct ImGuiTextFilter * _5;
  struct ImGuiTextBuffer * _7;

  <bb 2>:
  _2 = &this_1(D)->LineOffsets;
  ImVector<int>::~ImVector (_2);
  _5 = &this_1(D)->Filter;
  ImGuiTextFilter::~ImGuiTextFilter (_5);
  _7 = &this_1(D)->Buf;
  ImGuiTextBuffer::~ImGuiTextBuffer (_7);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function void ShowExampleAppLog(bool*) (_ZL17ShowExampleAppLogPb, funcdef_no=445, decl_uid=11337, cgraph_uid=353, symbol_order=532)

void ShowExampleAppLog(bool*) (bool * p_open)
{
  void * D.18701;
  int D.17341;
  struct ImGuiIO & D.17340;
  float D.17339;
  const char * random_words[7];
  float time;
  static float last_time = -1.0e+0;
  static struct ExampleAppLog log;
  const char * D.17336;
  int D.17335;
  int D.17334;
  double D.17333;
  int D.17332;
  bool D.17328;
  bool D.17327;
  struct ImGuiIO & D.17326;
  float D.17324;
  float last_time.585;
  bool iftmp.584;
  bool retval.583;
  bool D.12886;
  int D.17311;
  bool retval.582;
  unsigned char D.17307;
  bool retval.581;
  bool iftmp.584_1;
  unsigned char _9;
  bool retval.581_10;
  int _12;
  bool retval.582_13;
  bool _14;
  bool _16;
  float _21;
  float last_time.585_23;
  float _24;
  struct ImGuiIO & _26;
  struct ImGuiIO & _27;
  bool _28;
  bool _29;
  bool iftmp.584_30;
  bool iftmp.584_31;
  bool retval.583_32;
  int _41;
  int _42;
  double _43;
  int _45;
  int _46;
  const char * _47;

  <bb 2>:
  _9 = __atomic_load_1 (&_ZGVZL17ShowExampleAppLogPbE3log, 2);
  retval.581_10 = _9 == 0;
  if (retval.581_10 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _12 = __cxa_guard_acquire (&_ZGVZL17ShowExampleAppLogPbE3log);
  retval.582_13 = _12 != 0;
  if (retval.582_13 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _14 = 0;
  ExampleAppLog::ExampleAppLog (&log);

  <bb 5>:
  _16 = 1;
  __cxa_guard_release (&_ZGVZL17ShowExampleAppLogPbE3log);
  __cxa_atexit (__comp_dtor , &log, &__dso_handle);

  <bb 6>:
  _21 = ImGui::GetTime ();
  time_22 = _21;
  last_time.585_23 = last_time;
  _24 = time_22 - last_time.585_23;
  if (_24 >= 2.0000000298023223876953125e-1)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _26 = ImGui::GetIO ();
  _27 = _26;
  _28 = _27->KeyCtrl;
  _29 = ~_28;
  if (_29 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.584_30 = 1;
  goto <bb 10>;

  <bb 9>:
  iftmp.584_31 = 0;

  <bb 10>:
  # iftmp.584_1 = PHI <iftmp.584_30(8), iftmp.584_31(9)>
  retval.583_32 = iftmp.584_1;
  if (retval.583_32 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  random_words[0] = "system";
  random_words[1] = "info";
  random_words[2] = "warning";
  random_words[3] = "error";
  random_words[4] = "fatal";
  random_words[5] = "notice";
  random_words[6] = "log";
  _41 = ImGui::GetFrameCount ();
  _42 = _41;
  _43 = (double) time_22;
  _45 = rand ();
  _46 = _45 % 7;
  _47 = random_words[_46];
  ExampleAppLog::AddLog (&log, "[%s] Hello, time is %.1f, frame count is %d\n", _47, _43, _42);
  last_time = time_22;
  random_words ={v} {CLOBBER};

  <bb 12>:
  ExampleAppLog::Draw (&log, "Example: Log", p_open_52(D));
  return;

<L13>:
  if (_14 != 0)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  __cxa_guard_abort (&_ZGVZL17ShowExampleAppLogPbE3log);

  <bb 15>:
  _6 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_6);

}



;; Function void ShowExampleAppLayout(bool*) (_ZL20ShowExampleAppLayoutPb, funcdef_no=455, decl_uid=11339, cgraph_uid=354, symbol_order=534)

void ShowExampleAppLayout(bool*) (bool * p_open)
{
  bool D.17630;
  bool D.17628;
  float D.17626;
  bool D.17623;
  bool D.17621;
  bool D.17620;
  bool D.17619;
  bool D.17618;
  char label[128];
  int i;
  static int selected = 0;
  struct ImVec2 D.12917;
  bool retval.609;
  struct ImVec2 D.12916;
  bool retval.608;
  int selected.607;
  float D.17606;
  float D.17605;
  struct ImVec2 D.12915;
  int D.17601;
  bool D.17600;
  int selected.606;
  struct ImVec2 D.12914;
  bool retval.605;
  struct ImVec2 D.12911;
  bool retval.604;
  bool retval.603;
  bool retval.602;
  bool retval.601;
  struct ImVec2 D.12909;
  bool _14;
  bool retval.601_15;
  bool _17;
  bool retval.602_18;
  bool _20;
  bool retval.603_21;
  bool _23;
  bool retval.604_24;
  int selected.606_34;
  bool _35;
  int _36;
  bool _38;
  bool retval.605_39;
  float _50;
  float _51;
  float _52;
  int selected.607_56;
  bool _63;
  bool retval.608_64;
  bool _69;
  bool retval.609_70;

  <bb 2>:
  ImVec2::ImVec2 (&D.12909, 5.0e+2, 4.4e+2);
  ImGui::SetNextWindowSize (&D.12909, 4);
  D.12909 ={v} {CLOBBER};
  _14 = ImGui::Begin ("Example: Layout", p_open_12(D), 1024);
  retval.601_15 = _14;
  if (retval.601_15 != 0)
    goto <bb 3>;
  else
    goto <bb 17>;

  <bb 3>:
  _17 = ImGui::BeginMenuBar ();
  retval.602_18 = _17;
  if (retval.602_18 != 0)
    goto <bb 4>;
  else
    goto <bb 9>;

  <bb 4>:
  _20 = ImGui::BeginMenu ("File", 1);
  retval.603_21 = _20;
  if (retval.603_21 != 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _23 = ImGui::MenuItem ("Close", 0B, 0, 1);
  retval.604_24 = _23;
  if (retval.604_24 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  *p_open_12(D) = 0;

  <bb 7>:
  ImGui::EndMenu ();

  <bb 8>:
  ImGui::EndMenuBar ();

  <bb 9>:
  ImVec2::ImVec2 (&D.12911, 1.5e+2, 0.0);
  ImGui::BeginChild ("left pane", &D.12911, 1, 0);
  D.12911 ={v} {CLOBBER};
  i_31 = 0;

  <bb 10>:
  # i_1 = PHI <i_31(9), i_43(13)>
  if (i_1 > 99)
    goto <bb 14>;
  else
    goto <bb 11>;

  <bb 11>:
  sprintf (&label, "MyObject %d", i_1);
  ImVec2::ImVec2 (&D.12914, 0.0, 0.0);
  selected.606_34 = selected;
  _35 = selected.606_34 == i_1;
  _36 = (int) _35;
  _38 = ImGui::Selectable (&label, _36, 0, &D.12914);
  retval.605_39 = _38;
  D.12914 ={v} {CLOBBER};
  if (retval.605_39 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  selected = i_1;

  <bb 13>:
  label ={v} {CLOBBER};
  i_43 = i_1 + 1;
  goto <bb 10>;

  <bb 14>:
  ImGui::EndChild ();
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::BeginGroup ();
  _50 = ImGui::GetFrameHeightWithSpacing ();
  _51 = _50;
  _52 = -_51;
  ImVec2::ImVec2 (&D.12915, 0.0, _52);
  ImGui::BeginChild ("item view", &D.12915, 0, 0);
  D.12915 ={v} {CLOBBER};
  selected.607_56 = selected;
  ImGui::Text ("MyObject: %d", selected.607_56);
  ImGui::Separator ();
  ImGui::TextWrapped ("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");
  ImGui::EndChild ();
  ImVec2::ImVec2 (&D.12916, 0.0, 0.0);
  _63 = ImGui::Button ("Revert", &D.12916);
  retval.608_64 = _63;
  D.12916 ={v} {CLOBBER};

  <bb 15>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12917, 0.0, 0.0);
  _69 = ImGui::Button ("Save", &D.12917);
  retval.609_70 = _69;
  D.12917 ={v} {CLOBBER};

  <bb 16>:
  ImGui::EndGroup ();

  <bb 17>:
  ImGui::End ();
  return;

}



;; Function static void ShowExampleAppPropertyEditor(bool*)::funcs::ShowDummyObject(const char*, int) (_ZZL28ShowExampleAppPropertyEditorPbEN5funcs15ShowDummyObjectEPKci, funcdef_no=457, decl_uid=12929, cgraph_uid=355, symbol_order=536)

static void ShowExampleAppPropertyEditor(bool*)::funcs::ShowDummyObject(const char*, int) (const char * prefix, int uid)
{
  bool D.17655;
  char label[32];
  int i;
  static float dummy_members[8] = {0.0, 0.0, 1.0e+0, 3.1415998935699462890625e+0, 1.0e+2, 9.99e+2};
  bool node_open;
  float * D.17653;
  float * D.17651;
  struct ImVec2 D.12936;
  bool _13;
  float * _30;
  float * _32;

  <bb 2>:
  ImGui::PushID (uid_8(D));
  ImGui::AlignTextToFramePadding ();
  _13 = ImGui::TreeNode ("Object", "%s_%u", prefix_11(D), uid_8(D));
  node_open_14 = _13;
  ImGui::NextColumn ();
  ImGui::AlignTextToFramePadding ();
  ImGui::Text ("my sailor is rich");
  ImGui::NextColumn ();
  if (node_open_14 != 0)
    goto <bb 3>;
  else
    goto <bb 13>;

  <bb 3>:
  i_19 = 0;

  <bb 4>:
  # i_1 = PHI <i_19(3), i_40(11)>
  if (i_1 > 7)
    goto <bb 12>;
  else
    goto <bb 5>;

  <bb 5>:
  ImGui::PushID (i_1);
  if (i_1 <= 1)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  ShowExampleAppPropertyEditor(bool*)::funcs::ShowDummyObject ("Child", 424242);
  goto <bb 11>;

  <bb 7>:
  ImGui::AlignTextToFramePadding ();
  sprintf (&label, "Field_%d", i_1);
  ImGui::Bullet ();
  ImVec2::ImVec2 (&D.12936, 0.0, 0.0);
  ImGui::Selectable (&label, 0, 0, &D.12936);
  D.12936 ={v} {CLOBBER};
  ImGui::NextColumn ();
  ImGui::PushItemWidth (-1.0e+0);
  if (i_1 > 4)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _30 = &dummy_members[i_1];
  ImGui::InputFloat ("##value", _30, 1.0e+0, 0.0, -1, 0);
  goto <bb 10>;

  <bb 9>:
  _32 = &dummy_members[i_1];
  ImGui::DragFloat ("##value", _32, 9.99999977648258209228515625e-3, 0.0, 0.0, "%.3f", 1.0e+0);

  <bb 10>:
  ImGui::PopItemWidth ();
  ImGui::NextColumn ();
  label ={v} {CLOBBER};

  <bb 11>:
  ImGui::PopID ();
  i_40 = i_1 + 1;
  goto <bb 4>;

  <bb 12>:
  ImGui::TreePop ();

  <bb 13>:
  ImGui::PopID ();
  return;

}



;; Function void ShowExampleAppPropertyEditor(bool*) (_ZL28ShowExampleAppPropertyEditorPb, funcdef_no=456, decl_uid=11341, cgraph_uid=356, symbol_order=537)

void ShowExampleAppPropertyEditor(bool*) (bool * p_open)
{
  bool D.17640;
  int obj_i;
  struct ImVec2 D.12924;
  bool D.17633;
  bool retval.610;
  struct ImVec2 D.12923;
  bool _10;
  bool _11;
  bool retval.610_12;

  <bb 2>:
  ImVec2::ImVec2 (&D.12923, 4.3e+2, 4.5e+2);
  ImGui::SetNextWindowSize (&D.12923, 4);
  D.12923 ={v} {CLOBBER};
  _10 = ImGui::Begin ("Example: Property editor", p_open_8(D), 0);
  _11 = _10;
  retval.610_12 = ~_11;
  if (retval.610_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::End ();
  goto <bb 8> (<L5>);

  <bb 4>:
  ShowHelpMarker ("This example shows how you may implement a property editor using two columns.\nAll objects/fields data are dummies here.\nRemember that in many simple cases, you can use ImGui::SameLine(xxx) to position\nyour cursor horizontally instead of using the Columns() API.");
  ImVec2::ImVec2 (&D.12924, 2.0e+0, 2.0e+0);
  ImGui::PushStyleVar (10, &D.12924);
  D.12924 ={v} {CLOBBER};
  ImGui::Columns (2, 0B, 1);
  ImGui::Separator ();
  obj_i_20 = 0;

  <bb 5>:
  # obj_i_1 = PHI <obj_i_20(4), obj_i_22(6)>
  if (obj_i_1 > 2)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ShowExampleAppPropertyEditor(bool*)::funcs::ShowDummyObject ("Object", obj_i_1);
  obj_i_22 = obj_i_1 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::Columns (1, 0B, 1);
  ImGui::Separator ();
  ImGui::PopStyleVar (1);
  ImGui::End ();

<L5>:
  return;

}



;; Function void ShowExampleAppLongText(bool*) (_ZL22ShowExampleAppLongTextPb, funcdef_no=458, decl_uid=11343, cgraph_uid=357, symbol_order=542)

void ShowExampleAppLongText(bool*) (bool * p_open)
{
  void * D.18732;
  void * D.18731;
  bool D.17717;
  const char * D.17715;
  const char * D.17714;
  bool D.17711;
  bool D.17709;
  bool D.17707;
  int i;
  int i;
  struct ImGuiListClipper clipper;
  int i;
  static int lines = 0;
  static struct ImGuiTextBuffer log;
  static int test_type = 0;
  int lines.623;
  struct ImVec2 D.12961;
  int D.17699;
  bool retval.622;
  int lines.621;
  struct ImVec2 D.12957;
  const char * D.17693;
  const char * D.17692;
  int test_type.620;
  struct ImVec2 D.12954;
  int lines.619;
  int lines.618;
  int D.17687;
  int lines.617;
  struct ImVec2 D.12952;
  bool retval.616;
  struct ImVec2 D.12951;
  bool retval.615;
  int lines.614;
  int D.17675;
  bool D.12949;
  int D.17667;
  bool retval.613;
  unsigned char D.17663;
  bool retval.612;
  bool D.17659;
  bool retval.611;
  struct ImVec2 D.12945;
  bool _21;
  bool _22;
  bool retval.611_23;
  unsigned char _26;
  bool retval.612_27;
  int _29;
  bool retval.613_30;
  bool _31;
  bool _33;
  int _40;
  int lines.614_41;
  bool _45;
  bool retval.615_46;
  bool _53;
  bool retval.616_54;
  int lines.617_57;
  int _58;
  int lines.618_61;
  int lines.619_62;
  int test_type.620_67;
  const char * _69;
  const char * _70;
  const char * _72;
  const char * _73;
  int lines.621_78;
  bool _81;
  bool retval.622_82;
  int _84;
  int lines.623_97;

  <bb 2>:
  ImVec2::ImVec2 (&D.12945, 5.2e+2, 6.0e+2);
  ImGui::SetNextWindowSize (&D.12945, 4);
  D.12945 ={v} {CLOBBER};
  _21 = ImGui::Begin ("Example: Long text display", p_open_19(D), 0);
  _22 = _21;
  retval.611_23 = ~_22;
  if (retval.611_23 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::End ();
  goto <bb 33> (<L33>);

  <bb 4>:
  _26 = __atomic_load_1 (&_ZGVZL22ShowExampleAppLongTextPbE3log, 2);
  retval.612_27 = _26 == 0;
  if (retval.612_27 != 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _29 = __cxa_guard_acquire (&_ZGVZL22ShowExampleAppLongTextPbE3log);
  retval.613_30 = _29 != 0;
  if (retval.613_30 != 0)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _31 = 0;
  ImGuiTextBuffer::ImGuiTextBuffer (&log);

  <bb 7>:
  _33 = 1;
  __cxa_guard_release (&_ZGVZL22ShowExampleAppLongTextPbE3log);
  __cxa_atexit (__comp_dtor , &log, &__dso_handle);

  <bb 8>:
  ImGui::Text ("Printing unusually long amount of text.");
  ImGui::Combo ("Test type", &test_type, "Single call to TextUnformatted()", -1);
  _40 = ImGuiTextBuffer::size (&log);
  lines.614_41 = lines;
  ImGui::Text ("Buffer contents: %d lines, %d bytes", lines.614_41, _40);
  ImVec2::ImVec2 (&D.12951, 0.0, 0.0);
  _45 = ImGui::Button ("Clear", &D.12951);
  retval.615_46 = _45;
  D.12951 ={v} {CLOBBER};
  if (retval.615_46 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  ImGuiTextBuffer::clear (&log);
  lines = 0;

  <bb 10>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.12952, 0.0, 0.0);
  _53 = ImGui::Button ("Add 1000 lines", &D.12952);
  retval.616_54 = _53;
  D.12952 ={v} {CLOBBER};
  if (retval.616_54 != 0)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  i_56 = 0;

  <bb 12>:
  # i_1 = PHI <i_56(11), i_60(13)>
  if (i_1 > 999)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  lines.617_57 = lines;
  _58 = lines.617_57 + i_1;
  ImGuiTextBuffer::appendf (&log, "%i The quick brown fox jumps over the lazy dog\n", _58);
  i_60 = i_1 + 1;
  goto <bb 12>;

  <bb 14>:
  lines.618_61 = lines;
  lines.619_62 = lines.618_61 + 1000;
  lines = lines.619_62;

  <bb 15>:
  ImVec2::ImVec2 (&D.12954, 0.0, 0.0);
  ImGui::BeginChild ("Log", &D.12954, 0, 0);
  D.12954 ={v} {CLOBBER};
  test_type.620_67 = test_type;
  switch (test_type.620_67) <default: <L31>, case 0: <L17>, case 1: <L18>, case 2: <L27>>

<L17>:
  _69 = ImGuiTextBuffer::end (&log);
  _70 = _69;
  _72 = ImGuiTextBuffer::begin (&log);
  _73 = _72;
  ImGui::TextUnformatted (_73, _70);
  goto <bb 32> (<L31>);

<L18>:
  ImVec2::ImVec2 (&D.12957, 0.0, 0.0);
  ImGui::PushStyleVar (13, &D.12957);
  D.12957 ={v} {CLOBBER};
  lines.621_78 = lines;
  ImGuiListClipper::ImGuiListClipper (&clipper, lines.621_78, -1.0e+0);

  <bb 18>:
  _81 = ImGuiListClipper::Step (&clipper);

  <bb 19>:
  retval.622_82 = _81;
  if (retval.622_82 != 0)
    goto <bb 20>;
  else
    goto <bb 25>;

  <bb 20>:
  i_83 = clipper.DisplayStart;

  <bb 21>:
  # i_2 = PHI <i_83(20), i_86(23)>
  _84 = clipper.DisplayEnd;
  if (_84 <= i_2)
    goto <bb 24>;
  else
    goto <bb 22>;

  <bb 22>:
  ImGui::Text ("%i The quick brown fox jumps over the lazy dog", i_2);

  <bb 23>:
  i_86 = i_2 + 1;
  goto <bb 21>;

  <bb 24>:
  goto <bb 18>;

  <bb 25>:
  ImGui::PopStyleVar (1);

  <bb 26>:

  <bb 27>:
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  clipper ={v} {CLOBBER};
  goto <bb 32> (<L31>);

<L27>:
  ImVec2::ImVec2 (&D.12961, 0.0, 0.0);
  ImGui::PushStyleVar (13, &D.12961);
  D.12961 ={v} {CLOBBER};
  i_96 = 0;

  <bb 29>:
  # i_3 = PHI <i_96(28), i_99(30)>
  lines.623_97 = lines;
  if (i_3 >= lines.623_97)
    goto <bb 31>;
  else
    goto <bb 30>;

  <bb 30>:
  ImGui::Text ("%i The quick brown fox jumps over the lazy dog", i_3);
  i_99 = i_3 + 1;
  goto <bb 29>;

  <bb 31>:
  ImGui::PopStyleVar (1);

<L31>:
  ImGui::EndChild ();
  ImGui::End ();

<L33>:
  return;

<L35>:
  if (_31 != 0)
    goto <bb 36>;
  else
    goto <bb 35>;

  <bb 35>:
  __cxa_guard_abort (&_ZGVZL22ShowExampleAppLongTextPbE3log);

  <bb 36>:
  _14 = __builtin_eh_pointer (3);
  __builtin_unwind_resume (_14);

<L43>:
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  _101 = __builtin_eh_pointer (14);
  __builtin_unwind_resume (_101);

}



;; Function bool ImVector<T>::empty() const [with T = ImGuiTextFilter::TextRange] (_ZNK8ImVectorIN15ImGuiTextFilter9TextRangeEE5emptyEv, funcdef_no=459, decl_uid=4260, cgraph_uid=358, symbol_order=543)

bool ImVector<T>::empty() const [with T = ImGuiTextFilter::TextRange] (const struct ImVector * const this)
{
  int D.17561;
  bool D.17560;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::ImVector() [with T = char] (_ZN8ImVectorIcEC2Ev, funcdef_no=461, decl_uid=4481, cgraph_uid=360, symbol_order=545)

ImVector<T>::ImVector() [with T = char] (struct ImVector * const this)
{
  int D.17369;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = char] (_ZN8ImVectorIcED2Ev, funcdef_no=464, decl_uid=4486, cgraph_uid=363, symbol_order=548)

ImVector<T>::~ImVector() [with T = char] (struct ImVector * const this)
{
  char * D.17355;
  char * D.17352;
  char * _4;
  char * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = char] (_ZN8ImVectorIcE9push_backERKc, funcdef_no=466, decl_uid=4455, cgraph_uid=365, symbol_order=550)

void ImVector<T>::push_back(const value_type&) [with T = char] (struct ImVector * const this, const value_type & v)
{
  int D.17384;
  int D.17383;
  unsigned char D.17382;
  char * D.17381;
  sizetype D.17380;
  int D.17379;
  char * D.17378;
  int D.17376;
  int D.17375;
  int D.17374;
  int D.17371;
  int D.17370;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  char * _11;
  int _12;
  sizetype _13;
  char * _14;
  unsigned char _16;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<char>::_grow_capacity (this_3(D), _7);
  ImVector<char>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (sizetype) _12;
  _14 = _11 + _13;
  _16 = MEM[(char * {ref-all})v_15(D)];
  MEM[(char * {ref-all})_14] = _16;
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function const value_type& ImVector<T>::front() const [with T = char] (_ZNK8ImVectorIcE5frontEv, funcdef_no=467, decl_uid=4433, cgraph_uid=366, symbol_order=551)

const value_type& ImVector<T>::front() const [with T = char] (const struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[93] = "const value_type& ImVector<T>::front() const [with T = char; ImVector<T>::value_type = char]";
  const value_type & D.17579;
  int D.17575;
  int _3;
  const value_type & _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1178, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;

<L3>:
  return _4;

}



;; Function const value_type& ImVector<T>::back() const [with T = char] (_ZNK8ImVectorIcE4backEv, funcdef_no=468, decl_uid=4437, cgraph_uid=367, symbol_order=552)

const value_type& ImVector<T>::back() const [with T = char] (const struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[92] = "const value_type& ImVector<T>::back() const [with T = char; ImVector<T>::value_type = char]";
  sizetype D.17734;
  sizetype D.17733;
  int D.17732;
  char * D.17731;
  const value_type & D.17730;
  int D.17726;
  int _3;
  char * _4;
  int _5;
  sizetype _6;
  sizetype _7;
  const value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1180, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (sizetype) _5;
  _7 = _6 + 18446744073709551615;
  _8 = _4 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::clear() [with T = char] (_ZN8ImVectorIcE5clearEv, funcdef_no=469, decl_uid=4421, cgraph_uid=368, symbol_order=553)

void ImVector<T>::clear() [with T = char] (struct ImVector * const this)
{
  char * D.17548;
  int D.17547;
  char * D.17544;
  char * _4;
  int _6;
  char * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::reserve(int) [with T = char] (_ZN8ImVectorIcE7reserveEi, funcdef_no=470, decl_uid=4452, cgraph_uid=369, symbol_order=554)

void ImVector<T>::reserve(int) [with T = char] (struct ImVector * const this, int new_capacity)
{
  value_type * D.17412;
  value_type * new_data;
  char * D.17410;
  char * D.17408;
  long unsigned int D.17407;
  int D.17406;
  char * D.17403;
  long unsigned int D.17402;
  int D.17399;
  int _5;
  long unsigned int _7;
  value_type * _9;
  char * _11;
  int _12;
  long unsigned int _13;
  char * _14;
  char * _16;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _9 = ImGui::MemAlloc (_7);
  new_data_10 = _9;
  _11 = this_4(D)->Data;
  if (_11 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _12 = this_4(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = this_4(D)->Data;
  memcpy (new_data_10, _14, _13);

  <bb 6>:
  _16 = this_4(D)->Data;
  ImGui::MemFree (_16);
  this_4(D)->Data = new_data_10;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImVec2] (_ZN8ImVectorI6ImVec2EC2Ev, funcdef_no=503, decl_uid=5683, cgraph_uid=402, symbol_order=587)

ImVector<T>::ImVector() [with T = ImVec2] (struct ImVector * const this)
{
  int D.16620;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImVec2] (_ZN8ImVectorI6ImVec2ED2Ev, funcdef_no=506, decl_uid=5688, cgraph_uid=405, symbol_order=590)

ImVector<T>::~ImVector() [with T = ImVec2] (struct ImVector * const this)
{
  struct ImVec2 * D.16613;
  struct ImVec2 * D.16610;
  struct ImVec2 * _4;
  struct ImVec2 * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImVec2] (_ZN8ImVectorI6ImVec2E9push_backERKS0_, funcdef_no=516, decl_uid=5657, cgraph_uid=415, symbol_order=600)

void ImVector<T>::push_back(const value_type&) [with T = ImVec2] (struct ImVector * const this, const struct value_type & v)
{
  int D.16642;
  int D.16641;
  long unsigned int D.16640;
  struct ImVec2 * D.16639;
  long unsigned int D.16638;
  long unsigned int D.16637;
  int D.16636;
  struct ImVec2 * D.16635;
  int D.16633;
  int D.16632;
  int D.16631;
  int D.16628;
  int D.16627;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImVec2 * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImVec2 * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImVec2>::_grow_capacity (this_3(D), _7);
  ImVector<ImVec2>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImVec2] (_ZN8ImVectorI6ImVec2EixEi, funcdef_no=517, decl_uid=5617, cgraph_uid=416, symbol_order=601)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImVec2] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[106] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImVec2; ImVector<T>::value_type = ImVec2]";
  long unsigned int D.16683;
  long unsigned int D.16682;
  struct ImVec2 * D.16681;
  struct value_type & D.16680;
  int D.16676;
  int _3;
  struct ImVec2 * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEED2Ev, funcdef_no=529, decl_uid=4337, cgraph_uid=428, symbol_order=613)

ImVector<T>::~ImVector() [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this)
{
  struct TextRange * D.15404;
  struct TextRange * D.15401;
  struct TextRange * _4;
  struct TextRange * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImFont*] (_ZN8ImVectorIP6ImFontEixEi, funcdef_no=531, decl_uid=6522, cgraph_uid=430, symbol_order=615)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImFont*] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[108] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImFont*; ImVector<T>::value_type = ImFont*]";
  long unsigned int D.15518;
  long unsigned int D.15517;
  struct ImFont * * D.15516;
  struct ImFont * & D.15515;
  int D.15511;
  int _3;
  struct ImFont * * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct ImFont * & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::clear() [with T = ImVec2] (_ZN8ImVectorI6ImVec2E5clearEv, funcdef_no=532, decl_uid=5623, cgraph_uid=431, symbol_order=616)

void ImVector<T>::clear() [with T = ImVec2] (struct ImVector * const this)
{
  struct ImVec2 * D.16625;
  int D.16624;
  struct ImVec2 * D.16621;
  struct ImVec2 * _4;
  int _6;
  struct ImVec2 * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::pop_back() [with T = ImVec2] (_ZN8ImVectorI6ImVec2E8pop_backEv, funcdef_no=533, decl_uid=5660, cgraph_uid=432, symbol_order=617)

void ImVector<T>::pop_back() [with T = ImVec2] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[47] = "void ImVector<T>::pop_back() [with T = ImVec2]";
  int D.16690;
  int D.16689;
  int D.16685;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = ImVec2] (_ZNK8ImVectorI6ImVec2E5emptyEv, funcdef_no=534, decl_uid=5611, cgraph_uid=433, symbol_order=618)

bool ImVector<T>::empty() const [with T = ImVec2] (const struct ImVector * const this)
{
  int D.16674;
  bool D.16673;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::ImVector() [with T = char*] (_ZN8ImVectorIPcEC2Ev, funcdef_no=536, decl_uid=12392, cgraph_uid=435, symbol_order=620)

ImVector<T>::ImVector() [with T = char*] (struct ImVector * const this)
{
  int D.16764;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = char*] (_ZN8ImVectorIPcED2Ev, funcdef_no=539, decl_uid=12397, cgraph_uid=438, symbol_order=623)

ImVector<T>::~ImVector() [with T = char*] (struct ImVector * const this)
{
  char * * D.16744;
  char * * D.16741;
  char * * _4;
  char * * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = const char*] (_ZN8ImVectorIPKcEC2Ev, funcdef_no=542, decl_uid=12498, cgraph_uid=441, symbol_order=626)

ImVector<T>::ImVector() [with T = const char*] (struct ImVector * const this)
{
  int D.16765;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = const char*] (_ZN8ImVectorIPKcED2Ev, funcdef_no=545, decl_uid=12503, cgraph_uid=444, symbol_order=629)

ImVector<T>::~ImVector() [with T = const char*] (struct ImVector * const this)
{
  const char * * D.16739;
  const char * * D.16736;
  const char * * _4;
  const char * * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = const char*] (_ZN8ImVectorIPKcE9push_backERKS1_, funcdef_no=547, decl_uid=12472, cgraph_uid=446, symbol_order=631)

void ImVector<T>::push_back(const value_type&) [with T = const char*] (struct ImVector * const this, const char * const & v)
{
  int D.16781;
  int D.16780;
  long unsigned int D.16779;
  const char * * D.16778;
  long unsigned int D.16777;
  long unsigned int D.16776;
  int D.16775;
  const char * * D.16774;
  int D.16772;
  int D.16771;
  int D.16770;
  int D.16767;
  int D.16766;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  const char * * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  const char * * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<const char*>::_grow_capacity (this_3(D), _7);
  ImVector<const char*>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = char*] (_ZN8ImVectorIPcEixEi, funcdef_no=548, decl_uid=12326, cgraph_uid=447, symbol_order=632)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = char*] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[104] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = char*; ImVector<T>::value_type = char*]";
  long unsigned int D.16734;
  long unsigned int D.16733;
  char * * D.16732;
  char * & D.16731;
  int D.16727;
  int _3;
  char * * _5;
  long unsigned int _6;
  long unsigned int _7;
  char * & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::clear() [with T = char*] (_ZN8ImVectorIPcE5clearEv, funcdef_no=549, decl_uid=12332, cgraph_uid=448, symbol_order=633)

void ImVector<T>::clear() [with T = char*] (struct ImVector * const this)
{
  char * * D.16725;
  int D.16724;
  char * * D.16721;
  char * * _4;
  int _6;
  char * * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = char*] (_ZN8ImVectorIPcE9push_backERKS0_, funcdef_no=550, decl_uid=12366, cgraph_uid=449, symbol_order=634)

void ImVector<T>::push_back(const value_type&) [with T = char*] (struct ImVector * const this, char * const & v)
{
  int D.16834;
  int D.16833;
  long unsigned int D.16832;
  char * * D.16831;
  long unsigned int D.16830;
  long unsigned int D.16829;
  int D.16828;
  char * * D.16827;
  int D.16825;
  int D.16824;
  int D.16823;
  int D.16820;
  int D.16819;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  char * * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  char * * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<char*>::_grow_capacity (this_3(D), _7);
  ImVector<char*>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::begin() [with T = char*] (_ZN8ImVectorIPcE5beginEv, funcdef_no=551, decl_uid=12334, cgraph_uid=450, symbol_order=635)

ImVector<T>::value_type* ImVector<T>::begin() [with T = char*] (struct ImVector * const this)
{
  char * * D.17251;
  char * * _3;

  <bb 2>:
  _3 = this_2(D)->Data;

<L0>:
  return _3;

}



;; Function ImVector<T>::value_type* ImVector<T>::erase(ImVector<T>::const_iterator) [with T = char*] (_ZN8ImVectorIPcE5eraseEPKS0_, funcdef_no=552, decl_uid=12374, cgraph_uid=451, symbol_order=636)

ImVector<T>::value_type* ImVector<T>::erase(ImVector<T>::const_iterator) [with T = char*] (struct ImVector * const this, char * const * it)
{
  const ptrdiff_t off;
  static const char __PRETTY_FUNCTION__[199] = "ImVector<T>::value_type* ImVector<T>::erase(ImVector<T>::const_iterator) [with T = char*; ImVector<T>::iterator = char**; ImVector<T>::value_type = char*; ImVector<T>::const_iterator = char* const*]";
  long unsigned int D.17287;
  long unsigned int off.578;
  char * * D.17285;
  char * * D.17284;
  int D.17283;
  int D.17282;
  char * * D.17281;
  long unsigned int D.17280;
  long unsigned int off.577;
  char * * D.17278;
  char * * D.17277;
  sizetype D.17276;
  sizetype D.17275;
  sizetype off.576;
  char * * D.17273;
  long unsigned int D.17272;
  long unsigned int D.17271;
  long unsigned int D.17270;
  long unsigned int off.575;
  long unsigned int D.17268;
  int D.17267;
  long int D.17266;
  long int D.17265;
  char * * D.17264;
  long int it.574;
  char * * D.17261;
  long unsigned int D.17260;
  long unsigned int D.17259;
  int D.17258;
  char * * D.17257;
  char * * D.17255;
  char * * _3;
  char * * _5;
  int _6;
  long unsigned int _7;
  long unsigned int _8;
  char * * _9;
  long int it.574_10;
  char * * _11;
  long int _12;
  long int _13;
  int _15;
  long unsigned int _16;
  long unsigned int off.575_17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  char * * _21;
  sizetype off.576_22;
  sizetype _23;
  sizetype _24;
  char * * _25;
  char * * _26;
  long unsigned int off.577_27;
  long unsigned int _28;
  char * * _29;
  int _31;
  int _32;
  char * * _34;
  long unsigned int off.578_35;
  long unsigned int _36;
  char * * _37;

  <bb 2>:
  _3 = this_2(D)->Data;
  if (_3 <= it_4(D))
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _5 = this_2(D)->Data;
  _6 = this_2(D)->Size;
  _7 = (long unsigned int) _6;
  _8 = _7 * 8;
  _9 = _5 + _8;
  if (_9 > it_4(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("it >= Data && it < Data+Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1202, &__PRETTY_FUNCTION__);

  <bb 6>:
  it.574_10 = (long int) it_4(D);
  _11 = this_2(D)->Data;
  _12 = (long int) _11;
  _13 = it.574_10 - _12;
  off_14 = _13 /[ex] 8;
  _15 = this_2(D)->Size;
  _16 = (long unsigned int) _15;
  off.575_17 = (long unsigned int) off_14;
  _18 = _16 - off.575_17;
  _19 = _18 * 8;
  _20 = _19 + 18446744073709551608;
  _21 = this_2(D)->Data;
  off.576_22 = (sizetype) off_14;
  _23 = off.576_22 + 1;
  _24 = _23 * 8;
  _25 = _21 + _24;
  _26 = this_2(D)->Data;
  off.577_27 = (long unsigned int) off_14;
  _28 = off.577_27 * 8;
  _29 = _26 + _28;
  memmove (_29, _25, _20);
  _31 = this_2(D)->Size;
  _32 = _31 + -1;
  this_2(D)->Size = _32;
  _34 = this_2(D)->Data;
  off.578_35 = (long unsigned int) off_14;
  _36 = off.578_35 * 8;
  _37 = _34 + _36;

<L4>:
  return _37;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = const char*] (_ZN8ImVectorIPKcEixEi, funcdef_no=553, decl_uid=12432, cgraph_uid=452, symbol_order=637)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = const char*] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[116] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = const char*; ImVector<T>::value_type = const char*]";
  long unsigned int D.17199;
  long unsigned int D.17198;
  const char * * D.17197;
  const char * & D.17196;
  int D.17192;
  int _3;
  const char * * _5;
  long unsigned int _6;
  long unsigned int _7;
  const char * & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::clear() [with T = int] (_ZN8ImVectorIiE5clearEv, funcdef_no=554, decl_uid=12715, cgraph_uid=453, symbol_order=638)

void ImVector<T>::clear() [with T = int] (struct ImVector * const this)
{
  int * D.17554;
  int D.17553;
  int * D.17550;
  int * _4;
  int _6;
  int * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = int] (_ZN8ImVectorIiE9push_backERKi, funcdef_no=555, decl_uid=12749, cgraph_uid=454, symbol_order=639)

void ImVector<T>::push_back(const value_type&) [with T = int] (struct ImVector * const this, const value_type & v)
{
  int D.17455;
  int D.17454;
  unsigned int D.17453;
  int * D.17452;
  long unsigned int D.17451;
  long unsigned int D.17450;
  int D.17449;
  int * D.17448;
  int D.17446;
  int D.17445;
  int D.17444;
  int D.17441;
  int D.17440;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  int * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  int * _15;
  unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<int>::_grow_capacity (this_3(D), _7);
  ImVector<int>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 4;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = int] (_ZN8ImVectorIiEixEi, funcdef_no=556, decl_uid=12709, cgraph_uid=455, symbol_order=640)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = int] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[100] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = int; ImVector<T>::value_type = int]";
  long unsigned int D.17570;
  long unsigned int D.17569;
  int * D.17568;
  value_type & D.17567;
  int D.17563;
  int _3;
  int * _5;
  long unsigned int _6;
  long unsigned int _7;
  value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 4;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::ImVector() [with T = int] (_ZN8ImVectorIiEC2Ev, funcdef_no=558, decl_uid=12775, cgraph_uid=457, symbol_order=642)

ImVector<T>::ImVector() [with T = int] (struct ImVector * const this)
{
  int D.17413;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = int] (_ZN8ImVectorIiED2Ev, funcdef_no=561, decl_uid=12780, cgraph_uid=460, symbol_order=645)

ImVector<T>::~ImVector() [with T = int] (struct ImVector * const this)
{
  int * D.17349;
  int * D.17346;
  int * _4;
  int * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = char] (_ZNK8ImVectorIcE14_grow_capacityEi, funcdef_no=563, decl_uid=4442, cgraph_uid=462, symbol_order=647)

int ImVector<T>::_grow_capacity(int) const [with T = char] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.587;
  int D.17393;
  int D.17391;
  int D.17390;
  int D.17389;
  int D.17386;
  int iftmp.586;
  int iftmp.586_1;
  int iftmp.587_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.586_9;
  int iftmp.586_10;
  int iftmp.587_13;
  int iftmp.587_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.586_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.586_10 = 8;

  <bb 5>:
  # iftmp.586_1 = PHI <iftmp.586_9(3), iftmp.586_10(4)>
  new_capacity_11 = iftmp.586_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.587_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.587_14 = sz_12(D);

  <bb 8>:
  # iftmp.587_2 = PHI <iftmp.587_13(6), iftmp.587_14(7)>
  _15 = iftmp.587_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImVec2] (_ZN8ImVectorI6ImVec2E7reserveEi, funcdef_no=564, decl_uid=5654, cgraph_uid=463, symbol_order=648)

void ImVector<T>::reserve(int) [with T = ImVec2] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.16672;
  struct value_type * new_data;
  struct ImVec2 * D.16670;
  struct ImVec2 * D.16668;
  long unsigned int D.16667;
  long unsigned int D.16666;
  int D.16665;
  struct ImVec2 * D.16662;
  long unsigned int D.16661;
  long unsigned int D.16660;
  int D.16657;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImVec2 * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImVec2 * _16;
  struct ImVec2 * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImVec2] (_ZNK8ImVectorI6ImVec2E14_grow_capacityEi, funcdef_no=565, decl_uid=5644, cgraph_uid=464, symbol_order=649)

int ImVector<T>::_grow_capacity(int) const [with T = ImVec2] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.531;
  int D.16651;
  int D.16649;
  int D.16648;
  int D.16647;
  int D.16644;
  int iftmp.530;
  int iftmp.530_1;
  int iftmp.531_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.530_9;
  int iftmp.530_10;
  int iftmp.531_13;
  int iftmp.531_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.530_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.530_10 = 8;

  <bb 5>:
  # iftmp.530_1 = PHI <iftmp.530_9(3), iftmp.530_10(4)>
  new_capacity_11 = iftmp.530_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.531_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.531_14 = sz_12(D);

  <bb 8>:
  # iftmp.531_2 = PHI <iftmp.531_13(6), iftmp.531_14(7)>
  _15 = iftmp.531_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = const char*] (_ZN8ImVectorIPKcE7reserveEi, funcdef_no=568, decl_uid=12469, cgraph_uid=467, symbol_order=652)

void ImVector<T>::reserve(int) [with T = const char*] (struct ImVector * const this, int new_capacity)
{
  const char * * D.16811;
  const char * * new_data;
  const char * * D.16809;
  const char * * D.16807;
  long unsigned int D.16806;
  long unsigned int D.16805;
  int D.16804;
  const char * * D.16801;
  long unsigned int D.16800;
  long unsigned int D.16799;
  int D.16796;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  const char * * _10;
  const char * * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  const char * * _16;
  const char * * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = const char*] (_ZNK8ImVectorIPKcE14_grow_capacityEi, funcdef_no=569, decl_uid=12459, cgraph_uid=468, symbol_order=653)

int ImVector<T>::_grow_capacity(int) const [with T = const char*] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.535;
  int D.16790;
  int D.16788;
  int D.16787;
  int D.16786;
  int D.16783;
  int iftmp.534;
  int iftmp.534_1;
  int iftmp.535_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.534_9;
  int iftmp.534_10;
  int iftmp.535_13;
  int iftmp.535_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.534_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.534_10 = 8;

  <bb 5>:
  # iftmp.534_1 = PHI <iftmp.534_9(3), iftmp.534_10(4)>
  new_capacity_11 = iftmp.534_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.535_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.535_14 = sz_12(D);

  <bb 8>:
  # iftmp.535_2 = PHI <iftmp.535_13(6), iftmp.535_14(7)>
  _15 = iftmp.535_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = char*] (_ZN8ImVectorIPcE7reserveEi, funcdef_no=570, decl_uid=12363, cgraph_uid=469, symbol_order=654)

void ImVector<T>::reserve(int) [with T = char*] (struct ImVector * const this, int new_capacity)
{
  char * * D.16864;
  char * * new_data;
  char * * D.16862;
  char * * D.16860;
  long unsigned int D.16859;
  long unsigned int D.16858;
  int D.16857;
  char * * D.16854;
  long unsigned int D.16853;
  long unsigned int D.16852;
  int D.16849;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  char * * _10;
  char * * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  char * * _16;
  char * * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = char*] (_ZNK8ImVectorIPcE14_grow_capacityEi, funcdef_no=571, decl_uid=12353, cgraph_uid=470, symbol_order=655)

int ImVector<T>::_grow_capacity(int) const [with T = char*] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.537;
  int D.16843;
  int D.16841;
  int D.16840;
  int D.16839;
  int D.16836;
  int iftmp.536;
  int iftmp.536_1;
  int iftmp.537_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.536_9;
  int iftmp.536_10;
  int iftmp.537_13;
  int iftmp.537_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.536_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.536_10 = 8;

  <bb 5>:
  # iftmp.536_1 = PHI <iftmp.536_9(3), iftmp.536_10(4)>
  new_capacity_11 = iftmp.536_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.537_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.537_14 = sz_12(D);

  <bb 8>:
  # iftmp.537_2 = PHI <iftmp.537_13(6), iftmp.537_14(7)>
  _15 = iftmp.537_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = int] (_ZN8ImVectorIiE7reserveEi, funcdef_no=572, decl_uid=12746, cgraph_uid=471, symbol_order=656)

void ImVector<T>::reserve(int) [with T = int] (struct ImVector * const this, int new_capacity)
{
  value_type * D.17485;
  value_type * new_data;
  int * D.17483;
  int * D.17481;
  long unsigned int D.17480;
  long unsigned int D.17479;
  int D.17478;
  int * D.17475;
  long unsigned int D.17474;
  long unsigned int D.17473;
  int D.17470;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  value_type * _10;
  int * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  int * _16;
  int * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 4;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 4;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = int] (_ZNK8ImVectorIiE14_grow_capacityEi, funcdef_no=573, decl_uid=12736, cgraph_uid=472, symbol_order=657)

int ImVector<T>::_grow_capacity(int) const [with T = int] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.595;
  int D.17464;
  int D.17462;
  int D.17461;
  int D.17460;
  int D.17457;
  int iftmp.594;
  int iftmp.594_1;
  int iftmp.595_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.594_9;
  int iftmp.594_10;
  int iftmp.595_13;
  int iftmp.595_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.594_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.594_10 = 8;

  <bb 5>:
  # iftmp.594_1 = PHI <iftmp.594_9(3), iftmp.594_10(4)>
  new_capacity_11 = iftmp.594_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.595_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.595_14 = sz_12(D);

  <bb 8>:
  # iftmp.595_2 = PHI <iftmp.595_13(6), iftmp.595_14(7)>
  _15 = iftmp.595_2;

<L6>:
  return _15;

}


