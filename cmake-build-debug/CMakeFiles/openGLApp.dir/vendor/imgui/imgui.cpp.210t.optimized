
;; Function ImVec2::ImVec2() (_ZN6ImVec2C2Ev, funcdef_no=1, decl_uid=2367, cgraph_uid=1, symbol_order=1)

ImVec2::ImVec2() (struct ImVec2 * const this)
{
  float D.22390;
  float _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->y = 0.0;
  _5 = this_2(D)->y;
  this_2(D)->x = _5;
  return;

}



;; Function ImVec2::ImVec2(float, float) (_ZN6ImVec2C2Eff, funcdef_no=4, decl_uid=2361, cgraph_uid=4, symbol_order=4)

ImVec2::ImVec2(float, float) (struct ImVec2 * const this, float _x, float _y)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->x = _x_4(D);
  this_2(D)->y = _y_6(D);
  return;

}



;; Function ImVec4::ImVec4() (_ZN6ImVec4C2Ev, funcdef_no=8, decl_uid=2407, cgraph_uid=8, symbol_order=8)

ImVec4::ImVec4() (struct ImVec4 * const this)
{
  float D.22393;
  float D.22392;
  float D.22391;
  float _5;
  float _7;
  float _9;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->w = 0.0;
  _5 = this_2(D)->w;
  this_2(D)->z = _5;
  _7 = this_2(D)->z;
  this_2(D)->y = _7;
  _9 = this_2(D)->y;
  this_2(D)->x = _9;
  return;

}



;; Function ImVec4::ImVec4(float, float, float, float) (_ZN6ImVec4C2Effff, funcdef_no=11, decl_uid=2399, cgraph_uid=11, symbol_order=11)

ImVec4::ImVec4(float, float, float, float) (struct ImVec4 * const this, float _x, float _y, float _z, float _w)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->x = _x_4(D);
  this_2(D)->y = _y_6(D);
  this_2(D)->z = _z_8(D);
  this_2(D)->w = _w_10(D);
  return;

}



;; Function void* operator new(size_t, ImNewDummy, void*) (_Znwm10ImNewDummyPv, funcdef_no=59, decl_uid=4171, cgraph_uid=30, symbol_order=30)

void* operator new(size_t, ImNewDummy, void*) (size_t D.4168, struct ImNewDummy D.4169, void * ptr)
{
  void * D.24281;
  void * _2;

  <bb 2>:
  _2 = ptr_1(D);

<L0>:
  return _2;

}



;; Function void operator delete(void*, ImNewDummy, void*) (_ZdlPv10ImNewDummyS_, funcdef_no=60, decl_uid=4176, cgraph_uid=31, symbol_order=31)

void operator delete(void*, ImNewDummy, void*) (void * D.4173, struct ImNewDummy D.4174, void * D.4175)
{
  <bb 2>:
  GIMPLE_NOP
  return;

}



;; Function ImGuiTextFilter::TextRange::TextRange(const char*, const char*) (_ZN15ImGuiTextFilter9TextRangeC2EPKcS2_, funcdef_no=70, decl_uid=4231, cgraph_uid=40, symbol_order=40)

ImGuiTextFilter::TextRange::TextRange(const char*, const char*) (struct TextRange * const this, const char * _b, const char * _e)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->b = _b_4(D);
  this_2(D)->e = _e_6(D);
  return;

}



;; Function const char* ImGuiTextFilter::TextRange::begin() const (_ZNK15ImGuiTextFilter9TextRange5beginEv, funcdef_no=72, decl_uid=4210, cgraph_uid=42, symbol_order=42)

const char* ImGuiTextFilter::TextRange::begin() const (const struct TextRange * const this)
{
  const char * D.23898;
  const char * _3;

  <bb 2>:
  _3 = this_2(D)->b;

<L0>:
  return _3;

}



;; Function const char* ImGuiTextFilter::TextRange::end() const (_ZNK15ImGuiTextFilter9TextRange3endEv, funcdef_no=73, decl_uid=4212, cgraph_uid=43, symbol_order=43)

const char* ImGuiTextFilter::TextRange::end() const (const struct TextRange * const this)
{
  const char * D.23896;
  const char * _3;

  <bb 2>:
  _3 = this_2(D)->e;

<L0>:
  return _3;

}



;; Function bool ImGuiTextFilter::TextRange::empty() const (_ZNK15ImGuiTextFilter9TextRange5emptyEv, funcdef_no=74, decl_uid=4214, cgraph_uid=44, symbol_order=44)

bool ImGuiTextFilter::TextRange::empty() const (const struct TextRange * const this)
{
  const char * D.23833;
  const char * D.23832;
  bool D.23831;
  const char * _3;
  const char * _4;
  bool _5;

  <bb 2>:
  _3 = this_2(D)->b;
  _4 = this_2(D)->e;
  _5 = _3 == _4;

<L0>:
  return _5;

}



;; Function char ImGuiTextFilter::TextRange::front() const (_ZNK15ImGuiTextFilter9TextRange5frontEv, funcdef_no=75, decl_uid=4216, cgraph_uid=45, symbol_order=45)

char ImGuiTextFilter::TextRange::front() const (const struct TextRange * const this)
{
  const char * D.23845;
  char D.23844;
  const char * _3;
  char _4;

  <bb 2>:
  _3 = this_2(D)->b;
  _4 = *_3;

<L0>:
  return _4;

}



;; Function static bool ImGuiTextFilter::TextRange::is_blank(char) (_ZN15ImGuiTextFilter9TextRange8is_blankEc, funcdef_no=76, decl_uid=4219, cgraph_uid=46, symbol_order=46)

static bool ImGuiTextFilter::TextRange::is_blank(char) (char c)
{
  bool iftmp.126;
  bool D.23824;
  bool iftmp.126_1;
  bool iftmp.126_3;
  bool iftmp.126_4;
  bool _5;

  <bb 2>:
  if (c_2(D) == 32)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  if (c_2(D) == 9)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.126_4 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.126_3 = 0;

  <bb 6>:
  # iftmp.126_1 = PHI <iftmp.126_4(4), iftmp.126_3(5)>
  _5 = iftmp.126_1;

<L4>:
  return _5;

}



;; Function void ImGuiTextFilter::TextRange::trim_blanks() (_ZN15ImGuiTextFilter9TextRange11trim_blanksEv, funcdef_no=77, decl_uid=4220, cgraph_uid=47, symbol_order=47)

void ImGuiTextFilter::TextRange::trim_blanks() (struct TextRange * const this)
{
  const char * D.23823;
  const char * D.23822;
  bool D.23819;
  int D.23818;
  char D.23817;
  const char * D.23816;
  const char * D.23815;
  const char * D.23813;
  const char * D.23812;
  bool iftmp.125;
  bool retval.124;
  const char * D.23806;
  const char * D.23805;
  bool D.23802;
  int D.23801;
  char D.23800;
  const char * D.23799;
  const char * D.23797;
  const char * D.23796;
  bool iftmp.123;
  bool retval.122;
  bool iftmp.123_1;
  bool iftmp.125_2;
  const char * _11;
  const char * _12;
  const char * _13;
  char _14;
  int _15;
  bool _17;
  bool iftmp.123_18;
  bool iftmp.123_19;
  bool retval.122_20;
  const char * _21;
  const char * _22;
  const char * _24;
  const char * _25;
  const char * _26;
  const char * _27;
  char _28;
  int _29;
  bool _31;
  bool iftmp.125_32;
  bool iftmp.125_33;
  bool retval.124_34;
  const char * _35;
  const char * _36;

  <bb 2>:
  _11 = this_10(D)->b;
  _12 = this_10(D)->e;
  if (_11 < _12)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _13 = this_10(D)->b;
  _14 = *_13;
  _15 = (int) _14;
  _17 = ImGuiTextFilter::TextRange::is_blank (_15);
  if (_17 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.123_18 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.123_19 = 0;

  <bb 6>:
  # iftmp.123_1 = PHI <iftmp.123_18(4), iftmp.123_19(5)>
  retval.122_20 = iftmp.123_1;
  if (retval.122_20 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _21 = this_10(D)->b;
  _22 = _21 + 1;
  this_10(D)->b = _22;
  goto <bb 2>;

  <bb 8>:
  _24 = this_10(D)->e;
  _25 = this_10(D)->b;
  if (_24 > _25)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _26 = this_10(D)->e;
  _27 = _26 + 18446744073709551615;
  _28 = *_27;
  _29 = (int) _28;
  _31 = ImGuiTextFilter::TextRange::is_blank (_29);
  if (_31 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.125_32 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.125_33 = 0;

  <bb 12>:
  # iftmp.125_2 = PHI <iftmp.125_32(10), iftmp.125_33(11)>
  retval.124_34 = iftmp.125_2;
  if (retval.124_34 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _35 = this_10(D)->e;
  _36 = _35 + 18446744073709551615;
  this_10(D)->e = _36;
  goto <bb 8>;

  <bb 14>:
  return;

}



;; Function ImGuiTextBuffer::ImGuiTextBuffer() (_ZN15ImGuiTextBufferC2Ev, funcdef_no=81, decl_uid=4522, cgraph_uid=51, symbol_order=51)

ImGuiTextBuffer::ImGuiTextBuffer() (struct ImGuiTextBuffer * const this)
{
  void * D.46190;
  struct ImVector * D.27741;
  struct ImVector * D.27740;
  const value_type D.4528;
  struct ImVector * D.27739;
  struct ImVector * _4;
  struct ImVector * _7;
  struct ImVector * _11;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Buf;
  ImVector<char>::ImVector (_4);
  D.4528 = 0;
  _7 = &this_2(D)->Buf;
  ImVector<char>::push_back (_7, &D.4528);

  <bb 3>:
  D.4528 ={v} {CLOBBER};
  return;

<L1>:
  D.4528 ={v} {CLOBBER};
  _11 = &this_2(D)->Buf;
  ImVector<char>::~ImVector (_11);
  _13 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_13);

}



;; Function const char* ImGuiTextBuffer::begin() const (_ZNK15ImGuiTextBuffer5beginEv, funcdef_no=84, decl_uid=4498, cgraph_uid=54, symbol_order=54)

const char* ImGuiTextBuffer::begin() const (const struct ImGuiTextBuffer * const this)
{
  const struct ImVector * D.35074;
  const char * D.35073;
  const struct ImVector * _2;
  const char * _5;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  _5 = ImVector<char>::front (_2);

<L0>:
  return _5;

}



;; Function int ImGuiTextBuffer::size() const (_ZNK15ImGuiTextBuffer4sizeEv, funcdef_no=86, decl_uid=4502, cgraph_uid=56, symbol_order=56)

int ImGuiTextBuffer::size() const (const struct ImGuiTextBuffer * const this)
{
  int D.27710;
  int D.27709;
  int _3;
  int _4;

  <bb 2>:
  _3 = this_2(D)->Buf.Size;
  _4 = _3 + -1;

<L0>:
  return _4;

}



;; Function void ImGuiTextBuffer::clear() (_ZN15ImGuiTextBuffer5clearEv, funcdef_no=88, decl_uid=4506, cgraph_uid=58, symbol_order=58)

void ImGuiTextBuffer::clear() (struct ImGuiTextBuffer * const this)
{
  struct ImVector * D.35083;
  const value_type D.4536;
  struct ImVector * D.35082;
  struct ImVector * _2;
  struct ImVector * _6;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImVector<char>::clear (_2);
  D.4536 = 0;
  _6 = &this_1(D)->Buf;
  ImVector<char>::push_back (_6, &D.4536);
  D.4536 ={v} {CLOBBER};
  return;

}



;; Function void ImGuiTextBuffer::reserve(int) (_ZN15ImGuiTextBuffer7reserveEi, funcdef_no=89, decl_uid=4509, cgraph_uid=59, symbol_order=59)

void ImGuiTextBuffer::reserve(int) (struct ImGuiTextBuffer * const this, int capacity)
{
  struct ImVector * D.27712;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImVector<char>::reserve (_2, capacity_4(D));
  return;

}



;; Function ImGuiStorage::Pair::Pair(ImGuiID, int) (_ZN12ImGuiStorage4PairC2Eji, funcdef_no=92, decl_uid=4581, cgraph_uid=62, symbol_order=62)

ImGuiStorage::Pair::Pair(ImGuiID, int) (struct Pair * const this, ImGuiID _key, int _val_i)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->key = _key_4(D);
  this_2(D)->D.4548.val_i = _val_i_6(D);
  return;

}



;; Function ImGuiStorage::Pair::Pair(ImGuiID, float) (_ZN12ImGuiStorage4PairC2Ejf, funcdef_no=95, decl_uid=4573, cgraph_uid=65, symbol_order=65)

ImGuiStorage::Pair::Pair(ImGuiID, float) (struct Pair * const this, ImGuiID _key, float _val_f)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->key = _key_4(D);
  this_2(D)->D.4548.val_f = _val_f_6(D);
  return;

}



;; Function ImGuiStorage::Pair::Pair(ImGuiID, void*) (_ZN12ImGuiStorage4PairC2EjPv, funcdef_no=98, decl_uid=4565, cgraph_uid=68, symbol_order=68)

ImGuiStorage::Pair::Pair(ImGuiID, void*) (struct Pair * const this, ImGuiID _key, void * _val_p)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->key = _key_4(D);
  this_2(D)->D.4548.val_p = _val_p_6(D);
  return;

}



;; Function void ImGuiStorage::Clear() (_ZN12ImGuiStorage5ClearEv, funcdef_no=100, decl_uid=4690, cgraph_uid=70, symbol_order=70)

void ImGuiStorage::Clear() (struct ImGuiStorage * const this)
{
  struct ImVector * D.27935;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Data;
  ImVector<ImGuiStorage::Pair>::clear (_2);
  return;

}



;; Function ImGuiPayload::ImGuiPayload() (_ZN12ImGuiPayloadC2Ev, funcdef_no=103, decl_uid=4812, cgraph_uid=73, symbol_order=73)

ImGuiPayload::ImGuiPayload() (struct ImGuiPayload * const this)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  ImGuiPayload::Clear (this_2(D));
  return;

}



;; Function void ImGuiPayload::Clear() (_ZN12ImGuiPayload5ClearEv, funcdef_no=105, decl_uid=4801, cgraph_uid=75, symbol_order=75)

void ImGuiPayload::Clear() (struct ImGuiPayload * const this)
{
  bool D.25440;
  char[33] * D.25439;
  unsigned int D.25438;
  unsigned int _4;
  char[33] * _8;
  bool _12;

  <bb 2>:
  this_2(D)->SourceParentId = 0;
  _4 = this_2(D)->SourceParentId;
  this_2(D)->SourceId = _4;
  this_2(D)->Data = 0B;
  this_2(D)->DataSize = 0;
  _8 = &this_2(D)->DataType;
  memset (_8, 0, 33);
  this_2(D)->DataFrameCount = -1;
  this_2(D)->Delivery = 0;
  _12 = this_2(D)->Delivery;
  this_2(D)->Preview = _12;
  return;

}



;; Function bool ImGuiPayload::IsDataType(const char*) const (_ZNK12ImGuiPayload10IsDataTypeEPKc, funcdef_no=106, decl_uid=4804, cgraph_uid=76, symbol_order=76)

bool ImGuiPayload::IsDataType(const char*) const (const struct ImGuiPayload * const this, const char * type)
{
  int D.44623;
  const char[33] * D.44622;
  int D.44620;
  bool iftmp.1969;
  bool D.44616;
  bool iftmp.1969_1;
  int _4;
  const char[33] * _5;
  int _7;
  bool iftmp.1969_8;
  bool iftmp.1969_9;
  bool _10;

  <bb 2>:
  _4 = this_3(D)->DataFrameCount;
  if (_4 != -1)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _5 = &this_3(D)->DataType;
  _7 = strcmp (type_6(D), _5);
  if (_7 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1969_8 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.1969_9 = 0;

  <bb 6>:
  # iftmp.1969_1 = PHI <iftmp.1969_8(4), iftmp.1969_9(5)>
  _10 = iftmp.1969_1;

<L4>:
  return _10;

}



;; Function ImColor::ImColor(int, int, int, int) (_ZN7ImColorC2Eiiii, funcdef_no=113, decl_uid=4896, cgraph_uid=83, symbol_order=83)

ImColor::ImColor(int, int, int, int) (struct ImColor * const this, int r, int g, int b, int a)
{
  float sc;
  float D.45156;
  float D.45155;
  float D.45154;
  float D.45153;
  float D.45152;
  float D.45151;
  float D.45150;
  float D.45149;
  struct ImVec4 * D.45148;
  struct ImVec4 * _4;
  float _8;
  float _9;
  float _12;
  float _13;
  float _16;
  float _17;
  float _20;
  float _21;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Value;
  ImVec4::ImVec4 (_4);
  sc_6 = 3.9215688593685626983642578125e-3;
  _8 = (float) r_7(D);
  _9 = _8 * sc_6;
  this_2(D)->Value.x = _9;
  _12 = (float) g_11(D);
  _13 = _12 * sc_6;
  this_2(D)->Value.y = _13;
  _16 = (float) b_15(D);
  _17 = _16 * sc_6;
  this_2(D)->Value.z = _17;
  _20 = (float) a_19(D);
  _21 = _20 * sc_6;
  this_2(D)->Value.w = _21;
  return;

}



;; Function ImColor::operator ImVec4() const (_ZNK7ImColorcv6ImVec4Ev, funcdef_no=125, decl_uid=4853, cgraph_uid=95, symbol_order=95)

ImColor::operator ImVec4() const (const struct ImColor * const this)
{
  struct ImVec4 D.45157;

  <bb 2>:
  D.45157 = this_2(D)->Value;

<L0>:
  return D.45157;

}



;; Function ImGuiListClipper::ImGuiListClipper(int, float) (_ZN16ImGuiListClipperC2Eif, funcdef_no=129, decl_uid=4994, cgraph_uid=99, symbol_order=99)

ImGuiListClipper::ImGuiListClipper(int, float) (struct ImGuiListClipper * const this, int items_count, float items_height)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  ImGuiListClipper::Begin (this_2(D), items_count_4(D), items_height_5(D));
  return;

}



;; Function ImGuiListClipper::~ImGuiListClipper() (_ZN16ImGuiListClipperD2Ev, funcdef_no=132, decl_uid=5001, cgraph_uid=102, symbol_order=102)

ImGuiListClipper::~ImGuiListClipper() (struct ImGuiListClipper * const this)
{
  int D.41126;
  static const char __PRETTY_FUNCTION__[38] = "ImGuiListClipper::~ImGuiListClipper()";
  static const char __PRETTY_FUNCTION__[38] = "ImGuiListClipper::~ImGuiListClipper()";
  int _3;

  <bb 2>:
  _3 = this_2(D)->ItemsCount;
  if (_3 == -1)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("ItemsCount == -1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1452, &__PRETTY_FUNCTION__);

  <bb 4>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  return;

}



;; Function ImDrawList::ImDrawList(const ImDrawListSharedData*) (_ZN10ImDrawListC2EPK20ImDrawListSharedData, funcdef_no=138, decl_uid=6069, cgraph_uid=108, symbol_order=108)

Merging blocks 4 and 5
Merging blocks 4 and 6
Merging blocks 4 and 7
Merging blocks 4 and 8
Merging blocks 4 and 9
Merging blocks 4 and 10
ImDrawList::ImDrawList(const ImDrawListSharedData*) (struct ImDrawList * const this, const struct ImDrawListSharedData * shared_data)
{
  void * D.46198;
  struct ImVector * D.24296;
  struct ImVector * D.24295;
  struct ImVector * D.24294;
  struct ImVector * D.24293;
  struct ImVector * D.24292;
  struct ImVector * D.24291;
  struct ImVector * D.24290;
  struct ImVector * D.24289;
  struct ImVector * D.24288;
  struct ImVector * D.24287;
  struct ImVector * D.24286;
  struct ImVector * D.24285;
  struct ImVector * D.24284;
  struct ImVector * D.24283;
  struct ImVector * _4;
  struct ImVector * _6;
  struct ImVector * _8;
  struct ImVector * _10;
  struct ImVector * _12;
  struct ImVector * _14;
  struct ImVector * _16;
  struct ImVector * _22;
  struct ImVector * _24;
  struct ImVector * _26;
  struct ImVector * _28;
  struct ImVector * _30;
  struct ImVector * _32;
  struct ImVector * _34;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->CmdBuffer;
  ImVector<ImDrawCmd>::ImVector (_4);
  _6 = &this_2(D)->IdxBuffer;
  ImVector<short unsigned int>::ImVector (_6);
  _8 = &this_2(D)->VtxBuffer;
  ImVector<ImDrawVert>::ImVector (_8);
  _10 = &this_2(D)->_ClipRectStack;
  ImVector<ImVec4>::ImVector (_10);
  _12 = &this_2(D)->_TextureIdStack;
  ImVector<void*>::ImVector (_12);
  _14 = &this_2(D)->_Path;
  ImVector<ImVec2>::ImVector (_14);
  _16 = &this_2(D)->_Channels;
  ImVector<ImDrawChannel>::ImVector (_16);
  this_2(D)->_Data = shared_data_18(D);
  this_2(D)->_OwnerName = 0B;
  ImDrawList::Clear (this_2(D));

  <bb 3>:
  return;

<L0>:
  _22 = &this_2(D)->_Channels;
  ImVector<ImDrawChannel>::~ImVector (_22);
  __builtin_eh_copy_values (6, 7);
  _24 = &this_2(D)->_Path;
  ImVector<ImVec2>::~ImVector (_24);
  __builtin_eh_copy_values (5, 6);
  _26 = &this_2(D)->_TextureIdStack;
  ImVector<void*>::~ImVector (_26);
  __builtin_eh_copy_values (4, 5);
  _28 = &this_2(D)->_ClipRectStack;
  ImVector<ImVec4>::~ImVector (_28);
  __builtin_eh_copy_values (3, 4);
  _30 = &this_2(D)->VtxBuffer;
  ImVector<ImDrawVert>::~ImVector (_30);
  __builtin_eh_copy_values (2, 3);
  _32 = &this_2(D)->IdxBuffer;
  ImVector<short unsigned int>::~ImVector (_32);
  __builtin_eh_copy_values (1, 2);
  _34 = &this_2(D)->CmdBuffer;
  ImVector<ImDrawCmd>::~ImVector (_34);
  _36 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_36);

}



;; Function ImDrawList::~ImDrawList() (_ZN10ImDrawListD2Ev, funcdef_no=141, decl_uid=6075, cgraph_uid=111, symbol_order=111)

ImDrawList::~ImDrawList() (struct ImDrawList * const this)
{
  struct ImVector * D.24412;
  struct ImVector * D.24411;
  struct ImVector * D.24410;
  struct ImVector * D.24409;
  struct ImVector * D.24408;
  struct ImVector * D.24407;
  struct ImVector * D.24406;
  struct ImVector * _4;
  struct ImVector * _6;
  struct ImVector * _8;
  struct ImVector * _10;
  struct ImVector * _12;
  struct ImVector * _14;
  struct ImVector * _16;

  <bb 2>:
  ImDrawList::ClearFreeMemory (this_2(D));
  _4 = &this_2(D)->_Channels;
  ImVector<ImDrawChannel>::~ImVector (_4);
  _6 = &this_2(D)->_Path;
  ImVector<ImVec2>::~ImVector (_6);
  _8 = &this_2(D)->_TextureIdStack;
  ImVector<void*>::~ImVector (_8);
  _10 = &this_2(D)->_ClipRectStack;
  ImVector<ImVec4>::~ImVector (_10);
  _12 = &this_2(D)->VtxBuffer;
  ImVector<ImDrawVert>::~ImVector (_12);
  _14 = &this_2(D)->IdxBuffer;
  ImVector<short unsigned int>::~ImVector (_14);
  _16 = &this_2(D)->CmdBuffer;
  ImVector<ImDrawCmd>::~ImVector (_16);
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImDrawList::PathClear() (_ZN10ImDrawList9PathClearEv, funcdef_no=145, decl_uid=5961, cgraph_uid=115, symbol_order=115)

void ImDrawList::PathClear() (struct ImDrawList * const this)
{
  struct ImVector * D.29118;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->_Path;
  ImVector<ImVec2>::resize (_2, 0);
  return;

}



;; Function void ImDrawList::PathLineTo(const ImVec2&) (_ZN10ImDrawList10PathLineToERK6ImVec2, funcdef_no=146, decl_uid=5964, cgraph_uid=116, symbol_order=116)

void ImDrawList::PathLineTo(const ImVec2&) (struct ImDrawList * const this, const struct ImVec2 & pos)
{
  struct ImVector * D.29068;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->_Path;
  ImVector<ImVec2>::push_back (_2, pos_4(D));
  return;

}



;; Function void ImDrawList::PathFillConvex(ImU32) (_ZN10ImDrawList14PathFillConvexEj, funcdef_no=148, decl_uid=5970, cgraph_uid=118, symbol_order=118)

void ImDrawList::PathFillConvex(ImU32) (struct ImDrawList * const this, ImU32 col)
{
  struct ImVec2 * D.32800;
  int D.32799;
  int _3;
  struct ImVec2 * _4;

  <bb 2>:
  _3 = this_2(D)->_Path.Size;
  _4 = this_2(D)->_Path.Data;
  ImDrawList::AddConvexPolyFilled (this_2(D), _4, _3, col_5(D));
  ImDrawList::PathClear (this_2(D));
  return;

}



;; Function void ImDrawList::PathStroke(ImU32, bool, float) (_ZN10ImDrawList10PathStrokeEjbf, funcdef_no=149, decl_uid=5975, cgraph_uid=119, symbol_order=119)

void ImDrawList::PathStroke(ImU32, bool, float) (struct ImDrawList * const this, ImU32 col, bool closed, float thickness)
{
  struct ImVec2 * D.29117;
  int D.29116;
  int D.29115;
  int _2;
  int _5;
  struct ImVec2 * _6;

  <bb 2>:
  _2 = (int) closed_1(D);
  _5 = this_4(D)->_Path.Size;
  _6 = this_4(D)->_Path.Data;
  ImDrawList::AddPolyline (this_4(D), _6, _5, col_7(D), _2, thickness_8(D));
  ImDrawList::PathClear (this_4(D));
  return;

}



;; Function void ImDrawList::PrimWriteVtx(const ImVec2&, const ImVec2&, ImU32) (_ZN10ImDrawList12PrimWriteVtxERK6ImVec2S2_j, funcdef_no=150, decl_uid=6052, cgraph_uid=120, symbol_order=120)

void ImDrawList::PrimWriteVtx(const ImVec2&, const ImVec2&, ImU32) (struct ImDrawList * const this, const struct ImVec2 & pos, const struct ImVec2 & uv, ImU32 col)
{
  unsigned int D.43275;
  unsigned int D.43274;
  struct ImDrawVert * D.43273;
  struct ImDrawVert * D.43272;
  struct ImDrawVert * D.43271;
  struct ImDrawVert * D.43270;
  struct ImDrawVert * D.43269;
  struct ImDrawVert * _3;
  struct ImDrawVert * _6;
  struct ImDrawVert * _9;
  struct ImDrawVert * _12;
  struct ImDrawVert * _13;
  unsigned int _15;
  unsigned int _16;

  <bb 2>:
  _3 = this_2(D)->_VtxWritePtr;
  _3->pos = *pos_4(D);
  _6 = this_2(D)->_VtxWritePtr;
  _6->uv = *uv_7(D);
  _9 = this_2(D)->_VtxWritePtr;
  _9->col = col_10(D);
  _12 = this_2(D)->_VtxWritePtr;
  _13 = _12 + 20;
  this_2(D)->_VtxWritePtr = _13;
  _15 = this_2(D)->_VtxCurrentIdx;
  _16 = _15 + 1;
  this_2(D)->_VtxCurrentIdx = _16;
  return;

}



;; Function void ImDrawList::PrimWriteIdx(ImDrawIdx) (_ZN10ImDrawList12PrimWriteIdxEt, funcdef_no=151, decl_uid=6055, cgraph_uid=121, symbol_order=121)

void ImDrawList::PrimWriteIdx(ImDrawIdx) (struct ImDrawList * const this, ImDrawIdx idx)
{
  ImDrawIdx * D.43268;
  ImDrawIdx * D.43267;
  ImDrawIdx * D.43266;
  ImDrawIdx * _3;
  ImDrawIdx * _6;
  ImDrawIdx * _7;

  <bb 2>:
  _3 = this_2(D)->_IdxWritePtr;
  *_3 = idx_4(D);
  _6 = this_2(D)->_IdxWritePtr;
  _7 = _6 + 2;
  this_2(D)->_IdxWritePtr = _7;
  return;

}



;; Function void ImDrawList::PrimVtx(const ImVec2&, const ImVec2&, ImU32) (_ZN10ImDrawList7PrimVtxERK6ImVec2S2_j, funcdef_no=152, decl_uid=6060, cgraph_uid=122, symbol_order=122)

void ImDrawList::PrimVtx(const ImVec2&, const ImVec2&, ImU32) (struct ImDrawList * const this, const struct ImVec2 & pos, const struct ImVec2 & uv, ImU32 col)
{
  int D.43265;
  short unsigned int D.43264;
  unsigned int D.43263;
  unsigned int _3;
  short unsigned int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->_VtxCurrentIdx;
  _4 = (short unsigned int) _3;
  _5 = (int) _4;
  ImDrawList::PrimWriteIdx (this_2(D), _5);
  ImDrawList::PrimWriteVtx (this_2(D), pos_7(D), uv_8(D), col_9(D));
  return;

}



;; Function ImDrawData::ImDrawData() (_ZN10ImDrawDataC2Ev, funcdef_no=154, decl_uid=6149, cgraph_uid=124, symbol_order=124)

ImDrawData::ImDrawData() (struct ImDrawData * const this)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Valid = 0;
  ImDrawData::Clear (this_2(D));
  return;

}



;; Function ImDrawData::~ImDrawData() (_ZN10ImDrawDataD2Ev, funcdef_no=157, decl_uid=6154, cgraph_uid=127, symbol_order=127)

ImDrawData::~ImDrawData() (struct ImDrawData * const this)
{
  <bb 2>:
  ImDrawData::Clear (this_2(D));
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImDrawData::Clear() (_ZN10ImDrawData5ClearEv, funcdef_no=159, decl_uid=6140, cgraph_uid=129, symbol_order=129)

void ImDrawData::Clear() (struct ImDrawData * const this)
{
  int D.25409;
  int D.25408;
  int _6;
  int _8;

  <bb 2>:
  this_2(D)->Valid = 0;
  this_2(D)->CmdLists = 0B;
  this_2(D)->TotalIdxCount = 0;
  _6 = this_2(D)->TotalIdxCount;
  this_2(D)->TotalVtxCount = _6;
  _8 = this_2(D)->TotalVtxCount;
  this_2(D)->CmdListsCount = _8;
  return;

}



;; Function float ImFont::GetCharAdvance(ImWchar) const (_ZNK6ImFont14GetCharAdvanceEt, funcdef_no=172, decl_uid=7086, cgraph_uid=142, symbol_order=142)

float ImFont::GetCharAdvance(ImWchar) const (const struct ImFont * const this, ImWchar c)
{
  const value_type & D.37425;
  const struct ImVector * D.37424;
  int D.37423;
  int D.37420;
  int D.37419;
  value_type iftmp.1301;
  float D.37417;
  value_type iftmp.1301_1;
  int _4;
  int _7;
  int _8;
  const struct ImVector * _9;
  const value_type & _11;
  value_type iftmp.1301_12;
  value_type iftmp.1301_13;
  float _14;

  <bb 2>:
  _4 = (int) c_3(D);
  _7 = this_6(D)->IndexAdvanceX.Size;
  if (_4 < _7)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = (int) c_3(D);
  _9 = &this_6(D)->IndexAdvanceX;
  _11 = ImVector<float>::operator[] (_9, _8);
  iftmp.1301_12 = *_11;
  goto <bb 5>;

  <bb 4>:
  iftmp.1301_13 = this_6(D)->FallbackAdvanceX;

  <bb 5>:
  # iftmp.1301_1 = PHI <iftmp.1301_12(3), iftmp.1301_13(4)>
  _14 = iftmp.1301_1;

<L3>:
  return _14;

}



;; Function bool ImFont::IsLoaded() const (_ZNK6ImFont8IsLoadedEv, funcdef_no=173, decl_uid=7088, cgraph_uid=143, symbol_order=143)

bool ImFont::IsLoaded() const (const struct ImFont * const this)
{
  struct ImFontAtlas * D.27540;
  bool D.27539;
  struct ImFontAtlas * _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->ContainerAtlas;
  _4 = _3 != 0B;

<L0>:
  return _4;

}



;; Function bool ImCharIsSpace(unsigned int) (_ZL13ImCharIsSpacej, funcdef_no=398, decl_uid=10525, cgraph_uid=297, symbol_order=297)

bool ImCharIsSpace(unsigned int) (unsigned int c)
{
  bool iftmp.1206;
  bool D.35930;
  bool iftmp.1206_1;
  bool iftmp.1206_3;
  bool iftmp.1206_4;
  bool _5;

  <bb 2>:
  if (c_2(D) == 32)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  if (c_2(D) == 9)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  if (c_2(D) == 12288)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1206_4 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.1206_3 = 0;

  <bb 7>:
  # iftmp.1206_1 = PHI <iftmp.1206_4(5), iftmp.1206_3(6)>
  _5 = iftmp.1206_1;

<L5>:
  return _5;

}



;; Function bool ImIsPowerOfTwo(int) (_ZL14ImIsPowerOfTwoi, funcdef_no=399, decl_uid=10528, cgraph_uid=298, symbol_order=298)

bool ImIsPowerOfTwo(int) (int v)
{
  int D.34009;
  int D.34008;
  bool iftmp.1075;
  bool D.34003;
  bool iftmp.1075_1;
  int _3;
  int _4;
  bool iftmp.1075_5;
  bool iftmp.1075_6;
  bool _7;

  <bb 2>:
  if (v_2(D) != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _3 = v_2(D) + -1;
  _4 = _3 & v_2(D);
  if (_4 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1075_5 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.1075_6 = 0;

  <bb 6>:
  # iftmp.1075_1 = PHI <iftmp.1075_5(4), iftmp.1075_6(5)>
  _7 = iftmp.1075_1;

<L4>:
  return _7;

}



;; Function ImVec2 operator*(const ImVec2&, float) (_ZmlRK6ImVec2f, funcdef_no=401, decl_uid=10593, cgraph_uid=300, symbol_order=300)

ImVec2 operator*(const ImVec2&, float) (const struct ImVec2 & lhs, const float rhs)
{
  float D.22439;
  float D.22438;
  float D.22437;
  float D.22436;
  struct ImVec2 D.10595;
  struct ImVec2 D.22435;
  float _3;
  float _5;
  float _6;
  float _7;

  <bb 2>:
  _3 = lhs_2(D)->y;
  _5 = _3 * rhs_4(D);
  _6 = lhs_2(D)->x;
  _7 = _6 * rhs_4(D);
  ImVec2::ImVec2 (&D.10595, _7, _5);
  D.22435 = D.10595;
  D.10595 ={v} {CLOBBER};

<L1>:
  return D.22435;

}



;; Function ImVec2 operator/(const ImVec2&, float) (_ZdvRK6ImVec2f, funcdef_no=402, decl_uid=10598, cgraph_uid=301, symbol_order=301)

ImVec2 operator/(const ImVec2&, float) (const struct ImVec2 & lhs, const float rhs)
{
  float D.22536;
  float D.22535;
  float D.22534;
  float D.22533;
  struct ImVec2 D.10600;
  struct ImVec2 D.22532;
  float _3;
  float _5;
  float _6;
  float _7;

  <bb 2>:
  _3 = lhs_2(D)->y;
  _5 = _3 / rhs_4(D);
  _6 = lhs_2(D)->x;
  _7 = _6 / rhs_4(D);
  ImVec2::ImVec2 (&D.10600, _7, _5);
  D.22532 = D.10600;
  D.10600 ={v} {CLOBBER};

<L1>:
  return D.22532;

}



;; Function ImVec2 operator+(const ImVec2&, const ImVec2&) (_ZplRK6ImVec2S1_, funcdef_no=403, decl_uid=10603, cgraph_uid=302, symbol_order=302)

ImVec2 operator+(const ImVec2&, const ImVec2&) (const struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  float D.22545;
  float D.22544;
  float D.22543;
  float D.22542;
  float D.22541;
  float D.22540;
  struct ImVec2 D.10605;
  struct ImVec2 D.22539;
  float _3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;

  <bb 2>:
  _3 = lhs_2(D)->y;
  _5 = rhs_4(D)->y;
  _6 = _3 + _5;
  _7 = lhs_2(D)->x;
  _8 = rhs_4(D)->x;
  _9 = _7 + _8;
  ImVec2::ImVec2 (&D.10605, _9, _6);
  D.22539 = D.10605;
  D.10605 ={v} {CLOBBER};

<L1>:
  return D.22539;

}



;; Function ImVec2 operator-(const ImVec2&, const ImVec2&) (_ZmiRK6ImVec2S1_, funcdef_no=404, decl_uid=10608, cgraph_uid=303, symbol_order=303)

ImVec2 operator-(const ImVec2&, const ImVec2&) (const struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  float D.22529;
  float D.22528;
  float D.22527;
  float D.22526;
  float D.22525;
  float D.22524;
  struct ImVec2 D.10610;
  struct ImVec2 D.22523;
  float _3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;

  <bb 2>:
  _3 = lhs_2(D)->y;
  _5 = rhs_4(D)->y;
  _6 = _3 - _5;
  _7 = lhs_2(D)->x;
  _8 = rhs_4(D)->x;
  _9 = _7 - _8;
  ImVec2::ImVec2 (&D.10610, _9, _6);
  D.22523 = D.10610;
  D.10610 ={v} {CLOBBER};

<L1>:
  return D.22523;

}



;; Function ImVec2 operator*(const ImVec2&, const ImVec2&) (_ZmlRK6ImVec2S1_, funcdef_no=405, decl_uid=10613, cgraph_uid=304, symbol_order=304)

ImVec2 operator*(const ImVec2&, const ImVec2&) (const struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  float D.27554;
  float D.27553;
  float D.27552;
  float D.27551;
  float D.27550;
  float D.27549;
  struct ImVec2 D.10615;
  struct ImVec2 D.27548;
  float _3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;

  <bb 2>:
  _3 = lhs_2(D)->y;
  _5 = rhs_4(D)->y;
  _6 = _3 * _5;
  _7 = lhs_2(D)->x;
  _8 = rhs_4(D)->x;
  _9 = _7 * _8;
  ImVec2::ImVec2 (&D.10615, _9, _6);
  D.27548 = D.10615;
  D.10615 ={v} {CLOBBER};

<L1>:
  return D.27548;

}



;; Function ImVec2 operator/(const ImVec2&, const ImVec2&) (_ZdvRK6ImVec2S1_, funcdef_no=406, decl_uid=10618, cgraph_uid=305, symbol_order=305)

ImVec2 operator/(const ImVec2&, const ImVec2&) (const struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  float D.27563;
  float D.27562;
  float D.27561;
  float D.27560;
  float D.27559;
  float D.27558;
  struct ImVec2 D.10620;
  struct ImVec2 D.27557;
  float _3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;

  <bb 2>:
  _3 = lhs_2(D)->y;
  _5 = rhs_4(D)->y;
  _6 = _3 / _5;
  _7 = lhs_2(D)->x;
  _8 = rhs_4(D)->x;
  _9 = _7 / _8;
  ImVec2::ImVec2 (&D.10620, _9, _6);
  D.27557 = D.10620;
  D.10620 ={v} {CLOBBER};

<L1>:
  return D.27557;

}



;; Function ImVec2& operator+=(ImVec2&, const ImVec2&) (_ZpLR6ImVec2RKS_, funcdef_no=407, decl_uid=10623, cgraph_uid=306, symbol_order=306)

ImVec2& operator+=(ImVec2&, const ImVec2&) (struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  struct ImVec2 & D.25808;
  float D.25807;
  float D.25806;
  float D.25805;
  float D.25804;
  float D.25803;
  float D.25802;
  float _3;
  float _5;
  float _6;
  float _8;
  float _9;
  float _10;
  struct ImVec2 & _12;

  <bb 2>:
  _3 = lhs_2(D)->x;
  _5 = rhs_4(D)->x;
  _6 = _3 + _5;
  lhs_2(D)->x = _6;
  _8 = lhs_2(D)->y;
  _9 = rhs_4(D)->y;
  _10 = _8 + _9;
  lhs_2(D)->y = _10;
  _12 = lhs_2(D);

<L0>:
  return _12;

}



;; Function ImVec2& operator-=(ImVec2&, const ImVec2&) (_ZmIR6ImVec2RKS_, funcdef_no=408, decl_uid=10627, cgraph_uid=307, symbol_order=307)

ImVec2& operator-=(ImVec2&, const ImVec2&) (struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  struct ImVec2 & D.30864;
  float D.30863;
  float D.30862;
  float D.30861;
  float D.30860;
  float D.30859;
  float D.30858;
  float _3;
  float _5;
  float _6;
  float _8;
  float _9;
  float _10;
  struct ImVec2 & _12;

  <bb 2>:
  _3 = lhs_2(D)->x;
  _5 = rhs_4(D)->x;
  _6 = _3 - _5;
  lhs_2(D)->x = _6;
  _8 = lhs_2(D)->y;
  _9 = rhs_4(D)->y;
  _10 = _8 - _9;
  lhs_2(D)->y = _10;
  _12 = lhs_2(D);

<L0>:
  return _12;

}



;; Function ImVec2& operator*=(ImVec2&, float) (_ZmLR6ImVec2f, funcdef_no=409, decl_uid=10631, cgraph_uid=308, symbol_order=308)

ImVec2& operator*=(ImVec2&, float) (struct ImVec2 & lhs, const float rhs)
{
  struct ImVec2 & D.25814;
  float D.25813;
  float D.25812;
  float D.25811;
  float D.25810;
  float _3;
  float _5;
  float _7;
  float _8;
  struct ImVec2 & _10;

  <bb 2>:
  _3 = lhs_2(D)->x;
  _5 = _3 * rhs_4(D);
  lhs_2(D)->x = _5;
  _7 = lhs_2(D)->y;
  _8 = _7 * rhs_4(D);
  lhs_2(D)->y = _8;
  _10 = lhs_2(D);

<L0>:
  return _10;

}



;; Function ImVec4 operator*(const ImVec4&, const ImVec4&) (_ZmlRK6ImVec4S1_, funcdef_no=413, decl_uid=10649, cgraph_uid=312, symbol_order=312)

ImVec4 operator*(const ImVec4&, const ImVec4&) (const struct ImVec4 & lhs, const struct ImVec4 & rhs)
{
  float D.44372;
  float D.44371;
  float D.44370;
  float D.44369;
  float D.44368;
  float D.44367;
  float D.44366;
  float D.44365;
  float D.44364;
  float D.44363;
  float D.44362;
  float D.44361;
  struct ImVec4 D.10651;
  struct ImVec4 D.44360;
  float _3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;

  <bb 2>:
  _3 = lhs_2(D)->w;
  _5 = rhs_4(D)->w;
  _6 = _3 * _5;
  _7 = lhs_2(D)->z;
  _8 = rhs_4(D)->z;
  _9 = _7 * _8;
  _10 = lhs_2(D)->y;
  _11 = rhs_4(D)->y;
  _12 = _10 * _11;
  _13 = lhs_2(D)->x;
  _14 = rhs_4(D)->x;
  _15 = _13 * _14;
  ImVec4::ImVec4 (&D.10651, _15, _12, _9, _6);
  D.44360 = D.10651;
  D.10651 ={v} {CLOBBER};

<L1>:
  return D.44360;

}



;; Function int ImMin(int, int) (_ZL5ImMinii, funcdef_no=414, decl_uid=10654, cgraph_uid=313, symbol_order=313)

int ImMin(int, int) (int lhs, int rhs)
{
  int iftmp.1266;
  int D.36837;
  int iftmp.1266_1;
  int iftmp.1266_4;
  int iftmp.1266_5;
  int _6;

  <bb 2>:
  if (lhs_2(D) < rhs_3(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1266_4 = lhs_2(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.1266_5 = rhs_3(D);

  <bb 5>:
  # iftmp.1266_1 = PHI <iftmp.1266_4(3), iftmp.1266_5(4)>
  _6 = iftmp.1266_1;

<L3>:
  return _6;

}



;; Function int ImMax(int, int) (_ZL5ImMaxii, funcdef_no=415, decl_uid=10658, cgraph_uid=314, symbol_order=314)

int ImMax(int, int) (int lhs, int rhs)
{
  int iftmp.1267;
  int D.36843;
  int iftmp.1267_1;
  int iftmp.1267_4;
  int iftmp.1267_5;
  int _6;

  <bb 2>:
  if (lhs_2(D) >= rhs_3(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1267_4 = lhs_2(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.1267_5 = rhs_3(D);

  <bb 5>:
  # iftmp.1267_1 = PHI <iftmp.1267_4(3), iftmp.1267_5(4)>
  _6 = iftmp.1267_1;

<L3>:
  return _6;

}



;; Function float ImMin(float, float) (_ZL5ImMinff, funcdef_no=416, decl_uid=10662, cgraph_uid=315, symbol_order=315)

float ImMin(float, float) (float lhs, float rhs)
{
  float iftmp.4;
  float D.22642;
  float iftmp.4_1;
  float iftmp.4_4;
  float iftmp.4_5;
  float _6;

  <bb 2>:
  if (lhs_2(D) < rhs_3(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.4_4 = lhs_2(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.4_5 = rhs_3(D);

  <bb 5>:
  # iftmp.4_1 = PHI <iftmp.4_4(3), iftmp.4_5(4)>
  _6 = iftmp.4_1;

<L3>:
  return _6;

}



;; Function float ImMax(float, float) (_ZL5ImMaxff, funcdef_no=417, decl_uid=10666, cgraph_uid=316, symbol_order=316)

float ImMax(float, float) (float lhs, float rhs)
{
  float iftmp.139;
  float D.24022;
  float iftmp.139_1;
  float iftmp.139_4;
  float iftmp.139_5;
  float _6;

  <bb 2>:
  if (lhs_2(D) >= rhs_3(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.139_4 = lhs_2(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.139_5 = rhs_3(D);

  <bb 5>:
  # iftmp.139_1 = PHI <iftmp.139_4(3), iftmp.139_5(4)>
  _6 = iftmp.139_1;

<L3>:
  return _6;

}



;; Function ImVec2 ImMin(const ImVec2&, const ImVec2&) (_ZL5ImMinRK6ImVec2S1_, funcdef_no=418, decl_uid=10670, cgraph_uid=317, symbol_order=317)

ImVec2 ImMin(const ImVec2&, const ImVec2&) (const struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  float D.26849;
  float D.26848;
  const float iftmp.270;
  float D.26843;
  float D.26842;
  const float iftmp.269;
  struct ImVec2 D.10672;
  struct ImVec2 D.26840;
  const float iftmp.269_1;
  const float iftmp.270_2;
  float _5;
  float _7;
  const float iftmp.269_8;
  const float iftmp.269_9;
  float _10;
  float _11;
  const float iftmp.270_12;
  const float iftmp.270_13;

  <bb 2>:
  _5 = lhs_4(D)->y;
  _7 = rhs_6(D)->y;
  if (_5 < _7)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.269_8 = lhs_4(D)->y;
  goto <bb 5>;

  <bb 4>:
  iftmp.269_9 = rhs_6(D)->y;

  <bb 5>:
  # iftmp.269_1 = PHI <iftmp.269_8(3), iftmp.269_9(4)>
  _10 = lhs_4(D)->x;
  _11 = rhs_6(D)->x;
  if (_10 < _11)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.270_12 = lhs_4(D)->x;
  goto <bb 8>;

  <bb 7>:
  iftmp.270_13 = rhs_6(D)->x;

  <bb 8>:
  # iftmp.270_2 = PHI <iftmp.270_12(6), iftmp.270_13(7)>
  ImVec2::ImVec2 (&D.10672, iftmp.270_2, iftmp.269_1);
  D.26840 = D.10672;
  D.10672 ={v} {CLOBBER};

<L7>:
  return D.26840;

}



;; Function ImVec2 ImMax(const ImVec2&, const ImVec2&) (_ZL5ImMaxRK6ImVec2S1_, funcdef_no=419, decl_uid=10675, cgraph_uid=318, symbol_order=318)

ImVec2 ImMax(const ImVec2&, const ImVec2&) (const struct ImVec2 & lhs, const struct ImVec2 & rhs)
{
  float D.26834;
  float D.26833;
  const float iftmp.268;
  float D.26828;
  float D.26827;
  const float iftmp.267;
  struct ImVec2 D.10677;
  struct ImVec2 D.26825;
  const float iftmp.267_1;
  const float iftmp.268_2;
  float _5;
  float _7;
  const float iftmp.267_8;
  const float iftmp.267_9;
  float _10;
  float _11;
  const float iftmp.268_12;
  const float iftmp.268_13;

  <bb 2>:
  _5 = lhs_4(D)->y;
  _7 = rhs_6(D)->y;
  if (_5 >= _7)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.267_8 = lhs_4(D)->y;
  goto <bb 5>;

  <bb 4>:
  iftmp.267_9 = rhs_6(D)->y;

  <bb 5>:
  # iftmp.267_1 = PHI <iftmp.267_8(3), iftmp.267_9(4)>
  _10 = lhs_4(D)->x;
  _11 = rhs_6(D)->x;
  if (_10 >= _11)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.268_12 = lhs_4(D)->x;
  goto <bb 8>;

  <bb 7>:
  iftmp.268_13 = rhs_6(D)->x;

  <bb 8>:
  # iftmp.268_2 = PHI <iftmp.268_12(6), iftmp.268_13(7)>
  ImVec2::ImVec2 (&D.10677, iftmp.268_2, iftmp.267_1);
  D.26825 = D.10677;
  D.10677 ={v} {CLOBBER};

<L7>:
  return D.26825;

}



;; Function int ImClamp(int, int, int) (_ZL7ImClampiii, funcdef_no=420, decl_uid=10681, cgraph_uid=319, symbol_order=319)

int ImClamp(int, int, int) (int v, int mn, int mx)
{
  int iftmp.386;
  int iftmp.385;
  int D.29227;
  int iftmp.385_1;
  int iftmp.386_2;
  int iftmp.386_6;
  int iftmp.386_7;
  int iftmp.385_8;
  int iftmp.385_9;
  int _10;

  <bb 2>:
  if (v_3(D) >= mn_4(D))
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  if (v_3(D) > mx_5(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.386_6 = mx_5(D);
  goto <bb 6>;

  <bb 5>:
  iftmp.386_7 = v_3(D);

  <bb 6>:
  # iftmp.386_2 = PHI <iftmp.386_6(4), iftmp.386_7(5)>
  iftmp.385_8 = iftmp.386_2;
  goto <bb 8>;

  <bb 7>:
  iftmp.385_9 = mn_4(D);

  <bb 8>:
  # iftmp.385_1 = PHI <iftmp.385_8(6), iftmp.385_9(7)>
  _10 = iftmp.385_1;

<L6>:
  return _10;

}



;; Function float ImClamp(float, float, float) (_ZL7ImClampfff, funcdef_no=421, decl_uid=10686, cgraph_uid=320, symbol_order=320)

float ImClamp(float, float, float) (float v, float mn, float mx)
{
  float iftmp.162;
  float iftmp.161;
  float D.24784;
  float iftmp.161_1;
  float iftmp.162_2;
  float iftmp.161_5;
  float iftmp.162_7;
  float iftmp.162_8;
  float iftmp.161_9;
  float _10;

  <bb 2>:
  if (v_3(D) < mn_4(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.161_5 = mn_4(D);
  goto <bb 8>;

  <bb 4>:
  if (v_3(D) > mx_6(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.162_7 = mx_6(D);
  goto <bb 7>;

  <bb 6>:
  iftmp.162_8 = v_3(D);

  <bb 7>:
  # iftmp.162_2 = PHI <iftmp.162_7(5), iftmp.162_8(6)>
  iftmp.161_9 = iftmp.162_2;

  <bb 8>:
  # iftmp.161_1 = PHI <iftmp.161_5(3), iftmp.161_9(7)>
  _10 = iftmp.161_1;

<L6>:
  return _10;

}



;; Function ImVec2 ImClamp(const ImVec2&, const ImVec2&, ImVec2) (_ZL7ImClampRK6ImVec2S1_S_, funcdef_no=422, decl_uid=10691, cgraph_uid=321, symbol_order=321)

ImVec2 ImClamp(const ImVec2&, const ImVec2&, ImVec2) (const struct ImVec2 & f, const struct ImVec2 & mn, struct ImVec2 mx)
{
  float D.25636;
  float D.25635;
  float D.25634;
  float D.25633;
  float D.25632;
  float D.25631;
  float D.25630;
  float D.25629;
  struct ImVec2 D.10693;
  struct ImVec2 D.25628;
  float _2;
  float _4;
  float _6;
  float _8;
  float _9;
  float _10;
  float _11;
  float _13;

  <bb 2>:
  _2 = mx.y;
  _4 = mn_3(D)->y;
  _6 = f_5(D)->y;
  _8 = ImClamp (_6, _4, _2);
  _9 = mx.x;
  _10 = mn_3(D)->x;
  _11 = f_5(D)->x;
  _13 = ImClamp (_11, _10, _9);
  ImVec2::ImVec2 (&D.10693, _13, _8);
  D.25628 = D.10693;
  D.10693 ={v} {CLOBBER};

<L1>:
  return D.25628;

}



;; Function float ImSaturate(float) (_ZL10ImSaturatef, funcdef_no=423, decl_uid=10695, cgraph_uid=322, symbol_order=322)

float ImSaturate(float) (float f)
{
  float iftmp.66;
  float iftmp.65;
  float D.23235;
  float iftmp.65_1;
  float iftmp.66_2;
  float iftmp.65_4;
  float iftmp.66_5;
  float iftmp.66_6;
  float iftmp.65_7;
  float _8;

  <bb 2>:
  if (f_3(D) < 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.65_4 = 0.0;
  goto <bb 8>;

  <bb 4>:
  if (f_3(D) > 1.0e+0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.66_5 = 1.0e+0;
  goto <bb 7>;

  <bb 6>:
  iftmp.66_6 = f_3(D);

  <bb 7>:
  # iftmp.66_2 = PHI <iftmp.66_5(5), iftmp.66_6(6)>
  iftmp.65_7 = iftmp.66_2;

  <bb 8>:
  # iftmp.65_1 = PHI <iftmp.65_4(3), iftmp.65_7(7)>
  _8 = iftmp.65_1;

<L6>:
  return _8;

}



;; Function void ImSwap(float&, float&) (_ZL6ImSwapRfS_, funcdef_no=425, decl_uid=10704, cgraph_uid=324, symbol_order=324)

void ImSwap(float&, float&) (float & a, float & b)
{
  float tmp;
  float D.23301;
  float _5;

  <bb 2>:
  tmp_3 = *a_2(D);
  _5 = *b_4(D);
  *a_2(D) = _5;
  *b_4(D) = tmp_3;
  return;

}



;; Function int ImLerp(int, int, float) (_ZL6ImLerpiif, funcdef_no=426, decl_uid=10710, cgraph_uid=325, symbol_order=325)

int ImLerp(int, int, float) (int a, int b, float t)
{
  float D.41856;
  float D.41855;
  float D.41854;
  int D.41853;
  float D.41852;
  int D.41851;
  float _2;
  int _4;
  float _5;
  float _7;
  float _8;
  int _9;

  <bb 2>:
  _2 = (float) a_1(D);
  _4 = b_3(D) - a_1(D);
  _5 = (float) _4;
  _7 = _5 * t_6(D);
  _8 = _2 + _7;
  _9 = (int) _8;

<L0>:
  return _9;

}



;; Function float ImLerp(float, float, float) (_ZL6ImLerpfff, funcdef_no=427, decl_uid=10715, cgraph_uid=326, symbol_order=326)

float ImLerp(float, float, float) (float a, float b, float t)
{
  float D.24796;
  float D.24795;
  float D.24794;
  float _3;
  float _5;
  float _6;

  <bb 2>:
  _3 = b_1(D) - a_2(D);
  _5 = _3 * t_4(D);
  _6 = _5 + a_2(D);

<L0>:
  return _6;

}



;; Function ImVec2 ImLerp(const ImVec2&, const ImVec2&, float) (_ZL6ImLerpRK6ImVec2S1_f, funcdef_no=428, decl_uid=10720, cgraph_uid=327, symbol_order=327)

ImVec2 ImLerp(const ImVec2&, const ImVec2&, float) (const struct ImVec2 & a, const struct ImVec2 & b, float t)
{
  float D.43288;
  float D.43287;
  float D.43286;
  float D.43285;
  float D.43284;
  float D.43283;
  float D.43282;
  float D.43281;
  float D.43280;
  float D.43279;
  float D.43278;
  float D.43277;
  struct ImVec2 D.10722;
  struct ImVec2 D.43276;
  float _3;
  float _5;
  float _6;
  float _7;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;

  <bb 2>:
  _3 = a_2(D)->y;
  _5 = b_4(D)->y;
  _6 = a_2(D)->y;
  _7 = _5 - _6;
  _9 = _7 * t_8(D);
  _10 = _3 + _9;
  _11 = a_2(D)->x;
  _12 = b_4(D)->x;
  _13 = a_2(D)->x;
  _14 = _12 - _13;
  _15 = _14 * t_8(D);
  _16 = _11 + _15;
  ImVec2::ImVec2 (&D.10722, _16, _10);
  D.43276 = D.10722;
  D.10722 ={v} {CLOBBER};

<L1>:
  return D.43276;

}



;; Function ImVec2 ImLerp(const ImVec2&, const ImVec2&, const ImVec2&) (_ZL6ImLerpRK6ImVec2S1_S1_, funcdef_no=429, decl_uid=10726, cgraph_uid=328, symbol_order=328)

ImVec2 ImLerp(const ImVec2&, const ImVec2&, const ImVec2&) (const struct ImVec2 & a, const struct ImVec2 & b, const struct ImVec2 & t)
{
  float D.30794;
  float D.30793;
  float D.30792;
  float D.30791;
  float D.30790;
  float D.30789;
  float D.30788;
  float D.30787;
  float D.30786;
  float D.30785;
  float D.30784;
  float D.30783;
  float D.30782;
  float D.30781;
  struct ImVec2 D.10728;
  struct ImVec2 D.30780;
  float _3;
  float _5;
  float _6;
  float _7;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;
  float _17;
  float _18;

  <bb 2>:
  _3 = a_2(D)->y;
  _5 = b_4(D)->y;
  _6 = a_2(D)->y;
  _7 = _5 - _6;
  _9 = t_8(D)->y;
  _10 = _7 * _9;
  _11 = _3 + _10;
  _12 = a_2(D)->x;
  _13 = b_4(D)->x;
  _14 = a_2(D)->x;
  _15 = _13 - _14;
  _16 = t_8(D)->x;
  _17 = _15 * _16;
  _18 = _12 + _17;
  ImVec2::ImVec2 (&D.10728, _18, _11);
  D.30780 = D.10728;
  D.10728 ={v} {CLOBBER};

<L1>:
  return D.30780;

}



;; Function float ImLengthSqr(const ImVec2&) (_ZL11ImLengthSqrRK6ImVec2, funcdef_no=431, decl_uid=10736, cgraph_uid=330, symbol_order=330)

float ImLengthSqr(const ImVec2&) (const struct ImVec2 & lhs)
{
  float D.22640;
  float D.22639;
  float D.22638;
  float D.22637;
  float D.22636;
  float D.22635;
  float D.22634;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;

  <bb 2>:
  _3 = lhs_2(D)->x;
  _4 = lhs_2(D)->x;
  _5 = _3 * _4;
  _6 = lhs_2(D)->y;
  _7 = lhs_2(D)->y;
  _8 = _6 * _7;
  _9 = _5 + _8;

<L0>:
  return _9;

}



;; Function float ImFloor(float) (_ZL7ImFloorf, funcdef_no=434, decl_uid=10747, cgraph_uid=333, symbol_order=333)

float ImFloor(float) (float f)
{
  int D.22452;
  float D.22451;
  int _2;
  float _3;

  <bb 2>:
  _2 = (int) f_1(D);
  _3 = (float) _2;

<L0>:
  return _3;

}



;; Function ImVec2 ImFloor(const ImVec2&) (_ZL7ImFloorRK6ImVec2, funcdef_no=435, decl_uid=10750, cgraph_uid=334, symbol_order=334)

ImVec2 ImFloor(const ImVec2&) (const struct ImVec2 & v)
{
  float D.22448;
  int D.22447;
  float D.22446;
  float D.22445;
  int D.22444;
  float D.22443;
  struct ImVec2 D.10752;
  struct ImVec2 D.22442;
  float _3;
  int _4;
  float _5;
  float _6;
  int _7;
  float _8;

  <bb 2>:
  _3 = v_2(D)->y;
  _4 = (int) _3;
  _5 = (float) _4;
  _6 = v_2(D)->x;
  _7 = (int) _6;
  _8 = (float) _7;
  ImVec2::ImVec2 (&D.10752, _8, _5);
  D.22442 = D.10752;
  D.10752 ={v} {CLOBBER};

<L1>:
  return D.22442;

}



;; Function ImVec2 ImRotate(const ImVec2&, float, float) (_ZL8ImRotateRK6ImVec2ff, funcdef_no=437, decl_uid=10760, cgraph_uid=336, symbol_order=336)

ImVec2 ImRotate(const ImVec2&, float, float) (const struct ImVec2 & v, float cos_a, float sin_a)
{
  float D.43260;
  float D.43259;
  float D.43258;
  float D.43257;
  float D.43256;
  float D.43255;
  float D.43254;
  float D.43253;
  float D.43252;
  float D.43251;
  struct ImVec2 D.10762;
  struct ImVec2 D.43250;
  float _3;
  float _5;
  float _6;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;

  <bb 2>:
  _3 = v_2(D)->x;
  _5 = _3 * sin_a_4(D);
  _6 = v_2(D)->y;
  _8 = _6 * cos_a_7(D);
  _9 = _5 + _8;
  _10 = v_2(D)->x;
  _11 = _10 * cos_a_7(D);
  _12 = v_2(D)->y;
  _13 = _12 * sin_a_4(D);
  _14 = _11 - _13;
  ImVec2::ImVec2 (&D.10762, _14, _9);
  D.43250 = D.10762;
  D.10762 ={v} {CLOBBER};

<L1>:
  return D.43250;

}



;; Function ImRect::ImRect() (_ZN6ImRectC2Ev, funcdef_no=441, decl_uid=10947, cgraph_uid=340, symbol_order=340)

ImRect::ImRect() (struct ImRect * const this)
{
  struct ImVec2 * D.24347;
  struct ImVec2 * D.24346;
  struct ImVec2 * _4;
  struct ImVec2 * _6;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Min;
  ImVec2::ImVec2 (_4, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  _6 = &this_2(D)->Max;
  ImVec2::ImVec2 (_6, -3.4028234663852885981170418348451692544e+38, -3.4028234663852885981170418348451692544e+38);
  return;

}



;; Function ImRect::ImRect(const ImVec2&, const ImVec2&) (_ZN6ImRectC2ERK6ImVec2S2_, funcdef_no=444, decl_uid=10941, cgraph_uid=343, symbol_order=343)

ImRect::ImRect(const ImVec2&, const ImVec2&) (struct ImRect * const this, const struct ImVec2 & min, const struct ImVec2 & max)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Min = *min_4(D);
  this_2(D)->Max = *max_6(D);
  return;

}



;; Function ImRect::ImRect(const ImVec4&) (_ZN6ImRectC2ERK6ImVec4, funcdef_no=447, decl_uid=10934, cgraph_uid=346, symbol_order=346)

ImRect::ImRect(const ImVec4&) (struct ImRect * const this, const struct ImVec4 & v)
{
  struct ImVec2 * D.28500;
  float D.28499;
  float D.28498;
  struct ImVec2 * D.28497;
  float D.28496;
  float D.28495;
  float _5;
  float _6;
  struct ImVec2 * _7;
  float _9;
  float _10;
  struct ImVec2 * _11;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _5 = v_4(D)->y;
  _6 = v_4(D)->x;
  _7 = &this_2(D)->Min;
  ImVec2::ImVec2 (_7, _6, _5);
  _9 = v_4(D)->w;
  _10 = v_4(D)->z;
  _11 = &this_2(D)->Max;
  ImVec2::ImVec2 (_11, _10, _9);
  return;

}



;; Function ImRect::ImRect(float, float, float, float) (_ZN6ImRectC2Effff, funcdef_no=450, decl_uid=10925, cgraph_uid=349, symbol_order=349)

ImRect::ImRect(float, float, float, float) (struct ImRect * const this, float x1, float y1, float x2, float y2)
{
  struct ImVec2 * D.26856;
  struct ImVec2 * D.26855;
  struct ImVec2 * _4;
  struct ImVec2 * _8;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Min;
  ImVec2::ImVec2 (_4, x1_5(D), y1_6(D));
  _8 = &this_2(D)->Max;
  ImVec2::ImVec2 (_8, x2_9(D), y2_10(D));
  return;

}



;; Function ImVec2 ImRect::GetCenter() const (_ZNK6ImRect9GetCenterEv, funcdef_no=452, decl_uid=10867, cgraph_uid=351, symbol_order=351)

ImVec2 ImRect::GetCenter() const (const struct ImRect * const this)
{
  float D.34911;
  float D.34910;
  float D.34909;
  float D.34908;
  float D.34907;
  float D.34906;
  float D.34905;
  float D.34904;
  struct ImVec2 D.10964;
  struct ImVec2 D.34903;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;

  <bb 2>:
  _3 = this_2(D)->Min.y;
  _4 = this_2(D)->Max.y;
  _5 = _3 + _4;
  _6 = _5 * 5.0e-1;
  _7 = this_2(D)->Min.x;
  _8 = this_2(D)->Max.x;
  _9 = _7 + _8;
  _10 = _9 * 5.0e-1;
  ImVec2::ImVec2 (&D.10964, _10, _6);
  D.34903 = D.10964;
  D.10964 ={v} {CLOBBER};

<L1>:
  return D.34903;

}



;; Function ImVec2 ImRect::GetSize() const (_ZNK6ImRect7GetSizeEv, funcdef_no=453, decl_uid=10869, cgraph_uid=352, symbol_order=352)

ImVec2 ImRect::GetSize() const (const struct ImRect * const this)
{
  float D.24617;
  float D.24616;
  float D.24615;
  float D.24614;
  float D.24613;
  float D.24612;
  struct ImVec2 D.10966;
  struct ImVec2 D.24611;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;

  <bb 2>:
  _3 = this_2(D)->Max.y;
  _4 = this_2(D)->Min.y;
  _5 = _3 - _4;
  _6 = this_2(D)->Max.x;
  _7 = this_2(D)->Min.x;
  _8 = _6 - _7;
  ImVec2::ImVec2 (&D.10966, _8, _5);
  D.24611 = D.10966;
  D.10966 ={v} {CLOBBER};

<L1>:
  return D.24611;

}



;; Function float ImRect::GetWidth() const (_ZNK6ImRect8GetWidthEv, funcdef_no=454, decl_uid=10871, cgraph_uid=353, symbol_order=353)

float ImRect::GetWidth() const (const struct ImRect * const this)
{
  float D.25626;
  float D.25625;
  float D.25624;
  float _3;
  float _4;
  float _5;

  <bb 2>:
  _3 = this_2(D)->Max.x;
  _4 = this_2(D)->Min.x;
  _5 = _3 - _4;

<L0>:
  return _5;

}



;; Function float ImRect::GetHeight() const (_ZNK6ImRect9GetHeightEv, funcdef_no=455, decl_uid=10873, cgraph_uid=354, symbol_order=354)

float ImRect::GetHeight() const (const struct ImRect * const this)
{
  float D.25622;
  float D.25621;
  float D.25620;
  float _3;
  float _4;
  float _5;

  <bb 2>:
  _3 = this_2(D)->Max.y;
  _4 = this_2(D)->Min.y;
  _5 = _3 - _4;

<L0>:
  return _5;

}



;; Function ImVec2 ImRect::GetTL() const (_ZNK6ImRect5GetTLEv, funcdef_no=456, decl_uid=10875, cgraph_uid=355, symbol_order=355)

ImVec2 ImRect::GetTL() const (const struct ImRect * const this)
{
  struct ImVec2 D.41654;

  <bb 2>:
  D.41654 = this_2(D)->Min;

<L0>:
  return D.41654;

}



;; Function ImVec2 ImRect::GetTR() const (_ZNK6ImRect5GetTREv, funcdef_no=457, decl_uid=10877, cgraph_uid=356, symbol_order=356)

ImVec2 ImRect::GetTR() const (const struct ImRect * const this)
{
  float D.32939;
  float D.32938;
  struct ImVec2 D.10972;
  struct ImVec2 D.32937;
  float _3;
  float _4;

  <bb 2>:
  _3 = this_2(D)->Min.y;
  _4 = this_2(D)->Max.x;
  ImVec2::ImVec2 (&D.10972, _4, _3);
  D.32937 = D.10972;
  D.10972 ={v} {CLOBBER};

<L1>:
  return D.32937;

}



;; Function ImVec2 ImRect::GetBL() const (_ZNK6ImRect5GetBLEv, funcdef_no=458, decl_uid=10879, cgraph_uid=357, symbol_order=357)

ImVec2 ImRect::GetBL() const (const struct ImRect * const this)
{
  float D.32805;
  float D.32804;
  struct ImVec2 D.10974;
  struct ImVec2 D.32803;
  float _3;
  float _4;

  <bb 2>:
  _3 = this_2(D)->Max.y;
  _4 = this_2(D)->Min.x;
  ImVec2::ImVec2 (&D.10974, _4, _3);
  D.32803 = D.10974;
  D.10974 ={v} {CLOBBER};

<L1>:
  return D.32803;

}



;; Function ImVec2 ImRect::GetBR() const (_ZNK6ImRect5GetBREv, funcdef_no=459, decl_uid=10881, cgraph_uid=358, symbol_order=358)

ImVec2 ImRect::GetBR() const (const struct ImRect * const this)
{
  struct ImVec2 D.32801;

  <bb 2>:
  D.32801 = this_2(D)->Max;

<L0>:
  return D.32801;

}



;; Function bool ImRect::Contains(const ImVec2&) const (_ZNK6ImRect8ContainsERK6ImVec2, funcdef_no=460, decl_uid=10884, cgraph_uid=359, symbol_order=359)

bool ImRect::Contains(const ImVec2&) const (const struct ImRect * const this, const struct ImVec2 & p)
{
  float D.29277;
  float D.29276;
  float D.29274;
  float D.29273;
  float D.29271;
  float D.29270;
  float D.29268;
  float D.29267;
  bool iftmp.388;
  bool D.29263;
  bool iftmp.388_1;
  float _4;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  bool iftmp.388_13;
  bool iftmp.388_14;
  bool _15;

  <bb 2>:
  _4 = p_3(D)->x;
  _6 = this_5(D)->Min.x;
  if (_4 >= _6)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _7 = p_3(D)->y;
  _8 = this_5(D)->Min.y;
  if (_7 >= _8)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _9 = p_3(D)->x;
  _10 = this_5(D)->Max.x;
  if (_9 < _10)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _11 = p_3(D)->y;
  _12 = this_5(D)->Max.y;
  if (_11 < _12)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.388_13 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.388_14 = 0;

  <bb 8>:
  # iftmp.388_1 = PHI <iftmp.388_13(6), iftmp.388_14(7)>
  _15 = iftmp.388_1;

<L6>:
  return _15;

}



;; Function bool ImRect::Contains(const ImRect&) const (_ZNK6ImRect8ContainsERKS_, funcdef_no=461, decl_uid=10887, cgraph_uid=360, symbol_order=360)

bool ImRect::Contains(const ImRect&) const (const struct ImRect * const this, const struct ImRect & r)
{
  float D.26135;
  float D.26134;
  float D.26132;
  float D.26131;
  float D.26129;
  float D.26128;
  float D.26126;
  float D.26125;
  bool iftmp.236;
  bool D.26121;
  bool iftmp.236_1;
  float _4;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  bool iftmp.236_13;
  bool iftmp.236_14;
  bool _15;

  <bb 2>:
  _4 = r_3(D)->Min.x;
  _6 = this_5(D)->Min.x;
  if (_4 >= _6)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _7 = r_3(D)->Min.y;
  _8 = this_5(D)->Min.y;
  if (_7 >= _8)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _9 = r_3(D)->Max.x;
  _10 = this_5(D)->Max.x;
  if (_9 <= _10)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _11 = r_3(D)->Max.y;
  _12 = this_5(D)->Max.y;
  if (_11 <= _12)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.236_13 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.236_14 = 0;

  <bb 8>:
  # iftmp.236_1 = PHI <iftmp.236_13(6), iftmp.236_14(7)>
  _15 = iftmp.236_1;

<L6>:
  return _15;

}



;; Function bool ImRect::Overlaps(const ImRect&) const (_ZNK6ImRect8OverlapsERKS_, funcdef_no=462, decl_uid=10890, cgraph_uid=361, symbol_order=361)

bool ImRect::Overlaps(const ImRect&) const (const struct ImRect * const this, const struct ImRect & r)
{
  float D.25118;
  float D.25117;
  float D.25115;
  float D.25114;
  float D.25112;
  float D.25111;
  float D.25109;
  float D.25108;
  bool iftmp.175;
  bool D.25104;
  bool iftmp.175_1;
  float _4;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  bool iftmp.175_13;
  bool iftmp.175_14;
  bool _15;

  <bb 2>:
  _4 = r_3(D)->Min.y;
  _6 = this_5(D)->Max.y;
  if (_4 < _6)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _7 = r_3(D)->Max.y;
  _8 = this_5(D)->Min.y;
  if (_7 > _8)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _9 = r_3(D)->Min.x;
  _10 = this_5(D)->Max.x;
  if (_9 < _10)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _11 = r_3(D)->Max.x;
  _12 = this_5(D)->Min.x;
  if (_11 > _12)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.175_13 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.175_14 = 0;

  <bb 8>:
  # iftmp.175_1 = PHI <iftmp.175_13(6), iftmp.175_14(7)>
  _15 = iftmp.175_1;

<L6>:
  return _15;

}



;; Function void ImRect::Add(const ImVec2&) (_ZN6ImRect3AddERK6ImVec2, funcdef_no=463, decl_uid=10893, cgraph_uid=362, symbol_order=362)

void ImRect::Add(const ImVec2&) (struct ImRect * const this, const struct ImVec2 & p)
{
  float D.45189;
  float D.45186;
  float D.45185;
  float D.45183;
  float D.45180;
  float D.45179;
  float D.45177;
  float D.45174;
  float D.45173;
  float D.45171;
  float D.45168;
  float D.45167;
  float _7;
  float _9;
  float _10;
  float _12;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;
  float _20;
  float _21;
  float _22;

  <bb 2>:
  _7 = this_6(D)->Min.x;
  _9 = p_8(D)->x;
  if (_7 > _9)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = p_8(D)->x;
  this_6(D)->Min.x = _10;

  <bb 4>:
  _12 = this_6(D)->Min.y;
  _13 = p_8(D)->y;
  if (_12 > _13)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _14 = p_8(D)->y;
  this_6(D)->Min.y = _14;

  <bb 6>:
  _16 = this_6(D)->Max.x;
  _17 = p_8(D)->x;
  if (_16 < _17)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _18 = p_8(D)->x;
  this_6(D)->Max.x = _18;

  <bb 8>:
  _20 = this_6(D)->Max.y;
  _21 = p_8(D)->y;
  if (_20 < _21)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _22 = p_8(D)->y;
  this_6(D)->Max.y = _22;

  <bb 10>:
  return;

}



;; Function void ImRect::Add(const ImRect&) (_ZN6ImRect3AddERKS_, funcdef_no=464, decl_uid=10896, cgraph_uid=363, symbol_order=363)

void ImRect::Add(const ImRect&) (struct ImRect * const this, const struct ImRect & r)
{
  float D.37348;
  float D.37345;
  float D.37344;
  float D.37342;
  float D.37339;
  float D.37338;
  float D.37336;
  float D.37333;
  float D.37332;
  float D.37330;
  float D.37327;
  float D.37326;
  float _7;
  float _9;
  float _10;
  float _12;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;
  float _20;
  float _21;
  float _22;

  <bb 2>:
  _7 = this_6(D)->Min.x;
  _9 = r_8(D)->Min.x;
  if (_7 > _9)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = r_8(D)->Min.x;
  this_6(D)->Min.x = _10;

  <bb 4>:
  _12 = this_6(D)->Min.y;
  _13 = r_8(D)->Min.y;
  if (_12 > _13)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _14 = r_8(D)->Min.y;
  this_6(D)->Min.y = _14;

  <bb 6>:
  _16 = this_6(D)->Max.x;
  _17 = r_8(D)->Max.x;
  if (_16 < _17)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _18 = r_8(D)->Max.x;
  this_6(D)->Max.x = _18;

  <bb 8>:
  _20 = this_6(D)->Max.y;
  _21 = r_8(D)->Max.y;
  if (_20 < _21)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _22 = r_8(D)->Max.y;
  this_6(D)->Max.y = _22;

  <bb 10>:
  return;

}



;; Function void ImRect::Expand(float) (_ZN6ImRect6ExpandEf, funcdef_no=465, decl_uid=10899, cgraph_uid=364, symbol_order=364)

void ImRect::Expand(float) (struct ImRect * const this, const float amount)
{
  float D.32815;
  float D.32814;
  float D.32813;
  float D.32812;
  float D.32811;
  float D.32810;
  float D.32809;
  float D.32808;
  float _3;
  float _5;
  float _7;
  float _8;
  float _10;
  float _11;
  float _13;
  float _14;

  <bb 2>:
  _3 = this_2(D)->Min.x;
  _5 = _3 - amount_4(D);
  this_2(D)->Min.x = _5;
  _7 = this_2(D)->Min.y;
  _8 = _7 - amount_4(D);
  this_2(D)->Min.y = _8;
  _10 = this_2(D)->Max.x;
  _11 = _10 + amount_4(D);
  this_2(D)->Max.x = _11;
  _13 = this_2(D)->Max.y;
  _14 = _13 + amount_4(D);
  this_2(D)->Max.y = _14;
  return;

}



;; Function void ImRect::Expand(const ImVec2&) (_ZN6ImRect6ExpandERK6ImVec2, funcdef_no=466, decl_uid=10902, cgraph_uid=365, symbol_order=365)

void ImRect::Expand(const ImVec2&) (struct ImRect * const this, const struct ImVec2 & amount)
{
  float D.26820;
  float D.26819;
  float D.26818;
  float D.26817;
  float D.26816;
  float D.26815;
  float D.26814;
  float D.26813;
  float D.26812;
  float D.26811;
  float D.26810;
  float D.26809;
  float _3;
  float _5;
  float _6;
  float _8;
  float _9;
  float _10;
  float _12;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;

  <bb 2>:
  _3 = this_2(D)->Min.x;
  _5 = amount_4(D)->x;
  _6 = _3 - _5;
  this_2(D)->Min.x = _6;
  _8 = this_2(D)->Min.y;
  _9 = amount_4(D)->y;
  _10 = _8 - _9;
  this_2(D)->Min.y = _10;
  _12 = this_2(D)->Max.x;
  _13 = amount_4(D)->x;
  _14 = _12 + _13;
  this_2(D)->Max.x = _14;
  _16 = this_2(D)->Max.y;
  _17 = amount_4(D)->y;
  _18 = _16 + _17;
  this_2(D)->Max.y = _18;
  return;

}



;; Function void ImRect::Translate(const ImVec2&) (_ZN6ImRect9TranslateERK6ImVec2, funcdef_no=467, decl_uid=10905, cgraph_uid=366, symbol_order=366)

void ImRect::Translate(const ImVec2&) (struct ImRect * const this, const struct ImVec2 & v)
{
  float D.26149;
  float D.26148;
  float D.26147;
  float D.26146;
  float D.26145;
  float D.26144;
  float D.26143;
  float D.26142;
  float D.26141;
  float D.26140;
  float D.26139;
  float D.26138;
  float _3;
  float _5;
  float _6;
  float _8;
  float _9;
  float _10;
  float _12;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;

  <bb 2>:
  _3 = this_2(D)->Min.x;
  _5 = v_4(D)->x;
  _6 = _3 + _5;
  this_2(D)->Min.x = _6;
  _8 = this_2(D)->Min.y;
  _9 = v_4(D)->y;
  _10 = _8 + _9;
  this_2(D)->Min.y = _10;
  _12 = this_2(D)->Max.x;
  _13 = v_4(D)->x;
  _14 = _12 + _13;
  this_2(D)->Max.x = _14;
  _16 = this_2(D)->Max.y;
  _17 = v_4(D)->y;
  _18 = _16 + _17;
  this_2(D)->Max.y = _18;
  return;

}



;; Function void ImRect::ClipWith(const ImRect&) (_ZN6ImRect8ClipWithERKS_, funcdef_no=468, decl_uid=10908, cgraph_uid=367, symbol_order=367)

void ImRect::ClipWith(const ImRect&) (struct ImRect * const this, const struct ImRect & r)
{
  struct ImVec2 * D.26824;
  const struct ImVec2 * D.26823;
  struct ImVec2 * D.26822;
  const struct ImVec2 * D.26821;
  const struct ImVec2 * _2;
  struct ImVec2 * _4;
  const struct ImVec2 * _7;
  struct ImVec2 * _8;

  <bb 2>:
  _2 = &r_1(D)->Min;
  _4 = &this_3(D)->Min;
  this_3(D)->Min = ImMax (_4, _2);
  _7 = &r_1(D)->Max;
  _8 = &this_3(D)->Max;
  this_3(D)->Max = ImMin (_8, _7);
  return;

}



;; Function void ImRect::Floor() (_ZN6ImRect5FloorEv, funcdef_no=470, decl_uid=10913, cgraph_uid=369, symbol_order=369)

void ImRect::Floor() (struct ImRect * const this)
{
  float D.45202;
  int D.45201;
  float D.45200;
  float D.45199;
  int D.45198;
  float D.45197;
  float D.45196;
  int D.45195;
  float D.45194;
  float D.45193;
  int D.45192;
  float D.45191;
  float _3;
  int _4;
  float _5;
  float _7;
  int _8;
  float _9;
  float _11;
  int _12;
  float _13;
  float _15;
  int _16;
  float _17;

  <bb 2>:
  _3 = this_2(D)->Min.x;
  _4 = (int) _3;
  _5 = (float) _4;
  this_2(D)->Min.x = _5;
  _7 = this_2(D)->Min.y;
  _8 = (int) _7;
  _9 = (float) _8;
  this_2(D)->Min.y = _9;
  _11 = this_2(D)->Max.x;
  _12 = (int) _11;
  _13 = (float) _12;
  this_2(D)->Max.x = _13;
  _15 = this_2(D)->Max.y;
  _16 = (int) _15;
  _17 = (float) _16;
  this_2(D)->Max.y = _17;
  return;

}



;; Function void ImRect::FixInverted() (_ZN6ImRect11FixInvertedEv, funcdef_no=471, decl_uid=10915, cgraph_uid=370, symbol_order=370)

void ImRect::FixInverted() (struct ImRect * const this)
{
  float * D.31062;
  float * D.31061;
  float D.31058;
  float D.31057;
  float * D.31055;
  float * D.31054;
  float D.31051;
  float D.31050;
  float _5;
  float _6;
  float * _7;
  float * _8;
  float _10;
  float _11;
  float * _12;
  float * _13;

  <bb 2>:
  _5 = this_4(D)->Min.x;
  _6 = this_4(D)->Max.x;
  if (_5 > _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = &this_4(D)->Max.x;
  _8 = &this_4(D)->Min.x;
  ImSwap (_8, _7);

  <bb 4>:
  _10 = this_4(D)->Min.y;
  _11 = this_4(D)->Max.y;
  if (_10 > _11)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _12 = &this_4(D)->Max.y;
  _13 = &this_4(D)->Min.y;
  ImSwap (_13, _12);

  <bb 6>:
  return;

}



;; Function bool ImRect::IsInverted() const (_ZNK6ImRect10IsInvertedEv, funcdef_no=472, decl_uid=10917, cgraph_uid=371, symbol_order=371)

bool ImRect::IsInverted() const (const struct ImRect * const this)
{
  float D.26866;
  float D.26865;
  float D.26863;
  float D.26862;
  bool iftmp.271;
  bool D.26857;
  bool iftmp.271_1;
  float _4;
  float _5;
  float _6;
  float _7;
  bool iftmp.271_8;
  bool iftmp.271_9;
  bool _10;

  <bb 2>:
  _4 = this_3(D)->Min.x;
  _5 = this_3(D)->Max.x;
  if (_4 > _5)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _6 = this_3(D)->Min.y;
  _7 = this_3(D)->Max.y;
  if (_6 > _7)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.271_9 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.271_8 = 0;

  <bb 6>:
  # iftmp.271_1 = PHI <iftmp.271_9(4), iftmp.271_8(5)>
  _10 = iftmp.271_1;

<L4>:
  return _10;

}



;; Function ImGuiStyleMod::ImGuiStyleMod(ImGuiStyleVar, float) (_ZN13ImGuiStyleModC2Eif, funcdef_no=477, decl_uid=11032, cgraph_uid=376, symbol_order=376)

ImGuiStyleMod::ImGuiStyleMod(ImGuiStyleVar, float) (struct ImGuiStyleMod * const this, ImGuiStyleVar idx, float v)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->VarIdx = idx_4(D);
  this_2(D)->D.11007.BackupFloat[0] = v_6(D);
  return;

}



;; Function ImGuiStyleMod::ImGuiStyleMod(ImGuiStyleVar, ImVec2) (_ZN13ImGuiStyleModC2Ei6ImVec2, funcdef_no=480, decl_uid=11024, cgraph_uid=379, symbol_order=379)

ImGuiStyleMod::ImGuiStyleMod(ImGuiStyleVar, ImVec2) (struct ImGuiStyleMod * const this, ImGuiStyleVar idx, struct ImVec2 v)
{
  float D.33795;
  float D.33794;
  float _6;
  float _8;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->VarIdx = idx_4(D);
  _6 = v.x;
  this_2(D)->D.11007.BackupFloat[0] = _6;
  _8 = v.y;
  this_2(D)->D.11007.BackupFloat[1] = _8;
  return;

}



;; Function ImGuiTextEditState::ImGuiTextEditState() (_ZN18ImGuiTextEditStateC2Ev, funcdef_no=483, decl_uid=11136, cgraph_uid=382, symbol_order=382)

ImGuiTextEditState::ImGuiTextEditState() (struct ImGuiTextEditState * const this)
{
  struct ImVector * D.25447;
  struct ImVector * D.25446;
  struct ImVector * D.25445;
  struct ImVector * D.25444;
  struct ImVector * D.25443;
  struct ImVector * D.25442;
  struct ImVector * _4;
  struct ImVector * _6;
  struct ImVector * _8;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Text;
  ImVector<short unsigned int>::ImVector (_4);
  _6 = &this_2(D)->InitialText;
  ImVector<char>::ImVector (_6);
  _8 = &this_2(D)->TempTextBuffer;
  ImVector<char>::ImVector (_8);
  memset (this_2(D), 0, 3304);
  return;

}



;; Function void ImGuiTextEditState::CursorAnimReset() (_ZN18ImGuiTextEditState15CursorAnimResetEv, funcdef_no=485, decl_uid=11121, cgraph_uid=384, symbol_order=384)

void ImGuiTextEditState::CursorAnimReset() (struct ImGuiTextEditState * const this)
{
  <bb 2>:
  this_2(D)->CursorAnim = -3.00000011920928955078125e-1;
  return;

}



;; Function void ImGuiTextEditState::CursorClamp() (_ZN18ImGuiTextEditState11CursorClampEv, funcdef_no=486, decl_uid=11123, cgraph_uid=385, symbol_order=385)

void ImGuiTextEditState::CursorClamp() (struct ImGuiTextEditState * const this)
{
  int D.40330;
  int D.40329;
  int D.40328;
  int D.40327;
  int D.40326;
  int D.40325;
  int D.40324;
  int D.40323;
  int D.40322;
  int _3;
  int _4;
  int _6;
  int _8;
  int _9;
  int _11;
  int _13;
  int _14;
  int _16;

  <bb 2>:
  _3 = this_2(D)->CurLenW;
  _4 = this_2(D)->StbState.cursor;
  _6 = ImMin (_4, _3);
  this_2(D)->StbState.cursor = _6;
  _8 = this_2(D)->CurLenW;
  _9 = this_2(D)->StbState.select_start;
  _11 = ImMin (_9, _8);
  this_2(D)->StbState.select_start = _11;
  _13 = this_2(D)->CurLenW;
  _14 = this_2(D)->StbState.select_end;
  _16 = ImMin (_14, _13);
  this_2(D)->StbState.select_end = _16;
  return;

}



;; Function bool ImGuiTextEditState::HasSelection() const (_ZNK18ImGuiTextEditState12HasSelectionEv, funcdef_no=487, decl_uid=11125, cgraph_uid=386, symbol_order=386)

bool ImGuiTextEditState::HasSelection() const (const struct ImGuiTextEditState * const this)
{
  int D.40335;
  int D.40334;
  bool D.40333;
  int _3;
  int _4;
  bool _5;

  <bb 2>:
  _3 = this_2(D)->StbState.select_start;
  _4 = this_2(D)->StbState.select_end;
  _5 = _3 != _4;

<L0>:
  return _5;

}



;; Function void ImGuiTextEditState::ClearSelection() (_ZN18ImGuiTextEditState14ClearSelectionEv, funcdef_no=488, decl_uid=11127, cgraph_uid=387, symbol_order=387)

void ImGuiTextEditState::ClearSelection() (struct ImGuiTextEditState * const this)
{
  int D.40332;
  int D.40331;
  int _3;
  int _5;

  <bb 2>:
  _3 = this_2(D)->StbState.cursor;
  this_2(D)->StbState.select_end = _3;
  _5 = this_2(D)->StbState.select_end;
  this_2(D)->StbState.select_start = _5;
  return;

}



;; Function void ImGuiTextEditState::SelectAll() (_ZN18ImGuiTextEditState9SelectAllEv, funcdef_no=489, decl_uid=11129, cgraph_uid=388, symbol_order=388)

void ImGuiTextEditState::SelectAll() (struct ImGuiTextEditState * const this)
{
  int D.40338;
  int D.40337;
  int _4;
  int _6;

  <bb 2>:
  this_2(D)->StbState.select_start = 0;
  _4 = this_2(D)->CurLenW;
  this_2(D)->StbState.select_end = _4;
  _6 = this_2(D)->StbState.select_end;
  this_2(D)->StbState.cursor = _6;
  this_2(D)->StbState.has_preferred_x = 0;
  return;

}



;; Function ImGuiWindowSettings::ImGuiWindowSettings() (_ZN19ImGuiWindowSettingsC2Ev, funcdef_no=491, decl_uid=11267, cgraph_uid=390, symbol_order=390)

ImGuiWindowSettings::ImGuiWindowSettings() (struct ImGuiWindowSettings * const this)
{
  struct ImVec2 * D.28028;
  struct ImVec2 D.11277;
  struct ImVec2 * D.28027;
  struct ImVec2 * D.28026;
  struct ImVec2 * _4;
  struct ImVec2 * _6;
  struct ImVec2 * _12;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Pos;
  ImVec2::ImVec2 (_4);
  _6 = &this_2(D)->Size;
  ImVec2::ImVec2 (_6);
  this_2(D)->Name = 0B;
  this_2(D)->Id = 0;
  ImVec2::ImVec2 (&D.11277, 0.0, 0.0);
  this_2(D)->Size = D.11277;
  _12 = &this_2(D)->Size;
  this_2(D)->Pos = MEM[(const struct ImVec2 &)_12];
  D.11277 ={v} {CLOBBER};
  this_2(D)->Collapsed = 0;
  return;

}



;; Function ImGuiSettingsHandler::ImGuiSettingsHandler() (_ZN20ImGuiSettingsHandlerC2Ev, funcdef_no=494, decl_uid=11301, cgraph_uid=393, symbol_order=393)

ImGuiSettingsHandler::ImGuiSettingsHandler() (struct ImGuiSettingsHandler * const this)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  memset (this_2(D), 0, 48);
  return;

}



;; Function ImGuiColumnData::ImGuiColumnData() (_ZN15ImGuiColumnDataC2Ev, funcdef_no=497, decl_uid=11337, cgraph_uid=396, symbol_order=396)

ImGuiColumnData::ImGuiColumnData() (struct ImGuiColumnData * const this)
{
  float D.44042;
  struct ImRect * D.44041;
  struct ImRect * _4;
  float _7;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->ClipRect;
  ImRect::ImRect (_4);
  this_2(D)->OffsetNormBeforeResize = 0.0;
  _7 = this_2(D)->OffsetNormBeforeResize;
  this_2(D)->OffsetNorm = _7;
  this_2(D)->Flags = 0;
  return;

}



;; Function ImGuiColumnsSet::ImGuiColumnsSet() (_ZN15ImGuiColumnsSetC2Ev, funcdef_no=500, decl_uid=11496, cgraph_uid=399, symbol_order=399)

ImGuiColumnsSet::ImGuiColumnsSet() (struct ImGuiColumnsSet * const this)
{
  void * D.46218;
  struct ImVector * D.43843;
  struct ImVector * D.43842;
  struct ImVector * _4;
  struct ImVector * _7;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->Columns;
  ImVector<ImGuiColumnData>::ImVector (_4);
  ImGuiColumnsSet::Clear (this_2(D));

  <bb 3>:
  return;

<L0>:
  _7 = &this_2(D)->Columns;
  ImVector<ImGuiColumnData>::~ImVector (_7);
  _9 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_9);

}



;; Function void ImGuiColumnsSet::Clear() (_ZN15ImGuiColumnsSet5ClearEv, funcdef_no=502, decl_uid=11492, cgraph_uid=401, symbol_order=401)

void ImGuiColumnsSet::Clear() (struct ImGuiColumnsSet * const this)
{
  struct ImVector * D.43848;
  float D.43847;
  float D.43846;
  float _10;
  float _13;
  struct ImVector * _17;

  <bb 2>:
  this_2(D)->ID = 0;
  this_2(D)->Flags = 0;
  this_2(D)->IsFirstFrame = 0;
  this_2(D)->IsBeingResized = 0;
  this_2(D)->Current = 0;
  this_2(D)->Count = 1;
  this_2(D)->MaxX = 0.0;
  _10 = this_2(D)->MaxX;
  this_2(D)->MinX = _10;
  this_2(D)->LineMaxY = 0.0;
  _13 = this_2(D)->LineMaxY;
  this_2(D)->LineMinY = _13;
  this_2(D)->StartPosY = 0.0;
  this_2(D)->StartMaxPosX = 0.0;
  _17 = &this_2(D)->Columns;
  ImVector<ImGuiColumnData>::clear (_17);
  return;

}



;; Function void ImDrawDataBuilder::Clear() (_ZN17ImDrawDataBuilder5ClearEv, funcdef_no=503, decl_uid=11639, cgraph_uid=402, symbol_order=402)

void ImDrawDataBuilder::Clear() (struct ImDrawDataBuilder * const this)
{
  int n;
  struct ImVector * D.28771;
  struct ImVector * _6;

  <bb 2>:
  n_3 = 0;

  <bb 3>:
  # n_1 = PHI <n_3(2), n_8(4)>
  if (n_1 > 1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _6 = &this_5(D)->Layers[n_1];
  ImVector<ImDrawList*>::resize (_6, 0);
  n_8 = n_1 + 1;
  goto <bb 3>;

  <bb 5>:
  return;

}



;; Function void ImDrawDataBuilder::ClearFreeMemory() (_ZN17ImDrawDataBuilder15ClearFreeMemoryEv, funcdef_no=504, decl_uid=11641, cgraph_uid=403, symbol_order=403)

void ImDrawDataBuilder::ClearFreeMemory() (struct ImDrawDataBuilder * const this)
{
  int n;
  struct ImVector * D.27968;
  struct ImVector * _6;

  <bb 2>:
  n_3 = 0;

  <bb 3>:
  # n_1 = PHI <n_3(2), n_8(4)>
  if (n_1 > 1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _6 = &this_5(D)->Layers[n_1];
  ImVector<ImDrawList*>::clear (_6);
  n_8 = n_1 + 1;
  goto <bb 3>;

  <bb 5>:
  return;

}



;; Function ImGuiNavMoveResult::ImGuiNavMoveResult() (_ZN18ImGuiNavMoveResultC2Ev, funcdef_no=506, decl_uid=11669, cgraph_uid=405, symbol_order=405)

ImGuiNavMoveResult::ImGuiNavMoveResult() (struct ImGuiNavMoveResult * const this)
{
  struct ImRect * D.25404;
  struct ImRect * _4;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->RectRel;
  ImRect::ImRect (_4);
  ImGuiNavMoveResult::Clear (this_2(D));
  return;

}



;; Function void ImGuiNavMoveResult::Clear() (_ZN18ImGuiNavMoveResult5ClearEv, funcdef_no=508, decl_uid=11665, cgraph_uid=407, symbol_order=407)

void ImGuiNavMoveResult::Clear() (struct ImGuiNavMoveResult * const this)
{
  struct ImRect D.11682;
  float D.25407;
  float D.25406;
  unsigned int D.25405;
  unsigned int _4;
  float _8;
  float _10;

  <bb 2>:
  this_2(D)->ParentID = 0;
  _4 = this_2(D)->ParentID;
  this_2(D)->ID = _4;
  this_2(D)->Window = 0B;
  this_2(D)->DistAxial = 3.4028234663852885981170418348451692544e+38;
  _8 = this_2(D)->DistAxial;
  this_2(D)->DistCenter = _8;
  _10 = this_2(D)->DistCenter;
  this_2(D)->DistBox = _10;
  ImRect::ImRect (&D.11682);
  this_2(D)->RectRel = D.11682;
  D.11682 ={v} {CLOBBER};
  return;

}



;; Function ImGuiNextWindowData::ImGuiNextWindowData() (_ZN19ImGuiNextWindowDataC2Ev, funcdef_no=510, decl_uid=11713, cgraph_uid=409, symbol_order=409)

ImGuiNextWindowData::ImGuiNextWindowData() (struct ImGuiNextWindowData * const this)
{
  struct ImRect D.11738;
  struct ImVec2 D.11737;
  struct ImVec2 * D.25403;
  struct ImVec2 * D.25402;
  struct ImVec2 D.11736;
  int D.25401;
  int D.25400;
  int D.25399;
  int D.25398;
  int D.25397;
  int D.25396;
  struct ImRect * D.25395;
  struct ImVec2 * D.25394;
  struct ImVec2 * D.25393;
  struct ImVec2 * D.25392;
  struct ImVec2 * D.25391;
  struct ImVec2 * _4;
  struct ImVec2 * _6;
  struct ImVec2 * _8;
  struct ImVec2 * _10;
  struct ImRect * _12;
  int _15;
  int _17;
  int _19;
  int _21;
  int _23;
  int _25;
  struct ImVec2 * _29;
  struct ImVec2 * _31;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->PosVal;
  ImVec2::ImVec2 (_4);
  _6 = &this_2(D)->PosPivotVal;
  ImVec2::ImVec2 (_6);
  _8 = &this_2(D)->SizeVal;
  ImVec2::ImVec2 (_8);
  _10 = &this_2(D)->ContentSizeVal;
  ImVec2::ImVec2 (_10);
  _12 = &this_2(D)->SizeConstraintRect;
  ImRect::ImRect (_12);
  this_2(D)->BgAlphaCond = 0;
  _15 = this_2(D)->BgAlphaCond;
  this_2(D)->FocusCond = _15;
  _17 = this_2(D)->FocusCond;
  this_2(D)->SizeConstraintCond = _17;
  _19 = this_2(D)->SizeConstraintCond;
  this_2(D)->CollapsedCond = _19;
  _21 = this_2(D)->CollapsedCond;
  this_2(D)->ContentSizeCond = _21;
  _23 = this_2(D)->ContentSizeCond;
  this_2(D)->SizeCond = _23;
  _25 = this_2(D)->SizeCond;
  this_2(D)->PosCond = _25;
  ImVec2::ImVec2 (&D.11736, 0.0, 0.0);
  this_2(D)->SizeVal = D.11736;
  _29 = &this_2(D)->SizeVal;
  this_2(D)->PosPivotVal = MEM[(const struct ImVec2 &)_29];
  _31 = &this_2(D)->PosPivotVal;
  this_2(D)->PosVal = MEM[(const struct ImVec2 &)_31];
  D.11736 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.11737, 0.0, 0.0);
  this_2(D)->ContentSizeVal = D.11737;
  D.11737 ={v} {CLOBBER};
  this_2(D)->CollapsedVal = 0;
  ImRect::ImRect (&D.11738);
  this_2(D)->SizeConstraintRect = D.11738;
  D.11738 ={v} {CLOBBER};
  this_2(D)->SizeCallback = 0B;
  this_2(D)->SizeCallbackUserData = 0B;
  this_2(D)->BgAlphaVal = 3.4028234663852885981170418348451692544e+38;
  return;

}



;; Function void ImGuiNextWindowData::Clear() (_ZN19ImGuiNextWindowData5ClearEv, funcdef_no=512, decl_uid=11709, cgraph_uid=411, symbol_order=411)

void ImGuiNextWindowData::Clear() (struct ImGuiNextWindowData * const this)
{
  int D.29840;
  int D.29839;
  int D.29838;
  int D.29837;
  int D.29836;
  int D.29835;
  int _4;
  int _6;
  int _8;
  int _10;
  int _12;
  int _14;

  <bb 2>:
  this_2(D)->BgAlphaCond = 0;
  _4 = this_2(D)->BgAlphaCond;
  this_2(D)->FocusCond = _4;
  _6 = this_2(D)->FocusCond;
  this_2(D)->SizeConstraintCond = _6;
  _8 = this_2(D)->SizeConstraintCond;
  this_2(D)->CollapsedCond = _8;
  _10 = this_2(D)->CollapsedCond;
  this_2(D)->ContentSizeCond = _10;
  _12 = this_2(D)->ContentSizeCond;
  this_2(D)->SizeCond = _12;
  _14 = this_2(D)->SizeCond;
  this_2(D)->PosCond = _14;
  return;

}



;; Function ImGuiStorage::ImGuiStorage() (_ZN12ImGuiStorageC2Ev, funcdef_no=515, decl_uid=12699, cgraph_uid=413, symbol_order=413)

ImGuiStorage::ImGuiStorage() (struct ImGuiStorage * const this)
{
  struct ImVector * D.24232;
  struct ImVector * D.24231;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Data;
  ImVector<ImGuiStorage::Pair>::ImVector (_2);
  return;

}



;; Function ImGuiStorage::~ImGuiStorage() (_ZN12ImGuiStorageD2Ev, funcdef_no=518, decl_uid=12728, cgraph_uid=416, symbol_order=416)

ImGuiStorage::~ImGuiStorage() (struct ImGuiStorage * const this)
{
  struct ImVector * D.24353;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Data;
  ImVector<ImGuiStorage::Pair>::~ImVector (_2);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function ImDrawDataBuilder::ImDrawDataBuilder() (_ZN17ImDrawDataBuilderC2Ev, funcdef_no=521, decl_uid=12805, cgraph_uid=419, symbol_order=419)

ImDrawDataBuilder::ImDrawDataBuilder() (struct ImDrawDataBuilder * const this)
{
  struct ImVector * D.12830;
  struct ImVector * D.25413;
  struct ImVector[2] * D.25434;
  struct ImVector[2] * D.25431;
  struct ImVector[2] * D.25428;
  sizetype D.25423;
  sizetype D.25422;
  long int D.25421;
  long int D.25412;
  struct ImVector * D.25411;
  struct ImVector * D.25410;
  struct ImVector * retval.198;
  struct ImVector * _1;
  long int _2;
  struct ImVector * _5;
  struct ImVector * _6;
  long int _7;
  struct ImVector * _10;
  long int _11;
  struct ImVector * retval.198_12;

  <bb 2>:
  _5 = &this_4(D)->Layers;
  _6 = _5;
  _7 = 1;

  <bb 3>:
  # _1 = PHI <_6(2), _10(4)>
  # _2 = PHI <_7(2), _11(4)>
  if (_2 < 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  ImVector<ImDrawList*>::ImVector (_1);
  _10 = _1 + 16;
  _11 = _2 + -1;
  goto <bb 3>;

  <bb 5>:
  retval.198_12 = _5;
  return;

}



;; Function ImDrawDataBuilder::~ImDrawDataBuilder() (_ZN17ImDrawDataBuilderD2Ev, funcdef_no=524, decl_uid=12838, cgraph_uid=422, symbol_order=422)

ImDrawDataBuilder::~ImDrawDataBuilder() (struct ImDrawDataBuilder * const this)
{
  struct ImVector * D.12846;
  struct ImVector[2] * D.25480;
  struct ImVector[2] * D.25477;
  struct ImVector[2] * D.25474;
  struct ImVector * _1;
  struct ImVector[2] * _5;
  struct ImVector[2] * _7;
  struct ImVector * _8;
  struct ImVector[2] * _9;
  struct ImVector * _10;

  <bb 2>:
  _5 = &this_4(D)->Layers;
  if (_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _7 = &this_4(D)->Layers;
  _8 = _7 + 32;

  <bb 4>:
  # _1 = PHI <_8(3), _10(5)>
  _9 = &this_4(D)->Layers;
  if (_9 == _1)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _10 = _1 + 18446744073709551600;
  ImVector<ImDrawList*>::~ImVector (_10);
  goto <bb 4>;

  <bb 6>:
  MEM[(struct  &)this_4(D)] ={v} {CLOBBER};
  return;

}



;; Function ImGuiTextEditState::~ImGuiTextEditState() (_ZN18ImGuiTextEditStateD2Ev, funcdef_no=527, decl_uid=12910, cgraph_uid=425, symbol_order=425)

ImGuiTextEditState::~ImGuiTextEditState() (struct ImGuiTextEditState * const this)
{
  struct ImVector * D.25468;
  struct ImVector * D.25467;
  struct ImVector * D.25466;
  struct ImVector * _2;
  struct ImVector * _5;
  struct ImVector * _7;

  <bb 2>:
  _2 = &this_1(D)->TempTextBuffer;
  ImVector<char>::~ImVector (_2);
  _5 = &this_1(D)->InitialText;
  ImVector<char>::~ImVector (_5);
  _7 = &this_1(D)->Text;
  ImVector<short unsigned int>::~ImVector (_7);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function ImGuiContext::ImGuiContext(ImFontAtlas*) (_ZN12ImGuiContextC2EP11ImFontAtlas, funcdef_no=529, decl_uid=12485, cgraph_uid=428, symbol_order=428)

Merging blocks 11 and 12
Merging blocks 16 and 17
Merging blocks 19 and 20
Merging blocks 11 and 13
Merging blocks 11 and 14
Merging blocks 11 and 15
Merging blocks 16 and 18
Merging blocks 19 and 21
Merging blocks 19 and 22
Merging blocks 19 and 23
Merging blocks 19 and 24
Merging blocks 19 and 25
Merging blocks 19 and 26
Merging blocks 19 and 27
Merging blocks 19 and 28
Merging blocks 19 and 29
ImGuiContext::ImGuiContext(ImFontAtlas*) (struct ImGuiContext * const this, struct ImFontAtlas * shared_font_atlas)
{
  void * D.46222;
  void * D.25365;
  struct ImVector * D.25364;
  struct ImVector * D.25363;
  struct ImVector * D.25362;
  struct ImGuiStorage * D.25361;
  struct ImVector * D.25360;
  struct ImVector * D.25359;
  struct ImVector * D.25358;
  struct ImVector * D.25357;
  struct ImVector * D.25356;
  struct ImDrawData * D.25355;
  struct ImDrawDataBuilder * D.25354;
  struct ImDrawList * D.25353;
  struct ImVector * D.25352;
  struct ImGuiTextEditState * D.25351;
  struct ImFont * D.25350;
  struct ImVector * D.25349;
  struct ImVector * D.25348;
  struct ImVector * D.25347;
  char[3073] * D.25346;
  int D.25345;
  int D.25344;
  float[120] * D.25343;
  struct ImVec2 * D.25342;
  struct ImVec2 D.12991;
  struct ImVec2 D.12990;
  struct ImVec2 D.12989;
  unsigned char[8] * D.25341;
  unsigned int D.25340;
  struct ImDrawListSharedData * D.25339;
  int D.25338;
  float D.25337;
  struct ImRect D.12988;
  unsigned int D.25336;
  unsigned int D.25335;
  unsigned int D.25334;
  unsigned int D.25333;
  unsigned int D.25332;
  unsigned int D.25331;
  struct ImVec2 D.12987;
  int D.25330;
  struct ImNewDummy D.25328;
  void * D.12985;
  void * D.12984;
  struct ImNewDummy D.25327;
  struct ImNewDummy D.12983;
  struct ImNewDummy D.12982;
  struct ImFontAtlas * iftmp.197;
  bool D.25323;
  float D.25322;
  struct ImVector * D.25321;
  struct ImVector * D.25320;
  struct ImVec2 * D.25319;
  struct ImVec2 * D.25318;
  struct ImVector * D.25317;
  struct ImVec2 * D.25316;
  struct ImVec2 * D.25315;
  struct ImVec4 * D.25314;
  struct ImFont * D.25313;
  struct ImGuiTextEditState * D.25312;
  struct ImVector * D.25311;
  struct ImRect * D.25310;
  struct ImGuiPayload * D.25309;
  struct ImDrawList * D.25308;
  struct ImDrawDataBuilder * D.25307;
  struct ImDrawData * D.25306;
  struct ImGuiNavMoveResult * D.25305;
  struct ImGuiNavMoveResult * D.25304;
  struct ImRect * D.25303;
  struct ImRect * D.25302;
  struct ImGuiNextWindowData * D.25301;
  struct ImVector * D.25300;
  struct ImVector * D.25299;
  struct ImVector * D.25298;
  struct ImVector * D.25297;
  struct ImVector * D.25296;
  struct ImVec2 * D.25295;
  struct ImGuiStorage * D.25294;
  struct ImVector * D.25293;
  struct ImVector * D.25292;
  struct ImVector * D.25291;
  struct ImDrawListSharedData * D.25290;
  struct ImGuiStyle * D.25289;
  struct ImGuiIO * D.25288;
  struct ImFontAtlas * iftmp.197_1;
  struct ImGuiIO * _14;
  struct ImGuiStyle * _16;
  struct ImDrawListSharedData * _18;
  struct ImVector * _20;
  struct ImVector * _22;
  struct ImVector * _24;
  struct ImGuiStorage * _26;
  struct ImVec2 * _28;
  struct ImVector * _30;
  struct ImVector * _32;
  struct ImVector * _34;
  struct ImVector * _36;
  struct ImVector * _38;
  struct ImGuiNextWindowData * _40;
  struct ImRect * _42;
  struct ImRect * _44;
  struct ImGuiNavMoveResult * _46;
  struct ImGuiNavMoveResult * _48;
  struct ImDrawData * _50;
  struct ImDrawDataBuilder * _52;
  struct ImDrawList * _54;
  struct ImGuiPayload * _56;
  struct ImRect * _58;
  struct ImVector * _60;
  struct ImGuiTextEditState * _62;
  struct ImFont * _64;
  struct ImVec4 * _66;
  struct ImVec2 * _68;
  struct ImVec2 * _70;
  struct ImVector * _72;
  struct ImVec2 * _74;
  struct ImVec2 * _76;
  struct ImVector * _78;
  struct ImVector * _80;
  float _85;
  bool _88;
  void * _92;
  void * _93;
  void * _95;
  struct ImFontAtlas * iftmp.197_97;
  struct ImVector * _101;
  struct ImVector * _103;
  struct ImVector * _105;
  struct ImFont * _107;
  struct ImFontAtlas * iftmp.197_109;
  int _116;
  unsigned int _143;
  unsigned int _145;
  unsigned int _147;
  unsigned int _149;
  unsigned int _152;
  unsigned int _154;
  float _163;
  int _180;
  struct ImDrawListSharedData * _183;
  unsigned int _193;
  unsigned char[8] * _196;
  struct ImVec2 * _213;
  float[120] * _223;
  int _228;
  int _230;
  char[3073] * _232;
  struct ImGuiTextEditState * _234;
  struct ImVector * _236;
  struct ImDrawList * _238;
  struct ImDrawDataBuilder * _240;
  struct ImDrawData * _242;
  struct ImVector * _244;
  struct ImVector * _246;
  struct ImVector * _248;
  struct ImVector * _250;
  struct ImVector * _252;
  struct ImGuiStorage * _254;
  struct ImVector * _256;
  struct ImVector * _258;
  struct ImVector * _260;

  <bb 2>:
  MEM[(struct  &)this_12(D)] ={v} {CLOBBER};
  _14 = &this_12(D)->IO;
  ImGuiIO::ImGuiIO (_14);
  _16 = &this_12(D)->Style;
  ImGuiStyle::ImGuiStyle (_16);
  _18 = &this_12(D)->DrawListSharedData;
  ImDrawListSharedData::ImDrawListSharedData (_18);
  _20 = &this_12(D)->Windows;
  ImVector<ImGuiWindow*>::ImVector (_20);
  _22 = &this_12(D)->WindowsSortBuffer;
  ImVector<ImGuiWindow*>::ImVector (_22);
  _24 = &this_12(D)->CurrentWindowStack;
  ImVector<ImGuiWindow*>::ImVector (_24);
  _26 = &this_12(D)->WindowsById;
  ImGuiStorage::ImGuiStorage (_26);
  _28 = &this_12(D)->ActiveIdClickOffset;
  ImVec2::ImVec2 (_28);
  _30 = &this_12(D)->ColorModifiers;
  ImVector<ImGuiColMod>::ImVector (_30);
  _32 = &this_12(D)->StyleModifiers;
  ImVector<ImGuiStyleMod>::ImVector (_32);
  _34 = &this_12(D)->FontStack;
  ImVector<ImFont*>::ImVector (_34);
  _36 = &this_12(D)->OpenPopupStack;
  ImVector<ImGuiPopupRef>::ImVector (_36);
  _38 = &this_12(D)->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::ImVector (_38);
  _40 = &this_12(D)->NextWindowData;
  ImGuiNextWindowData::ImGuiNextWindowData (_40);
  _42 = &this_12(D)->NavScoringRectScreen;
  ImRect::ImRect (_42);
  _44 = &this_12(D)->NavInitResultRectRel;
  ImRect::ImRect (_44);
  _46 = &this_12(D)->NavMoveResultLocal;
  ImGuiNavMoveResult::ImGuiNavMoveResult (_46);
  _48 = &this_12(D)->NavMoveResultOther;
  ImGuiNavMoveResult::ImGuiNavMoveResult (_48);
  _50 = &this_12(D)->DrawData;
  ImDrawData::ImDrawData (_50);
  _52 = &this_12(D)->DrawDataBuilder;
  ImDrawDataBuilder::ImDrawDataBuilder (_52);
  _54 = &this_12(D)->OverlayDrawList;
  ImDrawList::ImDrawList (_54, 0B);

  <bb 3>:
  _56 = &this_12(D)->DragDropPayload;
  ImGuiPayload::ImGuiPayload (_56);
  _58 = &this_12(D)->DragDropTargetRect;
  ImRect::ImRect (_58);
  _60 = &this_12(D)->DragDropPayloadBufHeap;
  ImVector<unsigned char>::ImVector (_60);
  _62 = &this_12(D)->InputTextState;
  ImGuiTextEditState::ImGuiTextEditState (_62);
  _64 = &this_12(D)->InputTextPasswordFont;
  ImFont::ImFont (_64);

  <bb 4>:
  _66 = &this_12(D)->ColorPickerRef;
  ImVec4::ImVec4 (_66);
  _68 = &this_12(D)->DragLastMouseDelta;
  ImVec2::ImVec2 (_68);
  _70 = &this_12(D)->ScrollbarClickDeltaToGrabCenter;
  ImVec2::ImVec2 (_70);
  _72 = &this_12(D)->PrivateClipboard;
  ImVector<char>::ImVector (_72);
  _74 = &this_12(D)->OsImePosRequest;
  ImVec2::ImVec2 (_74);
  _76 = &this_12(D)->OsImePosSet;
  ImVec2::ImVec2 (_76);
  _78 = &this_12(D)->SettingsWindows;
  ImVector<ImGuiWindowSettings>::ImVector (_78);
  _80 = &this_12(D)->SettingsHandlers;
  ImVector<ImGuiSettingsHandler>::ImVector (_80);
  this_12(D)->Initialized = 0;
  this_12(D)->Font = 0B;
  this_12(D)->FontBaseSize = 0.0;
  _85 = this_12(D)->FontBaseSize;
  this_12(D)->FontSize = _85;
  _88 = shared_font_atlas_87(D) == 0B;
  this_12(D)->FontAtlasOwnedByContext = _88;
  if (shared_font_atlas_87(D) == 0B)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  D.12982 = D.25327;
  _92 = ImGui::MemAlloc (120);

  <bb 6>:
  _93 = _92;
  _95 = operator new (120, D.12982, _93);
  ImFontAtlas::ImFontAtlas (_95);

  <bb 7>:
  iftmp.197_97 = _95;
  goto <bb 9>;

  <bb 8>:
  iftmp.197_109 = shared_font_atlas_87(D);

  <bb 9>:
  # iftmp.197_1 = PHI <iftmp.197_97(7), iftmp.197_109(8)>
  this_12(D)->IO.Fonts = iftmp.197_1;
  D.12982 ={v} {CLOBBER};
  D.12983 ={v} {CLOBBER};
  this_12(D)->Time = 0.0;
  this_12(D)->FrameCount = 0;
  this_12(D)->FrameCountRendered = -1;
  _116 = this_12(D)->FrameCountRendered;
  this_12(D)->FrameCountEnded = _116;
  this_12(D)->WindowsActiveCount = 0;
  this_12(D)->CurrentWindow = 0B;
  this_12(D)->HoveredWindow = 0B;
  this_12(D)->HoveredRootWindow = 0B;
  this_12(D)->HoveredId = 0;
  this_12(D)->HoveredIdAllowOverlap = 0;
  this_12(D)->HoveredIdPreviousFrame = 0;
  this_12(D)->HoveredIdTimer = 0.0;
  this_12(D)->ActiveId = 0;
  this_12(D)->ActiveIdPreviousFrame = 0;
  this_12(D)->ActiveIdTimer = 0.0;
  this_12(D)->ActiveIdIsAlive = 0;
  this_12(D)->ActiveIdIsJustActivated = 0;
  this_12(D)->ActiveIdAllowOverlap = 0;
  this_12(D)->ActiveIdAllowNavDirFlags = 0;
  ImVec2::ImVec2 (&D.12987, -1.0e+0, -1.0e+0);
  this_12(D)->ActiveIdClickOffset = D.12987;
  D.12987 ={v} {CLOBBER};
  this_12(D)->ActiveIdWindow = 0B;
  this_12(D)->ActiveIdSource = 0;
  this_12(D)->MovingWindow = 0B;
  this_12(D)->NextTreeNodeOpenVal = 0;
  this_12(D)->NextTreeNodeOpenCond = 0;
  this_12(D)->NavWindow = 0B;
  this_12(D)->NavInputId = 0;
  _143 = this_12(D)->NavInputId;
  this_12(D)->NavActivatePressedId = _143;
  _145 = this_12(D)->NavActivatePressedId;
  this_12(D)->NavActivateDownId = _145;
  _147 = this_12(D)->NavActivateDownId;
  this_12(D)->NavActivateId = _147;
  _149 = this_12(D)->NavActivateId;
  this_12(D)->NavId = _149;
  this_12(D)->NavNextActivateId = 0;
  _152 = this_12(D)->NavNextActivateId;
  this_12(D)->NavJustMovedToId = _152;
  _154 = this_12(D)->NavJustMovedToId;
  this_12(D)->NavJustTabbedId = _154;
  this_12(D)->NavInputSource = 0;
  ImRect::ImRect (&D.12988);
  this_12(D)->NavScoringRectScreen = D.12988;
  D.12988 ={v} {CLOBBER};
  this_12(D)->NavScoringCount = 0;
  this_12(D)->NavWindowingTarget = 0B;
  this_12(D)->NavWindowingHighlightAlpha = 0.0;
  _163 = this_12(D)->NavWindowingHighlightAlpha;
  this_12(D)->NavWindowingHighlightTimer = _163;
  this_12(D)->NavWindowingToggleLayer = 0;
  this_12(D)->NavLayer = 0;
  this_12(D)->NavIdTabCounter = 2147483647;
  this_12(D)->NavIdIsAlive = 0;
  this_12(D)->NavMousePosDirty = 0;
  this_12(D)->NavDisableHighlight = 1;
  this_12(D)->NavDisableMouseHover = 0;
  this_12(D)->NavAnyRequest = 0;
  this_12(D)->NavInitRequest = 0;
  this_12(D)->NavInitRequestFromMove = 0;
  this_12(D)->NavInitResultId = 0;
  this_12(D)->NavMoveFromClampedRefRect = 0;
  this_12(D)->NavMoveRequest = 0;
  this_12(D)->NavMoveRequestForward = 0;
  this_12(D)->NavMoveDirLast = -1;
  _180 = this_12(D)->NavMoveDirLast;
  this_12(D)->NavMoveDir = _180;
  this_12(D)->ModalWindowDarkeningRatio = 0.0;
  _183 = &this_12(D)->DrawListSharedData;
  this_12(D)->OverlayDrawList._Data = _183;
  this_12(D)->OverlayDrawList._OwnerName = "##Overlay";
  this_12(D)->MouseCursor = 0;
  this_12(D)->DragDropActive = 0;
  this_12(D)->DragDropSourceFlags = 0;
  this_12(D)->DragDropMouseButton = -1;
  this_12(D)->DragDropTargetId = 0;
  this_12(D)->DragDropAcceptIdCurrRectSurface = 0.0;
  this_12(D)->DragDropAcceptIdCurr = 0;
  _193 = this_12(D)->DragDropAcceptIdCurr;
  this_12(D)->DragDropAcceptIdPrev = _193;
  this_12(D)->DragDropAcceptFrameCount = -1;
  _196 = &this_12(D)->DragDropPayloadBufLocal;
  memset (_196, 0, 8);
  this_12(D)->ScalarAsInputTextId = 0;
  this_12(D)->ColorEditOptions = 335872;
  this_12(D)->DragCurrentValue = 0.0;
  ImVec2::ImVec2 (&D.12989, 0.0, 0.0);
  this_12(D)->DragLastMouseDelta = D.12989;
  D.12989 ={v} {CLOBBER};
  this_12(D)->DragSpeedDefaultRatio = 9.99999977648258209228515625e-3;
  this_12(D)->DragSpeedScaleSlow = 9.99999977648258209228515625e-3;
  this_12(D)->DragSpeedScaleFast = 1.0e+1;
  ImVec2::ImVec2 (&D.12990, 0.0, 0.0);
  this_12(D)->ScrollbarClickDeltaToGrabCenter = D.12990;
  D.12990 ={v} {CLOBBER};
  this_12(D)->TooltipOverrideCount = 0;
  ImVec2::ImVec2 (&D.12991, -1.0e+0, -1.0e+0);
  this_12(D)->OsImePosSet = D.12991;
  _213 = &this_12(D)->OsImePosSet;
  this_12(D)->OsImePosRequest = MEM[(const struct ImVec2 &)_213];
  D.12991 ={v} {CLOBBER};
  this_12(D)->SettingsLoaded = 0;
  this_12(D)->SettingsDirtyTimer = 0.0;
  this_12(D)->LogEnabled = 0;
  this_12(D)->LogFile = 0B;
  this_12(D)->LogClipboard = 0B;
  this_12(D)->LogStartDepth = 0;
  this_12(D)->LogAutoExpandMaxDepth = 2;
  _223 = &this_12(D)->FramerateSecPerFrame;
  memset (_223, 0, 480);
  this_12(D)->FramerateSecPerFrameIdx = 0;
  this_12(D)->FramerateSecPerFrameAccum = 0.0;
  this_12(D)->WantTextInputNextFrame = -1;
  _228 = this_12(D)->WantTextInputNextFrame;
  this_12(D)->WantCaptureKeyboardNextFrame = _228;
  _230 = this_12(D)->WantCaptureKeyboardNextFrame;
  this_12(D)->WantCaptureMouseNextFrame = _230;
  _232 = &this_12(D)->TempBuffer;
  memset (_232, 0, 3073);
  return;

<L3>:
  operator delete (_95, D.25328, _93);
  __builtin_eh_copy_values (19, 21);

<L4>:
  __builtin_eh_copy_values (18, 19);
  D.12982 ={v} {CLOBBER};
  D.12983 ={v} {CLOBBER};
  _101 = &this_12(D)->SettingsHandlers;
  ImVector<ImGuiSettingsHandler>::~ImVector (_101);
  __builtin_eh_copy_values (17, 18);
  _103 = &this_12(D)->SettingsWindows;
  ImVector<ImGuiWindowSettings>::~ImVector (_103);
  __builtin_eh_copy_values (16, 17);
  _105 = &this_12(D)->PrivateClipboard;
  ImVector<char>::~ImVector (_105);
  __builtin_eh_copy_values (15, 16);
  _107 = &this_12(D)->InputTextPasswordFont;
  ImFont::~ImFont (_107);
  __builtin_eh_copy_values (14, 15);

<L10>:
  _234 = &this_12(D)->InputTextState;
  ImGuiTextEditState::~ImGuiTextEditState (_234);
  __builtin_eh_copy_values (13, 14);
  _236 = &this_12(D)->DragDropPayloadBufHeap;
  ImVector<unsigned char>::~ImVector (_236);
  __builtin_eh_copy_values (12, 13);
  _238 = &this_12(D)->OverlayDrawList;
  ImDrawList::~ImDrawList (_238);
  __builtin_eh_copy_values (11, 12);

<L13>:
  _240 = &this_12(D)->DrawDataBuilder;
  ImDrawDataBuilder::~ImDrawDataBuilder (_240);
  __builtin_eh_copy_values (10, 11);
  _242 = &this_12(D)->DrawData;
  ImDrawData::~ImDrawData (_242);
  __builtin_eh_copy_values (9, 10);
  _244 = &this_12(D)->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::~ImVector (_244);
  __builtin_eh_copy_values (8, 9);
  _246 = &this_12(D)->OpenPopupStack;
  ImVector<ImGuiPopupRef>::~ImVector (_246);
  __builtin_eh_copy_values (7, 8);
  _248 = &this_12(D)->FontStack;
  ImVector<ImFont*>::~ImVector (_248);
  __builtin_eh_copy_values (6, 7);
  _250 = &this_12(D)->StyleModifiers;
  ImVector<ImGuiStyleMod>::~ImVector (_250);
  __builtin_eh_copy_values (5, 6);
  _252 = &this_12(D)->ColorModifiers;
  ImVector<ImGuiColMod>::~ImVector (_252);
  __builtin_eh_copy_values (4, 5);
  _254 = &this_12(D)->WindowsById;
  ImGuiStorage::~ImGuiStorage (_254);
  __builtin_eh_copy_values (3, 4);
  _256 = &this_12(D)->CurrentWindowStack;
  ImVector<ImGuiWindow*>::~ImVector (_256);
  __builtin_eh_copy_values (2, 3);
  _258 = &this_12(D)->WindowsSortBuffer;
  ImVector<ImGuiWindow*>::~ImVector (_258);
  __builtin_eh_copy_values (1, 2);
  _260 = &this_12(D)->Windows;
  ImVector<ImGuiWindow*>::~ImVector (_260);
  _262 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_262);

}



;; Function ImGuiDrawContext::ImGuiDrawContext() (_ZN16ImGuiDrawContextC2Ev, funcdef_no=532, decl_uid=13249, cgraph_uid=431, symbol_order=431)

ImGuiDrawContext::ImGuiDrawContext() (struct ImGuiDrawContext * const this)
{
  struct ImVector * D.24225;
  struct ImVector * D.24224;
  struct ImVector * D.24223;
  struct ImVector * D.24222;
  struct ImVector * D.24221;
  int[6] * D.24220;
  int D.24219;
  int D.24218;
  struct ImRect * D.24217;
  struct ImRect D.13295;
  float D.24216;
  float D.24215;
  struct ImVec2 * D.24214;
  struct ImVec2 * D.24213;
  struct ImVec2 * D.24212;
  struct ImVec2 D.13294;
  struct ImVector * D.24211;
  struct ImVector * D.24210;
  struct ImVector * D.24209;
  struct ImVector * D.24208;
  struct ImVector * D.24207;
  struct ImRect * D.24206;
  struct ImRect * D.24205;
  struct ImVec2 * D.24204;
  struct ImVec2 * D.24203;
  struct ImVec2 * D.24202;
  struct ImVec2 * D.24201;
  struct ImVec2 * _4;
  struct ImVec2 * _6;
  struct ImVec2 * _8;
  struct ImVec2 * _10;
  struct ImRect * _12;
  struct ImRect * _14;
  struct ImVector * _16;
  struct ImVector * _18;
  struct ImVector * _20;
  struct ImVector * _22;
  struct ImVector * _24;
  struct ImVec2 * _28;
  struct ImVec2 * _30;
  struct ImVec2 * _32;
  float _36;
  float _39;
  struct ImRect * _48;
  int _54;
  int _62;
  int[6] * _67;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->CursorPos;
  ImVec2::ImVec2 (_4);
  _6 = &this_2(D)->CursorPosPrevLine;
  ImVec2::ImVec2 (_6);
  _8 = &this_2(D)->CursorStartPos;
  ImVec2::ImVec2 (_8);
  _10 = &this_2(D)->CursorMaxPos;
  ImVec2::ImVec2 (_10);
  _12 = &this_2(D)->LastItemRect;
  ImRect::ImRect (_12);
  _14 = &this_2(D)->LastItemDisplayRect;
  ImRect::ImRect (_14);
  _16 = &this_2(D)->ChildWindows;
  ImVector<ImGuiWindow*>::ImVector (_16);
  _18 = &this_2(D)->ItemFlagsStack;
  ImVector<int>::ImVector (_18);
  _20 = &this_2(D)->ItemWidthStack;
  ImVector<float>::ImVector (_20);
  _22 = &this_2(D)->TextWrapPosStack;
  ImVector<float>::ImVector (_22);
  _24 = &this_2(D)->GroupStack;
  ImVector<ImGuiGroupData>::ImVector (_24);
  ImVec2::ImVec2 (&D.13294, 0.0, 0.0);
  this_2(D)->CursorMaxPos = D.13294;
  _28 = &this_2(D)->CursorMaxPos;
  this_2(D)->CursorStartPos = MEM[(const struct ImVec2 &)_28];
  _30 = &this_2(D)->CursorStartPos;
  this_2(D)->CursorPosPrevLine = MEM[(const struct ImVec2 &)_30];
  _32 = &this_2(D)->CursorPosPrevLine;
  this_2(D)->CursorPos = MEM[(const struct ImVec2 &)_32];
  D.13294 ={v} {CLOBBER};
  this_2(D)->PrevLineHeight = 0.0;
  _36 = this_2(D)->PrevLineHeight;
  this_2(D)->CurrentLineHeight = _36;
  this_2(D)->PrevLineTextBaseOffset = 0.0;
  _39 = this_2(D)->PrevLineTextBaseOffset;
  this_2(D)->CurrentLineTextBaseOffset = _39;
  this_2(D)->LogLinePosY = -1.0e+0;
  this_2(D)->TreeDepth = 0;
  this_2(D)->TreeDepthMayJumpToParentOnPop = 0;
  this_2(D)->LastItemId = 0;
  this_2(D)->LastItemStatusFlags = 0;
  ImRect::ImRect (&D.13295);
  this_2(D)->LastItemDisplayRect = D.13295;
  _48 = &this_2(D)->LastItemDisplayRect;
  this_2(D)->LastItemRect = MEM[(const struct ImRect &)_48];
  D.13295 ={v} {CLOBBER};
  this_2(D)->NavHideHighlightOneFrame = 0;
  this_2(D)->NavHasScroll = 0;
  this_2(D)->NavLayerActiveMaskNext = 0;
  _54 = this_2(D)->NavLayerActiveMaskNext;
  this_2(D)->NavLayerActiveMask = _54;
  this_2(D)->NavLayerCurrent = 0;
  this_2(D)->NavLayerCurrentMask = 1;
  this_2(D)->MenuBarAppending = 0;
  this_2(D)->MenuBarOffsetX = 0.0;
  this_2(D)->StateStorage = 0B;
  this_2(D)->ParentLayoutType = 0;
  _62 = this_2(D)->ParentLayoutType;
  this_2(D)->LayoutType = _62;
  this_2(D)->ItemWidth = 0.0;
  this_2(D)->ItemFlags = 1;
  this_2(D)->TextWrapPos = -1.0e+0;
  _67 = &this_2(D)->StackSizesBackup;
  memset (_67, 0, 24);
  this_2(D)->IndentX = 0.0;
  this_2(D)->GroupOffsetX = 0.0;
  this_2(D)->ColumnsOffsetX = 0.0;
  this_2(D)->ColumnsSet = 0B;
  return;

}



;; Function ImRect ImGuiWindow::Rect() const (_ZNK11ImGuiWindow4RectEv, funcdef_no=534, decl_uid=13595, cgraph_uid=433, symbol_order=433)

ImRect ImGuiWindow::Rect() const (const struct ImGuiWindow * const this)
{
  float D.30855;
  float D.30854;
  float D.30853;
  float D.30852;
  float D.30851;
  float D.30850;
  float D.30849;
  float D.30848;
  struct ImRect D.13694;
  struct ImRect D.30847;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;

  <bb 2>:
  _3 = this_2(D)->Pos.y;
  _4 = this_2(D)->Size.y;
  _5 = _3 + _4;
  _6 = this_2(D)->Pos.x;
  _7 = this_2(D)->Size.x;
  _8 = _6 + _7;
  _9 = this_2(D)->Pos.y;
  _10 = this_2(D)->Pos.x;
  ImRect::ImRect (&D.13694, _10, _9, _8, _5);
  D.30847 = D.13694;
  D.13694 ={v} {CLOBBER};

<L1>:
  return D.30847;

}



;; Function float ImGuiWindow::CalcFontSize() const (_ZNK11ImGuiWindow12CalcFontSizeEv, funcdef_no=535, decl_uid=13597, cgraph_uid=434, symbol_order=434)

float ImGuiWindow::CalcFontSize() const (const struct ImGuiWindow * const this)
{
  float D.24500;
  float D.24499;
  struct ImGuiContext * GImGui.152;
  float D.24497;
  struct ImGuiContext * GImGui.152_2;
  float _3;
  float _5;
  float _6;

  <bb 2>:
  GImGui.152_2 = GImGui;
  _3 = GImGui.152_2->FontBaseSize;
  _5 = this_4(D)->FontWindowScale;
  _6 = _3 * _5;

<L0>:
  return _6;

}



;; Function float ImGuiWindow::TitleBarHeight() const (_ZNK11ImGuiWindow14TitleBarHeightEv, funcdef_no=536, decl_uid=13599, cgraph_uid=435, symbol_order=435)

float ImGuiWindow::TitleBarHeight() const (const struct ImGuiWindow * const this)
{
  float D.30608;
  float D.30607;
  struct ImGuiContext * GImGui.505;
  float D.30605;
  int D.30602;
  int D.30601;
  float iftmp.504;
  float D.30599;
  float iftmp.504_1;
  int _5;
  int _6;
  float _8;
  struct ImGuiContext * GImGui.505_9;
  float _10;
  float _11;
  float iftmp.504_12;
  float iftmp.504_13;
  float _14;

  <bb 2>:
  _5 = this_4(D)->Flags;
  _6 = _5 & 1;
  if (_6 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = ImGuiWindow::CalcFontSize (this_4(D));
  GImGui.505_9 = GImGui;
  _10 = GImGui.505_9->Style.FramePadding.y;
  _11 = _10 * 2.0e+0;
  iftmp.504_12 = _8 + _11;
  goto <bb 5>;

  <bb 4>:
  iftmp.504_13 = 0.0;

  <bb 5>:
  # iftmp.504_1 = PHI <iftmp.504_12(3), iftmp.504_13(4)>
  _14 = iftmp.504_1;

<L3>:
  return _14;

}



;; Function ImRect ImGuiWindow::TitleBarRect() const (_ZNK11ImGuiWindow12TitleBarRectEv, funcdef_no=537, decl_uid=13601, cgraph_uid=436, symbol_order=436)

ImRect ImGuiWindow::TitleBarRect() const (const struct ImGuiWindow * const this)
{
  const struct ImVec2 * D.32784;
  float D.32783;
  float D.32782;
  float D.32781;
  float D.32780;
  float D.32779;
  float D.32778;
  struct ImVec2 D.13698;
  struct ImRect D.13699;
  struct ImRect D.32777;
  float _3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;
  const struct ImVec2 * _11;

  <bb 2>:
  _3 = this_2(D)->Pos.y;
  _5 = ImGuiWindow::TitleBarHeight (this_2(D));
  _6 = _3 + _5;
  _7 = this_2(D)->Pos.x;
  _8 = this_2(D)->SizeFull.x;
  _9 = _7 + _8;
  ImVec2::ImVec2 (&D.13698, _9, _6);
  _11 = &this_2(D)->Pos;
  ImRect::ImRect (&D.13699, _11, &D.13698);
  D.32777 = D.13699;
  D.13699 ={v} {CLOBBER};
  D.13698 ={v} {CLOBBER};

<L2>:
  return D.32777;

}



;; Function float ImGuiWindow::MenuBarHeight() const (_ZNK11ImGuiWindow13MenuBarHeightEv, funcdef_no=538, decl_uid=13603, cgraph_uid=437, symbol_order=437)

float ImGuiWindow::MenuBarHeight() const (const struct ImGuiWindow * const this)
{
  float D.30620;
  float D.30619;
  struct ImGuiContext * GImGui.507;
  float D.30617;
  int D.30614;
  int D.30613;
  float iftmp.506;
  float D.30611;
  float iftmp.506_1;
  int _5;
  int _6;
  float _8;
  struct ImGuiContext * GImGui.507_9;
  float _10;
  float _11;
  float iftmp.506_12;
  float iftmp.506_13;
  float _14;

  <bb 2>:
  _5 = this_4(D)->Flags;
  _6 = _5 & 1024;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = ImGuiWindow::CalcFontSize (this_4(D));
  GImGui.507_9 = GImGui;
  _10 = GImGui.507_9->Style.FramePadding.y;
  _11 = _10 * 2.0e+0;
  iftmp.506_12 = _8 + _11;
  goto <bb 5>;

  <bb 4>:
  iftmp.506_13 = 0.0;

  <bb 5>:
  # iftmp.506_1 = PHI <iftmp.506_12(3), iftmp.506_13(4)>
  _14 = iftmp.506_1;

<L3>:
  return _14;

}



;; Function ImRect ImGuiWindow::MenuBarRect() const (_ZNK11ImGuiWindow11MenuBarRectEv, funcdef_no=539, decl_uid=13605, cgraph_uid=438, symbol_order=438)

ImRect ImGuiWindow::MenuBarRect() const (const struct ImGuiWindow * const this)
{
  float y1;
  float D.32796;
  float D.32795;
  float D.32794;
  float D.32793;
  float D.32792;
  float D.32791;
  struct ImRect D.13703;
  struct ImRect D.32790;
  float D.32789;
  float D.32788;
  float _3;
  float _5;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;

  <bb 2>:
  _3 = this_2(D)->Pos.y;
  _5 = ImGuiWindow::TitleBarHeight (this_2(D));
  y1_6 = _3 + _5;
  _8 = ImGuiWindow::MenuBarHeight (this_2(D));
  _9 = _8 + y1_6;
  _10 = this_2(D)->Pos.x;
  _11 = this_2(D)->SizeFull.x;
  _12 = _10 + _11;
  _13 = this_2(D)->Pos.x;
  ImRect::ImRect (&D.13703, _13, y1_6, _12, _9);
  D.32790 = D.13703;
  D.13703 ={v} {CLOBBER};

<L1>:
  return D.32790;

}



;; Function ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup() (_ZN26ImGuiItemHoveredDataBackupC2Ev, funcdef_no=541, decl_uid=13718, cgraph_uid=440, symbol_order=440)

ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup() (struct ImGuiItemHoveredDataBackup * const this)
{
  struct ImRect * D.35476;
  struct ImRect * D.35475;
  struct ImRect * _4;
  struct ImRect * _6;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  _4 = &this_2(D)->LastItemRect;
  ImRect::ImRect (_4);
  _6 = &this_2(D)->LastItemDisplayRect;
  ImRect::ImRect (_6);
  ImGuiItemHoveredDataBackup::Backup (this_2(D));
  return;

}



;; Function void ImGuiItemHoveredDataBackup::Backup() (_ZN26ImGuiItemHoveredDataBackup6BackupEv, funcdef_no=543, decl_uid=13712, cgraph_uid=442, symbol_order=442)

void ImGuiItemHoveredDataBackup::Backup() (struct ImGuiItemHoveredDataBackup * const this)
{
  struct ImGuiWindow * window;
  int D.35479;
  unsigned int D.35478;
  struct ImGuiContext * GImGui.1151;
  struct ImGuiContext * GImGui.1151_2;
  unsigned int _4;
  int _7;

  <bb 2>:
  GImGui.1151_2 = GImGui;
  window_3 = GImGui.1151_2->CurrentWindow;
  _4 = window_3->DC.LastItemId;
  this_5(D)->LastItemId = _4;
  _7 = window_3->DC.LastItemStatusFlags;
  this_5(D)->LastItemStatusFlags = _7;
  this_5(D)->LastItemRect = window_3->DC.LastItemRect;
  this_5(D)->LastItemDisplayRect = window_3->DC.LastItemDisplayRect;
  return;

}



;; Function void ImGuiItemHoveredDataBackup::Restore() const (_ZNK26ImGuiItemHoveredDataBackup7RestoreEv, funcdef_no=544, decl_uid=13714, cgraph_uid=443, symbol_order=443)

void ImGuiItemHoveredDataBackup::Restore() const (const struct ImGuiItemHoveredDataBackup * const this)
{
  struct ImGuiWindow * window;
  int D.35482;
  unsigned int D.35481;
  struct ImGuiContext * GImGui.1152;
  struct ImGuiContext * GImGui.1152_2;
  unsigned int _5;
  int _7;

  <bb 2>:
  GImGui.1152_2 = GImGui;
  window_3 = GImGui.1152_2->CurrentWindow;
  _5 = this_4(D)->LastItemId;
  window_3->DC.LastItemId = _5;
  _7 = this_4(D)->LastItemStatusFlags;
  window_3->DC.LastItemStatusFlags = _7;
  window_3->DC.LastItemRect = this_4(D)->LastItemRect;
  window_3->DC.LastItemDisplayRect = this_4(D)->LastItemDisplayRect;
  return;

}



;; Function ImGuiWindow* ImGui::GetCurrentWindowRead() (_ZN5ImGui20GetCurrentWindowReadEv, funcdef_no=545, decl_uid=13731, cgraph_uid=444, symbol_order=444)

ImGuiWindow* ImGui::GetCurrentWindowRead() ()
{
  struct ImGuiContext & g;
  struct ImGuiWindow * D.24129;
  struct ImGuiWindow * _3;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->CurrentWindow;

<L0>:
  return _3;

}



;; Function ImGuiWindow* ImGui::GetCurrentWindow() (_ZN5ImGui16GetCurrentWindowEv, funcdef_no=546, decl_uid=13734, cgraph_uid=445, symbol_order=445)

ImGuiWindow* ImGui::GetCurrentWindow() ()
{
  struct ImGuiContext & g;
  struct ImGuiWindow * D.24044;
  struct ImGuiWindow * D.24043;
  struct ImGuiWindow * _3;
  struct ImGuiWindow * _5;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->CurrentWindow;
  _3->WriteAccessed = 1;
  _5 = g_2->CurrentWindow;

<L0>:
  return _5;

}



;; Function void* MallocWrapper(size_t, void*) (_ZL13MallocWrappermPv, funcdef_no=553, decl_uid=15139, cgraph_uid=452, symbol_order=453)

void* MallocWrapper(size_t, void*) (size_t size, void * user_data)
{
  void * D.22370;
  void * _4;

  <bb 2>:
  _4 = malloc (size_2(D));

<L0>:
  return _4;

}



;; Function void FreeWrapper(void*, void*) (_ZL11FreeWrapperPvS_, funcdef_no=554, decl_uid=15143, cgraph_uid=453, symbol_order=454)

void FreeWrapper(void*, void*) (void * ptr, void * user_data)
{
  <bb 2>:
  free (ptr_2(D));
  return;

}



;; Function ImGuiStyle::ImGuiStyle() (_ZN10ImGuiStyleC2Ev, funcdef_no=556, decl_uid=3745, cgraph_uid=455, symbol_order=460)

ImGuiStyle::ImGuiStyle() (struct ImGuiStyle * const this)
{
  struct ImVec2 D.15178;
  struct ImVec2 D.15177;
  struct ImVec2 D.15176;
  struct ImVec2 D.15175;
  struct ImVec2 D.15174;
  struct ImVec2 D.15173;
  struct ImVec2 D.15172;
  struct ImVec2 D.15171;
  struct ImVec2 D.15170;
  struct ImVec2 D.15169;
  long int D.22384;
  struct ImVec4 * D.22383;
  struct ImVec4 * D.22382;
  struct ImVec4 * retval.0;
  struct ImVec2 * D.22381;
  struct ImVec2 * D.22380;
  struct ImVec2 * D.22379;
  struct ImVec2 * D.22378;
  struct ImVec2 * D.22377;
  struct ImVec2 * D.22376;
  struct ImVec2 * D.22375;
  struct ImVec2 * D.22374;
  struct ImVec2 * D.22373;
  struct ImVec2 * D.22372;
  struct ImVec4 * _1;
  long int _2;
  struct ImVec2 * _7;
  struct ImVec2 * _9;
  struct ImVec2 * _11;
  struct ImVec2 * _13;
  struct ImVec2 * _15;
  struct ImVec2 * _17;
  struct ImVec2 * _19;
  struct ImVec2 * _21;
  struct ImVec2 * _23;
  struct ImVec2 * _25;
  struct ImVec4 * _27;
  struct ImVec4 * _28;
  long int _29;
  struct ImVec4 * _31;
  long int _32;
  struct ImVec4 * retval.0_33;

  <bb 2>:
  MEM[(struct  &)this_5(D)] ={v} {CLOBBER};
  _7 = &this_5(D)->WindowPadding;
  ImVec2::ImVec2 (_7);
  _9 = &this_5(D)->WindowMinSize;
  ImVec2::ImVec2 (_9);
  _11 = &this_5(D)->WindowTitleAlign;
  ImVec2::ImVec2 (_11);
  _13 = &this_5(D)->FramePadding;
  ImVec2::ImVec2 (_13);
  _15 = &this_5(D)->ItemSpacing;
  ImVec2::ImVec2 (_15);
  _17 = &this_5(D)->ItemInnerSpacing;
  ImVec2::ImVec2 (_17);
  _19 = &this_5(D)->TouchExtraPadding;
  ImVec2::ImVec2 (_19);
  _21 = &this_5(D)->ButtonTextAlign;
  ImVec2::ImVec2 (_21);
  _23 = &this_5(D)->DisplayWindowPadding;
  ImVec2::ImVec2 (_23);
  _25 = &this_5(D)->DisplaySafeAreaPadding;
  ImVec2::ImVec2 (_25);
  _27 = &this_5(D)->Colors;
  _28 = _27;
  _29 = 41;

  <bb 3>:
  # _1 = PHI <_28(2), _31(4)>
  # _2 = PHI <_29(2), _32(4)>
  if (_2 < 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  ImVec4::ImVec4 (_1);
  _31 = _1 + 16;
  _32 = _2 + -1;
  goto <bb 3>;

  <bb 5>:
  retval.0_33 = _27;
  this_5(D)->Alpha = 1.0e+0;
  ImVec2::ImVec2 (&D.15169, 8.0e+0, 8.0e+0);
  this_5(D)->WindowPadding = D.15169;
  D.15169 ={v} {CLOBBER};
  this_5(D)->WindowRounding = 7.0e+0;
  this_5(D)->WindowBorderSize = 1.0e+0;
  ImVec2::ImVec2 (&D.15170, 3.2e+1, 3.2e+1);
  this_5(D)->WindowMinSize = D.15170;
  D.15170 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15171, 0.0, 5.0e-1);
  this_5(D)->WindowTitleAlign = D.15171;
  D.15171 ={v} {CLOBBER};
  this_5(D)->ChildRounding = 0.0;
  this_5(D)->ChildBorderSize = 1.0e+0;
  this_5(D)->PopupRounding = 0.0;
  this_5(D)->PopupBorderSize = 1.0e+0;
  ImVec2::ImVec2 (&D.15172, 4.0e+0, 3.0e+0);
  this_5(D)->FramePadding = D.15172;
  D.15172 ={v} {CLOBBER};
  this_5(D)->FrameRounding = 0.0;
  this_5(D)->FrameBorderSize = 0.0;
  ImVec2::ImVec2 (&D.15173, 8.0e+0, 4.0e+0);
  this_5(D)->ItemSpacing = D.15173;
  D.15173 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15174, 4.0e+0, 4.0e+0);
  this_5(D)->ItemInnerSpacing = D.15174;
  D.15174 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15175, 0.0, 0.0);
  this_5(D)->TouchExtraPadding = D.15175;
  D.15175 ={v} {CLOBBER};
  this_5(D)->IndentSpacing = 2.1e+1;
  this_5(D)->ColumnsMinSpacing = 6.0e+0;
  this_5(D)->ScrollbarSize = 1.6e+1;
  this_5(D)->ScrollbarRounding = 9.0e+0;
  this_5(D)->GrabMinSize = 1.0e+1;
  this_5(D)->GrabRounding = 0.0;
  ImVec2::ImVec2 (&D.15176, 5.0e-1, 5.0e-1);
  this_5(D)->ButtonTextAlign = D.15176;
  D.15176 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15177, 2.2e+1, 2.2e+1);
  this_5(D)->DisplayWindowPadding = D.15177;
  D.15177 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15178, 4.0e+0, 4.0e+0);
  this_5(D)->DisplaySafeAreaPadding = D.15178;
  D.15178 ={v} {CLOBBER};
  this_5(D)->MouseCursorScale = 1.0e+0;
  this_5(D)->AntiAliasedLines = 1;
  this_5(D)->AntiAliasedFill = 1;
  this_5(D)->CurveTessellationTol = 1.25e+0;
  ImGui::StyleColorsDark (this_5(D));
  return;

}



;; Function void ImGuiStyle::ScaleAllSizes(float) (_ZN10ImGuiStyle13ScaleAllSizesEf, funcdef_no=558, decl_uid=3741, cgraph_uid=457, symbol_order=462)

void ImGuiStyle::ScaleAllSizes(float) (struct ImGuiStyle * const this, float scale_factor)
{
  float D.22434;
  float D.22433;
  float D.22432;
  struct ImVec2 * D.22431;
  struct ImVec2 D.15198;
  struct ImVec2 * D.22430;
  struct ImVec2 D.15196;
  float D.22429;
  float D.22428;
  float D.22427;
  float D.22426;
  float D.22425;
  float D.22424;
  float D.22423;
  float D.22422;
  float D.22421;
  float D.22420;
  float D.22419;
  float D.22418;
  float D.22417;
  float D.22416;
  float D.22415;
  float D.22414;
  float D.22413;
  float D.22412;
  struct ImVec2 * D.22411;
  struct ImVec2 D.15194;
  struct ImVec2 * D.22410;
  struct ImVec2 D.15192;
  struct ImVec2 * D.22409;
  struct ImVec2 D.15190;
  float D.22408;
  float D.22407;
  float D.22406;
  struct ImVec2 * D.22405;
  struct ImVec2 D.15188;
  float D.22404;
  float D.22403;
  float D.22402;
  float D.22401;
  float D.22400;
  float D.22399;
  struct ImVec2 * D.22398;
  struct ImVec2 D.15186;
  float D.22397;
  float D.22396;
  float D.22395;
  struct ImVec2 * D.22394;
  struct ImVec2 D.15184;
  struct ImVec2 * _2;
  float _8;
  float _9;
  float _11;
  struct ImVec2 * _13;
  float _17;
  float _18;
  float _20;
  float _22;
  float _23;
  float _25;
  struct ImVec2 * _27;
  float _31;
  float _32;
  float _34;
  struct ImVec2 * _36;
  struct ImVec2 * _40;
  struct ImVec2 * _44;
  float _48;
  float _49;
  float _51;
  float _53;
  float _54;
  float _56;
  float _58;
  float _59;
  float _61;
  float _63;
  float _64;
  float _66;
  float _68;
  float _69;
  float _71;
  float _73;
  float _74;
  float _76;
  struct ImVec2 * _78;
  struct ImVec2 * _82;
  float _86;
  float _87;
  float _89;

  <bb 2>:
  _2 = &this_1(D)->WindowPadding;
  D.15184 = operator* (_2, scale_factor_4(D));
  this_1(D)->WindowPadding = ImFloor (&D.15184);
  D.15184 ={v} {CLOBBER};
  _8 = this_1(D)->WindowRounding;
  _9 = _8 * scale_factor_4(D);
  _11 = ImFloor (_9);
  this_1(D)->WindowRounding = _11;
  _13 = &this_1(D)->WindowMinSize;
  D.15186 = operator* (_13, scale_factor_4(D));
  this_1(D)->WindowMinSize = ImFloor (&D.15186);
  D.15186 ={v} {CLOBBER};
  _17 = this_1(D)->ChildRounding;
  _18 = _17 * scale_factor_4(D);
  _20 = ImFloor (_18);
  this_1(D)->ChildRounding = _20;
  _22 = this_1(D)->PopupRounding;
  _23 = _22 * scale_factor_4(D);
  _25 = ImFloor (_23);
  this_1(D)->PopupRounding = _25;
  _27 = &this_1(D)->FramePadding;
  D.15188 = operator* (_27, scale_factor_4(D));
  this_1(D)->FramePadding = ImFloor (&D.15188);
  D.15188 ={v} {CLOBBER};
  _31 = this_1(D)->FrameRounding;
  _32 = _31 * scale_factor_4(D);
  _34 = ImFloor (_32);
  this_1(D)->FrameRounding = _34;
  _36 = &this_1(D)->ItemSpacing;
  D.15190 = operator* (_36, scale_factor_4(D));
  this_1(D)->ItemSpacing = ImFloor (&D.15190);
  D.15190 ={v} {CLOBBER};
  _40 = &this_1(D)->ItemInnerSpacing;
  D.15192 = operator* (_40, scale_factor_4(D));
  this_1(D)->ItemInnerSpacing = ImFloor (&D.15192);
  D.15192 ={v} {CLOBBER};
  _44 = &this_1(D)->TouchExtraPadding;
  D.15194 = operator* (_44, scale_factor_4(D));
  this_1(D)->TouchExtraPadding = ImFloor (&D.15194);
  D.15194 ={v} {CLOBBER};
  _48 = this_1(D)->IndentSpacing;
  _49 = _48 * scale_factor_4(D);
  _51 = ImFloor (_49);
  this_1(D)->IndentSpacing = _51;
  _53 = this_1(D)->ColumnsMinSpacing;
  _54 = _53 * scale_factor_4(D);
  _56 = ImFloor (_54);
  this_1(D)->ColumnsMinSpacing = _56;
  _58 = this_1(D)->ScrollbarSize;
  _59 = _58 * scale_factor_4(D);
  _61 = ImFloor (_59);
  this_1(D)->ScrollbarSize = _61;
  _63 = this_1(D)->ScrollbarRounding;
  _64 = _63 * scale_factor_4(D);
  _66 = ImFloor (_64);
  this_1(D)->ScrollbarRounding = _66;
  _68 = this_1(D)->GrabMinSize;
  _69 = _68 * scale_factor_4(D);
  _71 = ImFloor (_69);
  this_1(D)->GrabMinSize = _71;
  _73 = this_1(D)->GrabRounding;
  _74 = _73 * scale_factor_4(D);
  _76 = ImFloor (_74);
  this_1(D)->GrabRounding = _76;
  _78 = &this_1(D)->DisplayWindowPadding;
  D.15196 = operator* (_78, scale_factor_4(D));
  this_1(D)->DisplayWindowPadding = ImFloor (&D.15196);
  D.15196 ={v} {CLOBBER};
  _82 = &this_1(D)->DisplaySafeAreaPadding;
  D.15198 = operator* (_82, scale_factor_4(D));
  this_1(D)->DisplaySafeAreaPadding = ImFloor (&D.15198);
  D.15198 ={v} {CLOBBER};
  _86 = this_1(D)->MouseCursorScale;
  _87 = _86 * scale_factor_4(D);
  _89 = ImFloor (_87);
  this_1(D)->MouseCursorScale = _89;
  return;

}



;; Function ImGuiIO::ImGuiIO() (_ZN7ImGuiIOC2Ev, funcdef_no=560, decl_uid=3863, cgraph_uid=459, symbol_order=464)

ImGuiIO::ImGuiIO() (struct ImGuiIO * const this)
{
  int i;
  int i;
  int i;
  int i;
  float D.22485;
  float D.22482;
  struct ImVec2 D.15231;
  struct ImVec2 D.15230;
  struct ImVec2 * D.22479;
  struct ImVec2 D.15229;
  struct ImVec2 D.15228;
  struct ImVec2 D.15225;
  long int D.22471;
  struct ImVec2 * D.22470;
  struct ImVec2 * D.22469;
  struct ImVec2 * retval.2;
  long int D.22463;
  struct ImVec2 * D.22462;
  struct ImVec2 * D.22461;
  struct ImVec2 * retval.1;
  struct ImVec2 * D.22460;
  struct ImVec2 * D.22459;
  struct ImVec2 * D.22458;
  struct ImVec2 * D.22457;
  struct ImVec2 * D.22456;
  struct ImVec2 * D.22455;
  struct ImVec2 * D.22454;
  struct ImVec2 * _5;
  long int _6;
  struct ImVec2 * _7;
  long int _8;
  struct ImVec2 * _18;
  struct ImVec2 * _20;
  struct ImVec2 * _22;
  struct ImVec2 * _24;
  struct ImVec2 * _26;
  struct ImVec2 * _28;
  struct ImVec2 * _30;
  struct ImVec2 * _32;
  struct ImVec2 * _33;
  long int _34;
  struct ImVec2 * _36;
  long int _37;
  struct ImVec2 * retval.1_38;
  struct ImVec2 * _39;
  struct ImVec2 * _40;
  long int _41;
  struct ImVec2 * _43;
  long int _44;
  struct ImVec2 * retval.2_45;
  struct ImVec2 * _73;
  float _93;
  float _98;

  <bb 2>:
  MEM[(struct  &)this_16(D)] ={v} {CLOBBER};
  _18 = &this_16(D)->DisplaySize;
  ImVec2::ImVec2 (_18);
  _20 = &this_16(D)->DisplayFramebufferScale;
  ImVec2::ImVec2 (_20);
  _22 = &this_16(D)->DisplayVisibleMin;
  ImVec2::ImVec2 (_22);
  _24 = &this_16(D)->DisplayVisibleMax;
  ImVec2::ImVec2 (_24);
  _26 = &this_16(D)->MousePos;
  ImVec2::ImVec2 (_26);
  _28 = &this_16(D)->MouseDelta;
  ImVec2::ImVec2 (_28);
  _30 = &this_16(D)->MousePosPrev;
  ImVec2::ImVec2 (_30);
  _32 = &this_16(D)->MouseClickedPos;
  _33 = _32;
  _34 = 4;

  <bb 3>:
  # _5 = PHI <_33(2), _36(4)>
  # _6 = PHI <_34(2), _37(4)>
  if (_6 < 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  ImVec2::ImVec2 (_5);
  _36 = _5 + 8;
  _37 = _6 + -1;
  goto <bb 3>;

  <bb 5>:
  retval.1_38 = _32;
  _39 = &this_16(D)->MouseDragMaxDistanceAbs;
  _40 = _39;
  _41 = 4;

  <bb 6>:
  # _7 = PHI <_40(5), _43(7)>
  # _8 = PHI <_41(5), _44(7)>
  if (_8 < 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  ImVec2::ImVec2 (_7);
  _43 = _7 + 8;
  _44 = _8 + -1;
  goto <bb 6>;

  <bb 8>:
  retval.2_45 = _39;
  memset (this_16(D), 0, 5400);
  this_16(D)->ConfigFlags = 0;
  this_16(D)->BackendFlags = 0;
  ImVec2::ImVec2 (&D.15225, -1.0e+0, -1.0e+0);
  this_16(D)->DisplaySize = D.15225;
  D.15225 ={v} {CLOBBER};
  this_16(D)->DeltaTime = 1.666666753590106964111328125e-2;
  this_16(D)->IniSavingRate = 5.0e+0;
  this_16(D)->IniFilename = "imgui.ini";
  this_16(D)->LogFilename = "imgui_log.txt";
  this_16(D)->MouseDoubleClickTime = 3.00000011920928955078125e-1;
  this_16(D)->MouseDoubleClickMaxDist = 6.0e+0;
  i_58 = 0;

  <bb 9>:
  # i_1 = PHI <i_58(8), i_60(10)>
  if (i_1 > 20)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  this_16(D)->KeyMap[i_1] = -1;
  i_60 = i_1 + 1;
  goto <bb 9>;

  <bb 11>:
  this_16(D)->KeyRepeatDelay = 2.5e-1;
  this_16(D)->KeyRepeatRate = 5.00000007450580596923828125e-2;
  this_16(D)->UserData = 0B;
  this_16(D)->Fonts = 0B;
  this_16(D)->FontGlobalScale = 1.0e+0;
  this_16(D)->FontDefault = 0B;
  this_16(D)->FontAllowUserScaling = 0;
  ImVec2::ImVec2 (&D.15228, 1.0e+0, 1.0e+0);
  this_16(D)->DisplayFramebufferScale = D.15228;
  D.15228 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15229, 0.0, 0.0);
  this_16(D)->DisplayVisibleMax = D.15229;
  _73 = &this_16(D)->DisplayVisibleMax;
  this_16(D)->DisplayVisibleMin = MEM[(const struct ImVec2 &)_73];
  D.15229 ={v} {CLOBBER};
  this_16(D)->OptMacOSXBehaviors = 0;
  this_16(D)->OptCursorBlink = 1;
  this_16(D)->GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;
  this_16(D)->SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
  this_16(D)->ClipboardUserData = 0B;
  this_16(D)->ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
  this_16(D)->ImeWindowHandle = 0B;
  this_16(D)->RenderDrawListsFn = 0B;
  ImVec2::ImVec2 (&D.15230, -3.4028234663852885981170418348451692544e+38, -3.4028234663852885981170418348451692544e+38);
  this_16(D)->MousePos = D.15230;
  D.15230 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15231, -3.4028234663852885981170418348451692544e+38, -3.4028234663852885981170418348451692544e+38);
  this_16(D)->MousePosPrev = D.15231;
  D.15231 ={v} {CLOBBER};
  this_16(D)->MouseDragThreshold = 6.0e+0;
  i_91 = 0;

  <bb 12>:
  # i_2 = PHI <i_91(11), i_95(13)>
  if (i_2 > 4)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  this_16(D)->MouseDownDurationPrev[i_2] = -1.0e+0;
  _93 = this_16(D)->MouseDownDurationPrev[i_2];
  this_16(D)->MouseDownDuration[i_2] = _93;
  i_95 = i_2 + 1;
  goto <bb 12>;

  <bb 14>:
  i_96 = 0;

  <bb 15>:
  # i_3 = PHI <i_96(14), i_100(16)>
  if (i_3 > 511)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  this_16(D)->KeysDownDurationPrev[i_3] = -1.0e+0;
  _98 = this_16(D)->KeysDownDurationPrev[i_3];
  this_16(D)->KeysDownDuration[i_3] = _98;
  i_100 = i_3 + 1;
  goto <bb 15>;

  <bb 17>:
  i_101 = 0;

  <bb 18>:
  # i_4 = PHI <i_101(17), i_103(19)>
  if (i_4 > 20)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  this_16(D)->NavInputsDownDuration[i_4] = -1.0e+0;
  i_103 = i_4 + 1;
  goto <bb 18>;

  <bb 20>:
  return;

}



;; Function void ImGuiIO::AddInputCharacter(ImWchar) (_ZN7ImGuiIO17AddInputCharacterEt, funcdef_no=562, decl_uid=3826, cgraph_uid=461, symbol_order=466)

void ImGuiIO::AddInputCharacter(ImWchar) (struct ImGuiIO * const this, ImWchar c)
{
  const int n;
  int D.22492;
  int D.22489;
  ImWchar[17] * D.22488;
  ImWchar[17] * _3;
  int _7;
  int _10;

  <bb 2>:
  _3 = &this_2(D)->InputCharacters;
  n_6 = ImStrlenW (_3);
  _7 = n_6 + 1;
  if (_7 <= 16)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_2(D)->InputCharacters[n_6] = c_8(D);
  _10 = n_6 + 1;
  this_2(D)->InputCharacters[_10] = 0;

  <bb 4>:
  return;

}



;; Function void ImGuiIO::AddInputCharactersUTF8(const char*) (_ZN7ImGuiIO22AddInputCharactersUTF8EPKc, funcdef_no=563, decl_uid=3829, cgraph_uid=462, symbol_order=467)

void ImGuiIO::AddInputCharactersUTF8(const char*) (struct ImGuiIO * const this, const char * utf8_chars)
{
  int i;
  ImWchar wchars[17];
  const int wchars_buf_len;
  int D.22499;
  short unsigned int D.22498;
  short unsigned int D.22496;
  short unsigned int _8;
  short unsigned int _9;
  int _10;

  <bb 2>:
  wchars_buf_len_3 = 17;
  ImTextStrFromUtf8 (&wchars, 17, utf8_chars_5(D), 0B, 0B);
  i_7 = 0;

  <bb 3>:
  # i_1 = PHI <i_7(2), i_13(5)>
  if (i_1 > 16)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  _8 = wchars[i_1];
  if (_8 == 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _9 = wchars[i_1];
  _10 = (int) _9;
  ImGuiIO::AddInputCharacter (this_11(D), _10);
  i_13 = i_1 + 1;
  goto <bb 3>;

  <bb 6>:
  wchars ={v} {CLOBBER};
  return;

}



;; Function ImVec2 ImLineClosestPoint(const ImVec2&, const ImVec2&, const ImVec2&) (_Z18ImLineClosestPointRK6ImVec2S1_S1_, funcdef_no=564, decl_uid=10536, cgraph_uid=463, symbol_order=468)

ImVec2 ImLineClosestPoint(const ImVec2&, const ImVec2&, const ImVec2&) (const struct ImVec2 & a, const struct ImVec2 & b, const struct ImVec2 & p)
{
  float ab_len_sqr;
  float dot;
  struct ImVec2 ab_dir;
  struct ImVec2 ap;
  struct ImVec2 D.15266;
  struct ImVec2 D.15267;
  float D.22516;
  float D.22515;
  float D.22514;
  float D.22513;
  float D.22512;
  float D.22511;
  struct ImVec2 D.22510;
  float D.22507;
  float D.22506;
  float D.22505;
  float D.22504;
  float D.22503;
  float D.22502;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _16;
  float _17;
  float _18;
  float _19;
  float _20;
  float _21;

  <bb 2>:
  ap = operator- (p_3(D), a_4(D));
  ab_dir = operator- (b_6(D), a_4(D));
  _8 = ap.x;
  _9 = ab_dir.x;
  _10 = _8 * _9;
  _11 = ap.y;
  _12 = ab_dir.y;
  _13 = _11 * _12;
  dot_14 = _10 + _13;
  if (dot_14 < 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  D.22510 = *a_4(D);
  goto <bb 7>;

  <bb 4>:
  _16 = ab_dir.x;
  _17 = ab_dir.x;
  _18 = _16 * _17;
  _19 = ab_dir.y;
  _20 = ab_dir.y;
  _21 = _19 * _20;
  ab_len_sqr_22 = _18 + _21;
  if (dot_14 > ab_len_sqr_22)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  D.22510 = *b_6(D);
  goto <bb 7>;

  <bb 6>:
  D.15266 = operator* (&ab_dir, dot_14);
  D.15267 = operator/ (&D.15266, ab_len_sqr_22);
  D.22510 = operator+ (a_4(D), &D.15267);
  D.15267 ={v} {CLOBBER};
  D.15266 ={v} {CLOBBER};

  <bb 7>:
  ap ={v} {CLOBBER};
  ab_dir ={v} {CLOBBER};

<L7>:
  return D.22510;

}



;; Function bool ImTriangleContainsPoint(const ImVec2&, const ImVec2&, const ImVec2&, const ImVec2&) (_Z23ImTriangleContainsPointRK6ImVec2S1_S1_S1_, funcdef_no=565, decl_uid=10541, cgraph_uid=464, symbol_order=469)

bool ImTriangleContainsPoint(const ImVec2&, const ImVec2&, const ImVec2&, const ImVec2&) (const struct ImVec2 & a, const struct ImVec2 & b, const struct ImVec2 & c, const struct ImVec2 & p)
{
  bool b3;
  bool b2;
  bool b1;
  bool iftmp.3;
  bool D.22593;
  float D.22592;
  float D.22591;
  float D.22590;
  float D.22589;
  float D.22588;
  float D.22587;
  float D.22586;
  float D.22585;
  float D.22584;
  float D.22583;
  float D.22582;
  float D.22581;
  float D.22580;
  float D.22579;
  float D.22578;
  float D.22577;
  float D.22576;
  float D.22575;
  float D.22574;
  float D.22573;
  float D.22572;
  float D.22571;
  float D.22570;
  float D.22569;
  float D.22568;
  float D.22567;
  float D.22566;
  float D.22565;
  float D.22564;
  float D.22563;
  float D.22562;
  float D.22561;
  float D.22560;
  float D.22559;
  float D.22558;
  float D.22557;
  float D.22556;
  float D.22555;
  float D.22554;
  float D.22553;
  float D.22552;
  float D.22551;
  float D.22550;
  float D.22549;
  float D.22548;
  bool iftmp.3_1;
  float _4;
  float _6;
  float _7;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;
  float _17;
  float _18;
  float _19;
  float _20;
  float _22;
  float _24;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _39;
  float _40;
  float _41;
  float _42;
  float _43;
  float _44;
  float _45;
  float _46;
  float _47;
  float _48;
  float _49;
  float _50;
  float _51;
  float _52;
  float _53;
  bool iftmp.3_55;
  bool iftmp.3_56;
  bool _57;

  <bb 2>:
  _4 = p_3(D)->x;
  _6 = b_5(D)->x;
  _7 = _4 - _6;
  _9 = a_8(D)->y;
  _10 = b_5(D)->y;
  _11 = _9 - _10;
  _12 = _7 * _11;
  _13 = p_3(D)->y;
  _14 = b_5(D)->y;
  _15 = _13 - _14;
  _16 = a_8(D)->x;
  _17 = b_5(D)->x;
  _18 = _16 - _17;
  _19 = _15 * _18;
  _20 = _12 - _19;
  b1_21 = _20 < 0.0;
  _22 = p_3(D)->x;
  _24 = c_23(D)->x;
  _25 = _22 - _24;
  _26 = b_5(D)->y;
  _27 = c_23(D)->y;
  _28 = _26 - _27;
  _29 = _25 * _28;
  _30 = p_3(D)->y;
  _31 = c_23(D)->y;
  _32 = _30 - _31;
  _33 = b_5(D)->x;
  _34 = c_23(D)->x;
  _35 = _33 - _34;
  _36 = _32 * _35;
  _37 = _29 - _36;
  b2_38 = _37 < 0.0;
  _39 = p_3(D)->x;
  _40 = a_8(D)->x;
  _41 = _39 - _40;
  _42 = c_23(D)->y;
  _43 = a_8(D)->y;
  _44 = _42 - _43;
  _45 = _41 * _44;
  _46 = p_3(D)->y;
  _47 = a_8(D)->y;
  _48 = _46 - _47;
  _49 = c_23(D)->x;
  _50 = a_8(D)->x;
  _51 = _49 - _50;
  _52 = _48 * _51;
  _53 = _45 - _52;
  b3_54 = _53 < 0.0;
  if (b1_21 == b2_38)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (b2_38 == b3_54)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.3_55 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.3_56 = 0;

  <bb 6>:
  # iftmp.3_1 = PHI <iftmp.3_55(4), iftmp.3_56(5)>
  _57 = iftmp.3_1;

<L4>:
  return _57;

}



;; Function void ImTriangleBarycentricCoords(const ImVec2&, const ImVec2&, const ImVec2&, const ImVec2&, float&, float&, float&) (_Z27ImTriangleBarycentricCoordsRK6ImVec2S1_S1_S1_RfS2_S2_, funcdef_no=566, decl_uid=10554, cgraph_uid=465, symbol_order=470)

void ImTriangleBarycentricCoords(const ImVec2&, const ImVec2&, const ImVec2&, const ImVec2&, float&, float&, float&) (const struct ImVec2 & a, const struct ImVec2 & b, const struct ImVec2 & c, const struct ImVec2 & p, float & out_u, float & out_v, float & out_w)
{
  const float denom;
  struct ImVec2 v2;
  struct ImVec2 v1;
  struct ImVec2 v0;
  float D.22625;
  float D.22624;
  float D.22623;
  float D.22622;
  float D.22621;
  float D.22620;
  float D.22619;
  float D.22618;
  float D.22617;
  float D.22616;
  float D.22615;
  float D.22614;
  float D.22613;
  float D.22612;
  float D.22611;
  float D.22610;
  float D.22609;
  float D.22608;
  float D.22607;
  float D.22606;
  float D.22605;
  float D.22604;
  float D.22603;
  float D.22602;
  float D.22601;
  float D.22600;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;
  float _19;
  float _20;
  float _21;
  float _22;
  float _23;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  float _33;
  float _36;
  float _37;
  float _38;
  float _39;

  <bb 2>:
  v0 = operator- (b_2(D), a_3(D));
  v1 = operator- (c_5(D), a_3(D));
  v2 = operator- (p_7(D), a_3(D));
  _9 = v0.x;
  _10 = v1.y;
  _11 = _9 * _10;
  _12 = v1.x;
  _13 = v0.y;
  _14 = _12 * _13;
  denom_15 = _11 - _14;
  _16 = v2.x;
  _17 = v1.y;
  _18 = _16 * _17;
  _19 = v1.x;
  _20 = v2.y;
  _21 = _19 * _20;
  _22 = _18 - _21;
  _23 = _22 / denom_15;
  *out_v_24(D) = _23;
  _26 = v0.x;
  _27 = v2.y;
  _28 = _26 * _27;
  _29 = v2.x;
  _30 = v0.y;
  _31 = _29 * _30;
  _32 = _28 - _31;
  _33 = _32 / denom_15;
  *out_w_34(D) = _33;
  _36 = *out_v_24(D);
  _37 = 1.0e+0 - _36;
  _38 = *out_w_34(D);
  _39 = _37 - _38;
  *out_u_40(D) = _39;
  v0 ={v} {CLOBBER};
  v1 ={v} {CLOBBER};
  v2 ={v} {CLOBBER};
  return;

}



;; Function ImVec2 ImTriangleClosestPoint(const ImVec2&, const ImVec2&, const ImVec2&, const ImVec2&) (_Z22ImTriangleClosestPointRK6ImVec2S1_S1_S1_, funcdef_no=567, decl_uid=10546, cgraph_uid=466, symbol_order=471)

ImVec2 ImTriangleClosestPoint(const ImVec2&, const ImVec2&, const ImVec2&, const ImVec2&) (const struct ImVec2 & a, const struct ImVec2 & b, const struct ImVec2 & c, const struct ImVec2 & p)
{
  float m;
  float dist2_ca;
  float dist2_bc;
  float dist2_ab;
  struct ImVec2 proj_ca;
  struct ImVec2 proj_bc;
  struct ImVec2 proj_ab;
  struct ImVec2 D.22629;
  float D.22626;
  struct ImVec2 D.15311;
  struct ImVec2 D.15309;
  struct ImVec2 D.15307;
  float _23;

  <bb 2>:
  proj_ab = ImLineClosestPoint (a_3(D), b_4(D), p_5(D));
  proj_bc = ImLineClosestPoint (b_4(D), c_7(D), p_5(D));
  proj_ca = ImLineClosestPoint (c_7(D), a_3(D), p_5(D));
  D.15307 = operator- (p_5(D), &proj_ab);
  dist2_ab_12 = ImLengthSqr (&D.15307);
  D.15307 ={v} {CLOBBER};
  D.15309 = operator- (p_5(D), &proj_bc);
  dist2_bc_16 = ImLengthSqr (&D.15309);
  D.15309 ={v} {CLOBBER};
  D.15311 = operator- (p_5(D), &proj_ca);
  dist2_ca_20 = ImLengthSqr (&D.15311);
  D.15311 ={v} {CLOBBER};
  _23 = ImMin (dist2_bc_16, dist2_ca_20);
  m_25 = ImMin (dist2_ab_12, _23);
  if (m_25 == dist2_ab_12)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  D.22629 = proj_ab;
  goto <bb 7>;

  <bb 4>:
  if (m_25 == dist2_bc_16)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  D.22629 = proj_bc;
  goto <bb 7>;

  <bb 6>:
  D.22629 = proj_ca;

  <bb 7>:
  proj_ab ={v} {CLOBBER};
  proj_bc ={v} {CLOBBER};
  proj_ca ={v} {CLOBBER};

<L5>:
  return D.22629;

}



;; Function int ImStricmp(const char*, const char*) (_Z9ImStricmpPKcS0_, funcdef_no=568, decl_uid=10557, cgraph_uid=467, symbol_order=472)

int ImStricmp(const char*, const char*) (const char * str1, const char * str2)
{
  int d;
  int D.22663;
  char D.22660;
  int D.22658;
  int D.22657;
  char D.22656;
  int D.22655;
  int D.22654;
  char D.22653;
  bool iftmp.6;
  bool retval.5;
  bool iftmp.6_3;
  char _7;
  int _8;
  int _9;
  char _10;
  int _11;
  int _12;
  char _14;
  bool iftmp.6_15;
  bool iftmp.6_16;
  bool retval.5_17;
  int _20;

  <bb 2>:
  # str1_1 = PHI <str1_4(D)(0), str1_18(7)>
  # str2_2 = PHI <str2_5(D)(0), str2_19(7)>
  _7 = *str2_2;
  _8 = (int) _7;
  _9 = toupper (_8);
  _10 = *str1_1;
  _11 = (int) _10;
  _12 = toupper (_11);
  d_13 = _9 - _12;
  if (d_13 == 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _14 = *str1_1;
  if (_14 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.6_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.6_16 = 0;

  <bb 6>:
  # iftmp.6_3 = PHI <iftmp.6_15(4), iftmp.6_16(5)>
  retval.5_17 = iftmp.6_3;
  if (retval.5_17 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  str1_18 = str1_1 + 1;
  str2_19 = str2_2 + 1;
  goto <bb 2>;

  <bb 8>:
  _20 = d_13;

<L7>:
  return _20;

}



;; Function int ImStrnicmp(const char*, const char*, size_t) (_Z10ImStrnicmpPKcS0_m, funcdef_no=569, decl_uid=10561, cgraph_uid=468, symbol_order=473)

int ImStrnicmp(const char*, const char*, size_t) (const char * str1, const char * str2, size_t count)
{
  int d;
  int D.22681;
  char D.22678;
  int D.22676;
  int D.22675;
  char D.22674;
  int D.22673;
  int D.22672;
  char D.22671;
  bool iftmp.8;
  bool retval.7;
  bool iftmp.8_7;
  char _13;
  int _14;
  int _15;
  char _16;
  int _17;
  int _18;
  char _20;
  bool iftmp.8_21;
  bool iftmp.8_22;
  bool retval.7_23;
  int _27;

  <bb 2>:
  d_8 = 0;

  <bb 3>:
  # str1_1 = PHI <str1_9(D)(2), str1_24(9)>
  # str2_2 = PHI <str2_10(D)(2), str2_25(9)>
  # count_3 = PHI <count_11(D)(2), count_26(9)>
  # d_4 = PHI <d_8(2), d_6(9)>
  if (count_3 != 0)
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _13 = *str2_2;
  _14 = (int) _13;
  _15 = toupper (_14);
  _16 = *str1_1;
  _17 = (int) _16;
  _18 = toupper (_17);
  d_19 = _15 - _18;
  if (d_19 == 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _20 = *str1_1;
  if (_20 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.8_21 = 1;
  goto <bb 8>;

  <bb 7>:
  # d_5 = PHI <d_4(3), d_19(4), d_19(5)>
  iftmp.8_22 = 0;

  <bb 8>:
  # d_6 = PHI <d_19(6), d_5(7)>
  # iftmp.8_7 = PHI <iftmp.8_21(6), iftmp.8_22(7)>
  retval.7_23 = iftmp.8_7;
  if (retval.7_23 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  str1_24 = str1_1 + 1;
  str2_25 = str2_2 + 1;
  count_26 = count_3 + 18446744073709551615;
  goto <bb 3>;

  <bb 10>:
  _27 = d_6;

<L8>:
  return _27;

}



;; Function void ImStrncpy(char*, const char*, size_t) (_Z9ImStrncpyPcPKcm, funcdef_no=570, decl_uid=10565, cgraph_uid=469, symbol_order=474)

void ImStrncpy(char*, const char*, size_t) (char * dst, const char * src, size_t count)
{
  char * D.22686;
  sizetype D.22685;
  sizetype _7;
  char * _8;

  <bb 2>:
  if (count_2(D) == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 5> (<L2>);

  <bb 4>:
  strncpy (dst_4(D), src_5(D), count_2(D));
  _7 = count_2(D) + 18446744073709551615;
  _8 = dst_4(D) + _7;
  *_8 = 0;

<L2>:
  return;

}



;; Function char* ImStrdup(const char*) (_Z8ImStrdupPKc, funcdef_no=571, decl_uid=10567, cgraph_uid=470, symbol_order=475)

char* ImStrdup(const char*) (const char * str)
{
  void * D.22691;
  void * buf;
  size_t len;
  char * D.22689;
  long unsigned int D.22688;
  long unsigned int _3;
  void * _6;
  char * _9;

  <bb 2>:
  _3 = strlen (str_2(D));
  len_4 = _3 + 1;
  _6 = ImGui::MemAlloc (len_4);
  buf_7 = _6;
  _9 = memcpy (buf_7, str_2(D), len_4);

<L0>:
  return _9;

}



;; Function const char* ImStrchrRange(const char*, const char*, char) (_Z13ImStrchrRangePKcS0_c, funcdef_no=572, decl_uid=10571, cgraph_uid=471, symbol_order=476)

const char* ImStrchrRange(const char*, const char*, char) (const char * str, const char * str_end, char c)
{
  const char * D.22697;
  char D.22694;
  const char * _2;
  char _6;
  const char * _9;
  const char * _10;

  <bb 2>:
  # str_1 = PHI <str_3(D)(0), str_8(5)>
  if (str_1 >= str_end_4(D))
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 3>:
  _6 = *str_1;
  if (_6 == c_7(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _9 = str_1;
  goto <bb 7> (<L5>);

  <bb 5>:
  str_8 = str_1 + 1;
  goto <bb 2>;

  <bb 6>:
  _10 = 0B;

  # _2 = PHI <_9(4), _10(6)>
<L5>:
  return _2;

}



;; Function int ImStrlenW(const ImWchar*) (_Z9ImStrlenWPKt, funcdef_no=573, decl_uid=10573, cgraph_uid=472, symbol_order=477)

int ImStrlenW(const ImWchar*) (const ImWchar * str)
{
  int n;
  int D.22704;
  short unsigned int D.22702;
  const ImWchar * str.10;
  bool retval.9;
  const ImWchar * str.10_5;
  short unsigned int _8;
  bool retval.9_9;
  int _11;

  <bb 2>:
  n_3 = 0;

  <bb 3>:
  # str_1 = PHI <str_4(D)(2), str_6(4)>
  # n_2 = PHI <n_3(2), n_10(4)>
  str.10_5 = str_1;
  str_6 = str.10_5 + 2;
  _8 = *str.10_5;
  retval.9_9 = _8 != 0;
  if (retval.9_9 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  n_10 = n_2 + 1;
  goto <bb 3>;

  <bb 5>:
  _11 = n_2;

<L3>:
  return _11;

}



;; Function const ImWchar* ImStrbolW(const ImWchar*, const ImWchar*) (_Z9ImStrbolWPKtS0_, funcdef_no=574, decl_uid=10576, cgraph_uid=473, symbol_order=478)

const ImWchar* ImStrbolW(const ImWchar*, const ImWchar*) (const ImWchar * buf_mid_line, const ImWchar * buf_begin)
{
  const ImWchar * D.22711;
  short unsigned int D.22709;
  const ImWchar * D.22708;
  const ImWchar * _4;
  short unsigned int _6;
  const ImWchar * _8;

  <bb 2>:
  # buf_mid_line_1 = PHI <buf_mid_line_2(D)(0), buf_mid_line_7(4)>
  if (buf_mid_line_1 <= buf_begin_3(D))
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _4 = buf_mid_line_1 + 18446744073709551614;
  _6 = *_4;
  if (_6 == 10)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  buf_mid_line_7 = buf_mid_line_1 + 18446744073709551614;
  goto <bb 2>;

  <bb 5>:
  _8 = buf_mid_line_1;

<L4>:
  return _8;

}



;; Function const char* ImStristr(const char*, const char*, const char*, const char*) (_Z9ImStristrPKcS0_S0_S0_, funcdef_no=575, decl_uid=10581, cgraph_uid=474, symbol_order=479)

const char* ImStristr(const char*, const char*, const char*, const char*) (const char * haystack, const char * haystack_end, const char * needle, const char * needle_end)
{
  const char * a;
  const char * b;
  const char un0;
  const char * D.22745;
  int D.22740;
  int D.22739;
  char D.22738;
  int D.22737;
  int D.22736;
  char D.22735;
  int D.22730;
  int D.22729;
  int D.22728;
  char D.22727;
  char D.22724;
  int D.22719;
  int D.22718;
  char D.22717;
  long unsigned int D.22715;
  const char * _5;
  long unsigned int _9;
  char _11;
  int _12;
  int _13;
  char _17;
  const char * _18;
  char _19;
  int _20;
  int _21;
  int _22;
  char _26;
  int _27;
  int _28;
  char _29;
  int _30;
  int _31;
  const char * _34;

  <bb 2>:
  if (needle_end_6(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _9 = strlen (needle_8(D));
  needle_end_10 = needle_8(D) + _9;

  <bb 4>:
  # needle_end_2 = PHI <needle_end_6(D)(2), needle_end_10(3)>
  _11 = *needle_8(D);
  _12 = (int) _11;
  _13 = toupper (_12);
  un0_14 = (const char) _13;

  <bb 5>:
  # haystack_1 = PHI <haystack_15(D)(4), haystack_23(18)>
  if (haystack_end_16(D) != 0B)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _17 = *haystack_1;
  if (_17 == 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  if (haystack_end_16(D) == 0B)
    goto <bb 19>;
  else
    goto <bb 8>;

  <bb 8>:
  if (haystack_1 >= haystack_end_16(D))
    goto <bb 19>;
  else
    goto <bb 9>;

  <bb 9>:
  _19 = *haystack_1;
  _20 = (int) _19;
  _21 = toupper (_20);
  _22 = (int) un0_14;
  if (_21 == _22)
    goto <bb 10>;
  else
    goto <bb 18>;

  <bb 10>:
  b_24 = needle_8(D) + 1;
  a_25 = haystack_1 + 1;

  <bb 11>:
  # b_3 = PHI <b_24(10), b_33(14)>
  # a_4 = PHI <a_25(10), a_32(14)>
  if (b_3 >= needle_end_2)
    goto <bb 15>;
  else
    goto <bb 12>;

  <bb 12>:
  _26 = *a_4;
  _27 = (int) _26;
  _28 = toupper (_27);
  _29 = *b_3;
  _30 = (int) _29;
  _31 = toupper (_30);
  if (_28 != _31)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  goto <bb 15>;

  <bb 14>:
  a_32 = a_4 + 1;
  b_33 = b_3 + 1;
  goto <bb 11>;

  <bb 15>:
  if (b_3 == needle_end_2)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _34 = haystack_1;
  goto <bb 20> (<L20>);

  <bb 17>:

  <bb 18>:
  haystack_23 = haystack_1 + 1;
  goto <bb 5>;

  <bb 19>:
  _18 = 0B;

  # _5 = PHI <_34(16), _18(19)>
<L20>:
  return _5;

}



;; Function const char* ImAtoi(const char*, int*) (_ZL6ImAtoiPKcPi, funcdef_no=576, decl_uid=15375, cgraph_uid=475, symbol_order=480)

const char* ImAtoi(const char*, int*) (const char * src, int * output)
{
  int v;
  int negative;
  const char * D.22770;
  int iftmp.12;
  int D.22765;
  int D.22764;
  char D.22763;
  const char * src.11;
  int D.22761;
  char D.22759;
  char D.22757;
  char D.22752;
  char D.22748;
  int iftmp.12_6;
  char _10;
  char _13;
  char _16;
  char _17;
  int _18;
  const char * src.11_19;
  char _21;
  int _22;
  int _23;
  int iftmp.12_25;
  int iftmp.12_26;
  const char * _29;

  <bb 2>:
  negative_7 = 0;
  _10 = *src_9(D);
  if (_10 == 45)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  negative_11 = 1;
  src_12 = src_9(D) + 1;

  <bb 4>:
  # src_1 = PHI <src_9(D)(2), src_12(3)>
  # negative_4 = PHI <negative_7(2), negative_11(3)>
  _13 = *src_1;
  if (_13 == 43)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  src_14 = src_1 + 1;

  <bb 6>:
  # src_2 = PHI <src_1(4), src_14(5)>
  v_15 = 0;

  <bb 7>:
  # src_3 = PHI <src_2(6), src_20(9)>
  # v_5 = PHI <v_15(6), v_24(9)>
  _16 = *src_3;
  if (_16 <= 47)
    goto <bb 10>;
  else
    goto <bb 8>;

  <bb 8>:
  _17 = *src_3;
  if (_17 > 57)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  _18 = v_5 * 10;
  src.11_19 = src_3;
  src_20 = src.11_19 + 1;
  _21 = *src.11_19;
  _22 = (int) _21;
  _23 = _22 + -48;
  v_24 = _18 + _23;
  goto <bb 7>;

  <bb 10>:
  if (negative_4 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.12_25 = -v_5;
  goto <bb 13>;

  <bb 12>:
  iftmp.12_26 = v_5;

  <bb 13>:
  # iftmp.12_6 = PHI <iftmp.12_25(11), iftmp.12_26(12)>
  *output_27(D) = iftmp.12_6;
  _29 = src_3;

<L13>:
  return _29;

}



;; Function int ImFormatString(char*, size_t, const char*, ...) (_Z14ImFormatStringPcmPKcz, funcdef_no=577, decl_uid=10585, cgraph_uid=476, symbol_order=481)

int ImFormatString(char*, size_t, const char*, ...) (char * buf, size_t buf_size, const char * fmt)
{
  int w;
  struct  args[1];
  char * D.22781;
  sizetype D.22780;
  int D.22779;
  int D.22778;
  int D.22774;
  int _2;
  int _12;
  int _13;
  int _14;
  sizetype _16;
  char * _17;
  int _19;

  <bb 2>:
  __builtin_va_start (&args, 0);
  w_10 = vsnprintf (buf_6(D), buf_size_7(D), fmt_8(D), &args);
  __builtin_va_end (&args);
  if (buf_6(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = w_10;
  goto <bb 8>;

  <bb 4>:
  if (w_10 == -1)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _13 = (int) buf_size_7(D);
  if (_13 <= w_10)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _14 = (int) buf_size_7(D);
  w_15 = _14 + -1;

  <bb 7>:
  # w_1 = PHI <w_10(5), w_15(6)>
  _16 = (sizetype) w_1;
  _17 = buf_6(D) + _16;
  *_17 = 0;
  _19 = w_1;

  <bb 8>:
  # _2 = PHI <_12(3), _19(7)>
  args ={v} {CLOBBER};

<L6>:
  return _2;

}



;; Function int ImFormatStringV(char*, size_t, const char*, __va_list_tag*) (_Z15ImFormatStringVPcmPKcP13__va_list_tag, funcdef_no=578, decl_uid=10590, cgraph_uid=477, symbol_order=482)

int ImFormatStringV(char*, size_t, const char*, __va_list_tag*) (char * buf, size_t buf_size, const char * fmt, struct  * args)
{
  int w;
  char * D.22793;
  sizetype D.22792;
  int D.22791;
  int D.22790;
  int D.22786;
  int _2;
  int _11;
  int _12;
  int _13;
  sizetype _15;
  char * _16;
  int _18;

  <bb 2>:
  w_10 = vsnprintf (buf_5(D), buf_size_6(D), fmt_7(D), args_8(D));
  if (buf_5(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = w_10;
  goto <bb 8> (<L5>);

  <bb 4>:
  if (w_10 == -1)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _12 = (int) buf_size_6(D);
  if (_12 <= w_10)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _13 = (int) buf_size_6(D);
  w_14 = _13 + -1;

  <bb 7>:
  # w_1 = PHI <w_10(5), w_14(6)>
  _15 = (sizetype) w_1;
  _16 = buf_5(D) + _15;
  *_16 = 0;
  _18 = w_1;

  # _2 = PHI <_11(3), _18(7)>
<L5>:
  return _2;

}



;; Function ImU32 ImHash(const void*, int, ImU32) (_Z6ImHashPKvij, funcdef_no=579, decl_uid=10515, cgraph_uid=478, symbol_order=484)

ImU32 ImHash(const void*, int, ImU32) (const void * data, int data_size, ImU32 seed)
{
  unsigned char c;
  ImU32 j;
  ImU32 crc;
  ImU32 i;
  const ImU32 polynomial;
  const unsigned char * current;
  ImU32 crc;
  static ImU32 crc32_lut[256] = {0};
  ImU32 D.22841;
  unsigned int D.22840;
  unsigned int D.22839;
  unsigned int D.22838;
  unsigned int D.22837;
  unsigned int D.22836;
  unsigned char D.22832;
  const unsigned char * D.22831;
  unsigned char D.22828;
  const unsigned char * current.17;
  unsigned int D.22821;
  unsigned int D.22820;
  unsigned int D.22819;
  unsigned char D.22818;
  const unsigned char * current.16;
  unsigned int D.22816;
  unsigned int D.22815;
  int data_size.15;
  bool retval.14;
  unsigned int D.22807;
  unsigned int D.22806;
  int D.22805;
  int D.22804;
  int crc.13;
  unsigned int D.22802;
  unsigned int D.22795;
  unsigned int _14;
  unsigned int _19;
  int crc.13_20;
  int _21;
  int _22;
  unsigned int _23;
  unsigned int _24;
  int data_size.15_35;
  bool retval.14_37;
  unsigned int _38;
  unsigned int _39;
  const unsigned char * current.16_40;
  unsigned char _42;
  unsigned int _43;
  unsigned int _44;
  unsigned int _45;
  const unsigned char * current.17_47;
  unsigned char _50;
  const unsigned char * _51;
  unsigned char _52;
  unsigned int _54;
  unsigned int _55;
  unsigned int _56;
  unsigned int _57;
  unsigned int _58;
  ImU32 _60;

  <bb 2>:
  _14 = crc32_lut[1];
  if (_14 == 0)
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 3>:
  polynomial_15 = 3988292384;
  i_16 = 0;

  <bb 4>:
  # i_2 = PHI <i_16(3), i_28(8)>
  if (i_2 > 255)
    goto <bb 9>;
  else
    goto <bb 5>;

  <bb 5>:
  crc_17 = i_2;
  j_18 = 0;

  <bb 6>:
  # crc_3 = PHI <crc_17(5), crc_25(7)>
  # j_4 = PHI <j_18(5), j_26(7)>
  if (j_4 > 7)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _19 = crc_3 >> 1;
  crc.13_20 = (int) crc_3;
  _21 = crc.13_20 & 1;
  _22 = -_21;
  _23 = (unsigned int) _22;
  _24 = _23 & 3988292384;
  crc_25 = _19 ^ _24;
  j_26 = j_4 + 1;
  goto <bb 6>;

  <bb 8>:
  crc32_lut[i_2] = crc_3;
  i_28 = i_2 + 1;
  goto <bb 4>;

  <bb 9>:

  <bb 10>:
  seed_30 = ~seed_29(D);
  crc_31 = seed_30;
  current_33 = data_32(D);
  if (data_size_34(D) > 0)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  # data_size_1 = PHI <data_size_34(D)(10), data_size_36(12)>
  # crc_5 = PHI <crc_31(10), crc_46(12)>
  # current_9 = PHI <current_33(10), current_41(12)>
  data_size.15_35 = data_size_1;
  data_size_36 = data_size.15_35 + -1;
  retval.14_37 = data_size.15_35 != 0;
  if (retval.14_37 != 0)
    goto <bb 12>;
  else
    goto <bb 19>;

  <bb 12>:
  _38 = crc_5 >> 8;
  _39 = crc_5 & 255;
  current.16_40 = current_9;
  current_41 = current.16_40 + 1;
  _42 = *current.16_40;
  _43 = (unsigned int) _42;
  _44 = _39 ^ _43;
  _45 = crc32_lut[_44];
  crc_46 = _38 ^ _45;
  goto <bb 11>;

  <bb 13>:
  # crc_6 = PHI <crc_31(10), crc_59(18)>
  # current_10 = PHI <current_33(10), current_48(18)>
  current.17_47 = current_10;
  current_48 = current.17_47 + 1;
  c_49 = *current.17_47;
  if (c_49 == 0)
    goto <bb 19>;
  else
    goto <bb 14>;

  <bb 14>:
  if (c_49 == 35)
    goto <bb 15>;
  else
    goto <bb 18>;

  <bb 15>:
  _50 = *current_48;
  if (_50 == 35)
    goto <bb 16>;
  else
    goto <bb 18>;

  <bb 16>:
  _51 = current_48 + 1;
  _52 = *_51;
  if (_52 == 35)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  crc_53 = seed_30;

  <bb 18>:
  # crc_7 = PHI <crc_6(14), crc_6(15), crc_6(16), crc_53(17)>
  _54 = crc_7 >> 8;
  _55 = crc_7 & 255;
  _56 = (unsigned int) c_49;
  _57 = _55 ^ _56;
  _58 = crc32_lut[_57];
  crc_59 = _54 ^ _58;
  goto <bb 13>;

  <bb 19>:
  # crc_8 = PHI <crc_5(11), crc_6(13)>
  _60 = ~crc_8;

<L25>:
  return _60;

}



;; Function int ImTextCharFromUtf8(unsigned int*, const char*, const char*) (_Z18ImTextCharFromUtf8PjPKcS1_, funcdef_no=580, decl_uid=10499, cgraph_uid=479, symbol_order=485)

int ImTextCharFromUtf8(unsigned int*, const char*, const char*) (unsigned int * out_char, const char * in_text, const char * in_text_end)
{
  const unsigned char * str;
  unsigned int c;
  unsigned int D.23006;
  unsigned int D.23005;
  int D.23004;
  unsigned char D.23003;
  const unsigned char * str.33;
  int D.15428;
  int D.22999;
  int D.22998;
  unsigned char D.22997;
  unsigned int D.22996;
  int D.22995;
  int D.22994;
  unsigned char D.22993;
  const unsigned char * str.32;
  unsigned int D.15427;
  int D.22989;
  int D.22988;
  unsigned char D.22987;
  unsigned int D.22986;
  int D.22985;
  int D.22984;
  unsigned char D.22983;
  const unsigned char * str.31;
  unsigned int D.15426;
  int D.22979;
  int D.22978;
  unsigned char D.22977;
  unsigned int D.22976;
  int D.22975;
  int D.22974;
  unsigned char D.22973;
  const unsigned char * str.30;
  int D.22969;
  unsigned char D.22968;
  const unsigned char * D.22967;
  unsigned char D.22964;
  int D.22963;
  unsigned char D.22962;
  const unsigned char * D.22961;
  int D.22959;
  unsigned char D.22958;
  const unsigned char * D.22957;
  unsigned char D.22954;
  int D.22949;
  unsigned char D.22948;
  long int D.22945;
  long int str.29;
  long int in_text_end.28;
  int D.22938;
  int D.22937;
  unsigned char D.22936;
  unsigned int D.22935;
  int D.22934;
  unsigned char D.22933;
  const unsigned char * str.27;
  int D.15425;
  int D.22929;
  int D.22928;
  unsigned char D.22927;
  unsigned int D.22926;
  int D.22925;
  int D.22924;
  unsigned char D.22923;
  const unsigned char * str.26;
  unsigned int D.15424;
  int D.22919;
  int D.22918;
  unsigned char D.22917;
  unsigned int D.22916;
  int D.22915;
  int D.22914;
  unsigned char D.22913;
  const unsigned char * str.25;
  int D.22909;
  unsigned char D.22908;
  const unsigned char * D.22907;
  unsigned char D.22904;
  int D.22903;
  unsigned char D.22902;
  const unsigned char * D.22901;
  int D.22899;
  unsigned char D.22898;
  const unsigned char * D.22897;
  unsigned char D.22894;
  long int D.22889;
  long int str.24;
  long int in_text_end.23;
  int D.22882;
  int D.22881;
  unsigned char D.22880;
  unsigned int D.22879;
  int D.22878;
  unsigned char D.22877;
  const unsigned char * str.22;
  int D.15423;
  int D.22873;
  int D.22872;
  unsigned char D.22871;
  unsigned int D.22870;
  int D.22869;
  int D.22868;
  unsigned char D.22867;
  const unsigned char * str.21;
  int D.22863;
  unsigned char D.22862;
  long int D.22859;
  long int str.20;
  long int in_text_end.19;
  int D.22852;
  int D.22851;
  unsigned char D.22850;
  int D.22849;
  unsigned char D.22848;
  const unsigned char * str.18;
  signed char D.22844;
  unsigned char D.22843;
  int _1;
  unsigned char _7;
  signed char _8;
  const unsigned char * str.18_9;
  unsigned char _11;
  int _15;
  unsigned char _16;
  int _17;
  int _18;
  long int in_text_end.19_21;
  long int str.20_22;
  long int _23;
  int _24;
  unsigned char _25;
  int _26;
  int _27;
  const unsigned char * str.21_28;
  unsigned char _30;
  int _31;
  int _32;
  unsigned int _33;
  unsigned char _35;
  int _36;
  int _37;
  int _38;
  const unsigned char * str.22_39;
  unsigned char _41;
  int _42;
  int _43;
  unsigned int _44;
  int _47;
  unsigned char _48;
  int _49;
  int _50;
  long int in_text_end.23_52;
  long int str.24_53;
  long int _54;
  int _55;
  unsigned char _56;
  const unsigned char * _57;
  unsigned char _58;
  int _59;
  const unsigned char * _60;
  unsigned char _61;
  int _62;
  int _63;
  unsigned char _64;
  const unsigned char * _65;
  unsigned char _66;
  int _67;
  int _68;
  const unsigned char * str.25_69;
  unsigned char _71;
  int _72;
  int _73;
  unsigned int _74;
  unsigned char _76;
  int _77;
  int _78;
  int _79;
  const unsigned char * str.26_80;
  unsigned char _82;
  int _83;
  int _84;
  unsigned int _85;
  unsigned int _86;
  unsigned char _88;
  int _89;
  int _90;
  int _91;
  const unsigned char * str.27_92;
  unsigned char _94;
  int _95;
  int _96;
  unsigned int _97;
  int _100;
  unsigned char _101;
  int _102;
  int _103;
  long int in_text_end.28_105;
  long int str.29_106;
  long int _107;
  int _108;
  unsigned char _109;
  int _110;
  int _111;
  unsigned char _112;
  const unsigned char * _113;
  unsigned char _114;
  int _115;
  const unsigned char * _116;
  unsigned char _117;
  int _118;
  int _119;
  unsigned char _120;
  const unsigned char * _121;
  unsigned char _122;
  int _123;
  int _124;
  const unsigned char * str.30_125;
  unsigned char _127;
  int _128;
  int _129;
  unsigned int _130;
  unsigned char _132;
  int _133;
  int _134;
  int _135;
  const unsigned char * str.31_136;
  unsigned char _138;
  int _139;
  int _140;
  unsigned int _141;
  unsigned int _142;
  unsigned char _144;
  int _145;
  int _146;
  int _147;
  const unsigned char * str.32_148;
  unsigned char _150;
  int _151;
  int _152;
  unsigned int _153;
  unsigned int _154;
  unsigned char _156;
  int _157;
  int _158;
  int _159;
  const unsigned char * str.33_160;
  unsigned char _162;
  int _163;
  int _164;
  unsigned int _165;
  unsigned int _167;
  int _168;
  int _170;
  int _172;

  <bb 2>:
  c_3 = 4294967295;
  str_5 = in_text_4(D);
  _7 = *str_5;
  _8 = (signed char) _7;
  if (_8 >= 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  str.18_9 = str_5;
  str_10 = str.18_9 + 1;
  _11 = *str.18_9;
  c_12 = (unsigned int) _11;
  *out_char_13(D) = c_12;
  _15 = 1;
  goto <bb 52> (<L56>);

  <bb 4>:
  _16 = *str_5;
  _17 = (int) _16;
  _18 = _17 & 224;
  if (_18 == 192)
    goto <bb 5>;
  else
    goto <bb 13>;

  <bb 5>:
  *out_char_13(D) = 65533;
  if (in_text_end_20(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  in_text_end.19_21 = (long int) in_text_end_20(D);
  str.20_22 = (long int) str_5;
  _23 = in_text_end.19_21 - str.20_22;
  if (_23 <= 1)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _24 = 1;
  goto <bb 52> (<L56>);

  <bb 8>:
  _25 = *str_5;
  _26 = (int) _25;
  if (_26 <= 193)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _27 = 2;
  goto <bb 52> (<L56>);

  <bb 10>:
  str.21_28 = str_5;
  str_29 = str.21_28 + 1;
  _30 = *str.21_28;
  _31 = (int) _30;
  _32 = _31 << 6;
  _33 = (unsigned int) _32;
  c_34 = _33 & 1984;
  _35 = *str_29;
  _36 = (int) _35;
  _37 = _36 & 192;
  if (_37 != 128)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _38 = 2;
  goto <bb 52> (<L56>);

  <bb 12>:
  str.22_39 = str_29;
  str_40 = str.22_39 + 1;
  _41 = *str.22_39;
  _42 = (int) _41;
  _43 = _42 & 63;
  _44 = (unsigned int) _43;
  c_45 = c_34 + _44;
  *out_char_13(D) = c_45;
  _47 = 2;
  goto <bb 52> (<L56>);

  <bb 13>:
  _48 = *str_5;
  _49 = (int) _48;
  _50 = _49 & 240;
  if (_50 == 224)
    goto <bb 14>;
  else
    goto <bb 29>;

  <bb 14>:
  *out_char_13(D) = 65533;
  if (in_text_end_20(D) != 0B)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  in_text_end.23_52 = (long int) in_text_end_20(D);
  str.24_53 = (long int) str_5;
  _54 = in_text_end.23_52 - str.24_53;
  if (_54 <= 2)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _55 = 1;
  goto <bb 52> (<L56>);

  <bb 17>:
  _56 = *str_5;
  if (_56 == 224)
    goto <bb 18>;
  else
    goto <bb 21>;

  <bb 18>:
  _57 = str_5 + 1;
  _58 = *_57;
  _59 = (int) _58;
  if (_59 <= 159)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  _60 = str_5 + 1;
  _61 = *_60;
  _62 = (int) _61;
  if (_62 > 191)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _63 = 3;
  goto <bb 52> (<L56>);

  <bb 21>:
  _64 = *str_5;
  if (_64 == 237)
    goto <bb 22>;
  else
    goto <bb 24>;

  <bb 22>:
  _65 = str_5 + 1;
  _66 = *_65;
  _67 = (int) _66;
  if (_67 > 159)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _68 = 3;
  goto <bb 52> (<L56>);

  <bb 24>:
  str.25_69 = str_5;
  str_70 = str.25_69 + 1;
  _71 = *str.25_69;
  _72 = (int) _71;
  _73 = _72 << 12;
  _74 = (unsigned int) _73;
  c_75 = _74 & 61440;
  _76 = *str_70;
  _77 = (int) _76;
  _78 = _77 & 192;
  if (_78 != 128)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _79 = 3;
  goto <bb 52> (<L56>);

  <bb 26>:
  str.26_80 = str_70;
  str_81 = str.26_80 + 1;
  _82 = *str.26_80;
  _83 = (int) _82;
  _84 = _83 << 6;
  _85 = (unsigned int) _84;
  _86 = _85 & 4032;
  c_87 = c_75 + _86;
  _88 = *str_81;
  _89 = (int) _88;
  _90 = _89 & 192;
  if (_90 != 128)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _91 = 3;
  goto <bb 52> (<L56>);

  <bb 28>:
  str.27_92 = str_81;
  str_93 = str.27_92 + 1;
  _94 = *str.27_92;
  _95 = (int) _94;
  _96 = _95 & 63;
  _97 = (unsigned int) _96;
  c_98 = c_87 + _97;
  *out_char_13(D) = c_98;
  _100 = 3;
  goto <bb 52> (<L56>);

  <bb 29>:
  _101 = *str_5;
  _102 = (int) _101;
  _103 = _102 & 248;
  if (_103 == 240)
    goto <bb 30>;
  else
    goto <bb 51>;

  <bb 30>:
  *out_char_13(D) = 65533;
  if (in_text_end_20(D) != 0B)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  in_text_end.28_105 = (long int) in_text_end_20(D);
  str.29_106 = (long int) str_5;
  _107 = in_text_end.28_105 - str.29_106;
  if (_107 <= 3)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  _108 = 1;
  goto <bb 52> (<L56>);

  <bb 33>:
  _109 = *str_5;
  _110 = (int) _109;
  if (_110 > 244)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  _111 = 4;
  goto <bb 52> (<L56>);

  <bb 35>:
  _112 = *str_5;
  if (_112 == 240)
    goto <bb 36>;
  else
    goto <bb 39>;

  <bb 36>:
  _113 = str_5 + 1;
  _114 = *_113;
  _115 = (int) _114;
  if (_115 <= 143)
    goto <bb 38>;
  else
    goto <bb 37>;

  <bb 37>:
  _116 = str_5 + 1;
  _117 = *_116;
  _118 = (int) _117;
  if (_118 > 191)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  _119 = 4;
  goto <bb 52> (<L56>);

  <bb 39>:
  _120 = *str_5;
  if (_120 == 244)
    goto <bb 40>;
  else
    goto <bb 42>;

  <bb 40>:
  _121 = str_5 + 1;
  _122 = *_121;
  _123 = (int) _122;
  if (_123 > 143)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  _124 = 4;
  goto <bb 52> (<L56>);

  <bb 42>:
  str.30_125 = str_5;
  str_126 = str.30_125 + 1;
  _127 = *str.30_125;
  _128 = (int) _127;
  _129 = _128 << 18;
  _130 = (unsigned int) _129;
  c_131 = _130 & 1835008;
  _132 = *str_126;
  _133 = (int) _132;
  _134 = _133 & 192;
  if (_134 != 128)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  _135 = 4;
  goto <bb 52> (<L56>);

  <bb 44>:
  str.31_136 = str_126;
  str_137 = str.31_136 + 1;
  _138 = *str.31_136;
  _139 = (int) _138;
  _140 = _139 << 12;
  _141 = (unsigned int) _140;
  _142 = _141 & 258048;
  c_143 = c_131 + _142;
  _144 = *str_137;
  _145 = (int) _144;
  _146 = _145 & 192;
  if (_146 != 128)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  _147 = 4;
  goto <bb 52> (<L56>);

  <bb 46>:
  str.32_148 = str_137;
  str_149 = str.32_148 + 1;
  _150 = *str.32_148;
  _151 = (int) _150;
  _152 = _151 << 6;
  _153 = (unsigned int) _152;
  _154 = _153 & 4032;
  c_155 = c_143 + _154;
  _156 = *str_149;
  _157 = (int) _156;
  _158 = _157 & 192;
  if (_158 != 128)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  _159 = 4;
  goto <bb 52> (<L56>);

  <bb 48>:
  str.33_160 = str_149;
  str_161 = str.33_160 + 1;
  _162 = *str.33_160;
  _163 = (int) _162;
  _164 = _163 & 63;
  _165 = (unsigned int) _164;
  c_166 = c_155 + _165;
  _167 = c_166 & 4294965248;
  if (_167 == 55296)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  _168 = 4;
  goto <bb 52> (<L56>);

  <bb 50>:
  *out_char_13(D) = c_166;
  _170 = 4;
  goto <bb 52> (<L56>);

  <bb 51>:
  *out_char_13(D) = 0;
  _172 = 0;

  # _1 = PHI <_15(3), _24(7), _27(9), _38(11), _47(12), _55(16), _63(20), _68(23), _79(25), _91(27), _100(28), _108(32), _111(34), _119(38), _124(41), _135(43), _147(45), _159(47), _168(49), _170(50), _172(51)>
<L56>:
  return _1;

}



;; Function int ImTextStrFromUtf8(ImWchar*, int, const char*, const char*, const char**) (_Z17ImTextStrFromUtf8PtiPKcS1_PS1_, funcdef_no=581, decl_uid=10505, cgraph_uid=480, symbol_order=486)

int ImTextStrFromUtf8(ImWchar*, int, const char*, const char*, const char**) (ImWchar * buf, int buf_size, const char * in_text, const char * in_text_end, const char * * in_text_remaining)
{
  unsigned int c;
  ImWchar * buf_end;
  ImWchar * buf_out;
  long int D.23037;
  long int D.23036;
  long int buf.39;
  long int buf_out.38;
  int D.23033;
  short unsigned int D.23028;
  unsigned int c.37;
  ImWchar * buf_out.36;
  unsigned int c.35;
  unsigned int c.34;
  sizetype D.23019;
  int D.15439;
  char D.23017;
  ImWchar * D.23014;
  long unsigned int D.23011;
  long unsigned int D.23010;
  long unsigned int _12;
  long unsigned int _13;
  ImWchar * _17;
  char _19;
  int _21;
  sizetype _22;
  unsigned int c.34_24;
  unsigned int c.35_25;
  ImWchar * buf_out.36_26;
  unsigned int c.37_28;
  short unsigned int _29;
  long int buf_out.38_36;
  long int buf.39_37;
  long int _38;
  long int _39;
  int _40;

  <bb 2>:
  buf_out_10 = buf_9(D);
  _12 = (long unsigned int) buf_size_11(D);
  _13 = _12 * 2;
  buf_end_14 = buf_9(D) + _13;

  <bb 3>:
  # in_text_1 = PHI <in_text_15(D)(2), in_text_23(11)>
  # buf_out_3 = PHI <buf_out_10(2), buf_out_4(11)>
  _17 = buf_end_14 + 18446744073709551614;
  if (_17 <= buf_out_3)
    goto <bb 12>;
  else
    goto <bb 4>;

  <bb 4>:
  if (in_text_end_18(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  if (in_text_1 >= in_text_end_18(D))
    goto <bb 12>;
  else
    goto <bb 6>;

  <bb 6>:
  _19 = *in_text_1;
  if (_19 == 0)
    goto <bb 12>;
  else
    goto <bb 7>;

  <bb 7>:
  _21 = ImTextCharFromUtf8 (&c, in_text_1, in_text_end_18(D));
  _22 = (sizetype) _21;
  in_text_23 = in_text_1 + _22;
  c.34_24 = c;
  if (c.34_24 == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  c ={v} {CLOBBER};
  goto <bb 12>;

  <bb 9>:
  c.35_25 = c;
  if (c.35_25 <= 65535)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  buf_out.36_26 = buf_out_3;
  buf_out_27 = buf_out.36_26 + 2;
  c.37_28 = c;
  _29 = (short unsigned int) c.37_28;
  *buf_out.36_26 = _29;

  <bb 11>:
  # buf_out_4 = PHI <buf_out_3(9), buf_out_27(10)>
  c ={v} {CLOBBER};
  goto <bb 3>;

  <bb 12>:
  # in_text_2 = PHI <in_text_1(3), in_text_1(5), in_text_1(6), in_text_23(8)>
  *buf_out_3 = 0;
  if (in_text_remaining_34(D) != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  *in_text_remaining_34(D) = in_text_2;

  <bb 14>:
  buf_out.38_36 = (long int) buf_out_3;
  buf.39_37 = (long int) buf_9(D);
  _38 = buf_out.38_36 - buf.39_37;
  _39 = _38 /[ex] 2;
  _40 = (int) _39;

<L16>:
  return _40;

}



;; Function int ImTextCountCharsFromUtf8(const char*, const char*) (_Z24ImTextCountCharsFromUtf8PKcS0_, funcdef_no=582, decl_uid=10508, cgraph_uid=481, symbol_order=487)

int ImTextCountCharsFromUtf8(const char*, const char*) (const char * in_text, const char * in_text_end)
{
  unsigned int c;
  int char_count;
  int D.23054;
  unsigned int c.41;
  unsigned int c.40;
  sizetype D.23046;
  int D.15448;
  char D.23044;
  char _10;
  int _12;
  sizetype _13;
  unsigned int c.40_15;
  unsigned int c.41_16;
  int _20;

  <bb 2>:
  char_count_6 = 0;

  <bb 3>:
  # in_text_1 = PHI <in_text_7(D)(2), in_text_14(10)>
  # char_count_2 = PHI <char_count_6(2), char_count_3(10)>
  if (in_text_end_9(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  if (in_text_1 >= in_text_end_9(D))
    goto <bb 11>;
  else
    goto <bb 5>;

  <bb 5>:
  _10 = *in_text_1;
  if (_10 == 0)
    goto <bb 11>;
  else
    goto <bb 6>;

  <bb 6>:
  _12 = ImTextCharFromUtf8 (&c, in_text_1, in_text_end_9(D));
  _13 = (sizetype) _12;
  in_text_14 = in_text_1 + _13;
  c.40_15 = c;
  if (c.40_15 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  c ={v} {CLOBBER};
  goto <bb 11>;

  <bb 8>:
  c.41_16 = c;
  if (c.41_16 <= 65535)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  char_count_17 = char_count_2 + 1;

  <bb 10>:
  # char_count_3 = PHI <char_count_2(8), char_count_17(9)>
  c ={v} {CLOBBER};
  goto <bb 3>;

  <bb 11>:
  _20 = char_count_2;

<L12>:
  return _20;

}



;; Function int ImTextCharToUtf8(char*, int, unsigned int) (_ZL16ImTextCharToUtf8Pcij, funcdef_no=583, decl_uid=15454, cgraph_uid=482, symbol_order=488)

int ImTextCharToUtf8(char*, int, unsigned int) (char * buf, int buf_size, unsigned int c)
{
  char D.23165;
  unsigned char D.23164;
  unsigned char D.23163;
  unsigned char D.23162;
  unsigned int c.63;
  char * D.23160;
  char D.23159;
  unsigned char D.23158;
  unsigned char D.23157;
  unsigned char D.23156;
  unsigned int D.23155;
  unsigned int c.62;
  char * D.23153;
  char D.23152;
  unsigned char D.23151;
  unsigned char D.23150;
  unsigned int D.23149;
  unsigned int c.61;
  char D.23145;
  unsigned char D.23144;
  unsigned char D.23143;
  unsigned char D.23142;
  unsigned int c.60;
  char * D.23140;
  char D.23139;
  unsigned char D.23138;
  unsigned char D.23137;
  unsigned char D.23136;
  unsigned int D.23135;
  unsigned int c.59;
  char * D.23133;
  char D.23132;
  unsigned char D.23131;
  unsigned char D.23130;
  unsigned char D.23129;
  unsigned int D.23128;
  unsigned int c.58;
  char * D.23126;
  char D.23125;
  unsigned char D.23124;
  unsigned char D.23123;
  unsigned int D.23122;
  unsigned int c.57;
  unsigned int c.56;
  unsigned int c.55;
  unsigned int c.54;
  unsigned int c.53;
  char D.23106;
  unsigned char D.23105;
  unsigned char D.23104;
  unsigned char D.23103;
  unsigned int c.52;
  char * D.23101;
  char D.23100;
  unsigned char D.23099;
  unsigned char D.23098;
  unsigned int D.23097;
  unsigned int c.51;
  unsigned int c.50;
  int D.23090;
  char D.23089;
  unsigned int c.49;
  unsigned int c.48;
  int _1;
  unsigned int c.48_4;
  unsigned int c.49_5;
  char _6;
  int _9;
  unsigned int c.50_10;
  int _12;
  unsigned int c.51_13;
  unsigned int _14;
  unsigned char _15;
  unsigned char _16;
  char _17;
  char * _19;
  unsigned int c.52_20;
  unsigned char _21;
  unsigned char _22;
  unsigned char _23;
  char _24;
  int _26;
  unsigned int c.53_27;
  unsigned int c.54_28;
  int _29;
  unsigned int c.55_30;
  unsigned int c.56_31;
  int _32;
  unsigned int c.57_33;
  unsigned int _34;
  unsigned char _35;
  unsigned char _36;
  char _37;
  char * _39;
  unsigned int c.58_40;
  unsigned int _41;
  unsigned char _42;
  unsigned char _43;
  unsigned char _44;
  char _45;
  char * _47;
  unsigned int c.59_48;
  unsigned int _49;
  unsigned char _50;
  unsigned char _51;
  unsigned char _52;
  char _53;
  char * _55;
  unsigned int c.60_56;
  unsigned char _57;
  unsigned char _58;
  unsigned char _59;
  char _60;
  int _62;
  int _63;
  unsigned int c.61_64;
  unsigned int _65;
  unsigned char _66;
  unsigned char _67;
  char _68;
  char * _70;
  unsigned int c.62_71;
  unsigned int _72;
  unsigned char _73;
  unsigned char _74;
  unsigned char _75;
  char _76;
  char * _78;
  unsigned int c.63_79;
  unsigned char _80;
  unsigned char _81;
  unsigned char _82;
  char _83;
  int _85;

  <bb 2>:
  c.48_4 = c;
  if (c.48_4 <= 127)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  c.49_5 = c;
  _6 = (char) c.49_5;
  *buf_7(D) = _6;
  _9 = 1;
  goto <bb 19> (<L18>);

  <bb 4>:
  c.50_10 = c;
  if (c.50_10 <= 2047)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  if (buf_size_11(D) <= 1)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _12 = 0;
  goto <bb 19> (<L18>);

  <bb 7>:
  c.51_13 = c;
  _14 = c.51_13 >> 6;
  _15 = (unsigned char) _14;
  _16 = _15 + 192;
  _17 = (char) _16;
  *buf_7(D) = _17;
  _19 = buf_7(D) + 1;
  c.52_20 = c;
  _21 = (unsigned char) c.52_20;
  _22 = _21 & 63;
  _23 = _22 + 128;
  _24 = (char) _23;
  *_19 = _24;
  _26 = 2;
  goto <bb 19> (<L18>);

  <bb 8>:
  c.53_27 = c;
  if (c.53_27 > 56319)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  c.54_28 = c;
  if (c.54_28 <= 57343)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _29 = 0;
  goto <bb 19> (<L18>);

  <bb 11>:
  c.55_30 = c;
  if (c.55_30 > 55295)
    goto <bb 12>;
  else
    goto <bb 16>;

  <bb 12>:
  c.56_31 = c;
  if (c.56_31 <= 56319)
    goto <bb 13>;
  else
    goto <bb 16>;

  <bb 13>:
  if (buf_size_11(D) <= 3)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _32 = 0;
  goto <bb 19> (<L18>);

  <bb 15>:
  c.57_33 = c;
  _34 = c.57_33 >> 18;
  _35 = (unsigned char) _34;
  _36 = _35 + 240;
  _37 = (char) _36;
  *buf_7(D) = _37;
  _39 = buf_7(D) + 1;
  c.58_40 = c;
  _41 = c.58_40 >> 12;
  _42 = (unsigned char) _41;
  _43 = _42 & 63;
  _44 = _43 + 128;
  _45 = (char) _44;
  *_39 = _45;
  _47 = buf_7(D) + 2;
  c.59_48 = c;
  _49 = c.59_48 >> 6;
  _50 = (unsigned char) _49;
  _51 = _50 & 63;
  _52 = _51 + 128;
  _53 = (char) _52;
  *_47 = _53;
  _55 = buf_7(D) + 3;
  c.60_56 = c;
  _57 = (unsigned char) c.60_56;
  _58 = _57 & 63;
  _59 = _58 + 128;
  _60 = (char) _59;
  *_55 = _60;
  _62 = 4;
  goto <bb 19> (<L18>);

  <bb 16>:
  if (buf_size_11(D) <= 2)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _63 = 0;
  goto <bb 19> (<L18>);

  <bb 18>:
  c.61_64 = c;
  _65 = c.61_64 >> 12;
  _66 = (unsigned char) _65;
  _67 = _66 + 224;
  _68 = (char) _67;
  *buf_7(D) = _68;
  _70 = buf_7(D) + 1;
  c.62_71 = c;
  _72 = c.62_71 >> 6;
  _73 = (unsigned char) _72;
  _74 = _73 & 63;
  _75 = _74 + 128;
  _76 = (char) _75;
  *_70 = _76;
  _78 = buf_7(D) + 2;
  c.63_79 = c;
  _80 = (unsigned char) c.63_79;
  _81 = _80 & 63;
  _82 = _81 + 128;
  _83 = (char) _82;
  *_78 = _83;
  _85 = 3;

  # _1 = PHI <_9(3), _12(6), _26(7), _29(10), _32(14), _62(15), _63(17), _85(18)>
<L18>:
  return _1;

}



;; Function int ImTextCountUtf8BytesFromChar(unsigned int) (_ZL28ImTextCountUtf8BytesFromCharj, funcdef_no=584, decl_uid=15457, cgraph_uid=483, symbol_order=489)

int ImTextCountUtf8BytesFromChar(unsigned int) (unsigned int c)
{
  int D.23181;
  int _1;
  int _3;
  int _4;
  int _5;
  int _6;
  int _7;

  <bb 2>:
  if (c_2(D) <= 127)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _3 = 1;
  goto <bb 13> (<L12>);

  <bb 4>:
  if (c_2(D) <= 2047)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _4 = 2;
  goto <bb 13> (<L12>);

  <bb 6>:
  if (c_2(D) > 56319)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  if (c_2(D) <= 57343)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _5 = 0;
  goto <bb 13> (<L12>);

  <bb 9>:
  if (c_2(D) > 55295)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  if (c_2(D) <= 56319)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _6 = 4;
  goto <bb 13> (<L12>);

  <bb 12>:
  _7 = 3;

  # _1 = PHI <_3(3), _4(5), _5(8), _6(11), _7(12)>
<L12>:
  return _1;

}



;; Function int ImTextStrToUtf8(char*, int, const ImWchar*, const ImWchar*) (_Z15ImTextStrToUtf8PciPKtS1_, funcdef_no=585, decl_uid=10495, cgraph_uid=484, symbol_order=490)

int ImTextStrToUtf8(char*, int, const ImWchar*, const ImWchar*) (char * buf, int buf_size, const ImWchar * in_text, const ImWchar * in_text_end)
{
  unsigned int c;
  const char * buf_end;
  char * buf_out;
  long int D.23083;
  long int buf.47;
  long int buf_out.46;
  int D.23080;
  sizetype D.23079;
  int D.23078;
  unsigned int D.23077;
  unsigned int D.23076;
  long int D.23075;
  long int buf_out.45;
  long int buf_end.44;
  int D.15468;
  char D.23071;
  char * buf_out.43;
  short unsigned int D.23067;
  const ImWchar * in_text.42;
  short unsigned int D.23064;
  const char * D.23061;
  sizetype D.23058;
  sizetype _9;
  const char * _13;
  short unsigned int _15;
  const ImWchar * in_text.42_16;
  short unsigned int _18;
  char * buf_out.43_20;
  char _22;
  long int buf_end.44_24;
  long int buf_out.45_25;
  long int _26;
  unsigned int _27;
  unsigned int _28;
  int _29;
  int _31;
  sizetype _32;
  long int buf_out.46_35;
  long int buf.47_36;
  long int _37;
  int _38;

  <bb 2>:
  buf_out_7 = buf_6(D);
  _9 = (sizetype) buf_size_8(D);
  buf_end_10 = buf_6(D) + _9;

  <bb 3>:
  # in_text_1 = PHI <in_text_11(D)(2), in_text_17(10)>
  # buf_out_2 = PHI <buf_out_7(2), buf_out_3(10)>
  _13 = buf_end_10 + 18446744073709551615;
  if (_13 <= buf_out_2)
    goto <bb 11>;
  else
    goto <bb 4>;

  <bb 4>:
  if (in_text_end_14(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  if (in_text_1 >= in_text_end_14(D))
    goto <bb 11>;
  else
    goto <bb 6>;

  <bb 6>:
  _15 = *in_text_1;
  if (_15 == 0)
    goto <bb 11>;
  else
    goto <bb 7>;

  <bb 7>:
  in_text.42_16 = in_text_1;
  in_text_17 = in_text.42_16 + 2;
  _18 = *in_text.42_16;
  c_19 = (unsigned int) _18;
  if (c_19 <= 127)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  buf_out.43_20 = buf_out_2;
  buf_out_21 = buf_out.43_20 + 1;
  _22 = (char) c_19;
  *buf_out.43_20 = _22;
  goto <bb 10>;

  <bb 9>:
  buf_end.44_24 = (long int) buf_end_10;
  buf_out.45_25 = (long int) buf_out_2;
  _26 = buf_end.44_24 - buf_out.45_25;
  _27 = (unsigned int) _26;
  _28 = _27 + 4294967295;
  _29 = (int) _28;
  _31 = ImTextCharToUtf8 (buf_out_2, _29, c_19);
  _32 = (sizetype) _31;
  buf_out_33 = buf_out_2 + _32;

  <bb 10>:
  # buf_out_3 = PHI <buf_out_21(8), buf_out_33(9)>
  goto <bb 3>;

  <bb 11>:
  *buf_out_2 = 0;
  buf_out.46_35 = (long int) buf_out_2;
  buf.47_36 = (long int) buf_6(D);
  _37 = buf_out.46_35 - buf.47_36;
  _38 = (int) _37;

<L9>:
  return _38;

}



;; Function int ImTextCountUtf8BytesFromStr(const ImWchar*, const ImWchar*) (_Z27ImTextCountUtf8BytesFromStrPKtS0_, funcdef_no=586, decl_uid=10511, cgraph_uid=485, symbol_order=491)

int ImTextCountUtf8BytesFromStr(const ImWchar*, const ImWchar*) (const ImWchar * in_text, const ImWchar * in_text_end)
{
  unsigned int c;
  int bytes_count;
  int D.23177;
  int D.15477;
  short unsigned int D.23173;
  const ImWchar * in_text.64;
  short unsigned int D.23170;
  short unsigned int _10;
  const ImWchar * in_text.64_11;
  short unsigned int _13;
  int _17;
  int _19;

  <bb 2>:
  bytes_count_6 = 0;

  <bb 3>:
  # in_text_1 = PHI <in_text_7(D)(2), in_text_12(9)>
  # bytes_count_2 = PHI <bytes_count_6(2), bytes_count_3(9)>
  if (in_text_end_9(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  if (in_text_1 >= in_text_end_9(D))
    goto <bb 10>;
  else
    goto <bb 5>;

  <bb 5>:
  _10 = *in_text_1;
  if (_10 == 0)
    goto <bb 10>;
  else
    goto <bb 6>;

  <bb 6>:
  in_text.64_11 = in_text_1;
  in_text_12 = in_text.64_11 + 2;
  _13 = *in_text.64_11;
  c_14 = (unsigned int) _13;
  if (c_14 <= 127)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  bytes_count_15 = bytes_count_2 + 1;
  goto <bb 9>;

  <bb 8>:
  _17 = ImTextCountUtf8BytesFromChar (c_14);
  bytes_count_18 = bytes_count_2 + _17;

  <bb 9>:
  # bytes_count_3 = PHI <bytes_count_15(7), bytes_count_18(8)>
  goto <bb 3>;

  <bb 10>:
  _19 = bytes_count_2;

<L8>:
  return _19;

}



;; Function ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32) (_ZN5ImGui23ColorConvertU32ToFloat4Ej, funcdef_no=587, decl_uid=3346, cgraph_uid=486, symbol_order=492)

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32) (ImU32 in)
{
  float s;
  float D.23207;
  float D.23206;
  unsigned int D.23205;
  float D.23204;
  float D.23203;
  unsigned int D.23202;
  unsigned int D.23201;
  float D.23200;
  float D.23199;
  unsigned int D.23198;
  unsigned int D.23197;
  float D.23196;
  float D.23195;
  unsigned int D.23194;
  struct ImVec4 D.15484;
  struct ImVec4 D.23193;
  unsigned int _3;
  float _4;
  float _5;
  unsigned int _6;
  unsigned int _7;
  float _8;
  float _9;
  unsigned int _10;
  unsigned int _11;
  float _12;
  float _13;
  unsigned int _14;
  float _15;
  float _16;

  <bb 2>:
  s_1 = 3.9215688593685626983642578125e-3;
  _3 = in_2(D) >> 24;
  _4 = (float) _3;
  _5 = _4 * s_1;
  _6 = in_2(D) >> 16;
  _7 = _6 & 255;
  _8 = (float) _7;
  _9 = _8 * s_1;
  _10 = in_2(D) >> 8;
  _11 = _10 & 255;
  _12 = (float) _11;
  _13 = _12 * s_1;
  _14 = in_2(D) & 255;
  _15 = (float) _14;
  _16 = _15 * s_1;
  ImVec4::ImVec4 (&D.15484, _16, _13, _9, _5);
  D.23193 = D.15484;
  D.15484 ={v} {CLOBBER};

<L1>:
  return D.23193;

}



;; Function ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4&) (_ZN5ImGui23ColorConvertFloat4ToU32ERK6ImVec4, funcdef_no=588, decl_uid=3348, cgraph_uid=487, symbol_order=493)

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4&) (const struct ImVec4 & in)
{
  ImU32 out;
  ImU32 D.23233;
  unsigned int D.23232;
  int D.23231;
  float D.23230;
  float D.23229;
  float D.23228;
  float D.23227;
  ImU32 D.15491;
  unsigned int D.23226;
  int D.23225;
  float D.23224;
  float D.23223;
  float D.23222;
  float D.23221;
  ImU32 D.15490;
  unsigned int D.23220;
  int D.23219;
  float D.23218;
  float D.23217;
  float D.23216;
  float D.23215;
  ImU32 D.15489;
  int D.23214;
  float D.23213;
  float D.23212;
  float D.23211;
  float D.23210;
  float _3;
  float _5;
  float _6;
  float _7;
  int _8;
  float _10;
  float _12;
  float _13;
  float _14;
  int _15;
  unsigned int _16;
  ImU32 _17;
  float _19;
  float _21;
  float _22;
  float _23;
  int _24;
  unsigned int _25;
  ImU32 _26;
  float _28;
  float _30;
  float _31;
  float _32;
  int _33;
  unsigned int _34;
  ImU32 _35;
  ImU32 _37;

  <bb 2>:
  _3 = in_2(D)->x;
  _5 = ImSaturate (_3);
  _6 = _5 * 2.55e+2;
  _7 = _6 + 5.0e-1;
  _8 = (int) _7;
  out_9 = (ImU32) _8;
  _10 = in_2(D)->y;
  _12 = ImSaturate (_10);
  _13 = _12 * 2.55e+2;
  _14 = _13 + 5.0e-1;
  _15 = (int) _14;
  _16 = (unsigned int) _15;
  _17 = _16 << 8;
  out_18 = out_9 | _17;
  _19 = in_2(D)->z;
  _21 = ImSaturate (_19);
  _22 = _21 * 2.55e+2;
  _23 = _22 + 5.0e-1;
  _24 = (int) _23;
  _25 = (unsigned int) _24;
  _26 = _25 << 16;
  out_27 = out_18 | _26;
  _28 = in_2(D)->w;
  _30 = ImSaturate (_28);
  _31 = _30 * 2.55e+2;
  _32 = _31 + 5.0e-1;
  _33 = (int) _32;
  _34 = (unsigned int) _33;
  _35 = _34 << 24;
  out_36 = out_27 | _35;
  _37 = out_36;

<L0>:
  return _37;

}



;; Function ImU32 ImGui::GetColorU32(ImGuiCol, float) (_ZN5ImGui11GetColorU32Eif, funcdef_no=589, decl_uid=2599, cgraph_uid=488, symbol_order=494)

ImU32 ImGui::GetColorU32(ImGuiCol, float) (ImGuiCol idx, float alpha_mul)
{
  struct ImVec4 c;
  struct ImGuiStyle & style;
  ImU32 D.23250;
  float D.23249;
  float D.23248;
  float D.23247;
  float D.23246;
  struct ImGuiContext * GImGui.67;
  struct ImGuiContext * GImGui.67_2;
  float _6;
  float _7;
  float _9;
  float _10;
  ImU32 _13;

  <bb 2>:
  GImGui.67_2 = GImGui;
  style_3 = &GImGui.67_2->Style;
  c = style_3->Colors[idx_4(D)];
  _6 = c.w;
  _7 = style_3->Alpha;
  _9 = _7 * alpha_mul_8(D);
  _10 = _6 * _9;
  c.w = _10;
  _13 = ImGui::ColorConvertFloat4ToU32 (&c);
  c ={v} {CLOBBER};

<L1>:
  return _13;

}



;; Function ImU32 ImGui::GetColorU32(const ImVec4&) (_ZN5ImGui11GetColorU32ERK6ImVec4, funcdef_no=590, decl_uid=2601, cgraph_uid=489, symbol_order=495)

ImU32 ImGui::GetColorU32(const ImVec4&) (const struct ImVec4 & col)
{
  struct ImVec4 c;
  struct ImGuiStyle & style;
  ImU32 D.23257;
  float D.23256;
  float D.23255;
  float D.23254;
  struct ImGuiContext * GImGui.68;
  struct ImGuiContext * GImGui.68_2;
  float _6;
  float _7;
  float _8;
  ImU32 _11;

  <bb 2>:
  GImGui.68_2 = GImGui;
  style_3 = &GImGui.68_2->Style;
  c = *col_4(D);
  _6 = c.w;
  _7 = style_3->Alpha;
  _8 = _6 * _7;
  c.w = _8;
  _11 = ImGui::ColorConvertFloat4ToU32 (&c);
  c ={v} {CLOBBER};

<L1>:
  return _11;

}



;; Function const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol) (_ZN5ImGui17GetStyleColorVec4Ei, funcdef_no=591, decl_uid=2593, cgraph_uid=490, symbol_order=496)

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol) (ImGuiCol idx)
{
  struct ImGuiStyle & style;
  const struct ImVec4 & D.23261;
  struct ImGuiContext * GImGui.69;
  struct ImGuiContext * GImGui.69_2;
  const struct ImVec4 & _5;

  <bb 2>:
  GImGui.69_2 = GImGui;
  style_3 = &GImGui.69_2->Style;
  _5 = &style_3->Colors[idx_4(D)];

<L0>:
  return _5;

}



;; Function ImU32 ImGui::GetColorU32(ImU32) (_ZN5ImGui11GetColorU32Ej, funcdef_no=592, decl_uid=2603, cgraph_uid=491, symbol_order=497)

ImU32 ImGui::GetColorU32(ImU32) (ImU32 col)
{
  ImU32 a;
  float style_alpha;
  unsigned int D.23270;
  unsigned int D.23269;
  float D.23268;
  float D.23267;
  ImU32 D.23266;
  struct ImGuiContext * GImGui.70;
  ImU32 _1;
  struct ImGuiContext * GImGui.70_3;
  ImU32 _6;
  float _8;
  float _9;
  unsigned int _11;
  unsigned int _12;
  ImU32 _13;

  <bb 2>:
  GImGui.70_3 = GImGui;
  style_alpha_4 = GImGui.70_3->Style.Alpha;
  if (style_alpha_4 >= 1.0e+0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = col_5(D);
  goto <bb 5> (<L2>);

  <bb 4>:
  a_7 = col_5(D) >> 24;
  _8 = (float) a_7;
  _9 = _8 * style_alpha_4;
  a_10 = (ImU32) _9;
  _11 = col_5(D) & 16777215;
  _12 = a_10 << 24;
  _13 = _11 | _12;

  # _1 = PHI <_6(3), _13(4)>
<L2>:
  return _1;

}



;; Function void ImGui::ColorConvertRGBtoHSV(float, float, float, float&, float&, float&) (_ZN5ImGui20ColorConvertRGBtoHSVEfffRfS0_S0_, funcdef_no=593, decl_uid=3355, cgraph_uid=492, symbol_order=498)

void ImGui::ColorConvertRGBtoHSV(float, float, float, float&, float&, float&) (float r, float g, float b, float & out_h, float & out_s, float & out_v)
{
  const float chroma;
  float K;
  float r.82;
  float D.23299;
  float D.23298;
  float r.81;
  float D.23296;
  float D.23295;
  float D.23294;
  float D.23293;
  float D.23292;
  float D.23291;
  float b.80;
  float g.79;
  float b.78;
  float g.77;
  float iftmp.76;
  float r.75;
  float g.74;
  float r.73;
  float b.72;
  float g.71;
  float iftmp.76_3;
  float g.71_8;
  float b.72_9;
  float r.73_12;
  float g.74_13;
  float r.75_16;
  float g.77_17;
  float b.78_18;
  float iftmp.76_19;
  float iftmp.76_20;
  float g.79_22;
  float b.80_23;
  float _24;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float r.81_32;
  float _33;
  float _34;
  float r.82_37;

  <bb 2>:
  K_6 = 0.0;
  g.71_8 = g;
  b.72_9 = b;
  if (g.71_8 < b.72_9)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImSwap (&g, &b);
  K_11 = -1.0e+0;

  <bb 4>:
  # K_1 = PHI <K_6(2), K_11(3)>
  r.73_12 = r;
  g.74_13 = g;
  if (r.73_12 < g.74_13)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImSwap (&r, &g);
  K_15 = -3.333333432674407958984375e-1 - K_1;

  <bb 6>:
  # K_2 = PHI <K_1(4), K_15(5)>
  r.75_16 = r;
  g.77_17 = g;
  b.78_18 = b;
  if (g.77_17 < b.78_18)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.76_19 = g;
  goto <bb 9>;

  <bb 8>:
  iftmp.76_20 = b;

  <bb 9>:
  # iftmp.76_3 = PHI <iftmp.76_19(7), iftmp.76_20(8)>
  chroma_21 = r.75_16 - iftmp.76_3;
  g.79_22 = g;
  b.80_23 = b;
  _24 = g.79_22 - b.80_23;
  _25 = chroma_21 * 6.0e+0;
  _26 = _25 + 9.9999996826552253889678874634872052240552875446155667305e-21;
  _27 = _24 / _26;
  _28 = _27 + K_2;
  _29 = ABS_EXPR <_28>;
  *out_h_30(D) = _29;
  r.81_32 = r;
  _33 = r.81_32 + 9.9999996826552253889678874634872052240552875446155667305e-21;
  _34 = chroma_21 / _33;
  *out_s_35(D) = _34;
  r.82_37 = r;
  *out_v_38(D) = r.82_37;
  return;

}



;; Function void ImGui::ColorConvertHSVtoRGB(float, float, float, float&, float&, float&) (_ZN5ImGui20ColorConvertHSVtoRGBEfffRfS0_S0_, funcdef_no=594, decl_uid=3362, cgraph_uid=493, symbol_order=499)

void ImGui::ColorConvertHSVtoRGB(float, float, float, float&, float&, float&) (float h, float s, float v, float & out_r, float & out_g, float & out_b)
{
  float t;
  float q;
  float p;
  float f;
  int i;
  float D.23313;
  float D.23312;
  float D.23311;
  float D.23310;
  float D.23309;
  float D.23308;
  float D.23307;
  float D.23306;
  float D.23305;
  float D.23304;
  float _7;
  float _10;
  float _15;
  float _18;
  float _20;
  float _22;
  float _23;
  float _25;
  float _26;
  float _27;

  <bb 2>:
  if (s_2(D) == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  *out_b_4(D) = v_5(D);
  _7 = *out_b_4(D);
  *out_g_8(D) = _7;
  _10 = *out_g_8(D);
  *out_r_11(D) = _10;
  goto <bb 11> (<L10>);

  <bb 4>:
  _15 = fmodf (h_13(D), 1.0e+0);
  h_16 = _15 / 1.6666667163372039794921875e-1;
  i_17 = (int) h_16;
  _18 = (float) i_17;
  f_19 = h_16 - _18;
  _20 = 1.0e+0 - s_2(D);
  p_21 = _20 * v_5(D);
  _22 = s_2(D) * f_19;
  _23 = 1.0e+0 - _22;
  q_24 = _23 * v_5(D);
  _25 = 1.0e+0 - f_19;
  _26 = _25 * s_2(D);
  _27 = 1.0e+0 - _26;
  t_28 = _27 * v_5(D);
  switch (i_17) <default: <L7>, case 0: <L2>, case 1: <L3>, case 2: <L4>, case 3: <L5>, case 4: <L6>>

<L2>:
  *out_r_11(D) = v_5(D);
  *out_g_8(D) = t_28;
  *out_b_4(D) = p_21;
  goto <bb 11> (<L10>);

<L3>:
  *out_r_11(D) = q_24;
  *out_g_8(D) = v_5(D);
  *out_b_4(D) = p_21;
  goto <bb 11> (<L10>);

<L4>:
  *out_r_11(D) = p_21;
  *out_g_8(D) = v_5(D);
  *out_b_4(D) = t_28;
  goto <bb 11> (<L10>);

<L5>:
  *out_r_11(D) = p_21;
  *out_g_8(D) = q_24;
  *out_b_4(D) = v_5(D);
  goto <bb 11> (<L10>);

<L6>:
  *out_r_11(D) = t_28;
  *out_g_8(D) = p_21;
  *out_b_4(D) = v_5(D);
  goto <bb 11> (<L10>);

<L7>:
  *out_r_11(D) = v_5(D);
  *out_g_8(D) = p_21;
  *out_b_4(D) = q_24;

<L10>:
  return;

}



;; Function FILE* ImFileOpen(const char*, const char*) (_Z10ImFileOpenPKcS0_, funcdef_no=595, decl_uid=10523, cgraph_uid=494, symbol_order=500)

FILE* ImFileOpen(const char*, const char*) (const char * filename, const char * mode)
{
  struct FILE * D.23317;
  struct FILE * D.23315;
  struct FILE * _5;
  struct FILE * _6;

  <bb 2>:
  _5 = fopen (filename_2(D), mode_3(D));
  _6 = _5;

<L0>:
  return _6;

}



;; Function void* ImFileLoadToMemory(const char*, const char*, int*, int) (_Z18ImFileLoadToMemoryPKcS0_Pii, funcdef_no=596, decl_uid=10520, cgraph_uid=495, symbol_order=501)

void* ImFileLoadToMemory(const char*, const char*, int*, int) (const char * filename, const char * file_open_mode, int * out_file_size, int padding_bytes)
{
  long unsigned int D.23363;
  void * D.23362;
  long int D.23361;
  struct FILE * D.23360;
  void * file_data;
  int file_size;
  long int file_size_signed;
  struct FILE * f;
  static const char __PRETTY_FUNCTION__[62] = "void* ImFileLoadToMemory(const char*, const char*, int*, int)";
  void * D.23354;
  sizetype D.23353;
  long unsigned int D.23352;
  long unsigned int D.23347;
  long unsigned int D.23346;
  long unsigned int D.23345;
  bool retval.86;
  long unsigned int D.23341;
  int D.23340;
  int D.23337;
  int D.23334;
  bool iftmp.85;
  bool retval.84;
  void * D.23328;
  bool retval.83;
  void * _3;
  bool iftmp.85_4;
  struct FILE * _17;
  bool retval.83_19;
  void * _20;
  int _22;
  long int _25;
  int _28;
  bool iftmp.85_29;
  bool iftmp.85_30;
  bool retval.84_31;
  void * _33;
  int _36;
  long unsigned int _37;
  void * _39;
  void * _42;
  long unsigned int _43;
  long unsigned int _45;
  long unsigned int _46;
  long unsigned int _47;
  bool retval.86_48;
  void * _51;
  long unsigned int _52;
  sizetype _53;
  void * _54;
  void * _58;

  <bb 2>:
  if (filename_11(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (file_open_mode_12(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("filename && file_open_mode", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 1460, &__PRETTY_FUNCTION__);

  <bb 6>:
  if (out_file_size_13(D) != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  *out_file_size_13(D) = 0;

  <bb 8>:
  _17 = ImFileOpen (filename_11(D), file_open_mode_12(D));
  f_18 = _17;
  retval.83_19 = f_18 == 0B;
  if (retval.83_19 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _20 = 0B;
  goto <bb 26> (<L26>);

  <bb 10>:
  _22 = fseek (f_18, 0, 2);
  if (_22 != 0)
    goto <bb 13>;
  else
    goto <bb 11>;

  <bb 11>:
  _25 = ftell (f_18);
  file_size_signed_26 = _25;
  if (file_size_signed_26 == -1)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  _28 = fseek (f_18, 0, 0);
  if (_28 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  # file_size_signed_1 = PHI <file_size_signed_23(D)(10), file_size_signed_26(11), file_size_signed_26(12)>
  iftmp.85_30 = 1;
  goto <bb 15>;

  <bb 14>:
  iftmp.85_29 = 0;

  <bb 15>:
  # file_size_signed_2 = PHI <file_size_signed_1(13), file_size_signed_26(14)>
  # iftmp.85_4 = PHI <iftmp.85_30(13), iftmp.85_29(14)>
  retval.84_31 = iftmp.85_4;
  if (retval.84_31 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  fclose (f_18);
  _33 = 0B;
  goto <bb 26> (<L26>);

  <bb 17>:
  file_size_34 = (int) file_size_signed_2;
  _36 = file_size_34 + padding_bytes_35(D);
  _37 = (long unsigned int) _36;
  _39 = ImGui::MemAlloc (_37);
  file_data_40 = _39;
  if (file_data_40 == 0B)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  fclose (f_18);
  _42 = 0B;
  goto <bb 26> (<L26>);

  <bb 19>:
  _43 = (long unsigned int) file_size_34;
  _45 = fread (file_data_40, 1, _43, f_18);
  _46 = _45;
  _47 = (long unsigned int) file_size_34;
  retval.86_48 = _46 != _47;
  if (retval.86_48 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  fclose (f_18);
  ImGui::MemFree (file_data_40);
  _51 = 0B;
  goto <bb 26> (<L26>);

  <bb 21>:
  if (padding_bytes_35(D) > 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  _52 = (long unsigned int) padding_bytes_35(D);
  _53 = (sizetype) file_size_34;
  _54 = file_data_40 + _53;
  memset (_54, 0, _52);

  <bb 23>:
  fclose (f_18);
  if (out_file_size_13(D) != 0B)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  *out_file_size_13(D) = file_size_34;

  <bb 25>:
  _58 = file_data_40;

  # _3 = PHI <_20(9), _33(16), _42(18), _51(20), _58(25)>
<L26>:
  return _3;

}



;; Function ImVector<ImGuiStorage::Pair>::value_type* LowerBound(ImVector<ImGuiStorage::Pair>&, ImGuiID) (_ZL10LowerBoundR8ImVectorIN12ImGuiStorage4PairEEj, funcdef_no=597, decl_uid=15562, cgraph_uid=496, symbol_order=502)

ImVector<ImGuiStorage::Pair>::value_type* LowerBound(ImVector<ImGuiStorage::Pair>&, ImGuiID) (struct ImVector & data, ImGuiID key)
{
  struct value_type * mid;
  size_t count2;
  size_t count;
  struct value_type * last;
  struct value_type * first;
  struct value_type * D.23376;
  long unsigned int D.23374;
  unsigned int D.23371;
  long unsigned int D.23370;
  long int D.23367;
  long int D.23366;
  long int first.88;
  long int last.87;
  long int last.87_11;
  long int first.88_12;
  long int _13;
  long int _14;
  long unsigned int _17;
  unsigned int _19;
  long unsigned int _23;
  struct value_type * _26;

  <bb 2>:
  first_8 = ImVector<ImGuiStorage::Pair>::begin (data_6(D));
  last_10 = ImVector<ImGuiStorage::Pair>::end (data_6(D));
  last.87_11 = (long int) last_10;
  first.88_12 = (long int) first_8;
  _13 = last.87_11 - first.88_12;
  _14 = _13 /[ex] 16;
  count_15 = (size_t) _14;

  <bb 3>:
  # first_1 = PHI <first_8(2), first_2(7)>
  # count_3 = PHI <count_15(2), count_4(7)>
  if (count_3 == 0)
    goto <bb 8>;
  else
    goto <bb 4>;

  <bb 4>:
  count2_16 = count_3 >> 1;
  _17 = count2_16 * 16;
  mid_18 = first_1 + _17;
  _19 = mid_18->key;
  if (_19 < key_20(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  mid_21 = mid_18 + 16;
  first_22 = mid_21;
  _23 = count_3 - count2_16;
  count_24 = _23 + 18446744073709551615;
  goto <bb 7>;

  <bb 6>:
  count_25 = count2_16;

  <bb 7>:
  # first_2 = PHI <first_22(5), first_1(6)>
  # count_4 = PHI <count_24(5), count_25(6)>
  goto <bb 3>;

  <bb 8>:
  _26 = first_1;

<L6>:
  return _26;

}



;; Function static int ImGuiStorage::BuildSortByKey()::StaticFunc::PairCompareByID(const void*, const void*) (_ZZN12ImGuiStorage14BuildSortByKeyEvEN10StaticFunc15PairCompareByIDEPKvS2_, funcdef_no=599, decl_uid=15578, cgraph_uid=497, symbol_order=503)

static int ImGuiStorage::BuildSortByKey()::StaticFunc::PairCompareByID(const void*, const void*) (const void * lhs, const void * rhs)
{
  unsigned int D.23399;
  unsigned int D.23398;
  int D.23397;
  unsigned int D.23394;
  unsigned int D.23393;
  int _1;
  unsigned int _4;
  unsigned int _6;
  int _7;
  unsigned int _8;
  unsigned int _9;
  int _10;
  int _11;

  <bb 2>:
  _4 = MEM[(const struct Pair *)lhs_3(D)].key;
  _6 = MEM[(const struct Pair *)rhs_5(D)].key;
  if (_4 > _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 1;
  goto <bb 7> (<L4>);

  <bb 4>:
  _8 = MEM[(const struct Pair *)lhs_3(D)].key;
  _9 = MEM[(const struct Pair *)rhs_5(D)].key;
  if (_8 < _9)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _10 = -1;
  goto <bb 7> (<L4>);

  <bb 6>:
  _11 = 0;

  # _1 = PHI <_7(3), _10(5), _11(6)>
<L4>:
  return _1;

}



;; Function void ImGuiStorage::BuildSortByKey() (_ZN12ImGuiStorage14BuildSortByKeyEv, funcdef_no=598, decl_uid=4742, cgraph_uid=498, symbol_order=504)

void ImGuiStorage::BuildSortByKey() (struct ImGuiStorage * const this)
{
  struct Pair * D.23391;
  long unsigned int D.23390;
  int D.23389;
  int D.23386;
  int _4;
  int _5;
  long unsigned int _6;
  struct Pair * _7;

  <bb 2>:
  _4 = this_3(D)->Data.Size;
  if (_4 > 1)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data.Size;
  _6 = (long unsigned int) _5;
  _7 = this_3(D)->Data.Data;
  qsort (_7, _6, 16, PairCompareByID);

  <bb 4>:
  return;

}



;; Function int ImGuiStorage::GetInt(ImGuiID, int) const (_ZNK12ImGuiStorage6GetIntEji, funcdef_no=600, decl_uid=4694, cgraph_uid=499, symbol_order=505)

int ImGuiStorage::GetInt(ImGuiID, int) const (const struct ImGuiStorage * const this, ImGuiID key, int default_val)
{
  struct value_type * D.23417;
  struct value_type * it;
  int D.23415;
  unsigned int D.23412;
  const struct value_type * D.23410;
  const struct ImVector * D.23409;
  bool iftmp.90;
  bool retval.89;
  const struct ImVector * D.23403;
  bool iftmp.90_1;
  int _2;
  const struct ImVector * _4;
  struct value_type * _8;
  const struct ImVector * _10;
  const struct value_type * _12;
  unsigned int _13;
  bool iftmp.90_14;
  bool iftmp.90_15;
  bool retval.89_16;
  int _18;
  int _19;

  <bb 2>:
  _4 = &this_3(D)->Data;
  _8 = LowerBound (_4, key_6(D));
  it_9 = _8;
  _10 = &this_3(D)->Data;
  _12 = ImVector<ImGuiStorage::Pair>::end (_10);
  if (_12 == it_9)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _13 = it_9->key;
  if (_13 != key_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.90_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.90_14 = 0;

  <bb 6>:
  # iftmp.90_1 = PHI <iftmp.90_15(4), iftmp.90_14(5)>
  retval.89_16 = iftmp.90_1;
  if (retval.89_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _18 = default_val_17(D);
  goto <bb 9> (<L6>);

  <bb 8>:
  _19 = it_9->D.4548.val_i;

  # _2 = PHI <_18(7), _19(8)>
<L6>:
  return _2;

}



;; Function bool ImGuiStorage::GetBool(ImGuiID, bool) const (_ZNK12ImGuiStorage7GetBoolEjb, funcdef_no=601, decl_uid=4702, cgraph_uid=500, symbol_order=506)

bool ImGuiStorage::GetBool(ImGuiID, bool) const (const struct ImGuiStorage * const this, ImGuiID key, bool default_val)
{
  int D.23431;
  int D.23429;
  int iftmp.91;
  bool D.23424;
  int iftmp.91_1;
  int iftmp.91_3;
  int iftmp.91_4;
  int _9;
  int _10;
  bool _11;

  <bb 2>:
  if (default_val_2(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.91_3 = 1;
  goto <bb 5>;

  <bb 4>:
  iftmp.91_4 = 0;

  <bb 5>:
  # iftmp.91_1 = PHI <iftmp.91_3(3), iftmp.91_4(4)>
  _9 = ImGuiStorage::GetInt (this_6(D), key_7(D), iftmp.91_1);
  _10 = _9;
  _11 = _10 != 0;

<L3>:
  return _11;

}



;; Function float ImGuiStorage::GetFloat(ImGuiID, float) const (_ZNK12ImGuiStorage8GetFloatEjf, funcdef_no=602, decl_uid=4710, cgraph_uid=501, symbol_order=507)

float ImGuiStorage::GetFloat(ImGuiID, float) const (const struct ImGuiStorage * const this, ImGuiID key, float default_val)
{
  struct value_type * D.23446;
  struct value_type * it;
  float D.23444;
  unsigned int D.23441;
  const struct value_type * D.23439;
  const struct ImVector * D.23438;
  bool iftmp.93;
  bool retval.92;
  const struct ImVector * D.23432;
  bool iftmp.93_1;
  float _2;
  const struct ImVector * _4;
  struct value_type * _8;
  const struct ImVector * _10;
  const struct value_type * _12;
  unsigned int _13;
  bool iftmp.93_14;
  bool iftmp.93_15;
  bool retval.92_16;
  float _18;
  float _19;

  <bb 2>:
  _4 = &this_3(D)->Data;
  _8 = LowerBound (_4, key_6(D));
  it_9 = _8;
  _10 = &this_3(D)->Data;
  _12 = ImVector<ImGuiStorage::Pair>::end (_10);
  if (_12 == it_9)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _13 = it_9->key;
  if (_13 != key_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.93_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.93_14 = 0;

  <bb 6>:
  # iftmp.93_1 = PHI <iftmp.93_15(4), iftmp.93_14(5)>
  retval.92_16 = iftmp.93_1;
  if (retval.92_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _18 = default_val_17(D);
  goto <bb 9> (<L6>);

  <bb 8>:
  _19 = it_9->D.4548.val_f;

  # _2 = PHI <_18(7), _19(8)>
<L6>:
  return _2;

}



;; Function void* ImGuiStorage::GetVoidPtr(ImGuiID) const (_ZNK12ImGuiStorage10GetVoidPtrEj, funcdef_no=603, decl_uid=4717, cgraph_uid=502, symbol_order=508)

void* ImGuiStorage::GetVoidPtr(ImGuiID) const (const struct ImGuiStorage * const this, ImGuiID key)
{
  struct value_type * D.23461;
  struct value_type * it;
  void * D.23459;
  unsigned int D.23456;
  const struct value_type * D.23454;
  const struct ImVector * D.23453;
  bool iftmp.95;
  bool retval.94;
  const struct ImVector * D.23447;
  bool iftmp.95_1;
  void * _2;
  const struct ImVector * _4;
  struct value_type * _8;
  const struct ImVector * _10;
  const struct value_type * _12;
  unsigned int _13;
  bool iftmp.95_14;
  bool iftmp.95_15;
  bool retval.94_16;
  void * _17;
  void * _18;

  <bb 2>:
  _4 = &this_3(D)->Data;
  _8 = LowerBound (_4, key_6(D));
  it_9 = _8;
  _10 = &this_3(D)->Data;
  _12 = ImVector<ImGuiStorage::Pair>::end (_10);
  if (_12 == it_9)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _13 = it_9->key;
  if (_13 != key_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.95_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.95_14 = 0;

  <bb 6>:
  # iftmp.95_1 = PHI <iftmp.95_15(4), iftmp.95_14(5)>
  retval.94_16 = iftmp.95_1;
  if (retval.94_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _17 = 0B;
  goto <bb 9> (<L6>);

  <bb 8>:
  _18 = it_9->D.4548.val_p;

  # _2 = PHI <_17(7), _18(8)>
<L6>:
  return _2;

}



;; Function int* ImGuiStorage::GetIntRef(ImGuiID, int) (_ZN12ImGuiStorage9GetIntRefEji, funcdef_no=604, decl_uid=4725, cgraph_uid=503, symbol_order=509)

int* ImGuiStorage::GetIntRef(ImGuiID, int) (struct ImGuiStorage * const this, ImGuiID key, int default_val)
{
  struct value_type * D.23479;
  struct value_type * D.23478;
  struct value_type * it;
  int * D.23476;
  struct ImVector * D.23474;
  struct Pair D.15627;
  unsigned int D.23471;
  struct value_type * D.23469;
  struct ImVector * D.23468;
  bool iftmp.97;
  bool retval.96;
  struct ImVector * D.23462;
  bool iftmp.97_2;
  struct ImVector * _5;
  struct value_type * _9;
  struct ImVector * _11;
  struct value_type * _13;
  unsigned int _14;
  bool iftmp.97_15;
  bool iftmp.97_16;
  bool retval.96_17;
  struct ImVector * _20;
  struct value_type * _22;
  int * _26;

  <bb 2>:
  _5 = &this_4(D)->Data;
  _9 = LowerBound (_5, key_7(D));
  it_10 = _9;
  _11 = &this_4(D)->Data;
  _13 = ImVector<ImGuiStorage::Pair>::end (_11);
  if (_13 == it_10)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _14 = it_10->key;
  if (_14 != key_7(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.97_16 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.97_15 = 0;

  <bb 6>:
  # iftmp.97_2 = PHI <iftmp.97_16(4), iftmp.97_15(5)>
  retval.96_17 = iftmp.97_2;
  if (retval.96_17 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiStorage::Pair::Pair (&D.15627, key_7(D), default_val_18(D));
  _20 = &this_4(D)->Data;
  _22 = ImVector<ImGuiStorage::Pair>::insert (_20, it_10, &D.15627);
  it_23 = _22;
  D.15627 ={v} {CLOBBER};

  <bb 8>:
  # it_1 = PHI <it_10(6), it_23(7)>
  _26 = &it_1->D.4548.val_i;

<L7>:
  return _26;

}



;; Function bool* ImGuiStorage::GetBoolRef(ImGuiID, bool) (_ZN12ImGuiStorage10GetBoolRefEjb, funcdef_no=605, decl_uid=4729, cgraph_uid=504, symbol_order=510)

bool* ImGuiStorage::GetBoolRef(ImGuiID, bool) (struct ImGuiStorage * const this, ImGuiID key, bool default_val)
{
  bool * D.23570;
  int iftmp.106;
  bool * D.23564;
  int iftmp.106_1;
  int iftmp.106_3;
  int iftmp.106_4;
  bool * _9;
  bool * _10;

  <bb 2>:
  if (default_val_2(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.106_3 = 1;
  goto <bb 5>;

  <bb 4>:
  iftmp.106_4 = 0;

  <bb 5>:
  # iftmp.106_1 = PHI <iftmp.106_3(3), iftmp.106_4(4)>
  _9 = ImGuiStorage::GetIntRef (this_6(D), key_7(D), iftmp.106_1);
  _10 = _9;

<L3>:
  return _10;

}



;; Function float* ImGuiStorage::GetFloatRef(ImGuiID, float) (_ZN12ImGuiStorage11GetFloatRefEjf, funcdef_no=606, decl_uid=4733, cgraph_uid=505, symbol_order=511)

float* ImGuiStorage::GetFloatRef(ImGuiID, float) (struct ImGuiStorage * const this, ImGuiID key, float default_val)
{
  struct value_type * D.23588;
  struct value_type * D.23587;
  struct value_type * it;
  float * D.23585;
  struct ImVector * D.23583;
  struct Pair D.15648;
  unsigned int D.23580;
  struct value_type * D.23578;
  struct ImVector * D.23577;
  bool iftmp.108;
  bool retval.107;
  struct ImVector * D.23571;
  bool iftmp.108_2;
  struct ImVector * _5;
  struct value_type * _9;
  struct ImVector * _11;
  struct value_type * _13;
  unsigned int _14;
  bool iftmp.108_15;
  bool iftmp.108_16;
  bool retval.107_17;
  struct ImVector * _20;
  struct value_type * _22;
  float * _26;

  <bb 2>:
  _5 = &this_4(D)->Data;
  _9 = LowerBound (_5, key_7(D));
  it_10 = _9;
  _11 = &this_4(D)->Data;
  _13 = ImVector<ImGuiStorage::Pair>::end (_11);
  if (_13 == it_10)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _14 = it_10->key;
  if (_14 != key_7(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.108_16 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.108_15 = 0;

  <bb 6>:
  # iftmp.108_2 = PHI <iftmp.108_16(4), iftmp.108_15(5)>
  retval.107_17 = iftmp.108_2;
  if (retval.107_17 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiStorage::Pair::Pair (&D.15648, key_7(D), default_val_18(D));
  _20 = &this_4(D)->Data;
  _22 = ImVector<ImGuiStorage::Pair>::insert (_20, it_10, &D.15648);
  it_23 = _22;
  D.15648 ={v} {CLOBBER};

  <bb 8>:
  # it_1 = PHI <it_10(6), it_23(7)>
  _26 = &it_1->D.4548.val_f;

<L7>:
  return _26;

}



;; Function void** ImGuiStorage::GetVoidPtrRef(ImGuiID, void*) (_ZN12ImGuiStorage13GetVoidPtrRefEjPv, funcdef_no=607, decl_uid=4737, cgraph_uid=506, symbol_order=512)

void** ImGuiStorage::GetVoidPtrRef(ImGuiID, void*) (struct ImGuiStorage * const this, ImGuiID key, void * default_val)
{
  struct value_type * D.23607;
  struct value_type * D.23606;
  struct value_type * it;
  void * * D.23604;
  struct ImVector * D.23602;
  struct Pair D.15655;
  unsigned int D.23599;
  struct value_type * D.23597;
  struct ImVector * D.23596;
  bool iftmp.110;
  bool retval.109;
  struct ImVector * D.23590;
  bool iftmp.110_2;
  struct ImVector * _5;
  struct value_type * _9;
  struct ImVector * _11;
  struct value_type * _13;
  unsigned int _14;
  bool iftmp.110_15;
  bool iftmp.110_16;
  bool retval.109_17;
  struct ImVector * _20;
  struct value_type * _22;
  void * * _26;

  <bb 2>:
  _5 = &this_4(D)->Data;
  _9 = LowerBound (_5, key_7(D));
  it_10 = _9;
  _11 = &this_4(D)->Data;
  _13 = ImVector<ImGuiStorage::Pair>::end (_11);
  if (_13 == it_10)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _14 = it_10->key;
  if (_14 != key_7(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.110_16 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.110_15 = 0;

  <bb 6>:
  # iftmp.110_2 = PHI <iftmp.110_16(4), iftmp.110_15(5)>
  retval.109_17 = iftmp.110_2;
  if (retval.109_17 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiStorage::Pair::Pair (&D.15655, key_7(D), default_val_18(D));
  _20 = &this_4(D)->Data;
  _22 = ImVector<ImGuiStorage::Pair>::insert (_20, it_10, &D.15655);
  it_23 = _22;
  D.15655 ={v} {CLOBBER};

  <bb 8>:
  # it_1 = PHI <it_10(6), it_23(7)>
  _26 = &it_1->D.4548.val_p;

<L7>:
  return _26;

}



;; Function void ImGuiStorage::SetInt(ImGuiID, int) (_ZN12ImGuiStorage6SetIntEji, funcdef_no=608, decl_uid=4698, cgraph_uid=507, symbol_order=513)

void ImGuiStorage::SetInt(ImGuiID, int) (struct ImGuiStorage * const this, ImGuiID key, int val)
{
  struct value_type * D.23623;
  struct value_type * it;
  struct ImVector * D.23621;
  struct Pair D.15662;
  unsigned int D.23618;
  struct value_type * D.23616;
  struct ImVector * D.23615;
  bool iftmp.112;
  bool retval.111;
  struct ImVector * D.23609;
  bool iftmp.112_1;
  struct ImVector * _4;
  struct value_type * _8;
  struct ImVector * _10;
  struct value_type * _12;
  unsigned int _13;
  bool iftmp.112_14;
  bool iftmp.112_15;
  bool retval.111_16;
  struct ImVector * _19;

  <bb 2>:
  _4 = &this_3(D)->Data;
  _8 = LowerBound (_4, key_6(D));
  it_9 = _8;
  _10 = &this_3(D)->Data;
  _12 = ImVector<ImGuiStorage::Pair>::end (_10);
  if (_12 == it_9)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _13 = it_9->key;
  if (_13 != key_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.112_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.112_14 = 0;

  <bb 6>:
  # iftmp.112_1 = PHI <iftmp.112_15(4), iftmp.112_14(5)>
  retval.111_16 = iftmp.112_1;
  if (retval.111_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiStorage::Pair::Pair (&D.15662, key_6(D), val_17(D));
  _19 = &this_3(D)->Data;
  ImVector<ImGuiStorage::Pair>::insert (_19, it_9, &D.15662);
  D.15662 ={v} {CLOBBER};
  goto <bb 9> (<L6>);

  <bb 8>:
  it_9->D.4548.val_i = val_17(D);

<L6>:
  return;

}



;; Function void ImGuiStorage::SetBool(ImGuiID, bool) (_ZN12ImGuiStorage7SetBoolEjb, funcdef_no=609, decl_uid=4706, cgraph_uid=508, symbol_order=514)

void ImGuiStorage::SetBool(ImGuiID, bool) (struct ImGuiStorage * const this, ImGuiID key, bool val)
{
  int iftmp.113;
  int iftmp.113_1;
  int iftmp.113_3;
  int iftmp.113_4;

  <bb 2>:
  if (val_2(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.113_3 = 1;
  goto <bb 5>;

  <bb 4>:
  iftmp.113_4 = 0;

  <bb 5>:
  # iftmp.113_1 = PHI <iftmp.113_3(3), iftmp.113_4(4)>
  ImGuiStorage::SetInt (this_6(D), key_7(D), iftmp.113_1);
  return;

}



;; Function void ImGuiStorage::SetFloat(ImGuiID, float) (_ZN12ImGuiStorage8SetFloatEjf, funcdef_no=610, decl_uid=4714, cgraph_uid=509, symbol_order=515)

void ImGuiStorage::SetFloat(ImGuiID, float) (struct ImGuiStorage * const this, ImGuiID key, float val)
{
  struct value_type * D.23643;
  struct value_type * it;
  struct ImVector * D.23641;
  struct Pair D.15674;
  unsigned int D.23638;
  struct value_type * D.23636;
  struct ImVector * D.23635;
  bool iftmp.115;
  bool retval.114;
  struct ImVector * D.23629;
  bool iftmp.115_1;
  struct ImVector * _4;
  struct value_type * _8;
  struct ImVector * _10;
  struct value_type * _12;
  unsigned int _13;
  bool iftmp.115_14;
  bool iftmp.115_15;
  bool retval.114_16;
  struct ImVector * _19;

  <bb 2>:
  _4 = &this_3(D)->Data;
  _8 = LowerBound (_4, key_6(D));
  it_9 = _8;
  _10 = &this_3(D)->Data;
  _12 = ImVector<ImGuiStorage::Pair>::end (_10);
  if (_12 == it_9)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _13 = it_9->key;
  if (_13 != key_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.115_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.115_14 = 0;

  <bb 6>:
  # iftmp.115_1 = PHI <iftmp.115_15(4), iftmp.115_14(5)>
  retval.114_16 = iftmp.115_1;
  if (retval.114_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiStorage::Pair::Pair (&D.15674, key_6(D), val_17(D));
  _19 = &this_3(D)->Data;
  ImVector<ImGuiStorage::Pair>::insert (_19, it_9, &D.15674);
  D.15674 ={v} {CLOBBER};
  goto <bb 9> (<L6>);

  <bb 8>:
  it_9->D.4548.val_f = val_17(D);

<L6>:
  return;

}



;; Function void ImGuiStorage::SetVoidPtr(ImGuiID, void*) (_ZN12ImGuiStorage10SetVoidPtrEjPv, funcdef_no=611, decl_uid=4721, cgraph_uid=510, symbol_order=516)

void ImGuiStorage::SetVoidPtr(ImGuiID, void*) (struct ImGuiStorage * const this, ImGuiID key, void * val)
{
  struct value_type * D.23659;
  struct value_type * it;
  struct ImVector * D.23657;
  struct Pair D.15681;
  unsigned int D.23654;
  struct value_type * D.23652;
  struct ImVector * D.23651;
  bool iftmp.117;
  bool retval.116;
  struct ImVector * D.23645;
  bool iftmp.117_1;
  struct ImVector * _4;
  struct value_type * _8;
  struct ImVector * _10;
  struct value_type * _12;
  unsigned int _13;
  bool iftmp.117_14;
  bool iftmp.117_15;
  bool retval.116_16;
  struct ImVector * _19;

  <bb 2>:
  _4 = &this_3(D)->Data;
  _8 = LowerBound (_4, key_6(D));
  it_9 = _8;
  _10 = &this_3(D)->Data;
  _12 = ImVector<ImGuiStorage::Pair>::end (_10);
  if (_12 == it_9)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _13 = it_9->key;
  if (_13 != key_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.117_15 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.117_14 = 0;

  <bb 6>:
  # iftmp.117_1 = PHI <iftmp.117_15(4), iftmp.117_14(5)>
  retval.116_16 = iftmp.117_1;
  if (retval.116_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiStorage::Pair::Pair (&D.15681, key_6(D), val_17(D));
  _19 = &this_3(D)->Data;
  ImVector<ImGuiStorage::Pair>::insert (_19, it_9, &D.15681);
  D.15681 ={v} {CLOBBER};
  goto <bb 9> (<L6>);

  <bb 8>:
  it_9->D.4548.val_p = val_17(D);

<L6>:
  return;

}



;; Function void ImGuiStorage::SetAllInt(int) (_ZN12ImGuiStorage9SetAllIntEi, funcdef_no=612, decl_uid=4740, cgraph_uid=511, symbol_order=517)

void ImGuiStorage::SetAllInt(int) (struct ImGuiStorage * const this, int v)
{
  int i;
  struct value_type & D.23665;
  struct ImVector * D.23664;
  int D.23662;
  int _6;
  struct ImVector * _7;
  struct value_type & _9;

  <bb 2>:
  i_3 = 0;

  <bb 3>:
  # i_1 = PHI <i_3(2), i_12(4)>
  _6 = this_5(D)->Data.Size;
  if (_6 <= i_1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _7 = &this_5(D)->Data;
  _9 = ImVector<ImGuiStorage::Pair>::operator[] (_7, i_1);
  _9->D.4548.val_i = v_10(D);
  i_12 = i_1 + 1;
  goto <bb 3>;

  <bb 5>:
  return;

}



;; Function ImGuiTextFilter::ImGuiTextFilter(const char*) (_ZN15ImGuiTextFilterC2EPKc, funcdef_no=614, decl_uid=4365, cgraph_uid=513, symbol_order=519)

ImGuiTextFilter::ImGuiTextFilter(const char*) (struct ImGuiTextFilter * const this, const char * default_filter)
{
  void * D.46259;
  struct ImVector * D.23680;
  char[256] * D.23678;
  struct ImVector * D.23675;
  struct ImVector * _5;
  char[256] * _8;
  struct ImVector * _11;

  <bb 2>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  _5 = &this_3(D)->Filters;
  ImVector<ImGuiTextFilter::TextRange>::ImVector (_5);
  if (default_filter_7(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = &this_3(D)->InputBuf;
  ImStrncpy (_8, default_filter_7(D), 256);
  ImGuiTextFilter::Build (this_3(D));

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  this_3(D)->InputBuf[0] = 0;
  this_3(D)->CountGrep = 0;

  <bb 6>:
  return;

<L3>:
  _11 = &this_3(D)->Filters;
  ImVector<ImGuiTextFilter::TextRange>::~ImVector (_11);
  _15 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_15);

}



;; Function bool ImGuiTextFilter::Draw(const char*, float) (_ZN15ImGuiTextFilter4DrawEPKcf, funcdef_no=616, decl_uid=4350, cgraph_uid=515, symbol_order=521)

bool ImGuiTextFilter::Draw(const char*, float) (struct ImGuiTextFilter * const this, const char * label, float width)
{
  bool D.23700;
  bool value_changed;
  bool D.23698;
  char[256] * D.23691;
  char[256] * _8;
  bool _11;
  bool _15;

  <bb 2>:
  if (width_4(D) != 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::PushItemWidth (width_4(D));

  <bb 4>:
  _8 = &this_7(D)->InputBuf;
  _11 = ImGui::InputText (label_9(D), _8, 256, 0, 0B, 0B);
  value_changed_12 = _11;
  if (width_4(D) != 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::PopItemWidth ();

  <bb 6>:
  if (value_changed_12 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGuiTextFilter::Build (this_7(D));

  <bb 8>:
  _15 = value_changed_12;

<L9>:
  return _15;

}



;; Function void ImGuiTextFilter::TextRange::split(char, ImVector<ImGuiTextFilter::TextRange>&) (_ZN15ImGuiTextFilter9TextRange5splitEcR8ImVectorIS0_E, funcdef_no=617, decl_uid=4225, cgraph_uid=516, symbol_order=522)

void ImGuiTextFilter::TextRange::split(char, ImVector<ImGuiTextFilter::TextRange>&) (struct TextRange * const this, char separator, struct ImVector & out)
{
  const char * we;
  const char * wb;
  struct TextRange D.15754;
  struct TextRange D.15744;
  char D.23704;
  const char * D.23702;
  const char * _13;
  char _14;

  <bb 2>:
  ImVector<ImGuiTextFilter::TextRange>::resize (out_8(D), 0);
  wb_11 = this_10(D)->b;
  we_12 = wb_11;

  <bb 3>:
  # wb_1 = PHI <wb_11(2), wb_2(6)>
  # we_3 = PHI <we_12(2), we_21(6)>
  _13 = this_10(D)->e;
  if (_13 <= we_3)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _14 = *we_3;
  if (_14 == separator_15(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGuiTextFilter::TextRange::TextRange (&D.15744, wb_1, we_3);
  ImVector<ImGuiTextFilter::TextRange>::push_back (out_8(D), &D.15744);
  D.15744 ={v} {CLOBBER};
  wb_19 = we_3 + 1;

  <bb 6>:
  # wb_2 = PHI <wb_1(4), wb_19(5)>
  we_21 = we_3 + 1;
  goto <bb 3>;

  <bb 7>:
  if (wb_1 != we_3)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  ImGuiTextFilter::TextRange::TextRange (&D.15754, wb_1, we_3);
  ImVector<ImGuiTextFilter::TextRange>::push_back (out_8(D), &D.15754);
  D.15754 ={v} {CLOBBER};

  <bb 9>:
  return;

}



;; Function void ImGuiTextFilter::Build() (_ZN15ImGuiTextFilter5BuildEv, funcdef_no=618, decl_uid=4356, cgraph_uid=517, symbol_order=523)

void ImGuiTextFilter::Build() (struct ImGuiTextFilter * const this)
{
  int i;
  struct TextRange input_range;
  int D.23788;
  int D.23787;
  char D.23784;
  struct value_type & D.23783;
  struct ImVector * D.23782;
  bool retval.121;
  struct value_type & D.23778;
  struct ImVector * D.23777;
  bool retval.120;
  struct value_type & D.23775;
  struct ImVector * D.23774;
  int D.23772;
  struct ImVector * D.23770;
  char[256] * D.23769;
  const char * D.23768;
  long unsigned int D.23767;
  char[256] * D.23766;
  char[256] * D.23765;
  struct ImVector * D.23764;
  struct ImVector * _6;
  char[256] * _9;
  char[256] * _10;
  long unsigned int _11;
  const char * _12;
  char[256] * _13;
  struct ImVector * _15;
  int _19;
  struct ImVector * _20;
  struct value_type & _22;
  struct ImVector * _24;
  struct value_type & _26;
  bool retval.120_28;
  struct ImVector * _29;
  struct value_type & _31;
  char _33;
  bool retval.121_34;
  int _35;
  int _36;

  <bb 2>:
  _6 = &this_5(D)->Filters;
  ImVector<ImGuiTextFilter::TextRange>::resize (_6, 0);
  _9 = &this_5(D)->InputBuf;
  _10 = &this_5(D)->InputBuf;
  _11 = strlen (_10);
  _12 = _9 + _11;
  _13 = &this_5(D)->InputBuf;
  ImGuiTextFilter::TextRange::TextRange (&input_range, _13, _12);
  _15 = &this_5(D)->Filters;
  ImGuiTextFilter::TextRange::split (&input_range, 44, _15);
  this_5(D)->CountGrep = 0;
  i_18 = 0;

  <bb 3>:
  # i_1 = PHI <i_18(2), i_38(8)>
  _19 = this_5(D)->Filters.Size;
  if (_19 == i_1)
    goto <bb 9>;
  else
    goto <bb 4>;

  <bb 4>:
  _20 = &this_5(D)->Filters;
  _22 = ImVector<ImGuiTextFilter::TextRange>::operator[] (_20, i_1);
  ImGuiTextFilter::TextRange::trim_blanks (_22);
  _24 = &this_5(D)->Filters;
  _26 = ImVector<ImGuiTextFilter::TextRange>::operator[] (_24, i_1);
  retval.120_28 = ImGuiTextFilter::TextRange::empty (_26);
  if (retval.120_28 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 8>;

  <bb 6>:
  _29 = &this_5(D)->Filters;
  _31 = ImVector<ImGuiTextFilter::TextRange>::operator[] (_29, i_1);
  _33 = ImGuiTextFilter::TextRange::front (_31);
  retval.121_34 = _33 != 45;
  if (retval.121_34 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _35 = this_5(D)->CountGrep;
  _36 = _35 + 1;
  this_5(D)->CountGrep = _36;

  <bb 8>:
  i_38 = i_1 + 1;
  goto <bb 3>;

  <bb 9>:
  input_range ={v} {CLOBBER};
  return;

}



;; Function bool ImGuiTextFilter::PassFilter(const char*, const char*) const (_ZNK15ImGuiTextFilter10PassFilterEPKcS1_, funcdef_no=619, decl_uid=4354, cgraph_uid=518, symbol_order=524)

bool ImGuiTextFilter::PassFilter(const char*, const char*) const (const struct ImGuiTextFilter * const this, const char * text, const char * text_end)
{
  const struct TextRange & f;
  int i;
  int D.23880;
  const char * D.23877;
  const char * D.23876;
  const char * D.23875;
  bool retval.131;
  const char * D.23870;
  const char * D.23869;
  const char * D.23868;
  const char * D.23867;
  bool retval.130;
  char D.23863;
  bool retval.129;
  bool retval.128;
  const struct ImVector * D.23858;
  int D.23856;
  bool D.23851;
  const struct ImVector * D.23848;
  bool retval.127;
  bool _3;
  const struct ImVector * _8;
  bool retval.127_11;
  bool _12;
  int _16;
  const struct ImVector * _17;
  bool retval.128_21;
  char _24;
  bool retval.129_25;
  const char * _27;
  const char * _29;
  const char * _32;
  bool retval.131_33;
  bool _34;
  const char * _36;
  const char * _38;
  const char * _39;
  const char * _41;
  bool retval.130_42;
  bool _43;
  int _44;
  bool _45;
  bool _46;

  <bb 2>:
  _8 = &this_7(D)->Filters;
  retval.127_11 = ImVector<ImGuiTextFilter::TextRange>::empty (_8);
  if (retval.127_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = 1;
  goto <bb 19> (<L20>);

  <bb 4>:
  if (text_13(D) == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  text_14 = "";

  <bb 6>:
  # text_1 = PHI <text_13(D)(4), text_14(5)>
  i_15 = 0;

  <bb 7>:
  # i_2 = PHI <i_15(6), i_22(15)>
  _16 = this_7(D)->Filters.Size;
  if (_16 == i_2)
    goto <bb 16>;
  else
    goto <bb 8>;

  <bb 8>:
  _17 = &this_7(D)->Filters;
  f_19 = ImVector<ImGuiTextFilter::TextRange>::operator[] (_17, i_2);
  retval.128_21 = ImGuiTextFilter::TextRange::empty (f_19);
  if (retval.128_21 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  goto <bb 15>;

  <bb 10>:
  _24 = ImGuiTextFilter::TextRange::front (f_19);
  retval.129_25 = _24 == 45;
  if (retval.129_25 != 0)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  _36 = ImGuiTextFilter::TextRange::end (f_19);
  _38 = ImGuiTextFilter::TextRange::begin (f_19);
  _39 = _38 + 1;
  _41 = ImStristr (text_1, text_end_30(D), _39, _36);
  retval.130_42 = _41 != 0B;
  if (retval.130_42 != 0)
    goto <bb 12>;
  else
    goto <bb 15>;

  <bb 12>:
  _43 = 0;
  goto <bb 19> (<L20>);

  <bb 13>:
  _27 = ImGuiTextFilter::TextRange::end (f_19);
  _29 = ImGuiTextFilter::TextRange::begin (f_19);
  _32 = ImStristr (text_1, text_end_30(D), _29, _27);
  retval.131_33 = _32 != 0B;
  if (retval.131_33 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _34 = 1;
  goto <bb 19> (<L20>);

  <bb 15>:
  i_22 = i_2 + 1;
  goto <bb 7>;

  <bb 16>:
  _44 = this_7(D)->CountGrep;
  if (_44 == 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _45 = 1;
  goto <bb 19> (<L20>);

  <bb 18>:
  _46 = 0;

  # _3 = PHI <_12(3), _43(12), _34(14), _45(17), _46(18)>
<L20>:
  return _3;

}



;; Function void ImGuiTextBuffer::appendfv(const char*, __va_list_tag*) (_ZN15ImGuiTextBuffer8appendfvEPKcP13__va_list_tag, funcdef_no=620, decl_uid=4518, cgraph_uid=519, symbol_order=525)

void ImGuiTextBuffer::appendfv(const char*, __va_list_tag*) (struct ImGuiTextBuffer * const this, const char * fmt, struct  * args)
{
  int double_capacity;
  const int needed_sz;
  const int write_off;
  int len;
  struct  args_copy[1];
  value_type & D.23921;
  struct ImVector * D.23920;
  int D.23919;
  long unsigned int D.23918;
  long unsigned int D.23917;
  struct ImVector * D.23916;
  struct ImVector * D.23914;
  int * double_capacity.135;
  int double_capacity.134;
  int iftmp.133;
  int double_capacity.132;
  int D.23906;
  int D.23903;
  int D.23902;
  int iftmp.133_1;
  int _14;
  int _15;
  int _16;
  int double_capacity.132_17;
  int double_capacity.134_19;
  int * double_capacity.135_20;
  int iftmp.133_21;
  int iftmp.133_22;
  struct ImVector * _23;
  struct ImVector * _27;
  long unsigned int _29;
  long unsigned int _30;
  int _31;
  struct ImVector * _32;
  value_type & _34;

  <bb 2>:
  __builtin_va_copy (&args_copy, args_6(D));
  len_10 = ImFormatStringV (0B, 0, fmt_8(D), args_6(D));
  if (len_10 <= 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  args_copy ={v} {CLOBBER};
  goto <bb 10> (<L10>);

  <bb 4>:
  write_off_12 = this_11(D)->Buf.Size;
  needed_sz_13 = write_off_12 + len_10;
  _14 = write_off_12 + len_10;
  _15 = this_11(D)->Buf.Capacity;
  if (_14 >= _15)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:
  _16 = this_11(D)->Buf.Capacity;
  double_capacity.132_17 = _16 * 2;
  double_capacity = double_capacity.132_17;
  double_capacity.134_19 = double_capacity;
  if (needed_sz_13 <= double_capacity.134_19)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  double_capacity.135_20 = &double_capacity;
  iftmp.133_21 = MEM[(const int &)double_capacity.135_20];
  goto <bb 8>;

  <bb 7>:
  iftmp.133_22 = needed_sz_13;

  <bb 8>:
  # iftmp.133_1 = PHI <iftmp.133_21(6), iftmp.133_22(7)>
  _23 = &this_11(D)->Buf;
  ImVector<char>::reserve (_23, iftmp.133_1);
  double_capacity ={v} {CLOBBER};

  <bb 9>:
  _27 = &this_11(D)->Buf;
  ImVector<char>::resize (_27, needed_sz_13);
  _29 = (long unsigned int) len_10;
  _30 = _29 + 1;
  _31 = write_off_12 + -1;
  _32 = &this_11(D)->Buf;
  _34 = ImVector<char>::operator[] (_32, _31);
  ImFormatStringV (_34, _30, fmt_8(D), &args_copy);
  args_copy ={v} {CLOBBER};

<L10>:
  return;

}



;; Function void ImGuiTextBuffer::appendf(const char*, ...) (_ZN15ImGuiTextBuffer7appendfEPKcz, funcdef_no=621, decl_uid=4514, cgraph_uid=520, symbol_order=526)

void ImGuiTextBuffer::appendf(const char*, ...) (struct ImGuiTextBuffer * const this, const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGuiTextBuffer::appendfv (this_3(D), fmt_4(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function ImGuiMenuColumns::ImGuiMenuColumns() (_ZN16ImGuiMenuColumnsC2Ev, funcdef_no=623, decl_uid=11098, cgraph_uid=522, symbol_order=528)

ImGuiMenuColumns::ImGuiMenuColumns() (struct ImGuiMenuColumns * const this)
{
  float[4] * D.23972;
  float[4] * D.23971;
  float D.23970;
  float D.23969;
  float _6;
  float _8;
  float[4] * _10;
  float[4] * _12;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Count = 0;
  this_2(D)->NextWidth = 0.0;
  _6 = this_2(D)->NextWidth;
  this_2(D)->Width = _6;
  _8 = this_2(D)->Width;
  this_2(D)->Spacing = _8;
  _10 = &this_2(D)->Pos;
  memset (_10, 0, 16);
  _12 = &this_2(D)->NextWidths;
  memset (_12, 0, 16);
  return;

}



;; Function void ImGuiMenuColumns::Update(int, float, bool) (_ZN16ImGuiMenuColumns6UpdateEifb, funcdef_no=625, decl_uid=11086, cgraph_uid=524, symbol_order=530)

void ImGuiMenuColumns::Update(int, float, bool) (struct ImGuiMenuColumns * const this, int count, float spacing, bool clear)
{
  int i;
  static const char __PRETTY_FUNCTION__[48] = "void ImGuiMenuColumns::Update(int, float, bool)";
  float D.23999;
  float D.23998;
  float D.23997;
  float D.23996;
  int D.23995;
  float D.23994;
  float D.23992;
  float D.23991;
  float D.23990;
  float D.23987;
  int D.23983;
  float[4] * D.23980;
  float D.23977;
  int D.23973;
  int _7;
  float _11;
  float[4] * _16;
  int _19;
  float _20;
  float _21;
  float _22;
  float _23;
  float _25;
  int _26;
  float _27;
  float _29;
  float _30;
  float _31;

  <bb 2>:
  _7 = this_6(D)->Count;
  if (_7 <= 4)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Count <= ((int)(sizeof(Pos)/sizeof(*Pos)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 1801, &__PRETTY_FUNCTION__);

  <bb 4>:
  this_6(D)->Count = count_8(D);
  this_6(D)->NextWidth = 0.0;
  _11 = this_6(D)->NextWidth;
  this_6(D)->Width = _11;
  this_6(D)->Spacing = spacing_13(D);
  if (clear_15(D) != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _16 = &this_6(D)->NextWidths;
  memset (_16, 0, 16);

  <bb 6>:
  i_18 = 0;

  <bb 7>:
  # i_1 = PHI <i_18(6), i_34(11)>
  _19 = this_6(D)->Count;
  if (_19 <= i_1)
    goto <bb 12>;
  else
    goto <bb 8>;

  <bb 8>:
  if (i_1 > 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _20 = this_6(D)->NextWidths[i_1];
  if (_20 > 0.0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _21 = this_6(D)->Width;
  _22 = this_6(D)->Spacing;
  _23 = _21 + _22;
  this_6(D)->Width = _23;

  <bb 11>:
  _25 = this_6(D)->Width;
  _26 = (int) _25;
  _27 = (float) _26;
  this_6(D)->Pos[i_1] = _27;
  _29 = this_6(D)->Width;
  _30 = this_6(D)->NextWidths[i_1];
  _31 = _29 + _30;
  this_6(D)->Width = _31;
  this_6(D)->NextWidths[i_1] = 0.0;
  i_34 = i_1 + 1;
  goto <bb 7>;

  <bb 12>:
  return;

}



;; Function float ImGuiMenuColumns::DeclColumns(float, float, float) (_ZN16ImGuiMenuColumns11DeclColumnsEfff, funcdef_no=626, decl_uid=11091, cgraph_uid=525, symbol_order=531)

float ImGuiMenuColumns::DeclColumns(float, float, float) (struct ImGuiMenuColumns * const this, float w0, float w1, float w2)
{
  int i;
  float D.24020;
  float D.24019;
  float D.24018;
  float D.24017;
  float D.24016;
  float D.24014;
  float iftmp.138;
  float D.24009;
  float D.24008;
  float D.24005;
  float D.24004;
  float D.24003;
  float D.24002;
  float D.24001;
  float D.24000;
  float iftmp.138_2;
  float _7;
  float _10;
  float _12;
  float _15;
  float _17;
  float _20;
  float _23;
  float _24;
  float _25;
  float iftmp.138_26;
  float iftmp.138_27;
  float _28;
  float _29;
  float _32;
  float _33;
  float _35;

  <bb 2>:
  this_5(D)->NextWidth = 0.0;
  _7 = this_5(D)->NextWidths[0];
  _10 = ImMax (_7, w0_8(D));
  this_5(D)->NextWidths[0] = _10;
  _12 = this_5(D)->NextWidths[1];
  _15 = ImMax (_12, w1_13(D));
  this_5(D)->NextWidths[1] = _15;
  _17 = this_5(D)->NextWidths[2];
  _20 = ImMax (_17, w2_18(D));
  this_5(D)->NextWidths[2] = _20;
  i_22 = 0;

  <bb 3>:
  # i_1 = PHI <i_22(2), i_31(8)>
  if (i_1 > 2)
    goto <bb 9>;
  else
    goto <bb 4>;

  <bb 4>:
  _23 = this_5(D)->NextWidth;
  _24 = this_5(D)->NextWidths[i_1];
  if (i_1 > 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _25 = this_5(D)->NextWidths[i_1];
  if (_25 > 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.138_26 = this_5(D)->Spacing;
  goto <bb 8>;

  <bb 7>:
  iftmp.138_27 = 0.0;

  <bb 8>:
  # iftmp.138_2 = PHI <iftmp.138_26(6), iftmp.138_27(7)>
  _28 = _24 + iftmp.138_2;
  _29 = _23 + _28;
  this_5(D)->NextWidth = _29;
  i_31 = i_1 + 1;
  goto <bb 3>;

  <bb 9>:
  _32 = this_5(D)->NextWidth;
  _33 = this_5(D)->Width;
  _35 = ImMax (_33, _32);

<L7>:
  return _35;

}



;; Function float ImGuiMenuColumns::CalcExtraSpace(float) (_ZN16ImGuiMenuColumns14CalcExtraSpaceEf, funcdef_no=627, decl_uid=11094, cgraph_uid=526, symbol_order=532)

float ImGuiMenuColumns::CalcExtraSpace(float) (struct ImGuiMenuColumns * const this, float avail_w)
{
  float D.24030;
  float D.24029;
  float D.24028;
  float _3;
  float _5;
  float _7;

  <bb 2>:
  _3 = this_2(D)->Width;
  _5 = avail_w_4(D) - _3;
  _7 = ImMax (0.0, _5);

<L0>:
  return _7;

}



;; Function void SetCursorPosYAndSetupDummyPrevLine(float, float) (_ZL34SetCursorPosYAndSetupDummyPrevLineff, funcdef_no=628, decl_uid=15836, cgraph_uid=527, symbol_order=533)

void SetCursorPosYAndSetupDummyPrevLine(float, float) (float pos_y, float line_height)
{
  struct ImGuiWindow * window;
  float D.24041;
  struct ImGuiColumnsSet * D.24040;
  struct ImGuiColumnsSet * D.24037;
  float D.24036;
  float D.24035;
  struct ImGuiContext * GImGui.140;
  float D.24033;
  float D.24032;
  float _7;
  float _9;
  struct ImGuiContext * GImGui.140_11;
  float _12;
  float _13;
  struct ImGuiColumnsSet * _15;
  struct ImGuiColumnsSet * _16;
  float _17;

  <bb 2>:
  ImGui::SetCursorPosY (pos_y_3(D));
  window_6 = ImGui::GetCurrentWindow ();
  _7 = window_6->DC.CursorPos.y;
  _9 = _7 - line_height_8(D);
  window_6->DC.CursorPosPrevLine.y = _9;
  GImGui.140_11 = GImGui;
  _12 = GImGui.140_11->Style.ItemSpacing.y;
  _13 = line_height_8(D) - _12;
  window_6->DC.PrevLineHeight = _13;
  _15 = window_6->DC.ColumnsSet;
  if (_15 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _16 = window_6->DC.ColumnsSet;
  _17 = window_6->DC.CursorPos.y;
  _16->LineMinY = _17;

  <bb 4>:
  return;

}



;; Function void ImGuiListClipper::Begin(int, float) (_ZN16ImGuiListClipper5BeginEif, funcdef_no=629, decl_uid=4986, cgraph_uid=528, symbol_order=534)

void ImGuiListClipper::Begin(int, float) (struct ImGuiListClipper * const this, int count, float items_height)
{
  float D.24064;
  float D.24063;
  float D.24062;
  float D.24061;
  int D.24060;
  float D.24059;
  float D.24058;
  int D.24055;
  int D.24054;
  float D.24053;
  int * D.24052;
  int * D.24051;
  float D.24048;
  int D.24047;
  float D.24046;
  float _5;
  int _14;
  float _16;
  int * _17;
  int * _18;
  float _19;
  int _20;
  int _22;
  float _23;
  float _24;
  int _25;
  float _26;
  float _27;
  float _28;
  float _29;

  <bb 2>:
  _5 = ImGui::GetCursorPosY ();
  this_6(D)->StartPosY = _5;
  this_6(D)->ItemsHeight = items_height_8(D);
  this_6(D)->ItemsCount = count_10(D);
  this_6(D)->StepNo = 0;
  this_6(D)->DisplayStart = -1;
  _14 = this_6(D)->DisplayStart;
  this_6(D)->DisplayEnd = _14;
  _16 = this_6(D)->ItemsHeight;
  if (_16 > 0.0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _17 = &this_6(D)->DisplayEnd;
  _18 = &this_6(D)->DisplayStart;
  _19 = this_6(D)->ItemsHeight;
  _20 = this_6(D)->ItemsCount;
  ImGui::CalcListClipping (_20, _19, _18, _17);
  _22 = this_6(D)->DisplayStart;
  if (_22 > 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _23 = this_6(D)->ItemsHeight;
  _24 = this_6(D)->StartPosY;
  _25 = this_6(D)->DisplayStart;
  _26 = (float) _25;
  _27 = this_6(D)->ItemsHeight;
  _28 = _26 * _27;
  _29 = _24 + _28;
  SetCursorPosYAndSetupDummyPrevLine (_29, _23);

  <bb 5>:
  this_6(D)->StepNo = 2;

  <bb 6>:
  return;

}



;; Function void ImGuiListClipper::End() (_ZN16ImGuiListClipper3EndEv, funcdef_no=630, decl_uid=4988, cgraph_uid=529, symbol_order=535)

void ImGuiListClipper::End() (struct ImGuiListClipper * const this)
{
  float D.24079;
  float D.24078;
  float D.24077;
  float D.24076;
  int D.24075;
  float D.24074;
  float D.24073;
  int D.24070;
  int D.24067;
  int _5;
  int _6;
  float _7;
  float _8;
  int _9;
  float _10;
  float _11;
  float _12;
  float _13;

  <bb 2>:
  _5 = this_4(D)->ItemsCount;
  if (_5 < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _6 = this_4(D)->ItemsCount;
  if (_6 != 2147483647)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _7 = this_4(D)->ItemsHeight;
  _8 = this_4(D)->StartPosY;
  _9 = this_4(D)->ItemsCount;
  _10 = (float) _9;
  _11 = this_4(D)->ItemsHeight;
  _12 = _10 * _11;
  _13 = _8 + _12;
  SetCursorPosYAndSetupDummyPrevLine (_13, _7);

  <bb 6>:
  this_4(D)->ItemsCount = -1;
  this_4(D)->StepNo = 3;

<L5>:
  return;

}



;; Function bool ImGuiListClipper::Step() (_ZN16ImGuiListClipper4StepEv, funcdef_no=631, decl_uid=4982, cgraph_uid=530, symbol_order=536)

bool ImGuiListClipper::Step() (struct ImGuiListClipper * const this)
{
  float items_height;
  static const char __PRETTY_FUNCTION__[30] = "bool ImGuiListClipper::Step()";
  int D.24124;
  int D.24122;
  int D.24120;
  int D.24115;
  int D.24114;
  int D.24113;
  int D.24112;
  int D.24111;
  int D.24110;
  int D.24109;
  float D.24105;
  float D.24104;
  int D.24101;
  int D.24098;
  float D.24097;
  int D.24094;
  bool D.24093;
  bool D.24090;
  struct ImGuiWindow * D.24089;
  int D.24087;
  bool iftmp.142;
  bool retval.141;
  bool iftmp.142_1;
  bool _2;
  int _9;
  struct ImGuiWindow * _11;
  bool _12;
  bool iftmp.142_13;
  bool iftmp.142_14;
  bool retval.141_15;
  bool _17;
  int _18;
  float _22;
  bool _25;
  int _26;
  int _27;
  bool _29;
  float _31;
  float _32;
  int _34;
  int _35;
  int _37;
  int _38;
  int _40;
  int _41;
  bool _44;
  int _46;
  int _47;
  int _48;
  bool _50;
  int _52;
  bool _54;

  <bb 2>:
  _9 = this_8(D)->ItemsCount;
  if (_9 == 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _11 = ImGui::GetCurrentWindowRead ();
  _12 = _11->SkipItems;
  if (_12 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.142_14 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.142_13 = 0;

  <bb 6>:
  # iftmp.142_1 = PHI <iftmp.142_14(4), iftmp.142_13(5)>
  retval.141_15 = iftmp.142_1;
  if (retval.141_15 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  this_8(D)->ItemsCount = -1;
  _17 = 0;
  goto <bb 25> (<L24>);

  <bb 8>:
  _18 = this_8(D)->StepNo;
  if (_18 == 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  this_8(D)->DisplayStart = 0;
  this_8(D)->DisplayEnd = 1;
  _22 = ImGui::GetCursorPosY ();
  this_8(D)->StartPosY = _22;
  this_8(D)->StepNo = 1;
  _25 = 1;
  goto <bb 25> (<L24>);

  <bb 10>:
  _26 = this_8(D)->StepNo;
  if (_26 == 1)
    goto <bb 11>;
  else
    goto <bb 16>;

  <bb 11>:
  _27 = this_8(D)->ItemsCount;
  if (_27 == 1)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  this_8(D)->ItemsCount = -1;
  _29 = 0;
  goto <bb 25> (<L24>);

  <bb 13>:
  _31 = ImGui::GetCursorPosY ();
  _32 = this_8(D)->StartPosY;
  items_height_33 = _31 - _32;
  if (items_height_33 > 0.0)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  __assert_fail ("items_height > 0.0f", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 1898, &__PRETTY_FUNCTION__);

  <bb 15>:
  _34 = this_8(D)->ItemsCount;
  _35 = _34 + -1;
  ImGuiListClipper::Begin (this_8(D), _35, items_height_33);
  _37 = this_8(D)->DisplayStart;
  _38 = _37 + 1;
  this_8(D)->DisplayStart = _38;
  _40 = this_8(D)->DisplayEnd;
  _41 = _40 + 1;
  this_8(D)->DisplayEnd = _41;
  this_8(D)->StepNo = 3;
  _44 = 1;
  goto <bb 25> (<L24>);

  <bb 16>:
  _46 = this_8(D)->StepNo;
  if (_46 == 2)
    goto <bb 17>;
  else
    goto <bb 22>;

  <bb 17>:
  _47 = this_8(D)->DisplayStart;
  if (_47 >= 0)
    goto <bb 18>;
  else
    goto <bb 20>;

  <bb 18>:
  _48 = this_8(D)->DisplayEnd;
  if (_48 >= 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  goto <bb 21>;

  <bb 20>:
  __assert_fail ("DisplayStart >= 0 && DisplayEnd >= 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 1907, &__PRETTY_FUNCTION__);

  <bb 21>:
  this_8(D)->StepNo = 3;
  _50 = 1;
  goto <bb 25> (<L24>);

  <bb 22>:
  _52 = this_8(D)->StepNo;
  if (_52 == 3)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  ImGuiListClipper::End (this_8(D));

  <bb 24>:
  _54 = 0;

  # _2 = PHI <_17(7), _25(9), _29(12), _44(15), _50(21), _54(24)>
<L24>:
  return _2;

}



;; Function ImGuiDrawContext::~ImGuiDrawContext() (_ZN16ImGuiDrawContextD2Ev, funcdef_no=634, decl_uid=15880, cgraph_uid=532, symbol_order=538)

ImGuiDrawContext::~ImGuiDrawContext() (struct ImGuiDrawContext * const this)
{
  struct ImVector * D.24368;
  struct ImVector * D.24367;
  struct ImVector * D.24366;
  struct ImVector * D.24365;
  struct ImVector * D.24364;
  struct ImVector * _2;
  struct ImVector * _5;
  struct ImVector * _7;
  struct ImVector * _9;
  struct ImVector * _11;

  <bb 2>:
  _2 = &this_1(D)->GroupStack;
  ImVector<ImGuiGroupData>::~ImVector (_2);
  _5 = &this_1(D)->TextWrapPosStack;
  ImVector<float>::~ImVector (_5);
  _7 = &this_1(D)->ItemWidthStack;
  ImVector<float>::~ImVector (_7);
  _9 = &this_1(D)->ItemFlagsStack;
  ImVector<int>::~ImVector (_9);
  _11 = &this_1(D)->ChildWindows;
  ImVector<ImGuiWindow*>::~ImVector (_11);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function ImGuiWindow::ImGuiWindow(ImGuiContext*, const char*) (_ZN11ImGuiWindowC2EP12ImGuiContextPKc, funcdef_no=636, decl_uid=13611, cgraph_uid=535, symbol_order=541)

Merging blocks 13 and 14
Merging blocks 13 and 15
Merging blocks 13 and 16
ImGuiWindow::ImGuiWindow(ImGuiContext*, const char*) (struct ImGuiWindow * const this, struct ImGuiContext * context, const char * name)
{
  void * D.46271;
  void * D.24193;
  unsigned int D.24192;
  char * D.24191;
  struct ImGuiDrawContext * D.24190;
  struct ImVector * D.24189;
  struct ImGuiStorage * D.24188;
  struct ImVector * D.24187;
  int D.24186;
  int D.24185;
  int D.24184;
  struct ImRect * D.24183;
  struct ImRect D.15939;
  unsigned int D.24182;
  char * D.24181;
  struct ImDrawList * D.24180;
  struct ImNewDummy D.24179;
  struct ImDrawListSharedData * D.24178;
  void * D.15938;
  void * D.15937;
  struct ImNewDummy D.24177;
  struct ImNewDummy D.15936;
  struct ImNewDummy D.15935;
  struct ImVec2 * D.24176;
  struct ImVec2 D.15934;
  int D.24175;
  int D.24174;
  int D.24173;
  bool D.24172;
  struct ImVec2 D.15933;
  bool D.24171;
  struct ImVec2 D.15932;
  struct ImVec2 D.15931;
  struct ImVec2 D.15930;
  unsigned int D.24170;
  struct ImVec2 D.15929;
  struct ImVec2 * D.24169;
  struct ImVec2 D.15928;
  struct ImVec2 * D.24168;
  struct ImVec2 D.15927;
  struct ImVec2 * D.24167;
  struct ImVec2 D.15926;
  struct ImVector * D.24166;
  ImGuiID * D.24165;
  unsigned int D.24164;
  char * D.24163;
  long int D.24157;
  struct ImRect * D.24156;
  struct ImRect * D.24155;
  struct ImRect * retval.143;
  struct ImVector * D.24154;
  struct ImGuiStorage * D.24153;
  struct ImGuiMenuColumns * D.24152;
  struct ImRect * D.24151;
  struct ImRect * D.24150;
  struct ImRect * D.24149;
  struct ImRect * D.24148;
  struct ImVector * D.24147;
  struct ImGuiDrawContext * D.24146;
  struct ImVec2 * D.24145;
  struct ImVec2 * D.24144;
  struct ImVec2 * D.24143;
  struct ImVec2 * D.24142;
  struct ImVec2 * D.24141;
  struct ImVec2 * D.24140;
  struct ImVec2 * D.24139;
  struct ImRect * D.24138;
  struct ImVec2 * D.24137;
  struct ImVec2 * D.24136;
  struct ImVec2 * D.24135;
  struct ImVec2 * D.24134;
  struct ImVec2 * D.24133;
  struct ImVec2 * D.24132;
  struct ImVec2 * D.24131;
  struct ImRect * _1;
  long int _2;
  struct ImVec2 * _10;
  struct ImVec2 * _12;
  struct ImVec2 * _14;
  struct ImVec2 * _16;
  struct ImVec2 * _18;
  struct ImVec2 * _20;
  struct ImVec2 * _22;
  struct ImRect * _24;
  struct ImVec2 * _26;
  struct ImVec2 * _28;
  struct ImVec2 * _30;
  struct ImVec2 * _32;
  struct ImVec2 * _34;
  struct ImVec2 * _36;
  struct ImVec2 * _38;
  struct ImGuiDrawContext * _40;
  struct ImVector * _42;
  struct ImRect * _44;
  struct ImRect * _46;
  struct ImRect * _48;
  struct ImRect * _50;
  struct ImGuiMenuColumns * _52;
  struct ImGuiStorage * _54;
  struct ImVector * _56;
  struct ImRect * _58;
  struct ImRect * _59;
  long int _60;
  struct ImRect * _62;
  long int _63;
  struct ImRect * retval.143_64;
  char * _67;
  char * _68;
  unsigned int _71;
  ImGuiID * _73;
  struct ImVector * _74;
  struct ImVec2 * _79;
  struct ImVec2 * _84;
  struct ImVec2 * _89;
  unsigned int _98;
  unsigned int _99;
  bool _112;
  bool _118;
  int _131;
  int _138;
  int _140;
  struct ImVec2 * _144;
  void * _152;
  void * _153;
  void * _155;
  struct ImDrawListSharedData * _157;
  struct ImDrawList * _162;
  char * _163;
  unsigned int _171;
  struct ImRect * _175;
  int _180;
  int _183;
  int _186;
  struct ImVector * _191;
  struct ImGuiStorage * _193;
  struct ImVector * _195;
  struct ImGuiDrawContext * _197;

  <bb 2>:
  MEM[(struct  &)this_8(D)] ={v} {CLOBBER};
  _10 = &this_8(D)->PosFloat;
  ImVec2::ImVec2 (_10);
  _12 = &this_8(D)->Pos;
  ImVec2::ImVec2 (_12);
  _14 = &this_8(D)->Size;
  ImVec2::ImVec2 (_14);
  _16 = &this_8(D)->SizeFull;
  ImVec2::ImVec2 (_16);
  _18 = &this_8(D)->SizeFullAtLastBegin;
  ImVec2::ImVec2 (_18);
  _20 = &this_8(D)->SizeContents;
  ImVec2::ImVec2 (_20);
  _22 = &this_8(D)->SizeContentsExplicit;
  ImVec2::ImVec2 (_22);
  _24 = &this_8(D)->ContentsRegionRect;
  ImRect::ImRect (_24);
  _26 = &this_8(D)->WindowPadding;
  ImVec2::ImVec2 (_26);
  _28 = &this_8(D)->Scroll;
  ImVec2::ImVec2 (_28);
  _30 = &this_8(D)->ScrollTarget;
  ImVec2::ImVec2 (_30);
  _32 = &this_8(D)->ScrollTargetCenterRatio;
  ImVec2::ImVec2 (_32);
  _34 = &this_8(D)->ScrollbarSizes;
  ImVec2::ImVec2 (_34);
  _36 = &this_8(D)->SetWindowPosVal;
  ImVec2::ImVec2 (_36);
  _38 = &this_8(D)->SetWindowPosPivot;
  ImVec2::ImVec2 (_38);
  _40 = &this_8(D)->DC;
  ImGuiDrawContext::ImGuiDrawContext (_40);
  _42 = &this_8(D)->IDStack;
  ImVector<unsigned int>::ImVector (_42);
  _44 = &this_8(D)->ClipRect;
  ImRect::ImRect (_44);
  _46 = &this_8(D)->WindowRectClipped;
  ImRect::ImRect (_46);
  _48 = &this_8(D)->InnerRect;
  ImRect::ImRect (_48);
  _50 = &this_8(D)->InnerClipRect;
  ImRect::ImRect (_50);
  _52 = &this_8(D)->MenuColumns;
  ImGuiMenuColumns::ImGuiMenuColumns (_52);
  _54 = &this_8(D)->StateStorage;
  ImGuiStorage::ImGuiStorage (_54);
  _56 = &this_8(D)->ColumnsStorage;
  ImVector<ImGuiColumnsSet>::ImVector (_56);
  _58 = &this_8(D)->NavRectRel;
  _59 = _58;
  _60 = 1;

  <bb 3>:
  # _1 = PHI <_59(2), _62(4)>
  # _2 = PHI <_60(2), _63(4)>
  if (_2 < 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  ImRect::ImRect (_1);
  _62 = _1 + 16;
  _63 = _2 + -1;
  goto <bb 3>;

  <bb 5>:
  retval.143_64 = _58;
  _67 = ImStrdup (name_65(D));

  <bb 6>:
  _68 = _67;
  this_8(D)->Name = _68;
  _71 = ImHash (name_65(D), 0, 0);
  this_8(D)->ID = _71;
  _73 = &this_8(D)->ID;
  _74 = &this_8(D)->IDStack;
  ImVector<unsigned int>::push_back (_74, _73);

  <bb 7>:
  this_8(D)->Flags = 0;
  ImVec2::ImVec2 (&D.15926, 0.0, 0.0);
  this_8(D)->Pos = D.15926;
  _79 = &this_8(D)->Pos;
  this_8(D)->PosFloat = MEM[(const struct ImVec2 &)_79];
  D.15926 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15927, 0.0, 0.0);
  this_8(D)->SizeFull = D.15927;
  _84 = &this_8(D)->SizeFull;
  this_8(D)->Size = MEM[(const struct ImVec2 &)_84];
  D.15927 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15928, 0.0, 0.0);
  this_8(D)->SizeContentsExplicit = D.15928;
  _89 = &this_8(D)->SizeContentsExplicit;
  this_8(D)->SizeContents = MEM[(const struct ImVec2 &)_89];
  D.15928 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15929, 0.0, 0.0);
  this_8(D)->WindowPadding = D.15929;
  D.15929 ={v} {CLOBBER};
  this_8(D)->WindowRounding = 0.0;
  this_8(D)->WindowBorderSize = 0.0;
  _98 = ImGuiWindow::GetID (this_8(D), "#MOVE", 0B);

  <bb 8>:
  _99 = _98;
  this_8(D)->MoveId = _99;
  this_8(D)->ChildId = 0;
  ImVec2::ImVec2 (&D.15930, 0.0, 0.0);
  this_8(D)->Scroll = D.15930;
  D.15930 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15931, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  this_8(D)->ScrollTarget = D.15931;
  D.15931 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.15932, 5.0e-1, 5.0e-1);
  this_8(D)->ScrollTargetCenterRatio = D.15932;
  D.15932 ={v} {CLOBBER};
  this_8(D)->ScrollbarY = 0;
  _112 = this_8(D)->ScrollbarY;
  this_8(D)->ScrollbarX = _112;
  ImVec2::ImVec2 (&D.15933, 0.0, 0.0);
  this_8(D)->ScrollbarSizes = D.15933;
  D.15933 ={v} {CLOBBER};
  this_8(D)->WasActive = 0;
  _118 = this_8(D)->WasActive;
  this_8(D)->Active = _118;
  this_8(D)->WriteAccessed = 0;
  this_8(D)->Collapsed = 0;
  this_8(D)->CollapseToggleWanted = 0;
  this_8(D)->SkipItems = 0;
  this_8(D)->Appearing = 0;
  this_8(D)->CloseButton = 0;
  this_8(D)->BeginOrderWithinParent = -1;
  this_8(D)->BeginOrderWithinContext = -1;
  this_8(D)->BeginCount = 0;
  this_8(D)->PopupId = 0;
  this_8(D)->AutoFitFramesY = -1;
  _131 = this_8(D)->AutoFitFramesY;
  this_8(D)->AutoFitFramesX = _131;
  this_8(D)->AutoFitOnlyGrows = 0;
  this_8(D)->AutoFitChildAxises = 0;
  this_8(D)->AutoPosLastDirection = -1;
  this_8(D)->HiddenFrames = 0;
  this_8(D)->SetWindowCollapsedAllowFlags = 15;
  _138 = this_8(D)->SetWindowCollapsedAllowFlags;
  this_8(D)->SetWindowSizeAllowFlags = _138;
  _140 = this_8(D)->SetWindowSizeAllowFlags;
  this_8(D)->SetWindowPosAllowFlags = _140;
  ImVec2::ImVec2 (&D.15934, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  this_8(D)->SetWindowPosPivot = D.15934;
  _144 = &this_8(D)->SetWindowPosPivot;
  this_8(D)->SetWindowPosVal = MEM[(const struct ImVec2 &)_144];
  D.15934 ={v} {CLOBBER};
  this_8(D)->LastFrameActive = -1;
  this_8(D)->ItemWidthDefault = 0.0;
  this_8(D)->FontWindowScale = 1.0e+0;
  D.15935 = D.24177;
  _152 = ImGui::MemAlloc (168);

  <bb 9>:
  _153 = _152;
  _155 = operator new (168, D.15935, _153);
  _157 = &context_156(D)->DrawListSharedData;
  ImDrawList::ImDrawList (_155, _157);

  <bb 10>:
  this_8(D)->DrawList = _155;
  D.15935 ={v} {CLOBBER};
  D.15936 ={v} {CLOBBER};
  _162 = this_8(D)->DrawList;
  _163 = this_8(D)->Name;
  _162->_OwnerName = _163;
  this_8(D)->ParentWindow = 0B;
  this_8(D)->RootWindow = 0B;
  this_8(D)->RootWindowForTitleBarHighlight = 0B;
  this_8(D)->RootWindowForTabbing = 0B;
  this_8(D)->RootWindowForNav = 0B;
  this_8(D)->NavLastIds[1] = 0;
  _171 = this_8(D)->NavLastIds[1];
  this_8(D)->NavLastIds[0] = _171;
  ImRect::ImRect (&D.15939);
  this_8(D)->NavRectRel[1] = D.15939;
  _175 = &this_8(D)->NavRectRel[1];
  this_8(D)->NavRectRel[0] = MEM[(const struct ImRect &)_175];
  D.15939 ={v} {CLOBBER};
  this_8(D)->NavLastChildNavWindow = 0B;
  this_8(D)->FocusIdxTabCounter = -1;
  _180 = this_8(D)->FocusIdxTabCounter;
  this_8(D)->FocusIdxAllCounter = _180;
  this_8(D)->FocusIdxTabRequestCurrent = 2147483647;
  _183 = this_8(D)->FocusIdxTabRequestCurrent;
  this_8(D)->FocusIdxAllRequestCurrent = _183;
  this_8(D)->FocusIdxTabRequestNext = 2147483647;
  _186 = this_8(D)->FocusIdxTabRequestNext;
  this_8(D)->FocusIdxAllRequestNext = _186;
  return;

<L3>:
  operator delete (_155, D.24179, _153);
  __builtin_eh_copy_values (14, 16);

<L4>:
  __builtin_eh_copy_values (4, 14);

<L6>:
  D.15935 ={v} {CLOBBER};
  D.15936 ={v} {CLOBBER};
  _191 = &this_8(D)->ColumnsStorage;
  ImVector<ImGuiColumnsSet>::~ImVector (_191);
  __builtin_eh_copy_values (3, 4);
  _193 = &this_8(D)->StateStorage;
  ImGuiStorage::~ImGuiStorage (_193);
  __builtin_eh_copy_values (2, 3);
  _195 = &this_8(D)->IDStack;
  ImVector<unsigned int>::~ImVector (_195);
  __builtin_eh_copy_values (1, 2);
  _197 = &this_8(D)->DC;
  ImGuiDrawContext::~ImGuiDrawContext (_197);
  _199 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_199);

}



;; Function ImGuiColumnsSet::~ImGuiColumnsSet() (_ZN15ImGuiColumnsSetD2Ev, funcdef_no=640, decl_uid=15957, cgraph_uid=538, symbol_order=544)

ImGuiColumnsSet::~ImGuiColumnsSet() (struct ImGuiColumnsSet * const this)
{
  struct ImVector * D.24428;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Columns;
  ImVector<ImGuiColumnData>::~ImVector (_2);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function ImGuiWindow::~ImGuiWindow() (_ZN11ImGuiWindowD2Ev, funcdef_no=642, decl_uid=13618, cgraph_uid=541, symbol_order=547)

ImGuiWindow::~ImGuiWindow() (struct ImGuiWindow * const this)
{
  int i;
  struct ImGuiDrawContext * D.24399;
  struct ImVector * D.24398;
  struct ImGuiStorage * D.24397;
  struct ImVector * D.24396;
  struct value_type & D.24395;
  struct ImVector * D.24394;
  int D.24392;
  char * * D.24390;
  struct ImDrawList * * D.24389;
  struct ImDrawList * * _4;
  char * * _7;
  int _10;
  struct ImVector * _11;
  struct value_type & _13;
  struct ImVector * _16;
  struct ImGuiStorage * _18;
  struct ImVector * _20;
  struct ImGuiDrawContext * _22;

  <bb 2>:
  _4 = &this_3(D)->DrawList;
  IM_DELETE<ImDrawList> (_4);
  _7 = &this_3(D)->Name;
  IM_DELETE<char> (_7);
  i_9 = 0;

  <bb 3>:
  # i_1 = PHI <i_9(2), i_15(4)>
  _10 = this_3(D)->ColumnsStorage.Size;
  if (_10 == i_1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _11 = &this_3(D)->ColumnsStorage;
  _13 = ImVector<ImGuiColumnsSet>::operator[] (_11, i_1);
  ImGuiColumnsSet::~ImGuiColumnsSet (_13);
  i_15 = i_1 + 1;
  goto <bb 3>;

  <bb 5>:
  _16 = &this_3(D)->ColumnsStorage;
  ImVector<ImGuiColumnsSet>::~ImVector (_16);
  _18 = &this_3(D)->StateStorage;
  ImGuiStorage::~ImGuiStorage (_18);
  _20 = &this_3(D)->IDStack;
  ImVector<unsigned int>::~ImVector (_20);
  _22 = &this_3(D)->DC;
  ImGuiDrawContext::~ImGuiDrawContext (_22);
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImGuiID ImGuiWindow::GetID(const char*, const char*) (_ZN11ImGuiWindow5GetIDEPKcS1_, funcdef_no=644, decl_uid=13583, cgraph_uid=543, symbol_order=549)

ImGuiID ImGuiWindow::GetID(const char*, const char*) (struct ImGuiWindow * const this, const char * str, const char * str_end)
{
  ImGuiID id;
  ImGuiID seed;
  ImGuiID D.24443;
  long int D.24441;
  long int str.148;
  long int str_end.147;
  int iftmp.146;
  value_type & D.24435;
  struct ImVector * D.24434;
  int iftmp.146_1;
  struct ImVector * _3;
  value_type & _6;
  long int str_end.147_9;
  long int str.148_11;
  long int _12;
  int iftmp.146_13;
  int iftmp.146_14;
  ImGuiID _18;

  <bb 2>:
  _3 = &this_2(D)->IDStack;
  _6 = ImVector<unsigned int>::back (_3);
  seed_7 = *_6;
  if (str_end_8(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  str_end.147_9 = (long int) str_end_8(D);
  str.148_11 = (long int) str_10(D);
  _12 = str_end.147_9 - str.148_11;
  iftmp.146_13 = (int) _12;
  goto <bb 5>;

  <bb 4>:
  iftmp.146_14 = 0;

  <bb 5>:
  # iftmp.146_1 = PHI <iftmp.146_13(3), iftmp.146_14(4)>
  id_16 = ImHash (str_10(D), iftmp.146_1, seed_7);
  ImGui::KeepAliveID (id_16);
  _18 = id_16;

<L3>:
  return _18;

}



;; Function ImGuiID ImGuiWindow::GetID(const void*) (_ZN11ImGuiWindow5GetIDEPKv, funcdef_no=645, decl_uid=13586, cgraph_uid=544, symbol_order=550)

ImGuiID ImGuiWindow::GetID(const void*) (struct ImGuiWindow * const this, const void * ptr)
{
  ImGuiID id;
  ImGuiID seed;
  ImGuiID D.24458;
  value_type & D.24457;
  struct ImVector * D.24456;
  struct ImVector * _2;
  value_type & _5;
  ImGuiID _10;

  <bb 2>:
  _2 = &this_1(D)->IDStack;
  _5 = ImVector<unsigned int>::back (_2);
  seed_6 = *_5;
  id_8 = ImHash (&ptr, 8, seed_6);
  ImGui::KeepAliveID (id_8);
  _10 = id_8;

<L0>:
  return _10;

}



;; Function ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char*, const char*) (_ZN11ImGuiWindow16GetIDNoKeepAliveEPKcS1_, funcdef_no=646, decl_uid=13590, cgraph_uid=545, symbol_order=551)

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char*, const char*) (struct ImGuiWindow * const this, const char * str, const char * str_end)
{
  ImGuiID seed;
  long int D.24468;
  long int str.151;
  long int str_end.150;
  int iftmp.149;
  ImGuiID D.24462;
  value_type & D.24461;
  struct ImVector * D.24460;
  int iftmp.149_1;
  struct ImVector * _3;
  value_type & _6;
  long int str_end.150_9;
  long int str.151_11;
  long int _12;
  int iftmp.149_13;
  int iftmp.149_14;
  ImGuiID _16;

  <bb 2>:
  _3 = &this_2(D)->IDStack;
  _6 = ImVector<unsigned int>::back (_3);
  seed_7 = *_6;
  if (str_end_8(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  str_end.150_9 = (long int) str_end_8(D);
  str.151_11 = (long int) str_10(D);
  _12 = str_end.150_9 - str.151_11;
  iftmp.149_13 = (int) _12;
  goto <bb 5>;

  <bb 4>:
  iftmp.149_14 = 0;

  <bb 5>:
  # iftmp.149_1 = PHI <iftmp.149_13(3), iftmp.149_14(4)>
  _16 = ImHash (str_10(D), iftmp.149_1, seed_7);

<L3>:
  return _16;

}



;; Function ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect&) (_ZN11ImGuiWindow18GetIDFromRectangleERK6ImRect, funcdef_no=647, decl_uid=13593, cgraph_uid=546, symbol_order=552)

ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect&) (struct ImGuiWindow * const this, const struct ImRect & r_abs)
{
  ImGuiID id;
  const int r_rel[4];
  ImGuiID seed;
  ImGuiID D.24489;
  int D.24488;
  float D.24487;
  float D.24486;
  float D.24485;
  int D.24484;
  float D.24483;
  float D.24482;
  float D.24481;
  int D.24480;
  float D.24479;
  float D.24478;
  float D.24477;
  int D.24476;
  float D.24475;
  float D.24474;
  float D.24473;
  value_type & D.24472;
  struct ImVector * D.24471;
  struct ImVector * _2;
  value_type & _5;
  float _8;
  float _9;
  float _10;
  int _11;
  float _13;
  float _14;
  float _15;
  int _16;
  float _18;
  float _19;
  float _20;
  int _21;
  float _23;
  float _24;
  float _25;
  int _26;
  ImGuiID _31;

  <bb 2>:
  _2 = &this_1(D)->IDStack;
  _5 = ImVector<unsigned int>::back (_2);
  seed_6 = *_5;
  _8 = r_abs_7(D)->Min.x;
  _9 = this_1(D)->Pos.x;
  _10 = _8 - _9;
  _11 = (int) _10;
  r_rel[0] = _11;
  _13 = r_abs_7(D)->Min.y;
  _14 = this_1(D)->Pos.y;
  _15 = _13 - _14;
  _16 = (int) _15;
  r_rel[1] = _16;
  _18 = r_abs_7(D)->Max.x;
  _19 = this_1(D)->Pos.x;
  _20 = _18 - _19;
  _21 = (int) _20;
  r_rel[2] = _21;
  _23 = r_abs_7(D)->Max.y;
  _24 = this_1(D)->Pos.y;
  _25 = _23 - _24;
  _26 = (int) _25;
  r_rel[3] = _26;
  id_29 = ImHash (&r_rel, 16, seed_6);
  ImGui::KeepAliveID (id_29);
  _31 = id_29;
  r_rel ={v} {CLOBBER};

<L1>:
  return _31;

}



;; Function void SetCurrentWindow(ImGuiWindow*) (_ZL16SetCurrentWindowP11ImGuiWindow, funcdef_no=648, decl_uid=15020, cgraph_uid=547, symbol_order=553)

void SetCurrentWindow(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  float D.24495;
  float D.24494;
  float _7;
  float _9;

  <bb 2>:
  g_3 = GImGui;
  g_3->CurrentWindow = window_4(D);
  if (window_4(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImGuiWindow::CalcFontSize (window_4(D));
  g_3->DrawListSharedData.FontSize = _7;
  _9 = g_3->DrawListSharedData.FontSize;
  g_3->FontSize = _9;

  <bb 4>:
  return;

}



;; Function void SetNavID(ImGuiID, int) (_ZL8SetNavIDji, funcdef_no=649, decl_uid=16008, cgraph_uid=548, symbol_order=554)

void SetNavID(ImGuiID, int) (ImGuiID id, int nav_layer)
{
  static const char __PRETTY_FUNCTION__[28] = "void SetNavID(ImGuiID, int)";
  struct ImGuiContext & g;
  struct ImGuiWindow * D.24511;
  struct ImGuiWindow * D.24502;
  struct ImGuiWindow * _3;
  struct ImGuiWindow * _8;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->NavWindow;
  if (_3 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.NavWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2034, &__PRETTY_FUNCTION__);

  <bb 4>:
  if (nav_layer_4(D) == 0)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 5>:
  if (nav_layer_4(D) == 1)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  __assert_fail ("nav_layer == 0 || nav_layer == 1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2035, &__PRETTY_FUNCTION__);

  <bb 7>:
  g_2->NavId = id_6(D);
  _8 = g_2->NavWindow;
  _8->NavLastIds[nav_layer_4(D)] = id_6(D);
  return;

}



;; Function void SetNavIDWithRectRel(ImGuiID, int, const ImRect&) (_ZL19SetNavIDWithRectReljiRK6ImRect, funcdef_no=650, decl_uid=16015, cgraph_uid=549, symbol_order=555)

void SetNavIDWithRectRel(ImGuiID, int, const ImRect&) (ImGuiID id, int nav_layer, const struct ImRect & rect_rel)
{
  struct ImGuiContext & g;
  struct ImGuiWindow * D.24512;
  struct ImGuiWindow * _6;

  <bb 2>:
  g_2 = GImGui;
  SetNavID (id_3(D), nav_layer_4(D));
  _6 = g_2->NavWindow;
  _6->NavRectRel[nav_layer_4(D)] = *rect_rel_7(D);
  g_2->NavMousePosDirty = 1;
  g_2->NavDisableHighlight = 0;
  g_2->NavDisableMouseHover = 1;
  return;

}



;; Function void ImGui::SetActiveID(ImGuiID, ImGuiWindow*) (_ZN5ImGui11SetActiveIDEjP11ImGuiWindow, funcdef_no=651, decl_uid=13762, cgraph_uid=550, symbol_order=556)

void ImGui::SetActiveID(ImGuiID, ImGuiWindow*) (ImGuiID id, struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  unsigned int D.24531;
  unsigned int D.24529;
  unsigned int D.24527;
  unsigned int D.24525;
  ImGuiInputSource iftmp.153;
  bool D.24515;
  bool D.24514;
  unsigned int D.24513;
  ImGuiInputSource iftmp.153_1;
  unsigned int _6;
  bool _8;
  bool _10;
  unsigned int _18;
  unsigned int _19;
  unsigned int _20;
  unsigned int _21;
  ImGuiInputSource iftmp.153_22;
  ImGuiInputSource iftmp.153_23;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->ActiveId;
  _8 = _6 != id_7(D);
  g_5->ActiveIdIsJustActivated = _8;
  _10 = g_5->ActiveIdIsJustActivated;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  g_5->ActiveIdTimer = 0.0;

  <bb 4>:
  g_5->ActiveId = id_7(D);
  g_5->ActiveIdAllowNavDirFlags = 0;
  g_5->ActiveIdAllowOverlap = 0;
  g_5->ActiveIdWindow = window_15(D);
  if (id_7(D) != 0)
    goto <bb 5>;
  else
    goto <bb 12>;

  <bb 5>:
  g_5->ActiveIdIsAlive = 1;
  _18 = g_5->NavActivateId;
  if (_18 == id_7(D))
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 6>:
  _19 = g_5->NavInputId;
  if (_19 == id_7(D))
    goto <bb 9>;
  else
    goto <bb 7>;

  <bb 7>:
  _20 = g_5->NavJustTabbedId;
  if (_20 == id_7(D))
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  _21 = g_5->NavJustMovedToId;
  if (_21 == id_7(D))
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.153_23 = 2;
  goto <bb 11>;

  <bb 10>:
  iftmp.153_22 = 1;

  <bb 11>:
  # iftmp.153_1 = PHI <iftmp.153_23(9), iftmp.153_22(10)>
  g_5->ActiveIdSource = iftmp.153_1;

  <bb 12>:
  return;

}



;; Function ImGuiID ImGui::GetActiveID() (_ZN5ImGui11GetActiveIDEv, funcdef_no=652, decl_uid=13763, cgraph_uid=551, symbol_order=557)

ImGuiID ImGui::GetActiveID() ()
{
  struct ImGuiContext & g;
  ImGuiID D.24533;
  ImGuiID _3;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->ActiveId;

<L0>:
  return _3;

}



;; Function void ImGui::SetFocusID(ImGuiID, ImGuiWindow*) (_ZN5ImGui10SetFocusIDEjP11ImGuiWindow, funcdef_no=653, decl_uid=13766, cgraph_uid=552, symbol_order=558)

void ImGui::SetFocusID(ImGuiID, ImGuiWindow*) (ImGuiID id, struct ImGuiWindow * window)
{
  const int nav_layer;
  static const char __PRETTY_FUNCTION__[46] = "void ImGui::SetFocusID(ImGuiID, ImGuiWindow*)";
  struct ImGuiContext & g;
  ImGuiInputSource D.24550;
  struct ImVec2 * D.24548;
  struct ImVec2 * D.24547;
  struct ImVec2 D.16033;
  struct ImVec2 * D.24546;
  struct ImVec2 * D.24545;
  struct ImVec2 D.16034;
  struct ImRect D.16035;
  unsigned int D.24542;
  struct ImGuiWindow * D.24538;
  struct ImGuiWindow * _9;
  unsigned int _15;
  struct ImVec2 * _16;
  struct ImVec2 * _17;
  struct ImVec2 * _19;
  struct ImVec2 * _20;
  ImGuiInputSource _27;

  <bb 2>:
  g_5 = GImGui;
  if (id_6(D) != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("id != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2076, &__PRETTY_FUNCTION__);

  <bb 4>:
  nav_layer_8 = window_7(D)->DC.NavLayerCurrent;
  _9 = g_5->NavWindow;
  if (_9 != window_7(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  g_5->NavInitRequest = 0;

  <bb 6>:
  g_5->NavId = id_6(D);
  g_5->NavWindow = window_7(D);
  g_5->NavLayer = nav_layer_8;
  window_7(D)->NavLastIds[nav_layer_8] = id_6(D);
  _15 = window_7(D)->DC.LastItemId;
  if (_15 == id_6(D))
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _16 = &window_7(D)->Pos;
  _17 = &window_7(D)->DC.LastItemRect.Max;
  D.16034 = operator- (_17, _16);
  _19 = &window_7(D)->Pos;
  _20 = &window_7(D)->DC.LastItemRect.Min;
  D.16033 = operator- (_20, _19);
  ImRect::ImRect (&D.16035, &D.16033, &D.16034);
  window_7(D)->NavRectRel[nav_layer_8] = D.16035;
  D.16035 ={v} {CLOBBER};
  D.16033 ={v} {CLOBBER};
  D.16034 ={v} {CLOBBER};

  <bb 8>:
  _27 = g_5->ActiveIdSource;
  if (_27 == 2)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  g_5->NavDisableMouseHover = 1;
  goto <bb 11>;

  <bb 10>:
  g_5->NavDisableHighlight = 1;

  <bb 11>:
  return;

}



;; Function void ImGui::ClearActiveID() (_ZN5ImGui13ClearActiveIDEv, funcdef_no=654, decl_uid=13767, cgraph_uid=553, symbol_order=559)

void ImGui::ClearActiveID() ()
{
  <bb 2>:
  ImGui::SetActiveID (0, 0B);
  return;

}



;; Function void ImGui::SetHoveredID(ImGuiID) (_ZN5ImGui12SetHoveredIDEj, funcdef_no=655, decl_uid=13769, cgraph_uid=554, symbol_order=560)

void ImGui::SetHoveredID(ImGuiID) (ImGuiID id)
{
  struct ImGuiContext & g;
  float D.24561;
  float D.24560;
  unsigned int D.24558;
  float iftmp.154;
  float iftmp.154_1;
  unsigned int _7;
  float _8;
  float _9;
  float iftmp.154_10;
  float iftmp.154_11;

  <bb 2>:
  g_3 = GImGui;
  g_3->HoveredId = id_4(D);
  g_3->HoveredIdAllowOverlap = 0;
  if (id_4(D) != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = g_3->HoveredIdPreviousFrame;
  if (_7 == id_4(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _8 = g_3->HoveredIdTimer;
  _9 = g_3->IO.DeltaTime;
  iftmp.154_10 = _8 + _9;
  goto <bb 6>;

  <bb 5>:
  iftmp.154_11 = 0.0;

  <bb 6>:
  # iftmp.154_1 = PHI <iftmp.154_10(4), iftmp.154_11(5)>
  g_3->HoveredIdTimer = iftmp.154_1;
  return;

}



;; Function ImGuiID ImGui::GetHoveredID() (_ZN5ImGui12GetHoveredIDEv, funcdef_no=656, decl_uid=13770, cgraph_uid=555, symbol_order=561)

ImGuiID ImGui::GetHoveredID() ()
{
  struct ImGuiContext & g;
  unsigned int D.24564;
  ImGuiID iftmp.155;
  ImGuiID D.24562;
  ImGuiID iftmp.155_1;
  unsigned int _4;
  ImGuiID iftmp.155_5;
  ImGuiID iftmp.155_6;
  ImGuiID _7;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->HoveredId;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.155_5 = g_3->HoveredId;
  goto <bb 5>;

  <bb 4>:
  iftmp.155_6 = g_3->HoveredIdPreviousFrame;

  <bb 5>:
  # iftmp.155_1 = PHI <iftmp.155_5(3), iftmp.155_6(4)>
  _7 = iftmp.155_1;

<L3>:
  return _7;

}



;; Function void ImGui::KeepAliveID(ImGuiID) (_ZN5ImGui11KeepAliveIDEj, funcdef_no=657, decl_uid=13772, cgraph_uid=556, symbol_order=562)

void ImGui::KeepAliveID(ImGuiID) (ImGuiID id)
{
  struct ImGuiContext & g;
  unsigned int D.24569;
  unsigned int _4;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->ActiveId;
  if (_4 == id_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  g_3->ActiveIdIsAlive = 1;

  <bb 4>:
  return;

}



;; Function bool IsWindowContentHoverable(ImGuiWindow*, ImGuiHoveredFlags) (_ZL24IsWindowContentHoverableP11ImGuiWindowi, funcdef_no=658, decl_uid=16051, cgraph_uid=557, symbol_order=563)

bool IsWindowContentHoverable(ImGuiWindow*, ImGuiHoveredFlags) (struct ImGuiWindow * window, ImGuiHoveredFlags flags)
{
  struct ImGuiWindow * focused_root_window;
  struct ImGuiContext & g;
  int D.25034;
  int D.25031;
  int D.25030;
  bool D.25029;
  int D.25026;
  int D.25025;
  struct ImGuiWindow * D.25022;
  bool D.25019;
  struct ImGuiWindow * D.25016;
  struct ImGuiWindow * D.25013;
  bool _1;
  struct ImGuiWindow * _4;
  struct ImGuiWindow * _5;
  bool _7;
  struct ImGuiWindow * _9;
  int _10;
  int _11;
  bool _12;
  int _13;
  int _14;
  int _16;
  bool _17;
  bool _18;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->NavWindow;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 12>;

  <bb 3>:
  _5 = g_3->NavWindow;
  focused_root_window_6 = _5->RootWindow;
  if (focused_root_window_6 != 0B)
    goto <bb 4>;
  else
    goto <bb 11>;

  <bb 4>:
  _7 = focused_root_window_6->WasActive;
  if (_7 != 0)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  _9 = window_8(D)->RootWindow;
  if (_9 != focused_root_window_6)
    goto <bb 6>;
  else
    goto <bb 11>;

  <bb 6>:
  _10 = focused_root_window_6->Flags;
  _11 = _10 & 134217728;
  if (_11 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _12 = 0;
  goto <bb 13> (<L17>);

  <bb 8>:
  _13 = focused_root_window_6->Flags;
  _14 = _13 & 67108864;
  if (_14 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _16 = flags_15(D) & 8;
  if (_16 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _17 = 0;
  goto <bb 13> (<L17>);

  <bb 11>:

  <bb 12>:
  _18 = 1;

  # _1 = PHI <_12(7), _17(10), _18(12)>
<L17>:
  return _1;

}



;; Function void ImGui::ItemSize(const ImVec2&, float) (_ZN5ImGui8ItemSizeERK6ImVec2f, funcdef_no=659, decl_uid=13775, cgraph_uid=558, symbol_order=564)

void ImGui::ItemSize(const ImVec2&, float) (const struct ImVec2 & size, float text_offset_y)
{
  const float text_base_offset;
  const float line_height;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.24605;
  float D.24604;
  float D.24603;
  float D.24602;
  float D.24601;
  float D.24600;
  float D.24599;
  float D.24598;
  float D.24597;
  float D.24596;
  float D.24595;
  int D.24594;
  float D.24593;
  float D.24592;
  float D.24591;
  float D.24590;
  float D.24589;
  float D.24588;
  int D.24587;
  float D.24586;
  float D.24585;
  float D.24584;
  float D.24583;
  struct ImVec2 D.16064;
  float D.24582;
  float D.24581;
  float D.24580;
  float D.24579;
  struct ImVec2 D.16063;
  float D.24578;
  float D.24577;
  float D.24576;
  bool D.24573;
  bool _5;
  float _7;
  float _8;
  float _11;
  float _15;
  float _16;
  float _17;
  float _18;
  float _22;
  float _23;
  float _24;
  float _25;
  int _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  int _33;
  float _34;
  float _38;
  float _39;
  float _41;
  float _43;
  float _44;
  float _45;
  float _46;
  float _48;
  float _53;
  int _55;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->CurrentWindow;
  _5 = window_4->SkipItems;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 6> (<L5>);

  <bb 4>:
  _7 = size_6(D)->y;
  _8 = window_4->DC.CurrentLineHeight;
  line_height_10 = ImMax (_8, _7);
  _11 = window_4->DC.CurrentLineTextBaseOffset;
  text_base_offset_14 = ImMax (_11, text_offset_y_12(D));
  _15 = window_4->DC.CursorPos.y;
  _16 = window_4->DC.CursorPos.x;
  _17 = size_6(D)->x;
  _18 = _16 + _17;
  ImVec2::ImVec2 (&D.16063, _18, _15);
  window_4->DC.CursorPosPrevLine = D.16063;
  D.16063 ={v} {CLOBBER};
  _22 = window_4->DC.CursorPos.y;
  _23 = _22 + line_height_10;
  _24 = g_3->Style.ItemSpacing.y;
  _25 = _23 + _24;
  _26 = (int) _25;
  _27 = (float) _26;
  _28 = window_4->Pos.x;
  _29 = window_4->DC.IndentX;
  _30 = _28 + _29;
  _31 = window_4->DC.ColumnsOffsetX;
  _32 = _30 + _31;
  _33 = (int) _32;
  _34 = (float) _33;
  ImVec2::ImVec2 (&D.16064, _34, _27);
  window_4->DC.CursorPos = D.16064;
  D.16064 ={v} {CLOBBER};
  _38 = window_4->DC.CursorPosPrevLine.x;
  _39 = window_4->DC.CursorMaxPos.x;
  _41 = ImMax (_39, _38);
  window_4->DC.CursorMaxPos.x = _41;
  _43 = window_4->DC.CursorPos.y;
  _44 = g_3->Style.ItemSpacing.y;
  _45 = _43 - _44;
  _46 = window_4->DC.CursorMaxPos.y;
  _48 = ImMax (_46, _45);
  window_4->DC.CursorMaxPos.y = _48;
  window_4->DC.PrevLineHeight = line_height_10;
  window_4->DC.PrevLineTextBaseOffset = text_base_offset_14;
  window_4->DC.CurrentLineTextBaseOffset = 0.0;
  _53 = window_4->DC.CurrentLineTextBaseOffset;
  window_4->DC.CurrentLineHeight = _53;
  _55 = window_4->DC.LayoutType;
  if (_55 == 1)
    goto <bb 5>;
  else
    goto <bb 6> (<L5>);

  <bb 5>:
  ImGui::SameLine (0.0, -1.0e+0);

<L5>:
  return;

}



;; Function void ImGui::ItemSize(const ImRect&, float) (_ZN5ImGui8ItemSizeERK6ImRectf, funcdef_no=660, decl_uid=13778, cgraph_uid=559, symbol_order=565)

void ImGui::ItemSize(const ImRect&, float) (const struct ImRect & bb, float text_offset_y)
{
  struct ImVec2 D.16069;

  <bb 2>:
  D.16069 = ImRect::GetSize (bb_2(D));
  ImGui::ItemSize (&D.16069, text_offset_y_4(D));
  D.16069 ={v} {CLOBBER};
  return;

}



;; Function ImGuiDir NavScoreItemGetQuadrant(float, float) (_ZL23NavScoreItemGetQuadrantff, funcdef_no=661, decl_uid=16072, cgraph_uid=560, symbol_order=566)

ImGuiDir NavScoreItemGetQuadrant(float, float) (float dx, float dy)
{
  ImGuiDir iftmp.157;
  ImGuiDir iftmp.156;
  ImGuiDir D.24624;
  float D.24621;
  float D.24620;
  ImGuiDir _1;
  ImGuiDir iftmp.156_2;
  ImGuiDir iftmp.157_3;
  float _5;
  float _7;
  ImGuiDir iftmp.156_8;
  ImGuiDir iftmp.156_9;
  ImGuiDir _10;
  ImGuiDir iftmp.157_11;
  ImGuiDir iftmp.157_12;
  ImGuiDir _13;

  <bb 2>:
  _5 = ABS_EXPR <dx_4(D)>;
  _7 = ABS_EXPR <dy_6(D)>;
  if (_5 > _7)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  if (dx_4(D) > 0.0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.156_8 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.156_9 = 0;

  <bb 6>:
  # iftmp.156_2 = PHI <iftmp.156_8(4), iftmp.156_9(5)>
  _10 = iftmp.156_2;
  goto <bb 11> (<L8>);

  <bb 7>:
  if (dy_6(D) > 0.0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.157_11 = 3;
  goto <bb 10>;

  <bb 9>:
  iftmp.157_12 = 2;

  <bb 10>:
  # iftmp.157_3 = PHI <iftmp.157_11(8), iftmp.157_12(9)>
  _13 = iftmp.157_3;

  # _1 = PHI <_10(6), _13(10)>
<L8>:
  return _1;

}



;; Function float NavScoreItemDistInterval(float, float, float, float) (_ZL24NavScoreItemDistIntervalffff, funcdef_no=662, decl_uid=16078, cgraph_uid=561, symbol_order=567)

float NavScoreItemDistInterval(float, float, float, float) (float a0, float a1, float b0, float b1)
{
  float D.24636;
  float _1;
  float _4;
  float _7;
  float _8;

  <bb 2>:
  if (a1_2(D) < b0_3(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _4 = a1_2(D) - b0_3(D);
  goto <bb 7> (<L4>);

  <bb 4>:
  if (b1_5(D) < a0_6(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _7 = a0_6(D) - b1_5(D);
  goto <bb 7> (<L4>);

  <bb 6>:
  _8 = 0.0;

  # _1 = PHI <_4(3), _7(5), _8(6)>
<L4>:
  return _1;

}



;; Function bool NavScoreItem(ImGuiNavMoveResult*, ImRect) (_ZL12NavScoreItemP18ImGuiNavMoveResult6ImRect, funcdef_no=663, decl_uid=16082, cgraph_uid=562, symbol_order=568)

bool NavScoreItem(ImGuiNavMoveResult*, ImRect) (struct ImGuiNavMoveResult * result, struct ImRect cand)
{
  bool new_best;
  float dist_axial;
  float day;
  float dax;
  ImGuiDir quadrant;
  float dist_center;
  float dcy;
  float dcx;
  float dist_box;
  float dby;
  float dbx;
  const struct ImRect & curr;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.24779;
  int D.24777;
  int D.24775;
  int D.24773;
  int D.24765;
  int D.24764;
  struct ImGuiWindow * D.24763;
  int D.24760;
  float D.24757;
  float D.24754;
  int D.24747;
  int D.24745;
  bool iftmp.160;
  float D.24738;
  float D.24734;
  float D.24731;
  float D.24728;
  int D.24725;
  unsigned int D.24721;
  unsigned int D.24720;
  ImGuiDir iftmp.159;
  float D.24710;
  float D.24709;
  float D.24708;
  float D.24707;
  float D.24706;
  float D.24705;
  float D.24704;
  float D.24703;
  float D.24702;
  float D.24701;
  float D.24700;
  float D.24699;
  float D.24698;
  float D.24697;
  float D.24696;
  float D.24695;
  float iftmp.158;
  float D.24689;
  float D.24684;
  float D.24683;
  float D.24682;
  float D.24681;
  float D.24680;
  float D.24679;
  float D.24678;
  float D.24677;
  float D.24676;
  float D.24675;
  float D.24674;
  float D.24673;
  float D.24672;
  float D.24671;
  float D.24670;
  float D.24669;
  float D.24668;
  float D.24667;
  float D.24666;
  float D.24665;
  float D.24664;
  float D.24663;
  float D.24662;
  float D.24661;
  float D.24660;
  float D.24659;
  float D.24658;
  float D.24657;
  float D.24656;
  float D.24655;
  float D.24654;
  float D.24653;
  int D.24652;
  int D.24650;
  int D.24646;
  int D.24645;
  bool D.24644;
  int D.24641;
  int D.24640;
  bool _9;
  float iftmp.158_10;
  ImGuiDir iftmp.159_11;
  bool iftmp.160_12;
  int _22;
  int _23;
  bool _24;
  int _26;
  int _27;
  int _29;
  int _30;
  float _31;
  float _32;
  float _33;
  float _35;
  float _37;
  float _38;
  float _39;
  float _41;
  float _43;
  float _44;
  float _45;
  float _47;
  float _49;
  float _50;
  float _51;
  float _53;
  float _55;
  float _56;
  float _57;
  float _58;
  float _61;
  float _62;
  float _64;
  float _65;
  float _66;
  float _68;
  float _69;
  float _70;
  float _72;
  float _73;
  float _74;
  float _76;
  float _79;
  float iftmp.158_80;
  float iftmp.158_81;
  float _83;
  float _84;
  float _86;
  float _87;
  float _88;
  float _89;
  float _90;
  float _91;
  float _93;
  float _94;
  float _95;
  float _96;
  float _97;
  float _98;
  float _100;
  float _101;
  unsigned int _106;
  unsigned int _107;
  ImGuiDir iftmp.159_108;
  ImGuiDir iftmp.159_109;
  int _122;
  float _124;
  bool _127;
  float _128;
  float _129;
  float _130;
  int _131;
  int _132;
  bool iftmp.160_133;
  bool iftmp.160_134;
  float _138;
  float _139;
  int _140;
  struct ImGuiWindow * _141;
  int _142;
  int _143;
  int _144;
  int _145;
  int _146;
  int _147;
  bool _150;

  <bb 2>:
  g_20 = GImGui;
  window_21 = g_20->CurrentWindow;
  _22 = g_20->NavLayer;
  _23 = window_21->DC.NavLayerCurrent;
  if (_22 != _23)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _24 = 0;
  goto <bb 52> (<L65>);

  <bb 4>:
  curr_25 = &g_20->NavScoringRectScreen;
  _26 = g_20->NavScoringCount;
  _27 = _26 + 1;
  g_20->NavScoringCount = _27;
  _29 = g_20->NavMoveDir;
  if (_29 == 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _30 = g_20->NavMoveDir;
  if (_30 == 1)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _43 = window_21->ClipRect.Max.y;
  _44 = window_21->ClipRect.Min.y;
  _45 = cand.Min.y;
  _47 = ImClamp (_45, _44, _43);
  cand.Min.y = _47;
  _49 = window_21->ClipRect.Max.y;
  _50 = window_21->ClipRect.Min.y;
  _51 = cand.Max.y;
  _53 = ImClamp (_51, _50, _49);
  cand.Max.y = _53;
  goto <bb 8>;

  <bb 7>:
  _31 = window_21->ClipRect.Max.x;
  _32 = window_21->ClipRect.Min.x;
  _33 = cand.Min.x;
  _35 = ImClamp (_33, _32, _31);
  cand.Min.x = _35;
  _37 = window_21->ClipRect.Max.x;
  _38 = window_21->ClipRect.Min.x;
  _39 = cand.Max.x;
  _41 = ImClamp (_39, _38, _37);
  cand.Max.x = _41;

  <bb 8>:
  _55 = curr_25->Max.x;
  _56 = curr_25->Min.x;
  _57 = cand.Max.x;
  _58 = cand.Min.x;
  dbx_60 = NavScoreItemDistInterval (_58, _57, _56, _55);
  _61 = curr_25->Max.y;
  _62 = curr_25->Min.y;
  _64 = ImLerp (_62, _61, 8.00000011920928955078125e-1);
  _65 = curr_25->Max.y;
  _66 = curr_25->Min.y;
  _68 = ImLerp (_66, _65, 2.0000000298023223876953125e-1);
  _69 = cand.Max.y;
  _70 = cand.Min.y;
  _72 = ImLerp (_70, _69, 8.00000011920928955078125e-1);
  _73 = cand.Max.y;
  _74 = cand.Min.y;
  _76 = ImLerp (_74, _73, 2.0000000298023223876953125e-1);
  dby_78 = NavScoreItemDistInterval (_76, _72, _68, _64);
  if (dby_78 != 0.0)
    goto <bb 9>;
  else
    goto <bb 14>;

  <bb 9>:
  if (dbx_60 != 0.0)
    goto <bb 10>;
  else
    goto <bb 14>;

  <bb 10>:
  _79 = dbx_60 / 1.0e+3;
  if (dbx_60 > 0.0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.158_80 = 1.0e+0;
  goto <bb 13>;

  <bb 12>:
  iftmp.158_81 = -1.0e+0;

  <bb 13>:
  # iftmp.158_10 = PHI <iftmp.158_80(11), iftmp.158_81(12)>
  dbx_82 = _79 + iftmp.158_10;

  <bb 14>:
  # dbx_1 = PHI <dbx_60(8), dbx_60(9), dbx_82(13)>
  _83 = ABS_EXPR <dbx_1>;
  _84 = ABS_EXPR <dby_78>;
  dist_box_85 = _83 + _84;
  _86 = cand.Min.x;
  _87 = cand.Max.x;
  _88 = _86 + _87;
  _89 = curr_25->Min.x;
  _90 = curr_25->Max.x;
  _91 = _89 + _90;
  dcx_92 = _88 - _91;
  _93 = cand.Min.y;
  _94 = cand.Max.y;
  _95 = _93 + _94;
  _96 = curr_25->Min.y;
  _97 = curr_25->Max.y;
  _98 = _96 + _97;
  dcy_99 = _95 - _98;
  _100 = ABS_EXPR <dcx_92>;
  _101 = ABS_EXPR <dcy_99>;
  dist_center_102 = _100 + _101;
  dax_103 = 0.0;
  day_104 = 0.0;
  dist_axial_105 = 0.0;
  if (dbx_1 != 0.0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  if (dby_78 != 0.0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  dax_116 = dbx_1;
  day_117 = dby_78;
  dist_axial_118 = dist_box_85;
  quadrant_120 = NavScoreItemGetQuadrant (dbx_1, dby_78);
  goto <bb 24>;

  <bb 17>:
  if (dcx_92 != 0.0)
    goto <bb 19>;
  else
    goto <bb 18>;

  <bb 18>:
  if (dcy_99 != 0.0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  dax_111 = dcx_92;
  day_112 = dcy_99;
  dist_axial_113 = dist_center_102;
  quadrant_115 = NavScoreItemGetQuadrant (dcx_92, dcy_99);
  goto <bb 24>;

  <bb 20>:
  _106 = window_21->DC.LastItemId;
  _107 = g_20->NavId;
  if (_106 < _107)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  iftmp.159_108 = 0;
  goto <bb 23>;

  <bb 22>:
  iftmp.159_109 = 1;

  <bb 23>:
  # iftmp.159_11 = PHI <iftmp.159_108(21), iftmp.159_109(22)>
  quadrant_110 = iftmp.159_11;

  <bb 24>:
  # quadrant_2 = PHI <quadrant_120(16), quadrant_115(19), quadrant_110(23)>
  # dax_3 = PHI <dax_116(16), dax_111(19), dax_103(23)>
  # day_4 = PHI <day_117(16), day_112(19), day_104(23)>
  # dist_axial_5 = PHI <dist_axial_118(16), dist_axial_113(19), dist_axial_105(23)>
  new_best_121 = 0;
  _122 = g_20->NavMoveDir;
  if (_122 == quadrant_2)
    goto <bb 25>;
  else
    goto <bb 37>;

  <bb 25>:
  _124 = result_123(D)->DistBox;
  if (_124 > dist_box_85)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  result_123(D)->DistBox = dist_box_85;
  result_123(D)->DistCenter = dist_center_102;
  _127 = 1;
  goto <bb 52> (<L65>);

  <bb 27>:
  _128 = result_123(D)->DistBox;
  if (_128 == dist_box_85)
    goto <bb 28>;
  else
    goto <bb 37>;

  <bb 28>:
  _129 = result_123(D)->DistCenter;
  if (_129 > dist_center_102)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  result_123(D)->DistCenter = dist_center_102;
  new_best_137 = 1;
  goto <bb 37>;

  <bb 30>:
  _130 = result_123(D)->DistCenter;
  if (_130 == dist_center_102)
    goto <bb 31>;
  else
    goto <bb 37>;

  <bb 31>:
  _131 = g_20->NavMoveDir;
  if (_131 == 2)
    goto <bb 33>;
  else
    goto <bb 32>;

  <bb 32>:
  _132 = g_20->NavMoveDir;
  if (_132 == 3)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  iftmp.160_134 = dby_78 < 0.0;
  goto <bb 35>;

  <bb 34>:
  iftmp.160_133 = dbx_1 < 0.0;

  <bb 35>:
  # iftmp.160_12 = PHI <iftmp.160_134(33), iftmp.160_133(34)>
  if (iftmp.160_12 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  new_best_135 = 1;

  <bb 37>:
  # new_best_6 = PHI <new_best_121(24), new_best_121(30), new_best_121(27), new_best_135(36), new_best_121(35), new_best_137(29)>
  _138 = result_123(D)->DistBox;
  if (_138 == 3.4028234663852885981170418348451692544e+38)
    goto <bb 38>;
  else
    goto <bb 51>;

  <bb 38>:
  _139 = result_123(D)->DistAxial;
  if (_139 > dist_axial_5)
    goto <bb 39>;
  else
    goto <bb 51>;

  <bb 39>:
  _140 = g_20->NavLayer;
  if (_140 == 1)
    goto <bb 40>;
  else
    goto <bb 51>;

  <bb 40>:
  _141 = g_20->NavWindow;
  _142 = _141->Flags;
  _143 = _142 & 268435456;
  if (_143 == 0)
    goto <bb 41>;
  else
    goto <bb 51>;

  <bb 41>:
  _144 = g_20->NavMoveDir;
  if (_144 == 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  if (dax_3 < 0.0)
    goto <bb 49>;
  else
    goto <bb 43>;

  <bb 43>:
  _145 = g_20->NavMoveDir;
  if (_145 == 1)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  if (dax_3 > 0.0)
    goto <bb 49>;
  else
    goto <bb 45>;

  <bb 45>:
  _146 = g_20->NavMoveDir;
  if (_146 == 2)
    goto <bb 46>;
  else
    goto <bb 47>;

  <bb 46>:
  if (day_4 < 0.0)
    goto <bb 49>;
  else
    goto <bb 47>;

  <bb 47>:
  _147 = g_20->NavMoveDir;
  if (_147 == 3)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  if (day_4 > 0.0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  result_123(D)->DistAxial = dist_axial_5;
  new_best_149 = 1;

  <bb 50>:
  # new_best_7 = PHI <new_best_6(47), new_best_6(48), new_best_149(49)>

  <bb 51>:
  # new_best_8 = PHI <new_best_6(37), new_best_6(38), new_best_6(40), new_best_6(39), new_best_7(50)>
  _150 = new_best_8;

  # _9 = PHI <_24(3), _127(26), _150(51)>
<L65>:
  return _9;

}



;; Function void NavSaveLastChildNavWindow(ImGuiWindow*) (_ZL25NavSaveLastChildNavWindowP11ImGuiWindow, funcdef_no=664, decl_uid=16099, cgraph_uid=563, symbol_order=569)

void NavSaveLastChildNavWindow(ImGuiWindow*) (struct ImGuiWindow * child_window)
{
  struct ImGuiWindow * parent_window;
  int D.24804;
  int D.24803;
  int D.24801;
  int D.24800;
  int _6;
  int _7;
  int _8;
  int _9;

  <bb 2>:
  parent_window_4 = child_window_3(D);

  <bb 3>:
  # parent_window_1 = PHI <parent_window_4(2), parent_window_10(6)>
  if (parent_window_1 == 0B)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _6 = parent_window_1->Flags;
  _7 = _6 & 16777216;
  if (_7 == 0)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 5>:
  _8 = parent_window_1->Flags;
  _9 = _8 & 335544320;
  if (_9 != 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  parent_window_10 = parent_window_1->ParentWindow;
  goto <bb 3>;

  <bb 7>:
  if (parent_window_1 != 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  if (parent_window_1 != child_window_3(D))
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  parent_window_1->NavLastChildNavWindow = child_window_3(D);

  <bb 10>:
  return;

}



;; Function ImGuiWindow* NavRestoreLastChildNavWindow(ImGuiWindow*) (_ZL28NavRestoreLastChildNavWindowP11ImGuiWindow, funcdef_no=665, decl_uid=16105, cgraph_uid=564, symbol_order=570)

ImGuiWindow* NavRestoreLastChildNavWindow(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiWindow * D.24813;
  struct ImGuiWindow * iftmp.163;
  struct ImGuiWindow * D.24811;
  struct ImGuiWindow * iftmp.163_1;
  struct ImGuiWindow * _4;
  struct ImGuiWindow * iftmp.163_5;
  struct ImGuiWindow * iftmp.163_6;
  struct ImGuiWindow * _7;

  <bb 2>:
  _4 = window_3(D)->NavLastChildNavWindow;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.163_5 = window_3(D)->NavLastChildNavWindow;
  goto <bb 5>;

  <bb 4>:
  iftmp.163_6 = window_3(D);

  <bb 5>:
  # iftmp.163_1 = PHI <iftmp.163_5(3), iftmp.163_6(4)>
  _7 = iftmp.163_1;

<L3>:
  return _7;

}



;; Function void NavRestoreLayer(int) (_ZL15NavRestoreLayeri, funcdef_no=666, decl_uid=16108, cgraph_uid=565, symbol_order=571)

void NavRestoreLayer(int) (int layer)
{
  struct ImGuiContext & g;
  struct ImGuiWindow * D.24833;
  unsigned int D.24832;
  struct ImGuiWindow * D.24831;
  struct ImRect * D.24830;
  struct ImGuiWindow * D.24829;
  unsigned int D.24827;
  struct ImGuiWindow * D.24826;
  struct ImGuiWindow * D.24821;
  struct ImGuiWindow * D.24820;
  struct ImGuiWindow * _7;
  struct ImGuiWindow * _9;
  struct ImGuiWindow * _11;
  unsigned int _12;
  struct ImGuiWindow * _13;
  struct ImRect * _14;
  struct ImGuiWindow * _15;
  unsigned int _16;
  struct ImGuiWindow * _18;

  <bb 2>:
  g_4 = GImGui;
  g_4->NavLayer = layer_5(D);
  if (layer_5(D) == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = g_4->NavWindow;
  _9 = NavRestoreLastChildNavWindow (_7);
  g_4->NavWindow = _9;

  <bb 4>:
  if (layer_5(D) == 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _11 = g_4->NavWindow;
  _12 = _11->NavLastIds[0];
  if (_12 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _13 = g_4->NavWindow;
  _14 = &_13->NavRectRel[0];
  _15 = g_4->NavWindow;
  _16 = _15->NavLastIds[0];
  SetNavIDWithRectRel (_16, layer_5(D), _14);
  goto <bb 8>;

  <bb 7>:
  _18 = g_4->NavWindow;
  ImGui::NavInitWindow (_18, 1);

  <bb 8>:
  return;

}



;; Function void NavUpdateAnyRequestFlag() (_ZL23NavUpdateAnyRequestFlagv, funcdef_no=667, decl_uid=16111, cgraph_uid=566, symbol_order=572)

void NavUpdateAnyRequestFlag() ()
{
  static const char __PRETTY_FUNCTION__[31] = "void NavUpdateAnyRequestFlag()";
  struct ImGuiContext & g;
  struct ImGuiWindow * D.24855;
  bool D.24852;
  bool D.24851;
  bool D.24849;
  bool iftmp.165;
  bool iftmp.165_1;
  bool _4;
  bool _5;
  bool iftmp.165_6;
  bool iftmp.165_7;
  bool _9;
  struct ImGuiWindow * _10;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->NavMoveRequest;
  if (_4 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _5 = g_3->NavInitRequest;
  if (_5 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.165_7 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.165_6 = 0;

  <bb 6>:
  # iftmp.165_1 = PHI <iftmp.165_7(4), iftmp.165_6(5)>
  g_3->NavAnyRequest = iftmp.165_1;
  _9 = g_3->NavAnyRequest;
  if (_9 != 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _10 = g_3->NavWindow;
  if (_10 != 0B)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  __assert_fail ("g.NavWindow != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2350, &__PRETTY_FUNCTION__);

  <bb 9>:
  return;

}



;; Function bool NavMoveRequestButNoResultYet() (_ZL28NavMoveRequestButNoResultYetv, funcdef_no=668, decl_uid=16115, cgraph_uid=567, symbol_order=573)

bool NavMoveRequestButNoResultYet() ()
{
  struct ImGuiContext & g;
  unsigned int D.24842;
  unsigned int D.24840;
  bool D.24838;
  bool iftmp.164;
  bool D.24834;
  bool iftmp.164_1;
  bool _4;
  unsigned int _5;
  unsigned int _6;
  bool iftmp.164_7;
  bool iftmp.164_8;
  bool _9;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->NavMoveRequest;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _5 = g_3->NavMoveResultLocal.ID;
  if (_5 == 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _6 = g_3->NavMoveResultOther.ID;
  if (_6 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.164_7 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.164_8 = 0;

  <bb 7>:
  # iftmp.164_1 = PHI <iftmp.164_7(5), iftmp.164_8(6)>
  _9 = iftmp.164_1;

<L5>:
  return _9;

}



;; Function void ImGui::NavMoveRequestCancel() (_ZN5ImGui20NavMoveRequestCancelEv, funcdef_no=669, decl_uid=13829, cgraph_uid=568, symbol_order=574)

void ImGui::NavMoveRequestCancel() ()
{
  struct ImGuiContext & g;

  <bb 2>:
  g_2 = GImGui;
  g_2->NavMoveRequest = 0;
  NavUpdateAnyRequestFlag ();
  return;

}



;; Function void ImGui::NavProcessItem(ImGuiWindow*, const ImRect&, ImGuiID) (_ZN5ImGuiL14NavProcessItemEP11ImGuiWindowRK6ImRectj, funcdef_no=670, decl_uid=15117, cgraph_uid=569, symbol_order=575)

void ImGui::NavProcessItem(ImGuiWindow*, const ImRect&, ImGuiID) (struct ImGuiWindow * window, const struct ImRect & nav_bb, const ImGuiID id)
{
  bool new_best;
  struct ImGuiNavMoveResult * result;
  const struct ImRect nav_bb_rel;
  const ImGuiItemFlags item_flags;
  struct ImGuiContext & g;
  int D.24911;
  int D.24910;
  int D.24909;
  unsigned int D.24906;
  unsigned int D.24903;
  value_type & D.24902;
  struct ImVector * D.24901;
  bool D.24897;
  bool D.24895;
  bool iftmp.167;
  struct ImGuiWindow * D.24888;
  struct ImGuiNavMoveResult * iftmp.166;
  int D.24884;
  unsigned int D.24881;
  int D.24876;
  unsigned int D.24875;
  int D.24873;
  int D.24868;
  int D.24867;
  bool D.24864;
  const struct ImVec2 * D.24863;
  struct ImVec2 * D.24862;
  struct ImVec2 D.16129;
  const struct ImVec2 * D.24861;
  struct ImVec2 * D.24860;
  struct ImVec2 D.16130;
  struct ImGuiNavMoveResult * iftmp.166_1;
  bool iftmp.167_2;
  struct ImVec2 * _14;
  const struct ImVec2 * _16;
  struct ImVec2 * _18;
  const struct ImVec2 * _19;
  bool _24;
  int _25;
  int _26;
  int _27;
  unsigned int _28;
  int _32;
  unsigned int _35;
  int _36;
  struct ImGuiWindow * _37;
  struct ImGuiNavMoveResult * iftmp.166_38;
  struct ImGuiNavMoveResult * iftmp.166_39;
  bool _41;
  bool _43;
  bool iftmp.167_44;
  bool iftmp.167_45;
  struct ImVector * _48;
  value_type & _50;
  unsigned int _51;
  unsigned int _55;
  int _57;
  int _60;
  int _62;

  <bb 2>:
  g_11 = GImGui;
  item_flags_13 = window_12(D)->DC.ItemFlags;
  _14 = &window_12(D)->Pos;
  _16 = &nav_bb_15(D)->Max;
  D.16130 = operator- (_16, _14);
  _18 = &window_12(D)->Pos;
  _19 = &nav_bb_15(D)->Min;
  D.16129 = operator- (_19, _18);
  ImRect::ImRect (&nav_bb_rel, &D.16129, &D.16130);
  D.16129 ={v} {CLOBBER};
  D.16130 ={v} {CLOBBER};
  _24 = g_11->NavInitRequest;
  if (_24 != 0)
    goto <bb 3>;
  else
    goto <bb 9>;

  <bb 3>:
  _25 = g_11->NavLayer;
  _26 = window_12(D)->DC.NavLayerCurrent;
  if (_25 == _26)
    goto <bb 4>;
  else
    goto <bb 9>;

  <bb 4>:
  _27 = item_flags_13 & 16;
  if (_27 == 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _28 = g_11->NavInitResultId;
  if (_28 == 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  g_11->NavInitResultId = id_29(D);
  g_11->NavInitResultRectRel = nav_bb_rel;

  <bb 7>:
  _32 = item_flags_13 & 16;
  if (_32 == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  g_11->NavInitRequest = 0;
  NavUpdateAnyRequestFlag ();

  <bb 9>:
  _35 = g_11->NavId;
  if (_35 != id_29(D))
    goto <bb 10>;
  else
    goto <bb 21>;

  <bb 10>:
  _36 = item_flags_13 & 8;
  if (_36 == 0)
    goto <bb 11>;
  else
    goto <bb 21>;

  <bb 11>:
  _37 = g_11->NavWindow;
  if (_37 == window_12(D))
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.166_38 = &g_11->NavMoveResultLocal;
  goto <bb 14>;

  <bb 13>:
  iftmp.166_39 = &g_11->NavMoveResultOther;

  <bb 14>:
  # iftmp.166_1 = PHI <iftmp.166_38(12), iftmp.166_39(13)>
  result_40 = iftmp.166_1;
  _41 = g_11->NavMoveRequest;
  if (_41 != 0)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  _43 = NavScoreItem (result_40, *nav_bb_15(D));
  if (_43 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.167_44 = 1;
  goto <bb 18>;

  <bb 17>:
  iftmp.167_45 = 0;

  <bb 18>:
  # iftmp.167_2 = PHI <iftmp.167_44(16), iftmp.167_45(17)>
  new_best_46 = iftmp.167_2;
  if (new_best_46 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  result_40->ID = id_29(D);
  _48 = &window_12(D)->IDStack;
  _50 = ImVector<unsigned int>::back (_48);
  _51 = *_50;
  result_40->ParentID = _51;
  result_40->Window = window_12(D);
  result_40->RectRel = nav_bb_rel;

  <bb 20>:

  <bb 21>:
  _55 = g_11->NavId;
  if (_55 == id_29(D))
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  g_11->NavWindow = window_12(D);
  _57 = window_12(D)->DC.NavLayerCurrent;
  g_11->NavLayer = _57;
  g_11->NavIdIsAlive = 1;
  _60 = window_12(D)->FocusIdxTabCounter;
  g_11->NavIdTabCounter = _60;
  _62 = window_12(D)->DC.NavLayerCurrent;
  window_12(D)->NavRectRel[_62] = nav_bb_rel;

  <bb 23>:
  nav_bb_rel ={v} {CLOBBER};
  return;

}



;; Function bool ImGui::ItemAdd(const ImRect&, ImGuiID, const ImRect*) (_ZN5ImGui7ItemAddERK6ImRectjPS1_, funcdef_no=671, decl_uid=13782, cgraph_uid=570, symbol_order=576)

bool ImGui::ItemAdd(const ImRect&, ImGuiID, const ImRect*) (const struct ImRect & bb, ImGuiID id, const struct ImRect * nav_bb_arg)
{
  const bool is_clipped;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.24952;
  int D.24951;
  const struct ImVec2 * D.24948;
  const struct ImVec2 * D.24947;
  bool retval.169;
  bool D.24945;
  const struct ImRect & iftmp.168;
  int D.24936;
  int D.24935;
  int D.24934;
  struct ImGuiWindow * D.24933;
  int D.24932;
  struct ImGuiWindow * D.24930;
  struct ImGuiWindow * D.24925;
  struct ImGuiWindow * D.24924;
  struct ImGuiWindow * D.24923;
  bool D.24922;
  unsigned int D.24920;
  int D.24917;
  int D.24916;
  int D.24915;
  const struct ImRect & iftmp.168_1;
  bool _2;
  int _11;
  int _12;
  int _13;
  unsigned int _15;
  bool _16;
  struct ImGuiWindow * _17;
  struct ImGuiWindow * _18;
  struct ImGuiWindow * _19;
  struct ImGuiWindow * _20;
  int _21;
  struct ImGuiWindow * _22;
  int _23;
  int _24;
  int _25;
  const struct ImRect & iftmp.168_27;
  const struct ImRect & iftmp.168_29;
  bool _36;
  const struct ImVec2 * _37;
  const struct ImVec2 * _38;
  bool retval.169_40;
  int _41;
  int _42;
  bool _44;

  <bb 2>:
  g_8 = GImGui;
  window_9 = g_8->CurrentWindow;
  if (id_10(D) != 0)
    goto <bb 3>;
  else
    goto <bb 13>;

  <bb 3>:
  _11 = window_9->DC.NavLayerActiveMaskNext;
  _12 = window_9->DC.NavLayerCurrentMask;
  _13 = _11 | _12;
  window_9->DC.NavLayerActiveMaskNext = _13;
  _15 = g_8->NavId;
  if (_15 == id_10(D))
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _16 = g_8->NavAnyRequest;
  if (_16 != 0)
    goto <bb 5>;
  else
    goto <bb 13>;

  <bb 5>:
  _17 = g_8->NavWindow;
  _18 = _17->RootWindowForNav;
  _19 = window_9->RootWindowForNav;
  if (_18 == _19)
    goto <bb 6>;
  else
    goto <bb 13>;

  <bb 6>:
  _20 = g_8->NavWindow;
  if (_20 == window_9)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _21 = window_9->Flags;
  _22 = g_8->NavWindow;
  _23 = _22->Flags;
  _24 = _21 | _23;
  _25 = _24 & 8388608;
  if (_25 != 0)
    goto <bb 8>;
  else
    goto <bb 12>;

  <bb 8>:
  if (nav_bb_arg_26(D) != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.168_27 = nav_bb_arg_26(D);
  goto <bb 11>;

  <bb 10>:
  iftmp.168_29 = bb_28(D);

  <bb 11>:
  # iftmp.168_1 = PHI <iftmp.168_27(9), iftmp.168_29(10)>
  ImGui::NavProcessItem (window_9, iftmp.168_1, id_10(D));

  <bb 12>:

  <bb 13>:
  window_9->DC.LastItemId = id_10(D);
  window_9->DC.LastItemRect = *bb_28(D);
  window_9->DC.LastItemStatusFlags = 0;
  is_clipped_35 = ImGui::IsClippedEx (bb_28(D), id_10(D), 0);
  if (is_clipped_35 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _36 = 0;
  goto <bb 18> (<L20>);

  <bb 15>:
  _37 = &bb_28(D)->Max;
  _38 = &bb_28(D)->Min;
  retval.169_40 = ImGui::IsMouseHoveringRect (_38, _37, 1);
  if (retval.169_40 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _41 = window_9->DC.LastItemStatusFlags;
  _42 = _41 | 1;
  window_9->DC.LastItemStatusFlags = _42;

  <bb 17>:
  _44 = 1;

  # _2 = PHI <_36(14), _44(17)>
<L20>:
  return _2;

}



;; Function bool ImGui::IsItemHovered(ImGuiHoveredFlags) (_ZN5ImGui13IsItemHoveredEi, funcdef_no=672, decl_uid=3303, cgraph_uid=571, symbol_order=577)

bool ImGui::IsItemHovered(ImGuiHoveredFlags) (ImGuiHoveredFlags flags)
{
  static const char __PRETTY_FUNCTION__[45] = "bool ImGui::IsItemHovered(ImGuiHoveredFlags)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.25009;
  unsigned int D.25006;
  unsigned int D.25005;
  int D.25002;
  int D.25001;
  bool D.24998;
  bool retval.170;
  unsigned int D.24993;
  unsigned int D.24992;
  bool D.24989;
  bool D.24988;
  unsigned int D.24985;
  unsigned int D.24984;
  unsigned int D.24981;
  int D.24978;
  int D.24975;
  struct ImGuiWindow * D.24972;
  struct ImGuiWindow * D.24971;
  int D.24967;
  int D.24964;
  int D.24963;
  bool D.24962;
  bool D.24959;
  bool D.24958;
  bool D.24955;
  bool _1;
  bool _6;
  bool _7;
  bool _8;
  bool _10;
  int _11;
  int _12;
  bool _13;
  int _15;
  struct ImGuiWindow * _16;
  struct ImGuiWindow * _17;
  int _18;
  bool _19;
  int _20;
  unsigned int _21;
  unsigned int _22;
  unsigned int _23;
  bool _24;
  bool _25;
  unsigned int _26;
  unsigned int _27;
  bool _28;
  bool _30;
  bool retval.170_31;
  bool _32;
  int _33;
  int _34;
  bool _35;
  unsigned int _36;
  unsigned int _37;
  bool _38;
  bool _39;
  bool _40;

  <bb 2>:
  g_4 = GImGui;
  window_5 = g_4->CurrentWindow;
  _6 = g_4->NavDisableMouseHover;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = g_4->NavDisableHighlight;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _10 = ImGui::IsItemFocused ();
  goto <bb 26> (<L32>);

  <bb 5>:
  _11 = window_5->DC.LastItemStatusFlags;
  _12 = _11 & 1;
  if (_12 == 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _13 = 0;
  goto <bb 26> (<L32>);

  <bb 7>:
  _15 = flags_14(D) & 3;
  if (_15 == 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  __assert_fail ("(flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2473, &__PRETTY_FUNCTION__);

  <bb 9>:
  _16 = g_4->HoveredRootWindow;
  _17 = window_5->RootWindow;
  if (_16 != _17)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _18 = flags_14(D) & 64;
  if (_18 == 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _19 = 0;
  goto <bb 26> (<L32>);

  <bb 12>:
  _20 = flags_14(D) & 32;
  if (_20 == 0)
    goto <bb 13>;
  else
    goto <bb 18>;

  <bb 13>:
  _21 = g_4->ActiveId;
  if (_21 != 0)
    goto <bb 14>;
  else
    goto <bb 18>;

  <bb 14>:
  _22 = g_4->ActiveId;
  _23 = window_5->DC.LastItemId;
  if (_22 != _23)
    goto <bb 15>;
  else
    goto <bb 18>;

  <bb 15>:
  _24 = g_4->ActiveIdAllowOverlap;
  _25 = ~_24;
  if (_25 != 0)
    goto <bb 16>;
  else
    goto <bb 18>;

  <bb 16>:
  _26 = g_4->ActiveId;
  _27 = window_5->MoveId;
  if (_26 != _27)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _28 = 0;
  goto <bb 26> (<L32>);

  <bb 18>:
  _30 = IsWindowContentHoverable (window_5, flags_14(D));
  retval.170_31 = ~_30;
  if (retval.170_31 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _32 = 0;
  goto <bb 26> (<L32>);

  <bb 20>:
  _33 = window_5->DC.ItemFlags;
  _34 = _33 & 4;
  if (_34 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _35 = 0;
  goto <bb 26> (<L32>);

  <bb 22>:
  _36 = window_5->DC.LastItemId;
  _37 = window_5->MoveId;
  if (_36 == _37)
    goto <bb 23>;
  else
    goto <bb 25>;

  <bb 23>:
  _38 = window_5->WriteAccessed;
  if (_38 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _39 = 0;
  goto <bb 26> (<L32>);

  <bb 25>:
  _40 = 1;

  # _1 = PHI <_10(4), _13(6), _19(11), _28(17), _32(19), _35(21), _39(24), _40(25)>
<L32>:
  return _1;

}



;; Function bool ImGui::ItemHoverable(const ImRect&, ImGuiID) (_ZN5ImGui13ItemHoverableERK6ImRectj, funcdef_no=673, decl_uid=13785, cgraph_uid=572, symbol_order=578)

bool ImGui::ItemHoverable(const ImRect&, ImGuiID) (const struct ImRect & bb, ImGuiID id)
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.25083;
  int D.25082;
  bool D.25079;
  bool D.25078;
  bool D.25076;
  bool iftmp.173;
  bool retval.172;
  bool D.25068;
  const struct ImVec2 * D.25067;
  const struct ImVec2 * D.25066;
  bool retval.171;
  bool D.25062;
  bool D.25061;
  unsigned int D.25058;
  unsigned int D.25055;
  struct ImGuiWindow * D.25052;
  bool D.25051;
  bool D.25048;
  bool D.25047;
  unsigned int D.25044;
  unsigned int D.25041;
  bool _1;
  bool iftmp.173_2;
  unsigned int _8;
  unsigned int _9;
  bool _11;
  bool _12;
  bool _13;
  struct ImGuiWindow * _15;
  bool _16;
  unsigned int _17;
  unsigned int _18;
  bool _19;
  bool _20;
  bool _21;
  const struct ImVec2 * _23;
  const struct ImVec2 * _24;
  bool _26;
  bool retval.171_27;
  bool _28;
  bool _29;
  bool _31;
  bool _32;
  bool iftmp.173_33;
  bool iftmp.173_34;
  bool retval.172_35;
  bool _36;
  int _37;
  int _38;
  bool _39;
  bool _41;

  <bb 2>:
  g_7 = GImGui;
  _8 = g_7->HoveredId;
  if (_8 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _9 = g_7->HoveredId;
  if (_9 != id_10(D))
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _11 = g_7->HoveredIdAllowOverlap;
  _12 = ~_11;
  if (_12 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = 0;
  goto <bb 23> (<L24>);

  <bb 6>:
  window_14 = g_7->CurrentWindow;
  _15 = g_7->HoveredWindow;
  if (_15 != window_14)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _16 = 0;
  goto <bb 23> (<L24>);

  <bb 8>:
  _17 = g_7->ActiveId;
  if (_17 != 0)
    goto <bb 9>;
  else
    goto <bb 12>;

  <bb 9>:
  _18 = g_7->ActiveId;
  if (_18 != id_10(D))
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _19 = g_7->ActiveIdAllowOverlap;
  _20 = ~_19;
  if (_20 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _21 = 0;
  goto <bb 23> (<L24>);

  <bb 12>:
  _23 = &bb_22(D)->Max;
  _24 = &bb_22(D)->Min;
  _26 = ImGui::IsMouseHoveringRect (_24, _23, 1);
  retval.171_27 = ~_26;
  if (retval.171_27 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _28 = 0;
  goto <bb 23> (<L24>);

  <bb 14>:
  _29 = g_7->NavDisableMouseHover;
  if (_29 != 0)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  _31 = IsWindowContentHoverable (window_14, 0);
  _32 = ~_31;
  if (_32 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.173_34 = 1;
  goto <bb 18>;

  <bb 17>:
  iftmp.173_33 = 0;

  <bb 18>:
  # iftmp.173_2 = PHI <iftmp.173_34(16), iftmp.173_33(17)>
  retval.172_35 = iftmp.173_2;
  if (retval.172_35 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _36 = 0;
  goto <bb 23> (<L24>);

  <bb 20>:
  _37 = window_14->DC.ItemFlags;
  _38 = _37 & 4;
  if (_38 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _39 = 0;
  goto <bb 23> (<L24>);

  <bb 22>:
  ImGui::SetHoveredID (id_10(D));
  _41 = 1;

  # _1 = PHI <_13(5), _16(7), _21(11), _28(13), _36(19), _39(21), _41(22)>
<L24>:
  return _1;

}



;; Function bool ImGui::IsClippedEx(const ImRect&, ImGuiID, bool) (_ZN5ImGui11IsClippedExERK6ImRectjb, funcdef_no=674, decl_uid=13789, cgraph_uid=573, symbol_order=579)

bool ImGui::IsClippedEx(const ImRect&, ImGuiID, bool) (const struct ImRect & bb, ImGuiID id, bool clip_even_when_logged)
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.25101;
  bool D.25100;
  bool D.25099;
  unsigned int D.25095;
  bool D.25089;
  struct ImRect * D.25088;
  bool retval.174;
  bool _1;
  struct ImRect * _5;
  bool _8;
  bool retval.174_9;
  unsigned int _11;
  bool _13;
  bool _14;
  bool _15;
  bool _16;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->CurrentWindow;
  _5 = &window_4->ClipRect;
  _8 = ImRect::Overlaps (bb_6(D), _5);
  retval.174_9 = ~_8;
  if (retval.174_9 != 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  if (id_10(D) == 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _11 = g_3->ActiveId;
  if (_11 != id_10(D))
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  if (clip_even_when_logged_12(D) != 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _13 = g_3->LogEnabled;
  _14 = ~_13;
  if (_14 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _15 = 1;
  goto <bb 9> (<L9>);

  <bb 8>:
  _16 = 0;

  # _1 = PHI <_15(7), _16(8)>
<L9>:
  return _1;

}



;; Function bool ImGui::FocusableItemRegister(ImGuiWindow*, ImGuiID, bool) (_ZN5ImGui21FocusableItemRegisterEP11ImGuiWindowjb, funcdef_no=675, decl_uid=13793, cgraph_uid=574, symbol_order=580)

bool ImGui::FocusableItemRegister(ImGuiWindow*, ImGuiID, bool) (struct ImGuiWindow * window, ImGuiID id, bool tab_stop)
{
  bool D.25172;
  const bool allow_keyboard_focus;
  struct ImGuiContext & g;
  int D.25168;
  int D.25167;
  bool D.25164;
  int D.25161;
  int D.25160;
  int D.25158;
  int iftmp.179;
  bool D.25150;
  int iftmp.178;
  int D.25148;
  bool D.25144;
  bool D.25142;
  bool D.25141;
  int D.25139;
  int D.25137;
  unsigned int D.25135;
  bool iftmp.177;
  bool retval.176;
  int D.25128;
  int D.25127;
  int D.25124;
  int D.25123;
  int D.25122;
  int D.25121;
  bool iftmp.177_1;
  int iftmp.178_2;
  int iftmp.179_3;
  bool _4;
  int _13;
  int _14;
  int _16;
  int _17;
  int _19;
  int _20;
  unsigned int _23;
  int _25;
  int _26;
  bool _27;
  bool _28;
  bool _30;
  bool _31;
  bool iftmp.177_32;
  bool iftmp.177_33;
  bool retval.176_34;
  int _35;
  bool _36;
  int iftmp.179_37;
  int iftmp.179_38;
  int iftmp.178_39;
  int iftmp.178_40;
  int _41;
  int _43;
  int _44;
  bool _45;
  int _46;
  int _47;
  bool _49;
  bool _50;

  <bb 2>:
  g_11 = GImGui;
  _13 = window_12(D)->DC.ItemFlags;
  _14 = _13 & 5;
  allow_keyboard_focus_15 = _14 == 1;
  _16 = window_12(D)->FocusIdxAllCounter;
  _17 = _16 + 1;
  window_12(D)->FocusIdxAllCounter = _17;
  if (allow_keyboard_focus_15 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _19 = window_12(D)->FocusIdxTabCounter;
  _20 = _19 + 1;
  window_12(D)->FocusIdxTabCounter = _20;

  <bb 4>:
  if (tab_stop_22(D) != 0)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  _23 = g_11->ActiveId;
  if (_23 == id_24(D))
    goto <bb 6>;
  else
    goto <bb 11>;

  <bb 6>:
  _25 = window_12(D)->FocusIdxAllRequestNext;
  if (_25 == 2147483647)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  _26 = window_12(D)->FocusIdxTabRequestNext;
  if (_26 == 2147483647)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  _27 = g_11->IO.KeyCtrl;
  _28 = ~_27;
  if (_28 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _30 = IsKeyPressedMap (0, 1);
  _31 = _30;
  if (_31 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.177_32 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.177_33 = 0;

  <bb 12>:
  # iftmp.177_1 = PHI <iftmp.177_32(10), iftmp.177_33(11)>
  retval.176_34 = iftmp.177_1;
  if (retval.176_34 != 0)
    goto <bb 13>;
  else
    goto <bb 20>;

  <bb 13>:
  _35 = window_12(D)->FocusIdxTabCounter;
  _36 = g_11->IO.KeyShift;
  if (_36 != 0)
    goto <bb 14>;
  else
    goto <bb 18>;

  <bb 14>:
  if (allow_keyboard_focus_15 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.179_37 = -1;
  goto <bb 17>;

  <bb 16>:
  iftmp.179_38 = 0;

  <bb 17>:
  # iftmp.179_3 = PHI <iftmp.179_37(15), iftmp.179_38(16)>
  iftmp.178_39 = iftmp.179_3;
  goto <bb 19>;

  <bb 18>:
  iftmp.178_40 = 1;

  <bb 19>:
  # iftmp.178_2 = PHI <iftmp.178_39(17), iftmp.178_40(18)>
  _41 = _35 + iftmp.178_2;
  window_12(D)->FocusIdxTabRequestNext = _41;

  <bb 20>:
  _43 = window_12(D)->FocusIdxAllCounter;
  _44 = window_12(D)->FocusIdxAllRequestCurrent;
  if (_43 == _44)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _45 = 1;
  goto <bb 26> (<L26>);

  <bb 22>:
  if (allow_keyboard_focus_15 != 0)
    goto <bb 23>;
  else
    goto <bb 25>;

  <bb 23>:
  _46 = window_12(D)->FocusIdxTabCounter;
  _47 = window_12(D)->FocusIdxTabRequestCurrent;
  if (_46 == _47)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  g_11->NavJustTabbedId = id_24(D);
  _49 = 1;
  goto <bb 26> (<L26>);

  <bb 25>:
  _50 = 0;

  # _4 = PHI <_45(21), _49(24), _50(25)>
<L26>:
  return _4;

}



;; Function void ImGui::FocusableItemUnregister(ImGuiWindow*) (_ZN5ImGui23FocusableItemUnregisterEP11ImGuiWindow, funcdef_no=676, decl_uid=13795, cgraph_uid=575, symbol_order=581)

void ImGui::FocusableItemUnregister(ImGuiWindow*) (struct ImGuiWindow * window)
{
  int D.25176;
  int D.25175;
  int D.25174;
  int D.25173;
  int _3;
  int _4;
  int _6;
  int _7;

  <bb 2>:
  _3 = window_2(D)->FocusIdxAllCounter;
  _4 = _3 + -1;
  window_2(D)->FocusIdxAllCounter = _4;
  _6 = window_2(D)->FocusIdxTabCounter;
  _7 = _6 + -1;
  window_2(D)->FocusIdxTabCounter = _7;
  return;

}



;; Function ImVec2 ImGui::CalcItemSize(ImVec2, float, float) (_ZN5ImGui12CalcItemSizeE6ImVec2ff, funcdef_no=677, decl_uid=13799, cgraph_uid=576, symbol_order=582)

ImVec2 ImGui::CalcItemSize(ImVec2, float, float) (struct ImVec2 size, float default_x, float default_y)
{
  struct ImVec2 content_max;
  struct ImGuiContext & g;
  struct ImVec2 D.25214;
  float D.25211;
  float D.25210;
  float D.25209;
  float D.25208;
  struct ImGuiWindow * D.25207;
  float D.25206;
  float D.25203;
  float iftmp.181;
  float D.25199;
  float D.25196;
  float D.25195;
  float D.25194;
  float D.25193;
  struct ImGuiWindow * D.25192;
  float D.25191;
  float D.25188;
  float iftmp.180;
  float D.25184;
  struct ImVec2 * D.25183;
  struct ImGuiWindow * D.25182;
  struct ImVec2 D.16178;
  float D.25181;
  float D.25179;
  float iftmp.180_1;
  float iftmp.181_2;
  float _11;
  float _12;
  struct ImGuiWindow * _14;
  struct ImVec2 * _15;
  float _19;
  float _20;
  float _21;
  struct ImGuiWindow * _22;
  float _23;
  float _24;
  float _26;
  float _27;
  float iftmp.180_28;
  float iftmp.180_30;
  float _32;
  float _33;
  float _34;
  struct ImGuiWindow * _35;
  float _36;
  float _37;
  float _39;
  float _40;
  float iftmp.181_41;
  float iftmp.181_43;

  <bb 2>:
  g_9 = GImGui;
  ImVec2::ImVec2 (&content_max);
  _11 = size.x;
  if (_11 < 0.0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _12 = size.y;
  if (_12 < 0.0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  D.16178 = ImGui::GetContentRegionMax ();
  _14 = g_9->CurrentWindow;
  _15 = &_14->Pos;
  content_max = operator+ (_15, &D.16178);
  D.16178 ={v} {CLOBBER};

  <bb 5>:
  _19 = size.x;
  if (_19 <= 0.0)
    goto <bb 6>;
  else
    goto <bb 10>;

  <bb 6>:
  _20 = size.x;
  if (_20 != 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _21 = content_max.x;
  _22 = g_9->CurrentWindow;
  _23 = _22->DC.CursorPos.x;
  _24 = _21 - _23;
  _26 = ImMax (_24, 4.0e+0);
  _27 = size.x;
  iftmp.180_28 = _26 + _27;
  goto <bb 9>;

  <bb 8>:
  iftmp.180_30 = default_x_29(D);

  <bb 9>:
  # iftmp.180_1 = PHI <iftmp.180_28(7), iftmp.180_30(8)>
  size.x = iftmp.180_1;

  <bb 10>:
  _32 = size.y;
  if (_32 <= 0.0)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  _33 = size.y;
  if (_33 != 0.0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _34 = content_max.y;
  _35 = g_9->CurrentWindow;
  _36 = _35->DC.CursorPos.y;
  _37 = _34 - _36;
  _39 = ImMax (_37, 4.0e+0);
  _40 = size.y;
  iftmp.181_41 = _39 + _40;
  goto <bb 14>;

  <bb 13>:
  iftmp.181_43 = default_y_42(D);

  <bb 14>:
  # iftmp.181_2 = PHI <iftmp.181_41(12), iftmp.181_43(13)>
  size.y = iftmp.181_2;

  <bb 15>:
  D.25214 = size;
  content_max ={v} {CLOBBER};

<L16>:
  return D.25214;

}



;; Function float ImGui::CalcWrapWidthForPos(const ImVec2&, float) (_ZN5ImGui19CalcWrapWidthForPosERK6ImVec2f, funcdef_no=678, decl_uid=13802, cgraph_uid=577, symbol_order=583)

float ImGui::CalcWrapWidthForPos(const ImVec2&, float) (const struct ImVec2 & pos, float wrap_pos_x)
{
  struct ImGuiWindow * window;
  float D.25233;
  float D.25232;
  float D.25230;
  float D.25229;
  float D.25228;
  float D.25224;
  float D.25223;
  struct ImVec2 D.16186;
  float D.25220;
  float _2;
  float _6;
  float _11;
  float _12;
  float _14;
  float _15;
  float _16;
  float _19;
  float _20;
  float _22;

  <bb 2>:
  if (wrap_pos_x_5(D) < 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = 0.0;
  goto <bb 9> (<L8>);

  <bb 4>:
  window_9 = ImGui::GetCurrentWindowRead ();
  if (wrap_pos_x_5(D) == 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  D.16186 = ImGui::GetContentRegionMax ();
  _11 = D.16186.x;
  _12 = window_9->Pos.x;
  wrap_pos_x_13 = _11 + _12;
  goto <bb 8>;

  <bb 6>:
  if (wrap_pos_x_5(D) > 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _14 = window_9->Pos.x;
  _15 = window_9->Scroll.x;
  _16 = _14 - _15;
  wrap_pos_x_17 = _16 + wrap_pos_x_5(D);

  <bb 8>:
  # wrap_pos_x_1 = PHI <wrap_pos_x_13(5), wrap_pos_x_5(D)(6), wrap_pos_x_17(7)>
  _19 = pos_18(D)->x;
  _20 = wrap_pos_x_1 - _19;
  _22 = ImMax (_20, 1.0e+0);

  # _2 = PHI <_6(3), _22(8)>
<L8>:
  return _2;

}



;; Function void* ImGui::MemAlloc(size_t) (_ZN5ImGui8MemAllocEm, funcdef_no=679, decl_uid=3421, cgraph_uid=578, symbol_order=584)

void* ImGui::MemAlloc(size_t) (size_t sz)
{
  void * D.25241;
  void * GImAllocatorUserData.184;
  void * (*<T83b>) (size_t, void *) GImAllocatorAllocFunc.183;
  void * D.25237;
  long unsigned int D.25236;
  long unsigned int GImAllocatorActiveAllocationsCount.182;
  long unsigned int GImAllocatorActiveAllocationsCount.182_2;
  long unsigned int _3;
  void * (*<T83b>) (size_t, void *) GImAllocatorAllocFunc.183_5;
  void * GImAllocatorUserData.184_6;
  void * _9;
  void * _10;

  <bb 2>:
  GImAllocatorActiveAllocationsCount.182_2 = GImAllocatorActiveAllocationsCount;
  _3 = GImAllocatorActiveAllocationsCount.182_2 + 1;
  GImAllocatorActiveAllocationsCount = _3;
  GImAllocatorAllocFunc.183_5 = GImAllocatorAllocFunc;
  GImAllocatorUserData.184_6 = GImAllocatorUserData;
  _9 = GImAllocatorAllocFunc.183_5 (sz_7(D), GImAllocatorUserData.184_6);
  _10 = _9;

<L0>:
  return _10;

}



;; Function void ImGui::MemFree(void*) (_ZN5ImGui7MemFreeEPv, funcdef_no=680, decl_uid=3423, cgraph_uid=579, symbol_order=585)

void ImGui::MemFree(void*) (void * ptr)
{
  void * GImAllocatorUserData.187;
  void (*<T115>) (void *, void *) GImAllocatorFreeFunc.186;
  long unsigned int D.25245;
  long unsigned int GImAllocatorActiveAllocationsCount.185;
  long unsigned int GImAllocatorActiveAllocationsCount.185_4;
  long unsigned int _5;
  void (*<T115>) (void *, void *) GImAllocatorFreeFunc.186_7;
  void * GImAllocatorUserData.187_8;

  <bb 2>:
  if (ptr_2(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  GImAllocatorActiveAllocationsCount.185_4 = GImAllocatorActiveAllocationsCount;
  _5 = GImAllocatorActiveAllocationsCount.185_4 + 18446744073709551615;
  GImAllocatorActiveAllocationsCount = _5;

  <bb 4>:
  GImAllocatorFreeFunc.186_7 = GImAllocatorFreeFunc;
  GImAllocatorUserData.187_8 = GImAllocatorUserData;
  GImAllocatorFreeFunc.186_7 (ptr_2(D), GImAllocatorUserData.187_8);

<L3>:
  return;

}



;; Function const char* ImGui::GetClipboardText() (_ZN5ImGui16GetClipboardTextEv, funcdef_no=681, decl_uid=3409, cgraph_uid=580, symbol_order=586)

const char* ImGui::GetClipboardText() ()
{
  const char * D.25262;
  void * D.25259;
  struct ImGuiContext * GImGui.191;
  const char * (*<T875>) (void *) D.25257;
  struct ImGuiContext * GImGui.190;
  const char * (*<T875>) (void *) D.25253;
  struct ImGuiContext * GImGui.189;
  const char * iftmp.188;
  const char * D.25250;
  const char * iftmp.188_1;
  struct ImGuiContext * GImGui.189_4;
  const char * (*<T875>) (void *) _5;
  struct ImGuiContext * GImGui.190_6;
  const char * (*<T875>) (void *) _7;
  struct ImGuiContext * GImGui.191_8;
  void * _9;
  const char * _11;
  const char * iftmp.188_12;
  const char * iftmp.188_13;
  const char * _14;

  <bb 2>:
  GImGui.189_4 = GImGui;
  _5 = GImGui.189_4->IO.GetClipboardTextFn;
  if (_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  GImGui.190_6 = GImGui;
  _7 = GImGui.190_6->IO.GetClipboardTextFn;
  GImGui.191_8 = GImGui;
  _9 = GImGui.191_8->IO.ClipboardUserData;
  _11 = _7 (_9);
  iftmp.188_12 = _11;
  goto <bb 5>;

  <bb 4>:
  iftmp.188_13 = "";

  <bb 5>:
  # iftmp.188_1 = PHI <iftmp.188_12(3), iftmp.188_13(4)>
  _14 = iftmp.188_1;

<L3>:
  return _14;

}



;; Function void ImGui::SetClipboardText(const char*) (_ZN5ImGui16SetClipboardTextEPKc, funcdef_no=682, decl_uid=3411, cgraph_uid=581, symbol_order=587)

void ImGui::SetClipboardText(const char*) (const char * text)
{
  void * D.25270;
  struct ImGuiContext * GImGui.194;
  void (*<T877>) (void *, const char *) D.25268;
  struct ImGuiContext * GImGui.193;
  void (*<T877>) (void *, const char *) D.25264;
  struct ImGuiContext * GImGui.192;
  struct ImGuiContext * GImGui.192_3;
  void (*<T877>) (void *, const char *) _4;
  struct ImGuiContext * GImGui.193_5;
  void (*<T877>) (void *, const char *) _6;
  struct ImGuiContext * GImGui.194_7;
  void * _8;

  <bb 2>:
  GImGui.192_3 = GImGui;
  _4 = GImGui.192_3->IO.SetClipboardTextFn;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  GImGui.193_5 = GImGui;
  _6 = GImGui.193_5->IO.SetClipboardTextFn;
  GImGui.194_7 = GImGui;
  _8 = GImGui.194_7->IO.ClipboardUserData;
  _6 (_8, text_9(D));

  <bb 4>:
  return;

}



;; Function const char* ImGui::GetVersion() (_ZN5ImGui10GetVersionEv, funcdef_no=683, decl_uid=2444, cgraph_uid=582, symbol_order=588)

const char* ImGui::GetVersion() ()
{
  const char * D.25272;
  const char * _1;

  <bb 2>:
  _1 = "1.60";

<L0>:
  return _1;

}



;; Function ImGuiContext* ImGui::GetCurrentContext() (_ZN5ImGui17GetCurrentContextEv, funcdef_no=684, decl_uid=2424, cgraph_uid=583, symbol_order=589)

ImGuiContext* ImGui::GetCurrentContext() ()
{
  struct ImGuiContext * D.25274;
  struct ImGuiContext * _2;

  <bb 2>:
  _2 = GImGui;

<L0>:
  return _2;

}



;; Function void ImGui::SetCurrentContext(ImGuiContext*) (_ZN5ImGui17SetCurrentContextEP12ImGuiContext, funcdef_no=685, decl_uid=2426, cgraph_uid=584, symbol_order=590)

void ImGui::SetCurrentContext(ImGuiContext*) (struct ImGuiContext * ctx)
{
  <bb 2>:
  GImGui = ctx_2(D);
  return;

}



;; Function void ImGui::SetAllocatorFunctions(void* (*)(size_t, void*), void (*)(void*, void*), void*) (_ZN5ImGui21SetAllocatorFunctionsEPFPvmS0_EPFvS0_S0_ES0_, funcdef_no=686, decl_uid=3419, cgraph_uid=585, symbol_order=591)

void ImGui::SetAllocatorFunctions(void* (*)(size_t, void*), void (*)(void*, void*), void*) (void * (*<T83b>) (size_t, void *) alloc_func, void (*<T115>) (void *, void *) free_func, void * user_data)
{
  <bb 2>:
  GImAllocatorAllocFunc = alloc_func_2(D);
  GImAllocatorFreeFunc = free_func_4(D);
  GImAllocatorUserData = user_data_6(D);
  return;

}



;; Function ImGuiContext* ImGui::CreateContext(ImFontAtlas*) (_ZN5ImGui13CreateContextEP11ImFontAtlas, funcdef_no=687, decl_uid=2421, cgraph_uid=586, symbol_order=592)

ImGuiContext* ImGui::CreateContext(ImFontAtlas*) (struct ImFontAtlas * shared_font_atlas)
{
  void * D.46288;
  void * D.25284;
  struct ImGuiContext * ctx;
  struct ImGuiContext * D.25282;
  struct ImGuiContext * GImGui.196;
  struct ImNewDummy D.25277;
  void * ctx.195;
  void * D.16221;
  struct ImNewDummy D.25276;
  struct ImNewDummy D.16218;
  struct ImNewDummy D.16220;
  void * _6;
  void * _7;
  void * ctx.195_9;
  struct ImGuiContext * GImGui.196_15;
  struct ImGuiContext * _18;

  <bb 2>:
  D.16220 = D.25276;
  _6 = ImGui::MemAlloc (14536);

  <bb 3>:
  _7 = _6;
  ctx.195_9 = operator new (14536, D.16220, _7);
  ImGuiContext::ImGuiContext (ctx.195_9, shared_font_atlas_10(D));

  <bb 4>:
  ctx_12 = ctx.195_9;
  D.16220 ={v} {CLOBBER};
  D.16218 ={v} {CLOBBER};
  GImGui.196_15 = GImGui;
  if (GImGui.196_15 == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::SetCurrentContext (ctx_12);

  <bb 6>:
  ImGui::Initialize (ctx_12);
  _18 = ctx_12;

<L3>:
  return _18;

<L4>:
  operator delete (ctx.195_9, D.25277, _7);
  __builtin_eh_copy_values (1, 3);

<L5>:
  _20 = __builtin_eh_pointer (1);
  __builtin_unwind_resume (_20);

}



;; Function void ImGui::DestroyContext(ImGuiContext*) (_ZN5ImGui14DestroyContextEP12ImGuiContext, funcdef_no=688, decl_uid=2423, cgraph_uid=587, symbol_order=593)

void ImGui::DestroyContext(ImGuiContext*) (struct ImGuiContext * ctx)
{
  struct ImGuiContext * ctx.203;
  struct ImGuiContext * GImGui.202;
  struct ImGuiContext * ctx.201;
  struct ImGuiContext * GImGui.200;
  struct ImGuiContext * ctx.199;
  struct ImGuiContext * ctx.199_4;
  struct ImGuiContext * GImGui.200_5;
  struct ImGuiContext * ctx.201_7;
  struct ImGuiContext * GImGui.202_9;
  struct ImGuiContext * ctx.203_10;

  <bb 2>:
  ctx.199_4 = ctx;
  if (ctx.199_4 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  GImGui.200_5 = GImGui;
  ctx = GImGui.200_5;

  <bb 4>:
  ctx.201_7 = ctx;
  ImGui::Shutdown (ctx.201_7);
  GImGui.202_9 = GImGui;
  ctx.203_10 = ctx;
  if (GImGui.202_9 == ctx.203_10)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::SetCurrentContext (0B);

  <bb 6>:
  IM_DELETE<ImGuiContext> (&ctx);
  return;

}



;; Function ImGuiIO& ImGui::GetIO() (_ZN5ImGui5GetIOEv, funcdef_no=689, decl_uid=2427, cgraph_uid=588, symbol_order=594)

ImGuiIO& ImGui::GetIO() ()
{
  static const char __PRETTY_FUNCTION__[24] = "ImGuiIO& ImGui::GetIO()";
  struct ImGuiContext * GImGui.205;
  struct ImGuiIO & D.25547;
  struct ImGuiContext * GImGui.204;
  struct ImGuiContext * GImGui.204_2;
  struct ImGuiContext * GImGui.205_3;
  struct ImGuiIO & _4;

  <bb 2>:
  GImGui.204_2 = GImGui;
  if (GImGui.204_2 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("GImGui != __null && \"No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2668, &__PRETTY_FUNCTION__);

  <bb 4>:
  GImGui.205_3 = GImGui;
  _4 = &GImGui.205_3->IO;

<L3>:
  return _4;

}



;; Function ImGuiStyle& ImGui::GetStyle() (_ZN5ImGui8GetStyleEv, funcdef_no=690, decl_uid=2428, cgraph_uid=589, symbol_order=595)

ImGuiStyle& ImGui::GetStyle() ()
{
  static const char __PRETTY_FUNCTION__[30] = "ImGuiStyle& ImGui::GetStyle()";
  struct ImGuiContext * GImGui.207;
  struct ImGuiStyle & D.25554;
  struct ImGuiContext * GImGui.206;
  struct ImGuiContext * GImGui.206_2;
  struct ImGuiContext * GImGui.207_3;
  struct ImGuiStyle & _4;

  <bb 2>:
  GImGui.206_2 = GImGui;
  if (GImGui.206_2 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("GImGui != __null && \"No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2674, &__PRETTY_FUNCTION__);

  <bb 4>:
  GImGui.207_3 = GImGui;
  _4 = &GImGui.207_3->Style;

<L3>:
  return _4;

}



;; Function ImDrawData* ImGui::GetDrawData() (_ZN5ImGui11GetDrawDataEv, funcdef_no=691, decl_uid=2431, cgraph_uid=590, symbol_order=596)

ImDrawData* ImGui::GetDrawData() ()
{
  struct ImGuiContext & g;
  bool D.25559;
  struct ImDrawData * iftmp.208;
  struct ImDrawData * D.25557;
  struct ImDrawData * iftmp.208_1;
  bool _4;
  struct ImDrawData * iftmp.208_5;
  struct ImDrawData * iftmp.208_6;
  struct ImDrawData * _7;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->DrawData.Valid;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.208_5 = &g_3->DrawData;
  goto <bb 5>;

  <bb 4>:
  iftmp.208_6 = 0B;

  <bb 5>:
  # iftmp.208_1 = PHI <iftmp.208_5(3), iftmp.208_6(4)>
  _7 = iftmp.208_1;

<L3>:
  return _7;

}



;; Function float ImGui::GetTime() (_ZN5ImGui7GetTimeEv, funcdef_no=692, decl_uid=3321, cgraph_uid=591, symbol_order=597)

float ImGui::GetTime() ()
{
  struct ImGuiContext * GImGui.209;
  float D.25564;
  struct ImGuiContext * GImGui.209_2;
  float _3;

  <bb 2>:
  GImGui.209_2 = GImGui;
  _3 = GImGui.209_2->Time;

<L0>:
  return _3;

}



;; Function int ImGui::GetFrameCount() (_ZN5ImGui13GetFrameCountEv, funcdef_no=693, decl_uid=3322, cgraph_uid=592, symbol_order=598)

int ImGui::GetFrameCount() ()
{
  struct ImGuiContext * GImGui.210;
  int D.25567;
  struct ImGuiContext * GImGui.210_2;
  int _3;

  <bb 2>:
  GImGui.210_2 = GImGui;
  _3 = GImGui.210_2->FrameCount;

<L0>:
  return _3;

}



;; Function ImDrawList* ImGui::GetOverlayDrawList() (_ZN5ImGui18GetOverlayDrawListEv, funcdef_no=694, decl_uid=3323, cgraph_uid=593, symbol_order=599)

ImDrawList* ImGui::GetOverlayDrawList() ()
{
  struct ImGuiContext * GImGui.211;
  struct ImDrawList * D.25570;
  struct ImGuiContext * GImGui.211_2;
  struct ImDrawList * _3;

  <bb 2>:
  GImGui.211_2 = GImGui;
  _3 = &GImGui.211_2->OverlayDrawList;

<L0>:
  return _3;

}



;; Function ImDrawListSharedData* ImGui::GetDrawListSharedData() (_ZN5ImGui21GetDrawListSharedDataEv, funcdef_no=695, decl_uid=3324, cgraph_uid=594, symbol_order=600)

ImDrawListSharedData* ImGui::GetDrawListSharedData() ()
{
  struct ImGuiContext * GImGui.212;
  struct ImDrawListSharedData * D.25573;
  struct ImGuiContext * GImGui.212_2;
  struct ImDrawListSharedData * _3;

  <bb 2>:
  GImGui.212_2 = GImGui;
  _3 = &GImGui.212_2->DrawListSharedData;

<L0>:
  return _3;

}



;; Function void ImGui::NavInitWindow(ImGuiWindow*, bool) (_ZN5ImGui13NavInitWindowEP11ImGuiWindowb, funcdef_no=696, decl_uid=13828, cgraph_uid=595, symbol_order=601)

void ImGui::NavInitWindow(ImGuiWindow*, bool) (struct ImGuiWindow * window, bool force_reinit)
{
  bool init_for_nav;
  static const char __PRETTY_FUNCTION__[46] = "void ImGui::NavInitWindow(ImGuiWindow*, bool)";
  struct ImGuiContext & g;
  unsigned int D.25599;
  struct ImRect D.16269;
  int D.25597;
  unsigned int D.25592;
  int D.25590;
  int D.25589;
  int D.25587;
  int D.25586;
  int D.25581;
  int D.25580;
  struct ImGuiWindow * D.25576;
  struct ImGuiWindow * _6;
  int _9;
  int _10;
  int _11;
  int _12;
  int _13;
  int _14;
  unsigned int _15;
  int _18;
  unsigned int _27;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->NavWindow;
  if (_6 == window_7(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("window == g.NavWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2709, &__PRETTY_FUNCTION__);

  <bb 4>:
  init_for_nav_8 = 0;
  _9 = window_7(D)->Flags;
  _10 = _9 & 262144;
  if (_10 == 0)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  _11 = window_7(D)->Flags;
  _12 = _11 & 16777216;
  if (_12 == 0)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 6>:
  _13 = window_7(D)->Flags;
  _14 = _13 & 67108864;
  if (_14 != 0)
    goto <bb 9>;
  else
    goto <bb 7>;

  <bb 7>:
  _15 = window_7(D)->NavLastIds[0];
  if (_15 == 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  if (force_reinit_16(D) != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  init_for_nav_17 = 1;

  <bb 10>:
  # init_for_nav_1 = PHI <init_for_nav_8(8), init_for_nav_17(9)>

  <bb 11>:
  # init_for_nav_2 = PHI <init_for_nav_8(4), init_for_nav_1(10)>
  if (init_for_nav_2 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _18 = g_5->NavLayer;
  SetNavID (0, _18);
  g_5->NavInitRequest = 1;
  g_5->NavInitRequestFromMove = 0;
  g_5->NavInitResultId = 0;
  ImRect::ImRect (&D.16269);
  g_5->NavInitResultRectRel = D.16269;
  D.16269 ={v} {CLOBBER};
  NavUpdateAnyRequestFlag ();
  goto <bb 14>;

  <bb 13>:
  _27 = window_7(D)->NavLastIds[0];
  g_5->NavId = _27;

  <bb 14>:
  return;

}



;; Function ImVec2 NavCalcPreferredMousePos() (_ZL24NavCalcPreferredMousePosv, funcdef_no=697, decl_uid=16270, cgraph_uid=596, symbol_order=602)

ImVec2 NavCalcPreferredMousePos() ()
{
  struct ImRect visible_rect;
  struct ImVec2 pos;
  const struct ImRect & rect_rel;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImVec2 D.16282;
  struct ImVec2 * D.25616;
  struct ImGuiWindow * D.25615;
  float D.25614;
  float D.25613;
  float D.25612;
  float D.25611;
  float D.25610;
  float D.25609;
  float D.25608;
  float D.25607;
  float D.25606;
  float D.25605;
  float D.25604;
  struct ImVec2 D.16277;
  int D.25603;
  struct ImVec2 D.25602;
  int _6;
  float _8;
  float _10;
  float _11;
  float _13;
  float _14;
  float _15;
  float _17;
  float _18;
  float _19;
  float _21;
  float _22;
  struct ImGuiWindow * _24;
  struct ImVec2 * _25;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->NavWindow;
  if (window_4 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  D.25602 = g_3->IO.MousePos;
  goto <bb 5>;

  <bb 4>:
  _6 = g_3->NavLayer;
  rect_rel_7 = &window_4->NavRectRel[_6];
  _8 = rect_rel_7->Max.y;
  _10 = ImRect::GetHeight (rect_rel_7);
  _11 = g_3->Style.FramePadding.y;
  _13 = ImMin (_11, _10);
  _14 = _8 - _13;
  _15 = rect_rel_7->Min.x;
  _17 = ImRect::GetWidth (rect_rel_7);
  _18 = g_3->Style.FramePadding.x;
  _19 = _18 * 4.0e+0;
  _21 = ImMin (_19, _17);
  _22 = _15 + _21;
  ImVec2::ImVec2 (&D.16277, _22, _14);
  _24 = g_3->NavWindow;
  _25 = &_24->Pos;
  pos = operator+ (_25, &D.16277);
  D.16277 ={v} {CLOBBER};
  visible_rect = GetViewportRect ();
  D.16282 = ImClamp (&pos, &visible_rect.Min, visible_rect.Max);
  D.25602 = ImFloor (&D.16282);
  D.16282 ={v} {CLOBBER};

  <bb 5>:
  pos ={v} {CLOBBER};
  visible_rect ={v} {CLOBBER};

<L4>:
  return D.25602;

}



;; Function int FindWindowIndex(ImGuiWindow*) (_ZL15FindWindowIndexP11ImGuiWindow, funcdef_no=698, decl_uid=16285, cgraph_uid=597, symbol_order=603)

int FindWindowIndex(ImGuiWindow*) (struct ImGuiWindow * window)
{
  int i;
  struct ImGuiContext & g;
  int D.25648;
  struct ImGuiWindow * D.25645;
  struct ImGuiWindow * & D.25644;
  struct ImVector * D.25643;
  bool retval.213;
  int D.25639;
  int _2;
  int _7;
  struct ImVector * _9;
  struct ImGuiWindow * & _11;
  struct ImGuiWindow * _12;
  bool retval.213_14;
  int _16;
  int _17;

  <bb 2>:
  g_6 = GImGui;
  _7 = g_6->Windows.Size;
  i_8 = _7 + -1;

  <bb 3>:
  # i_1 = PHI <i_8(2), i_15(6)>
  if (i_1 < 0)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _9 = &g_6->Windows;
  _11 = ImVector<ImGuiWindow*>::operator[] (_9, i_1);
  _12 = *_11;
  retval.213_14 = _12 == window_13(D);
  if (retval.213_14 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _16 = i_1;
  goto <bb 8> (<L5>);

  <bb 6>:
  i_15 = i_1 + -1;
  goto <bb 3>;

  <bb 7>:
  _17 = -1;

  # _2 = PHI <_16(5), _17(7)>
<L5>:
  return _2;

}



;; Function ImGuiWindow* FindWindowNavigable(int, int, int) (_ZL19FindWindowNavigableiii, funcdef_no=699, decl_uid=16294, cgraph_uid=598, symbol_order=604)

ImGuiWindow* FindWindowNavigable(int, int, int) (int i_start, int i_stop, int dir)
{
  int i;
  struct ImGuiContext & g;
  struct ImGuiWindow * & D.25672;
  struct ImVector * D.25671;
  struct ImGuiWindow * D.25670;
  struct ImGuiWindow * D.25667;
  struct ImGuiWindow * & D.25666;
  struct ImVector * D.25665;
  bool retval.214;
  int D.25661;
  struct ImGuiWindow * _2;
  int _9;
  struct ImVector * _11;
  struct ImGuiWindow * & _13;
  struct ImGuiWindow * _14;
  bool retval.214_16;
  struct ImVector * _19;
  struct ImGuiWindow * & _21;
  struct ImGuiWindow * _22;
  struct ImGuiWindow * _23;

  <bb 2>:
  g_6 = GImGui;
  i_8 = i_start_7(D);

  <bb 3>:
  # i_1 = PHI <i_8(2), i_18(8)>
  if (i_1 < 0)
    goto <bb 9>;
  else
    goto <bb 4>;

  <bb 4>:
  _9 = g_6->Windows.Size;
  if (_9 <= i_1)
    goto <bb 9>;
  else
    goto <bb 5>;

  <bb 5>:
  if (i_1 == i_stop_10(D))
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 6>:
  _11 = &g_6->Windows;
  _13 = ImVector<ImGuiWindow*>::operator[] (_11, i_1);
  _14 = *_13;
  retval.214_16 = ImGui::IsWindowNavFocusable (_14);
  if (retval.214_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _19 = &g_6->Windows;
  _21 = ImVector<ImGuiWindow*>::operator[] (_19, i_1);
  _22 = *_21;
  goto <bb 10> (<L7>);

  <bb 8>:
  i_18 = i_1 + dir_17(D);
  goto <bb 3>;

  <bb 9>:
  _23 = 0B;

  # _2 = PHI <_22(7), _23(9)>
<L7>:
  return _2;

}



;; Function float ImGui::GetNavInputAmount(ImGuiNavInput, ImGuiInputReadMode) (_ZN5ImGui17GetNavInputAmountEi18ImGuiInputReadMode, funcdef_no=700, decl_uid=13834, cgraph_uid=599, symbol_order=605)

float ImGui::GetNavInputAmount(ImGuiNavInput, ImGuiInputReadMode) (ImGuiNavInput n, ImGuiInputReadMode mode)
{
  const float t;
  struct ImGuiContext & g;
  int D.25719;
  float D.25718;
  float D.25717;
  float D.25716;
  float D.25715;
  float D.25714;
  float D.25713;
  int D.25710;
  float D.25709;
  float D.25708;
  float D.25707;
  float D.25706;
  float D.25705;
  int D.25702;
  float D.25701;
  float D.25700;
  float D.25699;
  float D.25698;
  float D.25697;
  float D.25696;
  float iftmp.216;
  float D.25682;
  float iftmp.215;
  float D.25676;
  float _1;
  float iftmp.215_2;
  float iftmp.216_3;
  float _9;
  float _11;
  float iftmp.215_12;
  float iftmp.215_13;
  float _14;
  float _15;
  float iftmp.216_16;
  float iftmp.216_17;
  float _18;
  float _19;
  float _20;
  float _21;
  float _22;
  float _23;
  float _24;
  int _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  int _34;
  float _35;
  float _36;
  float _37;
  float _38;
  float _39;
  float _40;
  float _41;
  int _43;
  float _44;
  float _45;

  <bb 2>:
  g_6 = GImGui;
  if (mode_7(D) == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _9 = g_6->IO.NavInputs[n_8(D)];
  goto <bb 24> (<L22>);

  <bb 4>:
  t_10 = g_6->IO.NavInputsDownDuration[n_8(D)];
  if (t_10 < 0.0)
    goto <bb 5>;
  else
    goto <bb 10>;

  <bb 5>:
  if (mode_7(D) == 2)
    goto <bb 6>;
  else
    goto <bb 10>;

  <bb 6>:
  _11 = g_6->IO.NavInputsDownDurationPrev[n_8(D)];
  if (_11 >= 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.215_12 = 1.0e+0;
  goto <bb 9>;

  <bb 8>:
  iftmp.215_13 = 0.0;

  <bb 9>:
  # iftmp.215_2 = PHI <iftmp.215_12(7), iftmp.215_13(8)>
  _14 = iftmp.215_2;
  goto <bb 24> (<L22>);

  <bb 10>:
  if (t_10 < 0.0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _15 = 0.0;
  goto <bb 24> (<L22>);

  <bb 12>:
  if (mode_7(D) == 1)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:
  if (t_10 == 0.0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  iftmp.216_16 = 1.0e+0;
  goto <bb 16>;

  <bb 15>:
  iftmp.216_17 = 0.0;

  <bb 16>:
  # iftmp.216_3 = PHI <iftmp.216_16(14), iftmp.216_17(15)>
  _18 = iftmp.216_3;
  goto <bb 24> (<L22>);

  <bb 17>:
  if (mode_7(D) == 3)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _19 = g_6->IO.KeyRepeatRate;
  _20 = _19 * 8.00000011920928955078125e-1;
  _21 = g_6->IO.KeyRepeatDelay;
  _22 = _21 * 8.00000011920928955078125e-1;
  _23 = g_6->IO.DeltaTime;
  _24 = t_10 - _23;
  _26 = ImGui::CalcTypematicPressedRepeatAmount (t_10, _24, _22, _20);
  _27 = (float) _26;
  goto <bb 24> (<L22>);

  <bb 19>:
  if (mode_7(D) == 4)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _28 = g_6->IO.KeyRepeatRate;
  _29 = _28 * 2.0e+0;
  _30 = g_6->IO.KeyRepeatDelay;
  _31 = g_6->IO.DeltaTime;
  _32 = t_10 - _31;
  _34 = ImGui::CalcTypematicPressedRepeatAmount (t_10, _32, _30, _29);
  _35 = (float) _34;
  goto <bb 24> (<L22>);

  <bb 21>:
  if (mode_7(D) == 5)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  _36 = g_6->IO.KeyRepeatRate;
  _37 = _36 * 3.00000011920928955078125e-1;
  _38 = g_6->IO.KeyRepeatDelay;
  _39 = _38 * 8.00000011920928955078125e-1;
  _40 = g_6->IO.DeltaTime;
  _41 = t_10 - _40;
  _43 = ImGui::CalcTypematicPressedRepeatAmount (t_10, _41, _39, _37);
  _44 = (float) _43;
  goto <bb 24> (<L22>);

  <bb 23>:
  _45 = 0.0;

  # _1 = PHI <_9(3), _14(9), _15(11), _18(16), _27(18), _35(20), _44(22), _45(23)>
<L22>:
  return _1;

}



;; Function bool IsNavInputDown(ImGuiNavInput) (_ZL14IsNavInputDowni, funcdef_no=701, decl_uid=16307, cgraph_uid=600, symbol_order=606)

bool IsNavInputDown(ImGuiNavInput) (ImGuiNavInput n)
{
  float D.25723;
  struct ImGuiContext * GImGui.217;
  bool D.25721;
  struct ImGuiContext * GImGui.217_2;
  float _4;
  bool _5;

  <bb 2>:
  GImGui.217_2 = GImGui;
  _4 = GImGui.217_2->IO.NavInputs[n_3(D)];
  _5 = _4 > 0.0;

<L0>:
  return _5;

}



;; Function bool IsNavInputPressed(ImGuiNavInput, ImGuiInputReadMode) (_ZL17IsNavInputPressedi18ImGuiInputReadMode, funcdef_no=702, decl_uid=16311, cgraph_uid=601, symbol_order=607)

bool IsNavInputPressed(ImGuiNavInput, ImGuiInputReadMode) (ImGuiNavInput n, ImGuiInputReadMode mode)
{
  float D.25728;
  float D.25726;
  bool D.25725;
  float _5;
  float _6;
  bool _7;

  <bb 2>:
  _5 = ImGui::GetNavInputAmount (n_2(D), mode_3(D));
  _6 = _5;
  _7 = _6 > 0.0;

<L0>:
  return _7;

}



;; Function bool IsNavInputPressedAnyOfTwo(ImGuiNavInput, ImGuiNavInput, ImGuiInputReadMode) (_ZL25IsNavInputPressedAnyOfTwoii18ImGuiInputReadMode, funcdef_no=703, decl_uid=16316, cgraph_uid=602, symbol_order=608)

bool IsNavInputPressedAnyOfTwo(ImGuiNavInput, ImGuiNavInput, ImGuiInputReadMode) (ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode)
{
  float D.25735;
  float D.25734;
  float D.25732;
  float D.25731;
  float D.25730;
  bool D.25729;
  float _5;
  float _6;
  float _9;
  float _10;
  float _11;
  bool _12;

  <bb 2>:
  _5 = ImGui::GetNavInputAmount (n1_2(D), mode_3(D));
  _6 = _5;
  _9 = ImGui::GetNavInputAmount (n2_7(D), mode_3(D));
  _10 = _9;
  _11 = _6 + _10;
  _12 = _11 > 0.0;

<L0>:
  return _12;

}



;; Function ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags, ImGuiInputReadMode, float, float) (_ZN5ImGui19GetNavInputAmount2dEi18ImGuiInputReadModeff, funcdef_no=704, decl_uid=13839, cgraph_uid=603, symbol_order=609)

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags, ImGuiInputReadMode, float, float) (ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
  float D.25799;
  float D.25798;
  float D.25797;
  float D.25796;
  float D.25795;
  float D.25794;
  float D.25793;
  float D.25792;
  float D.25791;
  float D.25790;
  float D.25789;
  float D.25788;
  struct ImVec2 delta;
  struct ImVec2 D.25786;
  bool D.25781;
  bool iftmp.221;
  bool retval.220;
  bool D.25771;
  bool iftmp.219;
  bool retval.218;
  float D.25764;
  float D.25763;
  float D.25762;
  float D.25761;
  float D.25760;
  float D.25759;
  struct ImVec2 D.16327;
  int D.25756;
  float D.25754;
  float D.25753;
  float D.25752;
  float D.25751;
  float D.25750;
  float D.25749;
  struct ImVec2 D.16326;
  int D.25746;
  float D.25744;
  float D.25743;
  float D.25742;
  float D.25741;
  float D.25740;
  float D.25739;
  struct ImVec2 D.16325;
  int D.25736;
  bool iftmp.219_1;
  bool iftmp.221_2;
  int _16;
  float _19;
  float _20;
  float _22;
  float _23;
  float _24;
  float _26;
  float _27;
  float _29;
  float _30;
  float _31;
  int _35;
  float _37;
  float _38;
  float _40;
  float _41;
  float _42;
  float _44;
  float _45;
  float _47;
  float _48;
  float _49;
  int _53;
  float _55;
  float _56;
  float _58;
  float _59;
  float _60;
  float _62;
  float _63;
  float _65;
  float _66;
  float _67;
  bool _73;
  bool iftmp.219_74;
  bool iftmp.219_75;
  bool retval.218_76;
  bool _80;
  bool iftmp.221_81;
  bool iftmp.221_82;
  bool retval.220_83;

  <bb 2>:
  ImVec2::ImVec2 (&delta, 0.0, 0.0);
  _16 = dir_sources_15(D) & 1;
  if (_16 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _19 = ImGui::GetNavInputAmount (20, mode_17(D));
  _20 = _19;
  _22 = ImGui::GetNavInputAmount (19, mode_17(D));
  _23 = _22;
  _24 = _20 - _23;
  _26 = ImGui::GetNavInputAmount (18, mode_17(D));
  _27 = _26;
  _29 = ImGui::GetNavInputAmount (17, mode_17(D));
  _30 = _29;
  _31 = _27 - _30;
  ImVec2::ImVec2 (&D.16325, _31, _24);
  operator+= (&delta, &D.16325);
  D.16325 ={v} {CLOBBER};

  <bb 4>:
  _35 = dir_sources_15(D) & 2;
  if (_35 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _37 = ImGui::GetNavInputAmount (7, mode_17(D));
  _38 = _37;
  _40 = ImGui::GetNavInputAmount (6, mode_17(D));
  _41 = _40;
  _42 = _38 - _41;
  _44 = ImGui::GetNavInputAmount (5, mode_17(D));
  _45 = _44;
  _47 = ImGui::GetNavInputAmount (4, mode_17(D));
  _48 = _47;
  _49 = _45 - _48;
  ImVec2::ImVec2 (&D.16326, _49, _42);
  operator+= (&delta, &D.16326);
  D.16326 ={v} {CLOBBER};

  <bb 6>:
  _53 = dir_sources_15(D) & 4;
  if (_53 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _55 = ImGui::GetNavInputAmount (11, mode_17(D));
  _56 = _55;
  _58 = ImGui::GetNavInputAmount (10, mode_17(D));
  _59 = _58;
  _60 = _56 - _59;
  _62 = ImGui::GetNavInputAmount (9, mode_17(D));
  _63 = _62;
  _65 = ImGui::GetNavInputAmount (8, mode_17(D));
  _66 = _65;
  _67 = _63 - _66;
  ImVec2::ImVec2 (&D.16327, _67, _60);
  operator+= (&delta, &D.16327);
  D.16327 ={v} {CLOBBER};

  <bb 8>:
  if (slow_factor_71(D) != 0.0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _73 = IsNavInputDown (14);
  if (_73 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.219_74 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.219_75 = 0;

  <bb 12>:
  # iftmp.219_1 = PHI <iftmp.219_74(10), iftmp.219_75(11)>
  retval.218_76 = iftmp.219_1;
  if (retval.218_76 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  operator*= (&delta, slow_factor_71(D));

  <bb 14>:
  if (fast_factor_78(D) != 0.0)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  _80 = IsNavInputDown (15);
  if (_80 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.221_81 = 1;
  goto <bb 18>;

  <bb 17>:
  iftmp.221_82 = 0;

  <bb 18>:
  # iftmp.221_2 = PHI <iftmp.221_81(16), iftmp.221_82(17)>
  retval.220_83 = iftmp.221_2;
  if (retval.220_83 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  operator*= (&delta, fast_factor_78(D));

  <bb 20>:
  D.25786 = delta;
  delta ={v} {CLOBBER};

<L24>:
  return D.25786;

}



;; Function void NavUpdateWindowingHighlightWindow(int) (_ZL33NavUpdateWindowingHighlightWindowi, funcdef_no=705, decl_uid=16330, cgraph_uid=604, symbol_order=610)

void NavUpdateWindowingHighlightWindow(int) (int focus_change_dir)
{
  struct ImGuiWindow * D.25838;
  struct ImGuiWindow * D.25837;
  const int D.25836;
  struct ImGuiWindow * window_target;
  const int i_current;
  static const char __PRETTY_FUNCTION__[44] = "void NavUpdateWindowingHighlightWindow(int)";
  struct ImGuiContext & g;
  int D.25832;
  int iftmp.222;
  int D.25826;
  struct ImGuiWindow * D.25825;
  int D.25822;
  int D.25821;
  struct ImGuiWindow * D.25820;
  struct ImGuiWindow * D.25816;
  int iftmp.222_2;
  struct ImGuiWindow * _7;
  struct ImGuiWindow * _8;
  int _9;
  int _10;
  struct ImGuiWindow * _11;
  const int _13;
  int _16;
  struct ImGuiWindow * _18;
  int _20;
  int iftmp.222_21;
  int iftmp.222_22;
  struct ImGuiWindow * _24;

  <bb 2>:
  g_6 = GImGui;
  _7 = g_6->NavWindowingTarget;
  if (_7 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.NavWindowingTarget", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 2817, &__PRETTY_FUNCTION__);

  <bb 4>:
  _8 = g_6->NavWindowingTarget;
  _9 = _8->Flags;
  _10 = _9 & 134217728;
  if (_10 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 12> (<L11>);

  <bb 6>:
  _11 = g_6->NavWindowingTarget;
  _13 = FindWindowIndex (_11);
  i_current_14 = _13;
  _16 = i_current_14 + focus_change_dir_15(D);
  _18 = FindWindowNavigable (_16, -2147483647, focus_change_dir_15(D));
  window_target_19 = _18;
  if (window_target_19 == 0B)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  if (focus_change_dir_15(D) < 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _20 = g_6->Windows.Size;
  iftmp.222_21 = _20 + -1;
  goto <bb 10>;

  <bb 9>:
  iftmp.222_22 = 0;

  <bb 10>:
  # iftmp.222_2 = PHI <iftmp.222_21(8), iftmp.222_22(9)>
  _24 = FindWindowNavigable (iftmp.222_2, i_current_14, focus_change_dir_15(D));
  window_target_25 = _24;

  <bb 11>:
  # window_target_1 = PHI <window_target_19(6), window_target_25(10)>
  g_6->NavWindowingTarget = window_target_1;
  g_6->NavWindowingToggleLayer = 0;

<L11>:
  return;

}



;; Function void ImGui::NavUpdateWindowing() (_ZN5ImGuiL18NavUpdateWindowingEv, funcdef_no=706, decl_uid=15113, cgraph_uid=605, symbol_order=611)

void ImGui::NavUpdateWindowing() ()
{
  bool D.26063;
  bool D.26062;
  bool D.26061;
  bool D.26060;
  struct ImGuiWindow * D.26059;
  bool D.26058;
  bool D.26057;
  struct ImGuiWindow * old_nav_window;
  struct ImGuiWindow * new_nav_window;
  const float move_speed;
  const float NAV_MOVE_SPEED;
  struct ImVec2 move_delta;
  const int focus_change_dir;
  struct ImGuiWindow * window;
  bool start_windowing_with_keyboard;
  bool start_windowing_with_gamepad;
  bool apply_toggle_layer;
  struct ImGuiWindow * apply_focus_window;
  struct ImGuiContext & g;
  int D.26054;
  int D.26051;
  int D.26050;
  struct ImGuiWindow * D.26049;
  int iftmp.234;
  struct ImGuiWindow * D.26044;
  int D.26042;
  int D.26041;
  int D.26039;
  int D.26038;
  int D.26036;
  int D.26035;
  struct ImGuiWindow * D.26031;
  int D.26022;
  unsigned int D.26018;
  struct ImGuiWindow * D.26017;
  struct ImGuiWindow * D.26016;
  struct ImGuiWindow * D.26014;
  struct ImGuiWindow * D.26008;
  struct ImVec2 * D.26007;
  struct ImGuiWindow * D.26006;
  struct ImVec2 D.16350;
  float D.26005;
  float D.26004;
  float D.26003;
  float D.26002;
  float D.26001;
  float D.26000;
  float D.25999;
  float D.25997;
  ImGuiInputSource D.25991;
  bool D.25987;
  bool D.25986;
  ImGuiInputSource D.25983;
  int D.25980;
  int D.25979;
  struct ImGuiWindow * D.25978;
  struct ImGuiWindow * D.25975;
  bool D.25970;
  struct ImVec2 * D.25969;
  bool D.25968;
  struct ImVec2 * D.25967;
  bool retval.233;
  bool D.25962;
  bool D.25961;
  unsigned int D.25959;
  bool iftmp.232;
  bool retval.231;
  bool D.25949;
  bool D.25948;
  bool D.25943;
  int iftmp.230;
  bool retval.229;
  float D.25938;
  float D.25937;
  float D.25936;
  float D.25935;
  float D.25934;
  float D.25933;
  ImGuiInputSource D.25930;
  struct ImGuiWindow * D.25927;
  bool D.25921;
  bool D.25920;
  struct ImGuiWindow * D.25918;
  bool D.25916;
  bool D.25913;
  int D.25912;
  int D.25911;
  bool D.25910;
  float D.25909;
  int D.25908;
  bool D.25907;
  bool D.25904;
  bool retval.228;
  int D.25899;
  bool D.25898;
  int D.25897;
  bool D.25896;
  float D.25895;
  float D.25894;
  float D.25893;
  float D.25892;
  float D.25891;
  float D.25890;
  ImGuiInputSource D.25887;
  struct ImGuiWindow * D.25884;
  float D.25883;
  float D.25882;
  float D.25881;
  ImGuiInputSource iftmp.227;
  bool iftmp.226;
  float D.25871;
  struct ImGuiWindow * D.25870;
  int D.25867;
  int D.25866;
  struct ImGuiWindow * D.25862;
  struct ImGuiWindow * iftmp.225;
  int D.25856;
  int D.25855;
  bool D.25853;
  bool D.25851;
  struct ImGuiWindow * D.25849;
  bool iftmp.224;
  bool D.25844;
  struct ImGuiWindow * D.25842;
  bool iftmp.223;
  bool iftmp.223_11;
  bool iftmp.224_12;
  struct ImGuiWindow * iftmp.225_13;
  bool iftmp.226_14;
  ImGuiInputSource iftmp.227_15;
  int iftmp.230_16;
  bool iftmp.232_17;
  int iftmp.234_18;
  struct ImGuiWindow * _47;
  bool _49;
  bool _50;
  bool iftmp.223_51;
  bool iftmp.223_52;
  struct ImGuiWindow * _54;
  bool _55;
  bool _57;
  bool _58;
  int _59;
  int _60;
  bool iftmp.224_61;
  bool iftmp.224_62;
  struct ImGuiWindow * _64;
  struct ImGuiWindow * iftmp.225_65;
  int _66;
  int _67;
  struct ImGuiWindow * _69;
  struct ImGuiWindow * iftmp.225_70;
  struct ImGuiWindow * _72;
  float _75;
  bool iftmp.226_77;
  bool iftmp.226_78;
  ImGuiInputSource iftmp.227_80;
  ImGuiInputSource iftmp.227_81;
  float _83;
  float _84;
  float _85;
  struct ImGuiWindow * _87;
  ImGuiInputSource _88;
  float _89;
  float _90;
  float _91;
  float _93;
  float _94;
  float _96;
  bool _99;
  bool _100;
  int _101;
  bool _103;
  bool _104;
  int _105;
  bool _110;
  bool retval.228_111;
  bool _112;
  int _113;
  float _114;
  bool _115;
  int _116;
  int _117;
  bool _118;
  bool _120;
  struct ImGuiWindow * _121;
  bool _123;
  bool _124;
  struct ImGuiWindow * _127;
  ImGuiInputSource _128;
  float _129;
  float _130;
  float _131;
  float _133;
  float _134;
  float _136;
  bool _139;
  bool retval.229_140;
  bool _141;
  int iftmp.230_142;
  int iftmp.230_143;
  bool _145;
  bool _146;
  unsigned int _148;
  bool _149;
  bool _151;
  bool _152;
  bool iftmp.232_153;
  bool iftmp.232_154;
  bool retval.231_155;
  struct ImVec2 * _156;
  bool _158;
  struct ImVec2 * _159;
  bool _161;
  bool retval.233_162;
  struct ImGuiWindow * _164;
  struct ImGuiWindow * _165;
  int _166;
  int _167;
  ImGuiInputSource _169;
  bool _170;
  bool _171;
  ImGuiInputSource _173;
  float _175;
  float _176;
  float _178;
  float _179;
  float _180;
  float _181;
  float _183;
  float _184;
  struct ImGuiWindow * _188;
  struct ImVec2 * _189;
  struct ImGuiWindow * _193;
  struct ImGuiWindow * _197;
  struct ImGuiWindow * _198;
  struct ImGuiWindow * _199;
  unsigned int _206;
  int _208;
  struct ImGuiWindow * _211;
  int _213;
  int _214;
  int _215;
  int _216;
  int _217;
  int _218;
  struct ImGuiWindow * _220;
  struct ImGuiWindow * _226;
  int _227;
  int _228;
  int _229;
  int iftmp.234_230;
  int iftmp.234_231;

  <bb 2>:
  g_44 = GImGui;
  apply_focus_window_45 = 0B;
  apply_toggle_layer_46 = 0;
  _47 = g_44->NavWindowingTarget;
  if (_47 == 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _49 = IsNavInputPressed (3, 1);
  _50 = _49;
  if (_50 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.223_51 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.223_52 = 0;

  <bb 6>:
  # iftmp.223_11 = PHI <iftmp.223_51(4), iftmp.223_52(5)>
  start_windowing_with_gamepad_53 = iftmp.223_11;
  _54 = g_44->NavWindowingTarget;
  if (_54 == 0B)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  _55 = g_44->IO.KeyCtrl;
  if (_55 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  _57 = IsKeyPressedMap (0, 1);
  _58 = _57;
  if (_58 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _59 = g_44->IO.ConfigFlags;
  _60 = _59 & 1;
  if (_60 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.224_61 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.224_62 = 0;

  <bb 12>:
  # iftmp.224_12 = PHI <iftmp.224_61(10), iftmp.224_62(11)>
  start_windowing_with_keyboard_63 = iftmp.224_12;
  if (start_windowing_with_gamepad_53 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  if (start_windowing_with_keyboard_63 != 0)
    goto <bb 14>;
  else
    goto <bb 25>;

  <bb 14>:
  _64 = g_44->NavWindow;
  if (_64 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.225_65 = g_44->NavWindow;
  goto <bb 17>;

  <bb 16>:
  _66 = g_44->Windows.Size;
  _67 = _66 + -1;
  _69 = FindWindowNavigable (_67, -2147483647, -1);
  iftmp.225_70 = _69;

  <bb 17>:
  # iftmp.225_13 = PHI <iftmp.225_65(15), iftmp.225_70(16)>
  window_71 = iftmp.225_13;
  if (window_71 != 0B)
    goto <bb 18>;
  else
    goto <bb 25>;

  <bb 18>:
  _72 = window_71->RootWindowForTabbing;
  g_44->NavWindowingTarget = _72;
  g_44->NavWindowingHighlightAlpha = 0.0;
  _75 = g_44->NavWindowingHighlightAlpha;
  g_44->NavWindowingHighlightTimer = _75;
  if (start_windowing_with_keyboard_63 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  iftmp.226_77 = 0;
  goto <bb 21>;

  <bb 20>:
  iftmp.226_78 = 1;

  <bb 21>:
  # iftmp.226_14 = PHI <iftmp.226_77(19), iftmp.226_78(20)>
  g_44->NavWindowingToggleLayer = iftmp.226_14;
  if (start_windowing_with_keyboard_63 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  iftmp.227_80 = 3;
  goto <bb 24>;

  <bb 23>:
  iftmp.227_81 = 4;

  <bb 24>:
  # iftmp.227_15 = PHI <iftmp.227_80(22), iftmp.227_81(23)>
  g_44->NavInputSource = iftmp.227_15;

  <bb 25>:
  _83 = g_44->NavWindowingHighlightTimer;
  _84 = g_44->IO.DeltaTime;
  _85 = _83 + _84;
  g_44->NavWindowingHighlightTimer = _85;
  _87 = g_44->NavWindowingTarget;
  if (_87 != 0B)
    goto <bb 26>;
  else
    goto <bb 37>;

  <bb 26>:
  _88 = g_44->NavInputSource;
  if (_88 == 4)
    goto <bb 27>;
  else
    goto <bb 37>;

  <bb 27>:
  _89 = g_44->NavWindowingHighlightTimer;
  _90 = _89 - 2.0000000298023223876953125e-1;
  _91 = _90 / 5.00000007450580596923828125e-2;
  _93 = ImSaturate (_91);
  _94 = g_44->NavWindowingHighlightAlpha;
  _96 = ImMax (_94, _93);
  g_44->NavWindowingHighlightAlpha = _96;
  _99 = IsNavInputPressed (12, 4);
  _100 = _99;
  _101 = (int) _100;
  _103 = IsNavInputPressed (13, 4);
  _104 = _103;
  _105 = (int) _104;
  focus_change_dir_106 = _101 - _105;
  if (focus_change_dir_106 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  NavUpdateWindowingHighlightWindow (focus_change_dir_106);
  g_44->NavWindowingHighlightAlpha = 1.0e+0;

  <bb 29>:
  _110 = IsNavInputDown (3);
  retval.228_111 = ~_110;
  if (retval.228_111 != 0)
    goto <bb 30>;
  else
    goto <bb 36>;

  <bb 30>:
  _112 = g_44->NavWindowingToggleLayer;
  _113 = (int) _112;
  _114 = g_44->NavWindowingHighlightAlpha;
  _115 = _114 < 1.0e+0;
  _116 = (int) _115;
  _117 = _113 & _116;
  _118 = _117 != 0;
  g_44->NavWindowingToggleLayer = _118;
  _120 = g_44->NavWindowingToggleLayer;
  if (_120 != 0)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  _121 = g_44->NavWindow;
  if (_121 != 0B)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  apply_toggle_layer_122 = 1;
  goto <bb 35>;

  <bb 33>:
  _123 = g_44->NavWindowingToggleLayer;
  _124 = ~_123;
  if (_124 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  apply_focus_window_125 = g_44->NavWindowingTarget;

  <bb 35>:
  # apply_focus_window_1 = PHI <apply_focus_window_45(32), apply_focus_window_45(33), apply_focus_window_125(34)>
  # apply_toggle_layer_6 = PHI <apply_toggle_layer_122(32), apply_toggle_layer_46(33), apply_toggle_layer_46(34)>
  g_44->NavWindowingTarget = 0B;

  <bb 36>:
  # apply_focus_window_2 = PHI <apply_focus_window_45(29), apply_focus_window_1(35)>
  # apply_toggle_layer_7 = PHI <apply_toggle_layer_46(29), apply_toggle_layer_6(35)>

  <bb 37>:
  # apply_focus_window_3 = PHI <apply_focus_window_45(25), apply_focus_window_45(26), apply_focus_window_2(36)>
  # apply_toggle_layer_8 = PHI <apply_toggle_layer_46(25), apply_toggle_layer_46(26), apply_toggle_layer_7(36)>
  _127 = g_44->NavWindowingTarget;
  if (_127 != 0B)
    goto <bb 38>;
  else
    goto <bb 46>;

  <bb 38>:
  _128 = g_44->NavInputSource;
  if (_128 == 3)
    goto <bb 39>;
  else
    goto <bb 46>;

  <bb 39>:
  _129 = g_44->NavWindowingHighlightTimer;
  _130 = _129 - 1.500000059604644775390625e-1;
  _131 = _130 / 3.9999999105930328369140625e-2;
  _133 = ImSaturate (_131);
  _134 = g_44->NavWindowingHighlightAlpha;
  _136 = ImMax (_134, _133);
  g_44->NavWindowingHighlightAlpha = _136;
  _139 = IsKeyPressedMap (0, 1);
  retval.229_140 = _139;
  if (retval.229_140 != 0)
    goto <bb 40>;
  else
    goto <bb 44>;

  <bb 40>:
  _141 = g_44->IO.KeyShift;
  if (_141 != 0)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  iftmp.230_142 = 1;
  goto <bb 43>;

  <bb 42>:
  iftmp.230_143 = -1;

  <bb 43>:
  # iftmp.230_16 = PHI <iftmp.230_142(41), iftmp.230_143(42)>
  NavUpdateWindowingHighlightWindow (iftmp.230_16);

  <bb 44>:
  _145 = g_44->IO.KeyCtrl;
  _146 = ~_145;
  if (_146 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  apply_focus_window_147 = g_44->NavWindowingTarget;

  <bb 46>:
  # apply_focus_window_4 = PHI <apply_focus_window_3(37), apply_focus_window_3(38), apply_focus_window_147(45), apply_focus_window_3(44)>
  _148 = g_44->ActiveId;
  if (_148 == 0)
    goto <bb 48>;
  else
    goto <bb 47>;

  <bb 47>:
  _149 = g_44->ActiveIdAllowOverlap;
  if (_149 != 0)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  _151 = IsNavInputPressed (16, 2);
  _152 = _151;
  if (_152 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.232_153 = 1;
  goto <bb 51>;

  <bb 50>:
  iftmp.232_154 = 0;

  <bb 51>:
  # iftmp.232_17 = PHI <iftmp.232_153(49), iftmp.232_154(50)>
  retval.231_155 = iftmp.232_17;
  if (retval.231_155 != 0)
    goto <bb 52>;
  else
    goto <bb 54>;

  <bb 52>:
  _156 = &g_44->IO.MousePos;
  _158 = ImGui::IsMousePosValid (_156);
  _159 = &g_44->IO.MousePosPrev;
  _161 = ImGui::IsMousePosValid (_159);
  retval.233_162 = _158 == _161;
  if (retval.233_162 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  apply_toggle_layer_163 = 1;

  <bb 54>:
  # apply_toggle_layer_9 = PHI <apply_toggle_layer_8(51), apply_toggle_layer_163(53), apply_toggle_layer_8(52)>
  _164 = g_44->NavWindowingTarget;
  if (_164 != 0B)
    goto <bb 55>;
  else
    goto <bb 65>;

  <bb 55>:
  _165 = g_44->NavWindowingTarget;
  _166 = _165->Flags;
  _167 = _166 & 4;
  if (_167 == 0)
    goto <bb 56>;
  else
    goto <bb 65>;

  <bb 56>:
  ImVec2::ImVec2 (&move_delta);
  _169 = g_44->NavInputSource;
  if (_169 == 3)
    goto <bb 57>;
  else
    goto <bb 59>;

  <bb 57>:
  _170 = g_44->IO.KeyShift;
  _171 = ~_170;
  if (_171 != 0)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  move_delta = ImGui::GetNavInputAmount2d (1, 0, 0.0, 0.0);

  <bb 59>:
  _173 = g_44->NavInputSource;
  if (_173 == 4)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  move_delta = ImGui::GetNavInputAmount2d (4, 0, 0.0, 0.0);

  <bb 61>:
  _175 = move_delta.x;
  if (_175 != 0.0)
    goto <bb 63>;
  else
    goto <bb 62>;

  <bb 62>:
  _176 = move_delta.y;
  if (_176 != 0.0)
    goto <bb 63>;
  else
    goto <bb 64>;

  <bb 63>:
  NAV_MOVE_SPEED_177 = 8.0e+2;
  _178 = g_44->IO.DeltaTime;
  _179 = _178 * 8.0e+2;
  _180 = g_44->IO.DisplayFramebufferScale.y;
  _181 = g_44->IO.DisplayFramebufferScale.x;
  _183 = ImMin (_181, _180);
  _184 = _179 * _183;
  move_speed_186 = ImFloor (_184);
  D.16350 = operator* (&move_delta, move_speed_186);
  _188 = g_44->NavWindowingTarget;
  _189 = &_188->PosFloat;
  operator+= (_189, &D.16350);
  D.16350 ={v} {CLOBBER};
  g_44->NavDisableMouseHover = 1;
  _193 = g_44->NavWindowingTarget;
  MarkIniSettingsDirty (_193);

  <bb 64>:
  move_delta ={v} {CLOBBER};

  <bb 65>:
  if (apply_focus_window_4 != 0B)
    goto <bb 66>;
  else
    goto <bb 72>;

  <bb 66>:
  _197 = g_44->NavWindow;
  if (_197 == 0B)
    goto <bb 68>;
  else
    goto <bb 67>;

  <bb 67>:
  _198 = g_44->NavWindow;
  _199 = _198->RootWindowForTabbing;
  if (_199 != apply_focus_window_4)
    goto <bb 68>;
  else
    goto <bb 72>;

  <bb 68>:
  g_44->NavDisableHighlight = 0;
  g_44->NavDisableMouseHover = 1;
  apply_focus_window_203 = NavRestoreLastChildNavWindow (apply_focus_window_4);
  ImGui::ClosePopupsOverWindow (apply_focus_window_203);
  ImGui::FocusWindow (apply_focus_window_203);
  _206 = apply_focus_window_203->NavLastIds[0];
  if (_206 == 0)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  ImGui::NavInitWindow (apply_focus_window_203, 0);

  <bb 70>:
  _208 = apply_focus_window_203->DC.NavLayerActiveMask;
  if (_208 == 2)
    goto <bb 71>;
  else
    goto <bb 72>;

  <bb 71>:
  g_44->NavLayer = 1;

  <bb 72>:
  # apply_focus_window_5 = PHI <apply_focus_window_4(65), apply_focus_window_4(67), apply_focus_window_203(70), apply_focus_window_203(71)>
  if (apply_focus_window_5 != 0B)
    goto <bb 73>;
  else
    goto <bb 74>;

  <bb 73>:
  g_44->NavWindowingTarget = 0B;

  <bb 74>:
  if (apply_toggle_layer_9 != 0)
    goto <bb 75>;
  else
    goto <bb 87>;

  <bb 75>:
  _211 = g_44->NavWindow;
  if (_211 != 0B)
    goto <bb 76>;
  else
    goto <bb 87>;

  <bb 76>:
  new_nav_window_212 = g_44->NavWindow;

  <bb 77>:
  # new_nav_window_10 = PHI <new_nav_window_212(76), new_nav_window_219(80)>
  _213 = new_nav_window_10->DC.NavLayerActiveMask;
  _214 = _213 & 2;
  if (_214 != 0)
    goto <bb 81>;
  else
    goto <bb 78>;

  <bb 78>:
  _215 = new_nav_window_10->Flags;
  _216 = _215 & 16777216;
  if (_216 == 0)
    goto <bb 81>;
  else
    goto <bb 79>;

  <bb 79>:
  _217 = new_nav_window_10->Flags;
  _218 = _217 & 335544320;
  if (_218 != 0)
    goto <bb 81>;
  else
    goto <bb 80>;

  <bb 80>:
  new_nav_window_219 = new_nav_window_10->ParentWindow;
  goto <bb 77>;

  <bb 81>:
  _220 = g_44->NavWindow;
  if (_220 != new_nav_window_10)
    goto <bb 82>;
  else
    goto <bb 83>;

  <bb 82>:
  old_nav_window_221 = g_44->NavWindow;
  ImGui::FocusWindow (new_nav_window_10);
  new_nav_window_10->NavLastChildNavWindow = old_nav_window_221;

  <bb 83>:
  g_44->NavDisableHighlight = 0;
  g_44->NavDisableMouseHover = 1;
  _226 = g_44->NavWindow;
  _227 = _226->DC.NavLayerActiveMask;
  _228 = _227 & 2;
  if (_228 != 0)
    goto <bb 84>;
  else
    goto <bb 85>;

  <bb 84>:
  _229 = g_44->NavLayer;
  iftmp.234_230 = _229 ^ 1;
  goto <bb 86>;

  <bb 85>:
  iftmp.234_231 = 0;

  <bb 86>:
  # iftmp.234_18 = PHI <iftmp.234_230(84), iftmp.234_231(85)>
  NavRestoreLayer (iftmp.234_18);

  <bb 87>:
  return;

}



;; Function void NavScrollToBringItemIntoView(ImGuiWindow*, ImRect&) (_ZL28NavScrollToBringItemIntoViewP11ImGuiWindowR6ImRect, funcdef_no=707, decl_uid=16357, cgraph_uid=606, symbol_order=612)

void NavScrollToBringItemIntoView(ImGuiWindow*, ImRect&) (struct ImGuiWindow * window, struct ImRect & item_rect_rel)
{
  struct ImVec2 next_scroll;
  struct ImGuiContext & g;
  struct ImRect window_rect_rel;
  struct ImVec2 * D.26117;
  struct ImVec2 D.16369;
  float D.26115;
  float D.26114;
  float D.26113;
  float D.26112;
  float D.26111;
  float D.26108;
  float D.26107;
  float D.26105;
  float D.26104;
  float D.26103;
  float D.26102;
  float D.26101;
  float D.26098;
  float D.26097;
  float D.26095;
  float D.26094;
  float D.26093;
  float D.26092;
  float D.26091;
  float D.26088;
  float D.26087;
  bool D.26084;
  float D.26083;
  float D.26082;
  float D.26081;
  float D.26080;
  float D.26079;
  float D.26077;
  float D.26076;
  bool D.26074;
  bool retval.235;
  struct ImVec2 * D.26068;
  struct ImVec2 * D.26067;
  struct ImVec2 D.16360;
  struct ImVec2 D.16361;
  struct ImVec2 D.16362;
  struct ImVec2 * D.26066;
  struct ImVec2 * D.26065;
  struct ImVec2 D.16363;
  struct ImVec2 D.16364;
  struct ImVec2 D.16365;
  struct ImVec2 * _7;
  struct ImVec2 * _8;
  struct ImVec2 * _12;
  struct ImVec2 * _13;
  bool retval.235_25;
  bool _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  float _33;
  float _34;
  bool _37;
  float _38;
  float _39;
  float _40;
  float _41;
  float _42;
  float _43;
  float _44;
  float _47;
  float _48;
  float _49;
  float _50;
  float _51;
  float _52;
  float _53;
  float _56;
  float _57;
  float _58;
  float _59;
  float _60;
  float _61;
  float _62;
  struct ImVec2 * _66;

  <bb 2>:
  ImVec2::ImVec2 (&D.16364, 1.0e+0, 1.0e+0);
  _7 = &window_6(D)->Pos;
  _8 = &window_6(D)->InnerRect.Max;
  D.16363 = operator- (_8, _7);
  D.16365 = operator+ (&D.16363, &D.16364);
  ImVec2::ImVec2 (&D.16361, 1.0e+0, 1.0e+0);
  _12 = &window_6(D)->Pos;
  _13 = &window_6(D)->InnerRect.Min;
  D.16360 = operator- (_13, _12);
  D.16362 = operator- (&D.16360, &D.16361);
  ImRect::ImRect (&window_rect_rel, &D.16362, &D.16365);
  D.16362 ={v} {CLOBBER};
  D.16360 ={v} {CLOBBER};
  D.16361 ={v} {CLOBBER};
  D.16365 ={v} {CLOBBER};
  D.16363 ={v} {CLOBBER};
  D.16364 ={v} {CLOBBER};
  retval.235_25 = ImRect::Contains (&window_rect_rel, item_rect_rel_23(D));
  if (retval.235_25 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  window_rect_rel ={v} {CLOBBER};
  next_scroll ={v} {CLOBBER};
  goto <bb 15> (<L19>);

  <bb 4>:
  g_26 = GImGui;
  _27 = window_6(D)->ScrollbarX;
  if (_27 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _28 = item_rect_rel_23(D)->Min.x;
  _29 = window_rect_rel.Min.x;
  if (_28 < _29)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _30 = item_rect_rel_23(D)->Min.x;
  _31 = window_6(D)->Scroll.x;
  _32 = _30 + _31;
  _33 = g_26->Style.ItemSpacing.x;
  _34 = _32 - _33;
  window_6(D)->ScrollTarget.x = _34;
  window_6(D)->ScrollTargetCenterRatio.x = 0.0;
  goto <bb 10>;

  <bb 7>:
  _37 = window_6(D)->ScrollbarX;
  if (_37 != 0)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _38 = item_rect_rel_23(D)->Max.x;
  _39 = window_rect_rel.Max.x;
  if (_38 >= _39)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _40 = item_rect_rel_23(D)->Max.x;
  _41 = window_6(D)->Scroll.x;
  _42 = _40 + _41;
  _43 = g_26->Style.ItemSpacing.x;
  _44 = _42 + _43;
  window_6(D)->ScrollTarget.x = _44;
  window_6(D)->ScrollTargetCenterRatio.x = 1.0e+0;

  <bb 10>:
  _47 = item_rect_rel_23(D)->Min.y;
  _48 = window_rect_rel.Min.y;
  if (_47 < _48)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _49 = item_rect_rel_23(D)->Min.y;
  _50 = window_6(D)->Scroll.y;
  _51 = _49 + _50;
  _52 = g_26->Style.ItemSpacing.y;
  _53 = _51 - _52;
  window_6(D)->ScrollTarget.y = _53;
  window_6(D)->ScrollTargetCenterRatio.y = 0.0;
  goto <bb 14>;

  <bb 12>:
  _56 = item_rect_rel_23(D)->Max.y;
  _57 = window_rect_rel.Max.y;
  if (_56 >= _57)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _58 = item_rect_rel_23(D)->Max.y;
  _59 = window_6(D)->Scroll.y;
  _60 = _58 + _59;
  _61 = g_26->Style.ItemSpacing.y;
  _62 = _60 + _61;
  window_6(D)->ScrollTarget.y = _62;
  window_6(D)->ScrollTargetCenterRatio.y = 1.0e+0;

  <bb 14>:
  next_scroll = CalcNextScrollFromScrollTargetAndClamp (window_6(D));
  _66 = &window_6(D)->Scroll;
  D.16369 = operator- (_66, &next_scroll);
  ImRect::Translate (item_rect_rel_23(D), &D.16369);
  D.16369 ={v} {CLOBBER};
  window_rect_rel ={v} {CLOBBER};
  next_scroll ={v} {CLOBBER};

<L19>:
  return;

}



;; Function void ImGui::NavUpdate() (_ZN5ImGuiL9NavUpdateEv, funcdef_no=708, decl_uid=15112, cgraph_uid=607, symbol_order=613)

void ImGui::NavUpdate() ()
{
  bool D.26795;
  bool D.26794;
  bool D.26793;
  bool D.26792;
  bool D.26791;
  bool D.26790;
  bool D.26789;
  float pad;
  struct ImRect window_rect_rel;
  struct ImGuiWindow * window;
  struct ImVec2 scroll_dir;
  const float scroll_speed;
  struct ImGuiWindow * window;
  bool activate_pressed;
  bool activate_down;
  struct ImGuiWindow * parent_window;
  struct ImGuiWindow * child_window;
  struct ImGuiNavMoveResult * result;
  int i;
  struct ImRect nav_rect_rel;
  const int allowed_dir_flags;
  bool nav_gamepad_active;
  bool nav_keyboard_active;
  static const char __PRETTY_FUNCTION__[24] = "void ImGui::NavUpdate()";
  struct ImGuiContext & g;
  bool D.26785;
  bool D.26784;
  struct ImRect * D.26783;
  float D.26782;
  float D.26781;
  float D.26780;
  float D.26779;
  float D.26778;
  struct ImVec2 * D.26776;
  struct ImGuiWindow * D.26775;
  struct ImVec2 D.16402;
  struct ImVec2 * D.26774;
  struct ImGuiWindow * D.26773;
  struct ImVec2 D.16403;
  struct ImRect D.16404;
  struct ImGuiWindow * D.26770;
  int D.26769;
  struct ImGuiWindow * D.26768;
  bool D.26766;
  bool D.26765;
  struct ImRect * D.26764;
  int D.26763;
  struct ImGuiWindow * D.26762;
  struct ImGuiWindow * D.26760;
  struct ImRect * D.26755;
  int D.26754;
  float D.26753;
  float D.26752;
  float D.26751;
  float D.26750;
  float D.26749;
  float D.26748;
  struct ImVec2 D.16397;
  float D.26747;
  bool D.26744;
  struct ImRect * D.26743;
  int D.26742;
  bool retval.266;
  struct ImVec2 * D.26740;
  struct ImVec2 * D.26739;
  struct ImVec2 D.16390;
  struct ImVec2 D.16391;
  struct ImVec2 D.16392;
  struct ImVec2 * D.26738;
  struct ImVec2 * D.26737;
  struct ImVec2 D.16393;
  struct ImVec2 D.16394;
  struct ImVec2 D.16395;
  int D.26734;
  bool D.26731;
  bool D.26728;
  struct ImGuiNavMoveResult * D.26727;
  struct ImGuiNavMoveResult * D.26726;
  float D.26723;
  float D.26722;
  float D.26721;
  float D.26720;
  float D.26719;
  float D.26716;
  float D.26714;
  float D.26713;
  float D.26712;
  float D.26711;
  float D.26710;
  bool D.26707;
  float D.26704;
  float D.26702;
  float D.26701;
  float D.26700;
  int D.26696;
  float iftmp.265;
  float D.26694;
  int D.26693;
  int D.26691;
  float D.26688;
  float D.26687;
  float D.26686;
  int D.26682;
  float iftmp.264;
  float D.26680;
  int D.26679;
  int D.26677;
  bool D.26672;
  bool D.26669;
  int D.26666;
  float D.26665;
  float D.26664;
  float D.26663;
  float D.26662;
  float D.26661;
  struct ImGuiWindow * D.26658;
  int D.26655;
  int D.26654;
  struct ImGuiWindow * D.26653;
  struct ImGuiWindow * D.26650;
  bool D.26648;
  unsigned int D.26645;
  bool D.26642;
  int D.26640;
  int D.26637;
  ImGuiNavForward D.26633;
  int D.26629;
  bool D.26622;
  int D.26620;
  bool iftmp.263;
  bool retval.262;
  bool D.26611;
  int D.26609;
  bool iftmp.261;
  bool retval.260;
  bool D.26600;
  int D.26598;
  bool iftmp.259;
  bool retval.258;
  bool D.26589;
  int D.26587;
  bool iftmp.257;
  bool retval.256;
  int D.26580;
  int D.26579;
  struct ImGuiWindow * D.26578;
  struct ImGuiWindow * D.26573;
  struct ImGuiWindow * D.26570;
  ImGuiNavForward D.26567;
  unsigned int D.26563;
  int iftmp.255;
  unsigned int D.26560;
  unsigned int D.26559;
  unsigned int D.26558;
  unsigned int D.26557;
  unsigned int D.26554;
  unsigned int D.26549;
  unsigned int D.26548;
  unsigned int D.26545;
  int D.26541;
  int D.26540;
  struct ImGuiWindow * D.26539;
  struct ImGuiWindow * D.26536;
  unsigned int D.26533;
  bool D.26529;
  unsigned int D.26528;
  unsigned int D.26527;
  unsigned int D.26525;
  bool iftmp.254;
  bool retval.253;
  unsigned int D.26518;
  unsigned int D.26515;
  unsigned int D.26514;
  unsigned int D.26512;
  unsigned int D.26508;
  unsigned int D.26505;
  unsigned int D.26504;
  unsigned int D.26502;
  unsigned int D.26498;
  unsigned int D.26493;
  bool D.26491;
  bool iftmp.252;
  int D.26484;
  int D.26483;
  struct ImGuiWindow * D.26482;
  struct ImGuiWindow * D.26479;
  struct ImGuiWindow * D.26476;
  bool D.26473;
  bool D.26472;
  unsigned int D.26469;
  unsigned int D.26468;
  unsigned int D.26467;
  unsigned int D.26466;
  struct ImGuiWindow * D.26464;
  int D.26463;
  int D.26462;
  struct ImGuiWindow * D.26461;
  int D.26459;
  int D.26458;
  struct ImGuiWindow * D.26457;
  struct ImGuiWindow * D.26454;
  int D.26448;
  int D.26445;
  int D.26444;
  int D.26441;
  int D.26440;
  struct ImGuiWindow * D.26439;
  struct value_type & D.26438;
  struct ImVector * D.26437;
  bool retval.251;
  int D.26433;
  bool D.26429;
  unsigned int D.26428;
  unsigned int D.26424;
  struct ImGuiWindow * D.26423;
  struct ImGuiWindow * D.26421;
  struct ImGuiWindow * D.26420;
  int D.26418;
  int D.26417;
  struct ImGuiWindow * D.26416;
  int D.26414;
  int D.26413;
  struct ImGuiWindow * D.26412;
  struct ImGuiWindow * D.26410;
  unsigned int D.26404;
  bool retval.250;
  bool D.26400;
  struct ImGuiWindow * D.26398;
  bool D.26397;
  bool D.26396;
  unsigned int D.26394;
  bool D.26392;
  bool iftmp.249;
  int D.26385;
  int D.26384;
  struct ImGuiWindow * D.26383;
  struct ImGuiWindow * D.26381;
  bool iftmp.248;
  int D.26374;
  int D.26373;
  int D.26371;
  int D.26370;
  bool iftmp.247;
  int D.26366;
  int D.26365;
  struct ImGuiWindow * D.26363;
  int D.26360;
  struct ImGuiWindow * D.26357;
  struct ImGuiWindow * D.26356;
  struct ImGuiWindow * D.26353;
  struct ImGuiWindow * D.26351;
  struct ImGuiWindow * D.26348;
  int D.26344;
  int D.26341;
  struct ImVec2 * D.26338;
  int D.26335;
  int D.26334;
  int D.26331;
  int D.26330;
  bool D.26327;
  bool D.26324;
  unsigned int D.26319;
  unsigned int D.26316;
  bool D.26312;
  ImGuiNavForward D.26309;
  unsigned int D.26308;
  unsigned int D.26307;
  int D.26306;
  struct ImRect * D.26305;
  struct ImGuiWindow * D.26304;
  struct ImGuiWindow * D.26302;
  struct ImRect * D.26301;
  int D.26298;
  struct ImGuiWindow * D.26296;
  struct ImGuiWindow * D.26294;
  float D.26290;
  float D.26289;
  float D.26287;
  float D.26286;
  float D.26284;
  float D.26283;
  struct ImGuiWindow * D.26278;
  struct ImGuiWindow * D.26277;
  struct ImGuiWindow * D.26276;
  unsigned int D.26273;
  unsigned int D.26269;
  struct ImGuiNavMoveResult * iftmp.246;
  unsigned int D.26267;
  unsigned int D.26265;
  bool D.26262;
  int D.26259;
  struct ImGuiWindow * D.26258;
  unsigned int D.26257;
  int D.26256;
  unsigned int D.26254;
  int D.26253;
  struct ImRect * D.26252;
  bool D.26249;
  struct ImGuiWindow * D.26245;
  bool D.26244;
  bool D.26242;
  bool D.26241;
  unsigned int D.26238;
  float D.26234;
  float D.26233;
  float D.26229;
  float iftmp.245;
  float D.26225;
  float iftmp.244;
  float[21] * D.26221;
  float[21] * D.26220;
  bool D.26215;
  bool D.26211;
  bool D.26207;
  int D.26203;
  bool retval.243;
  int D.26198;
  bool retval.242;
  int D.26193;
  bool retval.241;
  int D.26188;
  bool retval.240;
  int D.26183;
  bool retval.239;
  int D.26178;
  bool retval.238;
  int D.26173;
  bool retval.237;
  int D.26169;
  int D.26168;
  float D.26166;
  float D.26164;
  float D.26162;
  float D.26160;
  int D.26155;
  int D.26154;
  int D.26151;
  int D.26150;
  float iftmp.244_4;
  float iftmp.245_5;
  struct ImGuiNavMoveResult * iftmp.246_6;
  bool iftmp.247_7;
  bool iftmp.248_8;
  bool iftmp.249_9;
  bool iftmp.252_10;
  bool iftmp.254_11;
  int iftmp.255_12;
  bool iftmp.257_13;
  bool iftmp.259_14;
  bool iftmp.261_15;
  bool iftmp.263_16;
  float iftmp.264_17;
  float iftmp.265_18;
  int _86;
  int _87;
  int _88;
  int _89;
  float _90;
  float _91;
  float _92;
  float _93;
  int _95;
  int _96;
  int _97;
  bool retval.237_99;
  int _102;
  bool retval.238_104;
  int _107;
  bool retval.239_109;
  int _112;
  bool retval.240_114;
  int _117;
  bool retval.241_119;
  int _122;
  bool retval.242_124;
  int _127;
  bool retval.243_129;
  bool _132;
  bool _134;
  bool _136;
  float[21] * _138;
  float[21] * _139;
  float _142;
  float _143;
  float iftmp.245_144;
  float _145;
  float _146;
  float iftmp.245_147;
  float iftmp.244_148;
  float iftmp.244_149;
  unsigned int _152;
  bool _153;
  bool _154;
  bool _155;
  struct ImGuiWindow * _156;
  bool _157;
  struct ImRect * _158;
  int _159;
  unsigned int _160;
  int _162;
  unsigned int _163;
  struct ImGuiWindow * _165;
  int _166;
  bool _173;
  unsigned int _174;
  unsigned int _175;
  unsigned int _176;
  struct ImGuiNavMoveResult * iftmp.246_177;
  struct ImGuiNavMoveResult * iftmp.246_178;
  unsigned int _180;
  struct ImGuiWindow * _181;
  struct ImGuiWindow * _182;
  struct ImGuiWindow * _183;
  float _184;
  float _185;
  float _186;
  float _187;
  float _188;
  float _189;
  struct ImGuiWindow * _191;
  struct ImGuiWindow * _192;
  int _193;
  struct ImRect * _194;
  struct ImGuiWindow * _195;
  struct ImGuiWindow * _198;
  struct ImRect * _200;
  int _201;
  unsigned int _202;
  unsigned int _204;
  ImGuiNavForward _208;
  bool _209;
  unsigned int _210;
  unsigned int _211;
  bool _215;
  bool _216;
  int _217;
  int _218;
  int _219;
  int _220;
  struct ImVec2 * _222;
  int _228;
  int _229;
  struct ImGuiWindow * _231;
  struct ImGuiWindow * _232;
  struct ImGuiWindow * _234;
  struct ImGuiWindow * _235;
  struct ImGuiWindow * _236;
  int _237;
  struct ImGuiWindow * _238;
  int _241;
  int _242;
  int _244;
  int _245;
  int _246;
  int _247;
  bool iftmp.247_248;
  bool iftmp.247_249;
  struct ImGuiWindow * _251;
  struct ImGuiWindow * _252;
  int _253;
  int _254;
  bool iftmp.248_255;
  bool iftmp.248_256;
  bool _258;
  unsigned int _259;
  bool _260;
  bool _261;
  struct ImGuiWindow * _262;
  bool _263;
  bool iftmp.249_264;
  bool iftmp.249_265;
  bool _268;
  bool retval.250_269;
  unsigned int _270;
  struct ImGuiWindow * _272;
  struct ImGuiWindow * _273;
  int _274;
  int _275;
  struct ImGuiWindow * _276;
  int _277;
  int _278;
  struct ImGuiWindow * _279;
  struct ImGuiWindow * _280;
  struct ImGuiWindow * _282;
  unsigned int _284;
  unsigned int _286;
  bool _289;
  int _292;
  struct ImVector * _293;
  struct value_type & _295;
  struct ImGuiWindow * _296;
  int _297;
  int _298;
  bool retval.251_299;
  int _300;
  int _301;
  int _303;
  struct ImGuiWindow * _305;
  struct ImGuiWindow * _306;
  int _307;
  int _308;
  struct ImGuiWindow * _309;
  int _310;
  int _311;
  struct ImGuiWindow * _312;
  unsigned int _316;
  unsigned int _318;
  unsigned int _320;
  unsigned int _322;
  bool _323;
  bool _324;
  struct ImGuiWindow * _325;
  struct ImGuiWindow * _326;
  struct ImGuiWindow * _327;
  int _328;
  int _329;
  bool _333;
  bool _334;
  bool iftmp.252_335;
  bool iftmp.252_336;
  unsigned int _338;
  unsigned int _339;
  unsigned int _341;
  unsigned int _342;
  unsigned int _343;
  unsigned int _344;
  unsigned int _346;
  unsigned int _347;
  unsigned int _348;
  unsigned int _349;
  unsigned int _351;
  unsigned int _352;
  unsigned int _353;
  bool _355;
  bool _356;
  bool iftmp.254_357;
  bool iftmp.254_358;
  bool retval.253_359;
  unsigned int _360;
  struct ImGuiWindow * _362;
  struct ImGuiWindow * _363;
  int _364;
  int _365;
  unsigned int _367;
  unsigned int _368;
  unsigned int _369;
  unsigned int _372;
  unsigned int _373;
  unsigned int _375;
  unsigned int _377;
  unsigned int _379;
  unsigned int _382;
  int iftmp.255_383;
  int iftmp.255_384;
  ImGuiNavForward _386;
  struct ImGuiWindow * _388;
  struct ImGuiWindow * _389;
  struct ImGuiWindow * _390;
  int _391;
  int _392;
  int _393;
  bool _395;
  bool _396;
  bool iftmp.257_397;
  bool iftmp.257_398;
  bool retval.256_399;
  int _401;
  bool _403;
  bool _404;
  bool iftmp.259_405;
  bool iftmp.259_406;
  bool retval.258_407;
  int _409;
  bool _411;
  bool _412;
  bool iftmp.261_413;
  bool iftmp.261_414;
  bool retval.260_415;
  int _417;
  bool _419;
  bool _420;
  bool iftmp.263_421;
  bool iftmp.263_422;
  bool retval.262_423;
  int _425;
  ImGuiNavForward _426;
  int _430;
  int _432;
  bool _434;
  unsigned int _435;
  bool _437;
  struct ImGuiWindow * _442;
  struct ImGuiWindow * _443;
  int _444;
  int _445;
  struct ImGuiWindow * _446;
  float _449;
  float _450;
  float _451;
  float _452;
  float _453;
  int _456;
  bool _457;
  bool _458;
  int _459;
  int _460;
  float _461;
  int _462;
  float iftmp.264_463;
  float iftmp.264_464;
  float _465;
  float _466;
  float _468;
  int _470;
  int _471;
  float _472;
  int _473;
  float iftmp.265_474;
  float iftmp.265_475;
  float _476;
  float _477;
  float _479;
  float _482;
  bool _483;
  float _484;
  float _485;
  float _486;
  float _487;
  float _489;
  float _492;
  float _493;
  float _494;
  float _495;
  float _496;
  float _498;
  struct ImGuiNavMoveResult * _503;
  struct ImGuiNavMoveResult * _505;
  bool _507;
  bool _508;
  int _509;
  struct ImVec2 * _512;
  struct ImVec2 * _513;
  struct ImVec2 * _517;
  struct ImVec2 * _518;
  int _528;
  struct ImRect * _529;
  bool _531;
  bool retval.266_532;
  float _534;
  float _537;
  float _539;
  float _540;
  float _542;
  float _544;
  float _545;
  int _549;
  struct ImRect * _550;
  struct ImGuiWindow * _555;
  struct ImGuiWindow * _556;
  int _557;
  struct ImRect * _558;
  bool _560;
  bool _561;
  struct ImGuiWindow * _562;
  int _563;
  struct ImGuiWindow * _566;
  struct ImGuiWindow * _567;
  struct ImVec2 * _568;
  struct ImGuiWindow * _570;
  struct ImVec2 * _571;
  float _579;
  float _580;
  float _581;
  float _583;
  float _585;
  struct ImRect * _587;
  bool _589;
  bool _590;

  <bb 2>:
  g_84 = GImGui;
  g_84->IO.WantSetMousePos = 0;
  _86 = g_84->IO.ConfigFlags;
  _87 = _86 & 2;
  if (_87 != 0)
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 3>:
  _88 = g_84->IO.BackendFlags;
  _89 = _88 & 1;
  if (_89 != 0)
    goto <bb 4>;
  else
    goto <bb 10>;

  <bb 4>:
  _90 = g_84->IO.NavInputs[0];
  if (_90 > 0.0)
    goto <bb 8>;
  else
    goto <bb 5>;

  <bb 5>:
  _91 = g_84->IO.NavInputs[2];
  if (_91 > 0.0)
    goto <bb 8>;
  else
    goto <bb 6>;

  <bb 6>:
  _92 = g_84->IO.NavInputs[1];
  if (_92 > 0.0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _93 = g_84->IO.NavInputs[3];
  if (_93 > 0.0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  g_84->NavInputSource = 4;

  <bb 9>:

  <bb 10>:
  _95 = g_84->IO.ConfigFlags;
  _96 = _95 & 1;
  if (_96 != 0)
    goto <bb 11>;
  else
    goto <bb 31>;

  <bb 11>:
  _97 = g_84->IO.KeyMap[12];
  retval.237_99 = ImGui::IsKeyDown (_97);
  if (retval.237_99 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  g_84->IO.NavInputs[0] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 13>:
  _102 = g_84->IO.KeyMap[13];
  retval.238_104 = ImGui::IsKeyDown (_102);
  if (retval.238_104 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  g_84->IO.NavInputs[2] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 15>:
  _107 = g_84->IO.KeyMap[14];
  retval.239_109 = ImGui::IsKeyDown (_107);
  if (retval.239_109 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  g_84->IO.NavInputs[1] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 17>:
  _112 = g_84->IO.KeyMap[1];
  retval.240_114 = ImGui::IsKeyDown (_112);
  if (retval.240_114 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  g_84->IO.NavInputs[17] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 19>:
  _117 = g_84->IO.KeyMap[2];
  retval.241_119 = ImGui::IsKeyDown (_117);
  if (retval.241_119 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  g_84->IO.NavInputs[18] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 21>:
  _122 = g_84->IO.KeyMap[3];
  retval.242_124 = ImGui::IsKeyDown (_122);
  if (retval.242_124 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  g_84->IO.NavInputs[19] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 23>:
  _127 = g_84->IO.KeyMap[4];
  retval.243_129 = ImGui::IsKeyDown (_127);
  if (retval.243_129 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  g_84->IO.NavInputs[20] = 1.0e+0;
  g_84->NavInputSource = 3;

  <bb 25>:
  _132 = g_84->IO.KeyCtrl;
  if (_132 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  g_84->IO.NavInputs[14] = 1.0e+0;

  <bb 27>:
  _134 = g_84->IO.KeyShift;
  if (_134 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  g_84->IO.NavInputs[15] = 1.0e+0;

  <bb 29>:
  _136 = g_84->IO.KeyAlt;
  if (_136 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  g_84->IO.NavInputs[16] = 1.0e+0;

  <bb 31>:
  _138 = &g_84->IO.NavInputsDownDuration;
  _139 = &g_84->IO.NavInputsDownDurationPrev;
  memcpy (_139, _138, 84);
  i_141 = 0;

  <bb 32>:
  # i_1 = PHI <i_141(31), i_151(39)>
  if (i_1 > 20)
    goto <bb 40>;
  else
    goto <bb 33>;

  <bb 33>:
  _142 = g_84->IO.NavInputs[i_1];
  if (_142 > 0.0)
    goto <bb 34>;
  else
    goto <bb 38>;

  <bb 34>:
  _143 = g_84->IO.NavInputsDownDuration[i_1];
  if (_143 < 0.0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  iftmp.245_144 = 0.0;
  goto <bb 37>;

  <bb 36>:
  _145 = g_84->IO.NavInputsDownDuration[i_1];
  _146 = g_84->IO.DeltaTime;
  iftmp.245_147 = _145 + _146;

  <bb 37>:
  # iftmp.245_5 = PHI <iftmp.245_144(35), iftmp.245_147(36)>
  iftmp.244_148 = iftmp.245_5;
  goto <bb 39>;

  <bb 38>:
  iftmp.244_149 = -1.0e+0;

  <bb 39>:
  # iftmp.244_4 = PHI <iftmp.244_148(37), iftmp.244_149(38)>
  g_84->IO.NavInputsDownDuration[i_1] = iftmp.244_4;
  i_151 = i_1 + 1;
  goto <bb 32>;

  <bb 40>:
  _152 = g_84->NavInitResultId;
  if (_152 != 0)
    goto <bb 41>;
  else
    goto <bb 49>;

  <bb 41>:
  _153 = g_84->NavDisableHighlight;
  _154 = ~_153;
  if (_154 != 0)
    goto <bb 43>;
  else
    goto <bb 42>;

  <bb 42>:
  _155 = g_84->NavInitRequestFromMove;
  if (_155 != 0)
    goto <bb 43>;
  else
    goto <bb 49>;

  <bb 43>:
  _156 = g_84->NavWindow;
  if (_156 != 0B)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  __assert_fail ("g.NavWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3019, &__PRETTY_FUNCTION__);

  <bb 45>:
  _157 = g_84->NavInitRequestFromMove;
  if (_157 != 0)
    goto <bb 46>;
  else
    goto <bb 47>;

  <bb 46>:
  _158 = &g_84->NavInitResultRectRel;
  _159 = g_84->NavLayer;
  _160 = g_84->NavInitResultId;
  SetNavIDWithRectRel (_160, _159, _158);
  goto <bb 48>;

  <bb 47>:
  _162 = g_84->NavLayer;
  _163 = g_84->NavInitResultId;
  SetNavID (_163, _162);

  <bb 48>:
  _165 = g_84->NavWindow;
  _166 = g_84->NavLayer;
  _165->NavRectRel[_166] = g_84->NavInitResultRectRel;

  <bb 49>:
  g_84->NavInitRequest = 0;
  g_84->NavInitRequestFromMove = 0;
  g_84->NavInitResultId = 0;
  g_84->NavJustMovedToId = 0;
  _173 = g_84->NavMoveRequest;
  if (_173 != 0)
    goto <bb 50>;
  else
    goto <bb 69>;

  <bb 50>:
  _174 = g_84->NavMoveResultLocal.ID;
  if (_174 != 0)
    goto <bb 52>;
  else
    goto <bb 51>;

  <bb 51>:
  _175 = g_84->NavMoveResultOther.ID;
  if (_175 != 0)
    goto <bb 52>;
  else
    goto <bb 69>;

  <bb 52>:
  _176 = g_84->NavMoveResultLocal.ID;
  if (_176 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  iftmp.246_177 = &g_84->NavMoveResultLocal;
  goto <bb 55>;

  <bb 54>:
  iftmp.246_178 = &g_84->NavMoveResultOther;

  <bb 55>:
  # iftmp.246_6 = PHI <iftmp.246_177(53), iftmp.246_178(54)>
  result_179 = iftmp.246_6;
  _180 = g_84->NavMoveResultOther.ID;
  if (_180 != 0)
    goto <bb 56>;
  else
    goto <bb 62>;

  <bb 56>:
  _181 = g_84->NavMoveResultOther.Window;
  _182 = _181->ParentWindow;
  _183 = g_84->NavWindow;
  if (_182 == _183)
    goto <bb 57>;
  else
    goto <bb 62>;

  <bb 57>:
  _184 = g_84->NavMoveResultOther.DistBox;
  _185 = g_84->NavMoveResultLocal.DistBox;
  if (_184 < _185)
    goto <bb 60>;
  else
    goto <bb 58>;

  <bb 58>:
  _186 = g_84->NavMoveResultOther.DistBox;
  _187 = g_84->NavMoveResultLocal.DistBox;
  if (_186 == _187)
    goto <bb 59>;
  else
    goto <bb 61>;

  <bb 59>:
  _188 = g_84->NavMoveResultOther.DistCenter;
  _189 = g_84->NavMoveResultLocal.DistCenter;
  if (_188 < _189)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  result_190 = &g_84->NavMoveResultOther;

  <bb 61>:
  # result_2 = PHI <result_179(58), result_179(59), result_190(60)>

  <bb 62>:
  # result_3 = PHI <result_179(55), result_179(56), result_2(61)>
  _191 = g_84->NavWindow;
  if (_191 != 0B)
    goto <bb 63>;
  else
    goto <bb 65>;

  <bb 63>:
  _192 = result_3->Window;
  if (_192 != 0B)
    goto <bb 64>;
  else
    goto <bb 65>;

  <bb 64>:
  goto <bb 66>;

  <bb 65>:
  __assert_fail ("g.NavWindow && result->Window", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3040, &__PRETTY_FUNCTION__);

  <bb 66>:
  _193 = g_84->NavLayer;
  if (_193 == 0)
    goto <bb 67>;
  else
    goto <bb 68>;

  <bb 67>:
  _194 = &result_3->RectRel;
  _195 = result_3->Window;
  NavScrollToBringItemIntoView (_195, _194);

  <bb 68>:
  ImGui::ClearActiveID ();
  _198 = result_3->Window;
  g_84->NavWindow = _198;
  _200 = &result_3->RectRel;
  _201 = g_84->NavLayer;
  _202 = result_3->ID;
  SetNavIDWithRectRel (_202, _201, _200);
  _204 = result_3->ID;
  g_84->NavJustMovedToId = _204;
  g_84->NavMoveFromClampedRefRect = 0;

  <bb 69>:
  _208 = g_84->NavMoveRequestForward;
  if (_208 == 2)
    goto <bb 70>;
  else
    goto <bb 76>;

  <bb 70>:
  _209 = g_84->NavMoveRequest;
  if (_209 != 0)
    goto <bb 72>;
  else
    goto <bb 71>;

  <bb 71>:
  __assert_fail ("g.NavMoveRequest", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3057, &__PRETTY_FUNCTION__);

  <bb 72>:
  _210 = g_84->NavMoveResultLocal.ID;
  if (_210 == 0)
    goto <bb 73>;
  else
    goto <bb 75>;

  <bb 73>:
  _211 = g_84->NavMoveResultOther.ID;
  if (_211 == 0)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  g_84->NavDisableHighlight = 0;

  <bb 75>:
  g_84->NavMoveRequestForward = 0;

  <bb 76>:
  _215 = g_84->NavMousePosDirty;
  if (_215 != 0)
    goto <bb 77>;
  else
    goto <bb 82>;

  <bb 77>:
  _216 = g_84->NavIdIsAlive;
  if (_216 != 0)
    goto <bb 78>;
  else
    goto <bb 82>;

  <bb 78>:
  _217 = g_84->IO.ConfigFlags;
  _218 = _217 & 4;
  if (_218 != 0)
    goto <bb 79>;
  else
    goto <bb 81>;

  <bb 79>:
  _219 = g_84->IO.BackendFlags;
  _220 = _219 & 4;
  if (_220 != 0)
    goto <bb 80>;
  else
    goto <bb 81>;

  <bb 80>:
  g_84->IO.MousePosPrev = NavCalcPreferredMousePos ();
  _222 = &g_84->IO.MousePosPrev;
  g_84->IO.MousePos = MEM[(const struct ImVec2 &)_222];
  g_84->IO.WantSetMousePos = 1;

  <bb 81>:
  g_84->NavMousePosDirty = 0;

  <bb 82>:
  g_84->NavIdIsAlive = 0;
  g_84->NavJustTabbedId = 0;
  _228 = g_84->NavLayer;
  if (_228 == 0)
    goto <bb 85>;
  else
    goto <bb 83>;

  <bb 83>:
  _229 = g_84->NavLayer;
  if (_229 == 1)
    goto <bb 85>;
  else
    goto <bb 84>;

  <bb 84>:
  __assert_fail ("g.NavLayer == 0 || g.NavLayer == 1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3076, &__PRETTY_FUNCTION__);

  <bb 85>:
  _231 = g_84->NavWindow;
  if (_231 != 0B)
    goto <bb 86>;
  else
    goto <bb 87>;

  <bb 86>:
  _232 = g_84->NavWindow;
  NavSaveLastChildNavWindow (_232);

  <bb 87>:
  _234 = g_84->NavWindow;
  if (_234 != 0B)
    goto <bb 88>;
  else
    goto <bb 91>;

  <bb 88>:
  _235 = g_84->NavWindow;
  _236 = _235->NavLastChildNavWindow;
  if (_236 != 0B)
    goto <bb 89>;
  else
    goto <bb 91>;

  <bb 89>:
  _237 = g_84->NavLayer;
  if (_237 == 0)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  _238 = g_84->NavWindow;
  _238->NavLastChildNavWindow = 0B;

  <bb 91>:
  ImGui::NavUpdateWindowing ();
  _241 = g_84->IO.ConfigFlags;
  _242 = _241 & 1;
  nav_keyboard_active_243 = _242 != 0;
  _244 = g_84->IO.ConfigFlags;
  _245 = _244 & 2;
  if (_245 != 0)
    goto <bb 92>;
  else
    goto <bb 94>;

  <bb 92>:
  _246 = g_84->IO.BackendFlags;
  _247 = _246 & 1;
  if (_247 != 0)
    goto <bb 93>;
  else
    goto <bb 94>;

  <bb 93>:
  iftmp.247_248 = 1;
  goto <bb 95>;

  <bb 94>:
  iftmp.247_249 = 0;

  <bb 95>:
  # iftmp.247_7 = PHI <iftmp.247_248(93), iftmp.247_249(94)>
  nav_gamepad_active_250 = iftmp.247_7;
  if (nav_keyboard_active_243 != 0)
    goto <bb 97>;
  else
    goto <bb 96>;

  <bb 96>:
  if (nav_gamepad_active_250 != 0)
    goto <bb 97>;
  else
    goto <bb 100>;

  <bb 97>:
  _251 = g_84->NavWindow;
  if (_251 != 0B)
    goto <bb 98>;
  else
    goto <bb 100>;

  <bb 98>:
  _252 = g_84->NavWindow;
  _253 = _252->Flags;
  _254 = _253 & 262144;
  if (_254 == 0)
    goto <bb 99>;
  else
    goto <bb 100>;

  <bb 99>:
  iftmp.248_255 = 1;
  goto <bb 101>;

  <bb 100>:
  iftmp.248_256 = 0;

  <bb 101>:
  # iftmp.248_8 = PHI <iftmp.248_255(99), iftmp.248_256(100)>
  g_84->IO.NavActive = iftmp.248_8;
  _258 = g_84->IO.NavActive;
  if (_258 != 0)
    goto <bb 102>;
  else
    goto <bb 104>;

  <bb 102>:
  _259 = g_84->NavId;
  if (_259 != 0)
    goto <bb 103>;
  else
    goto <bb 104>;

  <bb 103>:
  _260 = g_84->NavDisableHighlight;
  _261 = ~_260;
  if (_261 != 0)
    goto <bb 106>;
  else
    goto <bb 104>;

  <bb 104>:
  _262 = g_84->NavWindowingTarget;
  if (_262 != 0B)
    goto <bb 106>;
  else
    goto <bb 105>;

  <bb 105>:
  _263 = g_84->NavInitRequest;
  if (_263 != 0)
    goto <bb 106>;
  else
    goto <bb 107>;

  <bb 106>:
  iftmp.249_265 = 1;
  goto <bb 108>;

  <bb 107>:
  iftmp.249_264 = 0;

  <bb 108>:
  # iftmp.249_9 = PHI <iftmp.249_265(106), iftmp.249_264(107)>
  g_84->IO.NavVisible = iftmp.249_9;
  _268 = IsNavInputPressed (1, 1);
  retval.250_269 = _268;
  if (retval.250_269 != 0)
    goto <bb 109>;
  else
    goto <bb 131>;

  <bb 109>:
  _270 = g_84->ActiveId;
  if (_270 != 0)
    goto <bb 110>;
  else
    goto <bb 111>;

  <bb 110>:
  ImGui::ClearActiveID ();
  goto <bb 130>;

  <bb 111>:
  _272 = g_84->NavWindow;
  if (_272 != 0B)
    goto <bb 112>;
  else
    goto <bb 120>;

  <bb 112>:
  _273 = g_84->NavWindow;
  _274 = _273->Flags;
  _275 = _274 & 16777216;
  if (_275 != 0)
    goto <bb 113>;
  else
    goto <bb 120>;

  <bb 113>:
  _276 = g_84->NavWindow;
  _277 = _276->Flags;
  _278 = _277 & 67108864;
  if (_278 == 0)
    goto <bb 114>;
  else
    goto <bb 120>;

  <bb 114>:
  _279 = g_84->NavWindow;
  _280 = _279->ParentWindow;
  if (_280 != 0B)
    goto <bb 115>;
  else
    goto <bb 120>;

  <bb 115>:
  child_window_281 = g_84->NavWindow;
  _282 = g_84->NavWindow;
  parent_window_283 = _282->ParentWindow;
  _284 = child_window_281->ChildId;
  if (_284 != 0)
    goto <bb 117>;
  else
    goto <bb 116>;

  <bb 116>:
  __assert_fail ("child_window->ChildId != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3104, &__PRETTY_FUNCTION__);

  <bb 117>:
  ImGui::FocusWindow (parent_window_283);
  _286 = child_window_281->ChildId;
  SetNavID (_286, 0);
  g_84->NavIdIsAlive = 0;
  _289 = g_84->NavDisableMouseHover;
  if (_289 != 0)
    goto <bb 118>;
  else
    goto <bb 119>;

  <bb 118>:
  g_84->NavMousePosDirty = 1;

  <bb 119>:
  goto <bb 130>;

  <bb 120>:
  _292 = g_84->OpenPopupStack.Size;
  if (_292 > 0)
    goto <bb 121>;
  else
    goto <bb 123>;

  <bb 121>:
  _293 = &g_84->OpenPopupStack;
  _295 = ImVector<ImGuiPopupRef>::back (_293);
  _296 = _295->Window;
  _297 = _296->Flags;
  _298 = _297 & 134217728;
  retval.251_299 = _298 == 0;
  if (retval.251_299 != 0)
    goto <bb 122>;
  else
    goto <bb 130>;

  <bb 122>:
  _300 = g_84->OpenPopupStack.Size;
  _301 = _300 + -1;
  ClosePopupToLevel (_301);
  goto <bb 130>;

  <bb 123>:
  _303 = g_84->NavLayer;
  if (_303 != 0)
    goto <bb 124>;
  else
    goto <bb 125>;

  <bb 124>:
  NavRestoreLayer (0);
  goto <bb 130>;

  <bb 125>:
  _305 = g_84->NavWindow;
  if (_305 != 0B)
    goto <bb 126>;
  else
    goto <bb 129>;

  <bb 126>:
  _306 = g_84->NavWindow;
  _307 = _306->Flags;
  _308 = _307 & 67108864;
  if (_308 != 0)
    goto <bb 128>;
  else
    goto <bb 127>;

  <bb 127>:
  _309 = g_84->NavWindow;
  _310 = _309->Flags;
  _311 = _310 & 16777216;
  if (_311 == 0)
    goto <bb 128>;
  else
    goto <bb 129>;

  <bb 128>:
  _312 = g_84->NavWindow;
  _312->NavLastIds[0] = 0;

  <bb 129>:
  g_84->NavId = 0;

  <bb 130>:

  <bb 131>:
  g_84->NavInputId = 0;
  _316 = g_84->NavInputId;
  g_84->NavActivatePressedId = _316;
  _318 = g_84->NavActivatePressedId;
  g_84->NavActivateDownId = _318;
  _320 = g_84->NavActivateDownId;
  g_84->NavActivateId = _320;
  _322 = g_84->NavId;
  if (_322 != 0)
    goto <bb 132>;
  else
    goto <bb 159>;

  <bb 132>:
  _323 = g_84->NavDisableHighlight;
  _324 = ~_323;
  if (_324 != 0)
    goto <bb 133>;
  else
    goto <bb 159>;

  <bb 133>:
  _325 = g_84->NavWindowingTarget;
  if (_325 == 0B)
    goto <bb 134>;
  else
    goto <bb 159>;

  <bb 134>:
  _326 = g_84->NavWindow;
  if (_326 != 0B)
    goto <bb 135>;
  else
    goto <bb 159>;

  <bb 135>:
  _327 = g_84->NavWindow;
  _328 = _327->Flags;
  _329 = _328 & 262144;
  if (_329 == 0)
    goto <bb 136>;
  else
    goto <bb 159>;

  <bb 136>:
  activate_down_331 = IsNavInputDown (0);
  if (activate_down_331 != 0)
    goto <bb 137>;
  else
    goto <bb 139>;

  <bb 137>:
  _333 = IsNavInputPressed (0, 1);
  _334 = _333;
  if (_334 != 0)
    goto <bb 138>;
  else
    goto <bb 139>;

  <bb 138>:
  iftmp.252_335 = 1;
  goto <bb 140>;

  <bb 139>:
  iftmp.252_336 = 0;

  <bb 140>:
  # iftmp.252_10 = PHI <iftmp.252_335(138), iftmp.252_336(139)>
  activate_pressed_337 = iftmp.252_10;
  _338 = g_84->ActiveId;
  if (_338 == 0)
    goto <bb 141>;
  else
    goto <bb 143>;

  <bb 141>:
  if (activate_pressed_337 != 0)
    goto <bb 142>;
  else
    goto <bb 143>;

  <bb 142>:
  _339 = g_84->NavId;
  g_84->NavActivateId = _339;

  <bb 143>:
  _341 = g_84->ActiveId;
  if (_341 == 0)
    goto <bb 145>;
  else
    goto <bb 144>;

  <bb 144>:
  _342 = g_84->ActiveId;
  _343 = g_84->NavId;
  if (_342 == _343)
    goto <bb 145>;
  else
    goto <bb 147>;

  <bb 145>:
  if (activate_down_331 != 0)
    goto <bb 146>;
  else
    goto <bb 147>;

  <bb 146>:
  _344 = g_84->NavId;
  g_84->NavActivateDownId = _344;

  <bb 147>:
  _346 = g_84->ActiveId;
  if (_346 == 0)
    goto <bb 149>;
  else
    goto <bb 148>;

  <bb 148>:
  _347 = g_84->ActiveId;
  _348 = g_84->NavId;
  if (_347 == _348)
    goto <bb 149>;
  else
    goto <bb 151>;

  <bb 149>:
  if (activate_pressed_337 != 0)
    goto <bb 150>;
  else
    goto <bb 151>;

  <bb 150>:
  _349 = g_84->NavId;
  g_84->NavActivatePressedId = _349;

  <bb 151>:
  _351 = g_84->ActiveId;
  if (_351 == 0)
    goto <bb 153>;
  else
    goto <bb 152>;

  <bb 152>:
  _352 = g_84->ActiveId;
  _353 = g_84->NavId;
  if (_352 == _353)
    goto <bb 153>;
  else
    goto <bb 155>;

  <bb 153>:
  _355 = IsNavInputPressed (2, 1);
  _356 = _355;
  if (_356 != 0)
    goto <bb 154>;
  else
    goto <bb 155>;

  <bb 154>:
  iftmp.254_357 = 1;
  goto <bb 156>;

  <bb 155>:
  iftmp.254_358 = 0;

  <bb 156>:
  # iftmp.254_11 = PHI <iftmp.254_357(154), iftmp.254_358(155)>
  retval.253_359 = iftmp.254_11;
  if (retval.253_359 != 0)
    goto <bb 157>;
  else
    goto <bb 158>;

  <bb 157>:
  _360 = g_84->NavId;
  g_84->NavInputId = _360;

  <bb 158>:

  <bb 159>:
  _362 = g_84->NavWindow;
  if (_362 != 0B)
    goto <bb 160>;
  else
    goto <bb 162>;

  <bb 160>:
  _363 = g_84->NavWindow;
  _364 = _363->Flags;
  _365 = _364 & 262144;
  if (_365 != 0)
    goto <bb 161>;
  else
    goto <bb 162>;

  <bb 161>:
  g_84->NavDisableHighlight = 1;

  <bb 162>:
  _367 = g_84->NavActivateId;
  if (_367 != 0)
    goto <bb 163>;
  else
    goto <bb 165>;

  <bb 163>:
  _368 = g_84->NavActivateDownId;
  _369 = g_84->NavActivateId;
  if (_368 == _369)
    goto <bb 165>;
  else
    goto <bb 164>;

  <bb 164>:
  __assert_fail ("g.NavActivateDownId == g.NavActivateId", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3149, &__PRETTY_FUNCTION__);

  <bb 165>:
  g_84->NavMoveRequest = 0;
  _372 = g_84->NavNextActivateId;
  if (_372 != 0)
    goto <bb 166>;
  else
    goto <bb 167>;

  <bb 166>:
  _373 = g_84->NavNextActivateId;
  g_84->NavInputId = _373;
  _375 = g_84->NavInputId;
  g_84->NavActivatePressedId = _375;
  _377 = g_84->NavActivatePressedId;
  g_84->NavActivateDownId = _377;
  _379 = g_84->NavActivateDownId;
  g_84->NavActivateId = _379;

  <bb 167>:
  g_84->NavNextActivateId = 0;
  _382 = g_84->ActiveId;
  if (_382 != 0)
    goto <bb 168>;
  else
    goto <bb 169>;

  <bb 168>:
  iftmp.255_383 = g_84->ActiveIdAllowNavDirFlags;
  goto <bb 170>;

  <bb 169>:
  iftmp.255_384 = -1;

  <bb 170>:
  # iftmp.255_12 = PHI <iftmp.255_383(168), iftmp.255_384(169)>
  allowed_dir_flags_385 = iftmp.255_12;
  _386 = g_84->NavMoveRequestForward;
  if (_386 == 0)
    goto <bb 171>;
  else
    goto <bb 199>;

  <bb 171>:
  g_84->NavMoveDir = -1;
  _388 = g_84->NavWindow;
  if (_388 != 0B)
    goto <bb 172>;
  else
    goto <bb 204>;

  <bb 172>:
  _389 = g_84->NavWindowingTarget;
  if (_389 == 0B)
    goto <bb 173>;
  else
    goto <bb 204>;

  <bb 173>:
  if (allowed_dir_flags_385 != 0)
    goto <bb 174>;
  else
    goto <bb 204>;

  <bb 174>:
  _390 = g_84->NavWindow;
  _391 = _390->Flags;
  _392 = _391 & 262144;
  if (_392 == 0)
    goto <bb 175>;
  else
    goto <bb 204>;

  <bb 175>:
  _393 = allowed_dir_flags_385 & 1;
  if (_393 != 0)
    goto <bb 176>;
  else
    goto <bb 178>;

  <bb 176>:
  _395 = IsNavInputPressedAnyOfTwo (4, 17, 3);
  _396 = _395;
  if (_396 != 0)
    goto <bb 177>;
  else
    goto <bb 178>;

  <bb 177>:
  iftmp.257_397 = 1;
  goto <bb 179>;

  <bb 178>:
  iftmp.257_398 = 0;

  <bb 179>:
  # iftmp.257_13 = PHI <iftmp.257_397(177), iftmp.257_398(178)>
  retval.256_399 = iftmp.257_13;
  if (retval.256_399 != 0)
    goto <bb 180>;
  else
    goto <bb 181>;

  <bb 180>:
  g_84->NavMoveDir = 0;

  <bb 181>:
  _401 = allowed_dir_flags_385 & 2;
  if (_401 != 0)
    goto <bb 182>;
  else
    goto <bb 184>;

  <bb 182>:
  _403 = IsNavInputPressedAnyOfTwo (5, 18, 3);
  _404 = _403;
  if (_404 != 0)
    goto <bb 183>;
  else
    goto <bb 184>;

  <bb 183>:
  iftmp.259_405 = 1;
  goto <bb 185>;

  <bb 184>:
  iftmp.259_406 = 0;

  <bb 185>:
  # iftmp.259_14 = PHI <iftmp.259_405(183), iftmp.259_406(184)>
  retval.258_407 = iftmp.259_14;
  if (retval.258_407 != 0)
    goto <bb 186>;
  else
    goto <bb 187>;

  <bb 186>:
  g_84->NavMoveDir = 1;

  <bb 187>:
  _409 = allowed_dir_flags_385 & 4;
  if (_409 != 0)
    goto <bb 188>;
  else
    goto <bb 190>;

  <bb 188>:
  _411 = IsNavInputPressedAnyOfTwo (6, 19, 3);
  _412 = _411;
  if (_412 != 0)
    goto <bb 189>;
  else
    goto <bb 190>;

  <bb 189>:
  iftmp.261_413 = 1;
  goto <bb 191>;

  <bb 190>:
  iftmp.261_414 = 0;

  <bb 191>:
  # iftmp.261_15 = PHI <iftmp.261_413(189), iftmp.261_414(190)>
  retval.260_415 = iftmp.261_15;
  if (retval.260_415 != 0)
    goto <bb 192>;
  else
    goto <bb 193>;

  <bb 192>:
  g_84->NavMoveDir = 2;

  <bb 193>:
  _417 = allowed_dir_flags_385 & 8;
  if (_417 != 0)
    goto <bb 194>;
  else
    goto <bb 196>;

  <bb 194>:
  _419 = IsNavInputPressedAnyOfTwo (7, 20, 3);
  _420 = _419;
  if (_420 != 0)
    goto <bb 195>;
  else
    goto <bb 196>;

  <bb 195>:
  iftmp.263_421 = 1;
  goto <bb 197>;

  <bb 196>:
  iftmp.263_422 = 0;

  <bb 197>:
  # iftmp.263_16 = PHI <iftmp.263_421(195), iftmp.263_422(196)>
  retval.262_423 = iftmp.263_16;
  if (retval.262_423 != 0)
    goto <bb 198>;
  else
    goto <bb 204>;

  <bb 198>:
  g_84->NavMoveDir = 3;
  goto <bb 204>;

  <bb 199>:
  _425 = g_84->NavMoveDir;
  if (_425 != -1)
    goto <bb 201>;
  else
    goto <bb 200>;

  <bb 200>:
  __assert_fail ("g.NavMoveDir != ImGuiDir_None", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3173, &__PRETTY_FUNCTION__);

  <bb 201>:
  _426 = g_84->NavMoveRequestForward;
  if (_426 == 1)
    goto <bb 203>;
  else
    goto <bb 202>;

  <bb 202>:
  __assert_fail ("g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3174, &__PRETTY_FUNCTION__);

  <bb 203>:
  g_84->NavMoveRequestForward = 2;

  <bb 204>:
  _430 = g_84->NavMoveDir;
  if (_430 != -1)
    goto <bb 205>;
  else
    goto <bb 206>;

  <bb 205>:
  g_84->NavMoveRequest = 1;
  _432 = g_84->NavMoveDir;
  g_84->NavMoveDirLast = _432;

  <bb 206>:
  _434 = g_84->NavMoveRequest;
  if (_434 != 0)
    goto <bb 207>;
  else
    goto <bb 209>;

  <bb 207>:
  _435 = g_84->NavId;
  if (_435 == 0)
    goto <bb 208>;
  else
    goto <bb 209>;

  <bb 208>:
  g_84->NavInitRequestFromMove = 1;
  _437 = g_84->NavInitRequestFromMove;
  g_84->NavInitRequest = _437;
  g_84->NavInitResultId = 0;
  g_84->NavDisableHighlight = 0;

  <bb 209>:
  NavUpdateAnyRequestFlag ();
  _442 = g_84->NavWindow;
  if (_442 != 0B)
    goto <bb 210>;
  else
    goto <bb 234>;

  <bb 210>:
  _443 = g_84->NavWindow;
  _444 = _443->Flags;
  _445 = _444 & 262144;
  if (_445 == 0)
    goto <bb 211>;
  else
    goto <bb 234>;

  <bb 211>:
  _446 = g_84->NavWindowingTarget;
  if (_446 == 0B)
    goto <bb 212>;
  else
    goto <bb 234>;

  <bb 212>:
  window_447 = g_84->NavWindow;
  _449 = ImGuiWindow::CalcFontSize (window_447);
  _450 = _449 * 1.0e+2;
  _451 = g_84->IO.DeltaTime;
  _452 = _450 * _451;
  _453 = _452 + 5.0e-1;
  scroll_speed_455 = ImFloor (_453);
  _456 = window_447->DC.NavLayerActiveMask;
  if (_456 == 0)
    goto <bb 213>;
  else
    goto <bb 228>;

  <bb 213>:
  _457 = window_447->DC.NavHasScroll;
  if (_457 != 0)
    goto <bb 214>;
  else
    goto <bb 228>;

  <bb 214>:
  _458 = g_84->NavMoveRequest;
  if (_458 != 0)
    goto <bb 215>;
  else
    goto <bb 228>;

  <bb 215>:
  _459 = g_84->NavMoveDir;
  if (_459 == 0)
    goto <bb 217>;
  else
    goto <bb 216>;

  <bb 216>:
  _460 = g_84->NavMoveDir;
  if (_460 == 1)
    goto <bb 217>;
  else
    goto <bb 221>;

  <bb 217>:
  _461 = window_447->Scroll.x;
  _462 = g_84->NavMoveDir;
  if (_462 == 0)
    goto <bb 218>;
  else
    goto <bb 219>;

  <bb 218>:
  iftmp.264_463 = -1.0e+0;
  goto <bb 220>;

  <bb 219>:
  iftmp.264_464 = 1.0e+0;

  <bb 220>:
  # iftmp.264_17 = PHI <iftmp.264_463(218), iftmp.264_464(219)>
  _465 = iftmp.264_17 * scroll_speed_455;
  _466 = _461 + _465;
  _468 = ImFloor (_466);
  SetWindowScrollX (window_447, _468);

  <bb 221>:
  _470 = g_84->NavMoveDir;
  if (_470 == 2)
    goto <bb 223>;
  else
    goto <bb 222>;

  <bb 222>:
  _471 = g_84->NavMoveDir;
  if (_471 == 3)
    goto <bb 223>;
  else
    goto <bb 227>;

  <bb 223>:
  _472 = window_447->Scroll.y;
  _473 = g_84->NavMoveDir;
  if (_473 == 2)
    goto <bb 224>;
  else
    goto <bb 225>;

  <bb 224>:
  iftmp.265_474 = -1.0e+0;
  goto <bb 226>;

  <bb 225>:
  iftmp.265_475 = 1.0e+0;

  <bb 226>:
  # iftmp.265_18 = PHI <iftmp.265_474(224), iftmp.265_475(225)>
  _476 = iftmp.265_18 * scroll_speed_455;
  _477 = _472 + _476;
  _479 = ImFloor (_477);
  SetWindowScrollY (window_447, _479);

  <bb 227>:

  <bb 228>:
  scroll_dir = ImGui::GetNavInputAmount2d (4, 0, 1.00000001490116119384765625e-1, 1.0e+1);
  _482 = scroll_dir.x;
  if (_482 != 0.0)
    goto <bb 229>;
  else
    goto <bb 231>;

  <bb 229>:
  _483 = window_447->ScrollbarX;
  if (_483 != 0)
    goto <bb 230>;
  else
    goto <bb 231>;

  <bb 230>:
  _484 = window_447->Scroll.x;
  _485 = scroll_dir.x;
  _486 = _485 * scroll_speed_455;
  _487 = _484 + _486;
  _489 = ImFloor (_487);
  SetWindowScrollX (window_447, _489);
  g_84->NavMoveFromClampedRefRect = 1;

  <bb 231>:
  _492 = scroll_dir.y;
  if (_492 != 0.0)
    goto <bb 232>;
  else
    goto <bb 233>;

  <bb 232>:
  _493 = window_447->Scroll.y;
  _494 = scroll_dir.y;
  _495 = _494 * scroll_speed_455;
  _496 = _493 + _495;
  _498 = ImFloor (_496);
  SetWindowScrollY (window_447, _498);
  g_84->NavMoveFromClampedRefRect = 1;

  <bb 233>:
  scroll_dir ={v} {CLOBBER};

  <bb 234>:
  _503 = &g_84->NavMoveResultLocal;
  ImGuiNavMoveResult::Clear (_503);
  _505 = &g_84->NavMoveResultOther;
  ImGuiNavMoveResult::Clear (_505);
  _507 = g_84->NavMoveRequest;
  if (_507 != 0)
    goto <bb 235>;
  else
    goto <bb 240>;

  <bb 235>:
  _508 = g_84->NavMoveFromClampedRefRect;
  if (_508 != 0)
    goto <bb 236>;
  else
    goto <bb 240>;

  <bb 236>:
  _509 = g_84->NavLayer;
  if (_509 == 0)
    goto <bb 237>;
  else
    goto <bb 240>;

  <bb 237>:
  window_510 = g_84->NavWindow;
  ImVec2::ImVec2 (&D.16394, 1.0e+0, 1.0e+0);
  _512 = &window_510->Pos;
  _513 = &window_510->InnerRect.Max;
  D.16393 = operator- (_513, _512);
  D.16395 = operator+ (&D.16393, &D.16394);
  ImVec2::ImVec2 (&D.16391, 1.0e+0, 1.0e+0);
  _517 = &window_510->Pos;
  _518 = &window_510->InnerRect.Min;
  D.16390 = operator- (_518, _517);
  D.16392 = operator- (&D.16390, &D.16391);
  ImRect::ImRect (&window_rect_rel, &D.16392, &D.16395);
  D.16392 ={v} {CLOBBER};
  D.16390 ={v} {CLOBBER};
  D.16391 ={v} {CLOBBER};
  D.16395 ={v} {CLOBBER};
  D.16393 ={v} {CLOBBER};
  D.16394 ={v} {CLOBBER};
  _528 = g_84->NavLayer;
  _529 = &window_510->NavRectRel[_528];
  _531 = ImRect::Contains (&window_rect_rel, _529);
  retval.266_532 = ~_531;
  if (retval.266_532 != 0)
    goto <bb 238>;
  else
    goto <bb 239>;

  <bb 238>:
  _534 = ImGuiWindow::CalcFontSize (window_510);
  pad_535 = _534 * 5.0e-1;
  _537 = ImRect::GetHeight (&window_rect_rel);
  _539 = ImMin (_537, pad_535);
  _540 = -_539;
  _542 = ImRect::GetWidth (&window_rect_rel);
  _544 = ImMin (_542, pad_535);
  _545 = -_544;
  ImVec2::ImVec2 (&D.16397, _545, _540);
  ImRect::Expand (&window_rect_rel, &D.16397);
  D.16397 ={v} {CLOBBER};
  _549 = g_84->NavLayer;
  _550 = &window_510->NavRectRel[_549];
  ImRect::ClipWith (_550, &window_rect_rel);
  g_84->NavId = 0;

  <bb 239>:
  g_84->NavMoveFromClampedRefRect = 0;
  window_rect_rel ={v} {CLOBBER};

  <bb 240>:
  _555 = g_84->NavWindow;
  if (_555 != 0B)
    goto <bb 241>;
  else
    goto <bb 243>;

  <bb 241>:
  _556 = g_84->NavWindow;
  _557 = g_84->NavLayer;
  _558 = &_556->NavRectRel[_557];
  _560 = ImRect::IsInverted (_558);
  _561 = ~_560;
  if (_561 != 0)
    goto <bb 242>;
  else
    goto <bb 243>;

  <bb 242>:
  _562 = g_84->NavWindow;
  _563 = g_84->NavLayer;
  nav_rect_rel = _562->NavRectRel[_563];
  goto <bb 244>;

  <bb 243>:
  ImRect::ImRect (&nav_rect_rel, 0.0, 0.0, 0.0, 0.0);

  <bb 244>:
  _566 = g_84->NavWindow;
  if (_566 != 0B)
    goto <bb 245>;
  else
    goto <bb 246>;

  <bb 245>:
  _567 = g_84->NavWindow;
  _568 = &_567->Pos;
  D.16403 = operator+ (_568, &nav_rect_rel.Max);
  _570 = g_84->NavWindow;
  _571 = &_570->Pos;
  D.16402 = operator+ (_571, &nav_rect_rel.Min);
  ImRect::ImRect (&D.16404, &D.16402, &D.16403);
  g_84->NavScoringRectScreen = D.16404;
  goto <bb 247>;

  <bb 246>:
  g_84->NavScoringRectScreen = GetViewportRect ();

  <bb 247>:
  D.16404 ={v} {CLOBBER};
  D.16402 ={v} {CLOBBER};
  D.16403 ={v} {CLOBBER};
  _579 = g_84->NavScoringRectScreen.Max.x;
  _580 = g_84->NavScoringRectScreen.Min.x;
  _581 = _580 + 1.0e+0;
  _583 = ImMin (_581, _579);
  g_84->NavScoringRectScreen.Min.x = _583;
  _585 = g_84->NavScoringRectScreen.Min.x;
  g_84->NavScoringRectScreen.Max.x = _585;
  _587 = &g_84->NavScoringRectScreen;
  _589 = ImRect::IsInverted (_587);
  _590 = ~_589;
  if (_590 != 0)
    goto <bb 249>;
  else
    goto <bb 248>;

  <bb 248>:
  __assert_fail ("!g.NavScoringRectScreen.IsInverted()", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3247, &__PRETTY_FUNCTION__);

  <bb 249>:
  g_84->NavScoringCount = 0;
  nav_rect_rel ={v} {CLOBBER};
  return;

}



;; Function void ImGui::NewFrameUpdateMovingWindow() (_ZN5ImGuiL26NewFrameUpdateMovingWindowEv, funcdef_no=709, decl_uid=15118, cgraph_uid=608, symbol_order=614)

void ImGui::NewFrameUpdateMovingWindow() ()
{
  struct ImVec2 pos;
  struct ImGuiWindow * moving_window;
  static const char __PRETTY_FUNCTION__[41] = "void ImGui::NewFrameUpdateMovingWindow()";
  struct ImGuiContext & g;
  bool D.26911;
  bool D.26910;
  unsigned int D.26909;
  unsigned int D.26906;
  unsigned int D.26905;
  struct ImGuiWindow * D.26904;
  struct ImGuiWindow * D.26901;
  struct ImGuiWindow * D.26899;
  float D.26898;
  float D.26897;
  float D.26895;
  float D.26894;
  struct ImVec2 * D.26891;
  struct ImVec2 * D.26890;
  bool D.26887;
  struct ImGuiWindow * D.26886;
  struct ImGuiWindow * D.26884;
  struct ImGuiWindow * D.26883;
  struct ImGuiWindow * D.26881;
  unsigned int D.26878;
  ImGuiInputSource D.26876;
  unsigned int D.26874;
  unsigned int D.26873;
  struct ImGuiWindow * D.26872;
  struct ImGuiWindow * D.26870;
  struct ImGuiWindow * _7;
  struct ImGuiWindow * _8;
  unsigned int _9;
  unsigned int _10;
  ImGuiInputSource _11;
  unsigned int _12;
  struct ImGuiWindow * _14;
  struct ImGuiWindow * _15;
  struct ImGuiWindow * _16;
  struct ImGuiWindow * _17;
  bool _19;
  struct ImVec2 * _20;
  struct ImVec2 * _21;
  float _23;
  float _24;
  float _25;
  float _26;
  struct ImGuiWindow * _29;
  struct ImGuiWindow * _36;
  struct ImGuiWindow * _37;
  unsigned int _38;
  unsigned int _39;
  unsigned int _40;
  bool _42;
  bool _43;

  <bb 2>:
  g_6 = GImGui;
  _7 = g_6->MovingWindow;
  if (_7 != 0B)
    goto <bb 3>;
  else
    goto <bb 16>;

  <bb 3>:
  _8 = g_6->MovingWindow;
  _9 = _8->MoveId;
  _10 = g_6->ActiveId;
  if (_9 == _10)
    goto <bb 4>;
  else
    goto <bb 16>;

  <bb 4>:
  _11 = g_6->ActiveIdSource;
  if (_11 == 1)
    goto <bb 5>;
  else
    goto <bb 16>;

  <bb 5>:
  _12 = g_6->ActiveId;
  ImGui::KeepAliveID (_12);
  _14 = g_6->MovingWindow;
  if (_14 != 0B)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _15 = g_6->MovingWindow;
  _16 = _15->RootWindow;
  if (_16 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 9>;

  <bb 8>:
  __assert_fail ("g.MovingWindow && g.MovingWindow->RootWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3264, &__PRETTY_FUNCTION__);

  <bb 9>:
  _17 = g_6->MovingWindow;
  moving_window_18 = _17->RootWindow;
  _19 = g_6->IO.MouseDown[0];
  if (_19 != 0)
    goto <bb 10>;
  else
    goto <bb 14>;

  <bb 10>:
  _20 = &g_6->ActiveIdClickOffset;
  _21 = &g_6->IO.MousePos;
  pos = operator- (_21, _20);
  _23 = moving_window_18->PosFloat.x;
  _24 = pos.x;
  if (_23 != _24)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  _25 = moving_window_18->PosFloat.y;
  _26 = pos.y;
  if (_25 != _26)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  MarkIniSettingsDirty (moving_window_18);
  moving_window_18->PosFloat = pos;

  <bb 13>:
  _29 = g_6->MovingWindow;
  ImGui::FocusWindow (_29);
  pos ={v} {CLOBBER};
  goto <bb 15>;

  <bb 14>:
  ImGui::ClearActiveID ();
  g_6->MovingWindow = 0B;

  <bb 15>:
  goto <bb 21>;

  <bb 16>:
  _36 = g_6->ActiveIdWindow;
  if (_36 != 0B)
    goto <bb 17>;
  else
    goto <bb 20>;

  <bb 17>:
  _37 = g_6->ActiveIdWindow;
  _38 = _37->MoveId;
  _39 = g_6->ActiveId;
  if (_38 == _39)
    goto <bb 18>;
  else
    goto <bb 20>;

  <bb 18>:
  _40 = g_6->ActiveId;
  ImGui::KeepAliveID (_40);
  _42 = g_6->IO.MouseDown[0];
  _43 = ~_42;
  if (_43 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  ImGui::ClearActiveID ();

  <bb 20>:
  g_6->MovingWindow = 0B;

  <bb 21>:
  return;

}



;; Function void ImGui::NewFrameUpdateMouseInputs() (_ZN5ImGuiL25NewFrameUpdateMouseInputsEv, funcdef_no=710, decl_uid=15119, cgraph_uid=609, symbol_order=615)

void ImGui::NewFrameUpdateMouseInputs() ()
{
  struct ImVec2 mouse_delta;
  int i;
  struct ImGuiContext & g;
  bool D.27014;
  float D.27012;
  float D.27011;
  float D.27010;
  float D.27009;
  float D.27008;
  float D.27006;
  float D.27003;
  float iftmp.280;
  float D.27001;
  float D.27000;
  float D.26998;
  float D.26995;
  float iftmp.279;
  struct ImVec2 * D.26993;
  struct ImVec2 * D.26992;
  bool D.26989;
  struct ImVec2 D.16423;
  float D.26987;
  float D.26982;
  float D.26981;
  float D.26980;
  float D.26979;
  struct ImVec2 * D.26978;
  struct ImVec2 * D.26977;
  struct ImVec2 D.16422;
  bool retval.278;
  float D.26973;
  float D.26972;
  float D.26971;
  float D.26970;
  bool D.26967;
  float D.26965;
  float D.26964;
  float D.26960;
  float iftmp.277;
  bool D.26956;
  float iftmp.276;
  float D.26954;
  float D.26952;
  bool D.26950;
  bool D.26949;
  bool iftmp.275;
  float D.26944;
  bool D.26942;
  bool iftmp.274;
  float D.26936;
  float D.26934;
  struct ImVec2 D.16420;
  struct ImVec2 * D.26930;
  struct ImVec2 * D.26929;
  bool D.26925;
  struct ImVec2 * D.26924;
  bool D.26922;
  struct ImVec2 * D.26921;
  bool iftmp.273;
  bool retval.272;
  bool iftmp.273_2;
  bool iftmp.274_3;
  bool iftmp.275_4;
  float iftmp.276_5;
  float iftmp.277_6;
  float iftmp.279_7;
  float iftmp.280_8;
  struct ImVec2 * _20;
  bool _22;
  struct ImVec2 * _23;
  bool _25;
  bool iftmp.273_26;
  bool iftmp.273_27;
  bool retval.272_28;
  struct ImVec2 * _29;
  struct ImVec2 * _30;
  float _35;
  float _36;
  bool _40;
  float _41;
  bool iftmp.274_42;
  bool iftmp.274_43;
  bool _45;
  bool _46;
  float _47;
  bool iftmp.275_48;
  bool iftmp.275_49;
  float _51;
  bool _53;
  float _54;
  float iftmp.277_55;
  float _56;
  float _57;
  float iftmp.277_58;
  float iftmp.276_59;
  float iftmp.276_60;
  bool _63;
  float _64;
  float _65;
  float _66;
  float _67;
  struct ImVec2 * _68;
  struct ImVec2 * _69;
  float _72;
  float _73;
  float _74;
  float _75;
  bool retval.278_76;
  float _80;
  bool _87;
  struct ImVec2 * _88;
  struct ImVec2 * _89;
  float _91;
  float _92;
  float iftmp.279_93;
  float iftmp.279_94;
  float _95;
  float _97;
  float _99;
  float _100;
  float iftmp.280_101;
  float iftmp.280_102;
  float _103;
  float _105;
  float _108;
  float _109;
  float _111;
  bool _114;

  <bb 2>:
  g_19 = GImGui;
  _20 = &g_19->IO.MousePos;
  _22 = ImGui::IsMousePosValid (_20);
  if (_22 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _23 = &g_19->IO.MousePosPrev;
  _25 = ImGui::IsMousePosValid (_23);
  if (_25 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.273_26 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.273_27 = 0;

  <bb 6>:
  # iftmp.273_2 = PHI <iftmp.273_26(4), iftmp.273_27(5)>
  retval.272_28 = iftmp.273_2;
  if (retval.272_28 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _29 = &g_19->IO.MousePosPrev;
  _30 = &g_19->IO.MousePos;
  g_19->IO.MouseDelta = operator- (_30, _29);
  goto <bb 9>;

  <bb 8>:
  ImVec2::ImVec2 (&D.16420, 0.0, 0.0);
  g_19->IO.MouseDelta = D.16420;
  D.16420 ={v} {CLOBBER};

  <bb 9>:
  _35 = g_19->IO.MouseDelta.x;
  if (_35 != 0.0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  _36 = g_19->IO.MouseDelta.y;
  if (_36 != 0.0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  g_19->NavDisableMouseHover = 0;

  <bb 12>:
  g_19->IO.MousePosPrev = g_19->IO.MousePos;
  i_39 = 0;

  <bb 13>:
  # i_1 = PHI <i_39(12), i_116(45)>
  if (i_1 > 4)
    goto <bb 46>;
  else
    goto <bb 14>;

  <bb 14>:
  _40 = g_19->IO.MouseDown[i_1];
  if (_40 != 0)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  _41 = g_19->IO.MouseDownDuration[i_1];
  if (_41 < 0.0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.274_42 = 1;
  goto <bb 18>;

  <bb 17>:
  iftmp.274_43 = 0;

  <bb 18>:
  # iftmp.274_3 = PHI <iftmp.274_42(16), iftmp.274_43(17)>
  g_19->IO.MouseClicked[i_1] = iftmp.274_3;
  _45 = g_19->IO.MouseDown[i_1];
  _46 = ~_45;
  if (_46 != 0)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  _47 = g_19->IO.MouseDownDuration[i_1];
  if (_47 >= 0.0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  iftmp.275_48 = 1;
  goto <bb 22>;

  <bb 21>:
  iftmp.275_49 = 0;

  <bb 22>:
  # iftmp.275_4 = PHI <iftmp.275_48(20), iftmp.275_49(21)>
  g_19->IO.MouseReleased[i_1] = iftmp.275_4;
  _51 = g_19->IO.MouseDownDuration[i_1];
  g_19->IO.MouseDownDurationPrev[i_1] = _51;
  _53 = g_19->IO.MouseDown[i_1];
  if (_53 != 0)
    goto <bb 23>;
  else
    goto <bb 27>;

  <bb 23>:
  _54 = g_19->IO.MouseDownDuration[i_1];
  if (_54 < 0.0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  iftmp.277_55 = 0.0;
  goto <bb 26>;

  <bb 25>:
  _56 = g_19->IO.MouseDownDuration[i_1];
  _57 = g_19->IO.DeltaTime;
  iftmp.277_58 = _56 + _57;

  <bb 26>:
  # iftmp.277_6 = PHI <iftmp.277_55(24), iftmp.277_58(25)>
  iftmp.276_59 = iftmp.277_6;
  goto <bb 28>;

  <bb 27>:
  iftmp.276_60 = -1.0e+0;

  <bb 28>:
  # iftmp.276_5 = PHI <iftmp.276_59(26), iftmp.276_60(27)>
  g_19->IO.MouseDownDuration[i_1] = iftmp.276_5;
  g_19->IO.MouseDoubleClicked[i_1] = 0;
  _63 = g_19->IO.MouseClicked[i_1];
  if (_63 != 0)
    goto <bb 29>;
  else
    goto <bb 35>;

  <bb 29>:
  _64 = g_19->Time;
  _65 = g_19->IO.MouseClickedTime[i_1];
  _66 = _64 - _65;
  _67 = g_19->IO.MouseDoubleClickTime;
  if (_66 < _67)
    goto <bb 30>;
  else
    goto <bb 33>;

  <bb 30>:
  _68 = &g_19->IO.MouseClickedPos[i_1];
  _69 = &g_19->IO.MousePos;
  D.16422 = operator- (_69, _68);
  _72 = ImLengthSqr (&D.16422);
  _73 = g_19->IO.MouseDoubleClickMaxDist;
  _74 = g_19->IO.MouseDoubleClickMaxDist;
  _75 = _73 * _74;
  retval.278_76 = _72 < _75;
  D.16422 ={v} {CLOBBER};
  if (retval.278_76 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  g_19->IO.MouseDoubleClicked[i_1] = 1;

  <bb 32>:
  g_19->IO.MouseClickedTime[i_1] = -3.4028234663852885981170418348451692544e+38;
  goto <bb 34>;

  <bb 33>:
  _80 = g_19->Time;
  g_19->IO.MouseClickedTime[i_1] = _80;

  <bb 34>:
  g_19->IO.MouseClickedPos[i_1] = g_19->IO.MousePos;
  ImVec2::ImVec2 (&D.16423, 0.0, 0.0);
  g_19->IO.MouseDragMaxDistanceAbs[i_1] = D.16423;
  D.16423 ={v} {CLOBBER};
  g_19->IO.MouseDragMaxDistanceSqr[i_1] = 0.0;
  goto <bb 43>;

  <bb 35>:
  _87 = g_19->IO.MouseDown[i_1];
  if (_87 != 0)
    goto <bb 36>;
  else
    goto <bb 43>;

  <bb 36>:
  _88 = &g_19->IO.MouseClickedPos[i_1];
  _89 = &g_19->IO.MousePos;
  mouse_delta = operator- (_89, _88);
  _91 = mouse_delta.x;
  if (_91 < 0.0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  _92 = mouse_delta.x;
  iftmp.279_93 = -_92;
  goto <bb 39>;

  <bb 38>:
  iftmp.279_94 = mouse_delta.x;

  <bb 39>:
  # iftmp.279_7 = PHI <iftmp.279_93(37), iftmp.279_94(38)>
  _95 = g_19->IO.MouseDragMaxDistanceAbs[i_1].x;
  _97 = ImMax (_95, iftmp.279_7);
  g_19->IO.MouseDragMaxDistanceAbs[i_1].x = _97;
  _99 = mouse_delta.y;
  if (_99 < 0.0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  _100 = mouse_delta.y;
  iftmp.280_101 = -_100;
  goto <bb 42>;

  <bb 41>:
  iftmp.280_102 = mouse_delta.y;

  <bb 42>:
  # iftmp.280_8 = PHI <iftmp.280_101(40), iftmp.280_102(41)>
  _103 = g_19->IO.MouseDragMaxDistanceAbs[i_1].y;
  _105 = ImMax (_103, iftmp.280_8);
  g_19->IO.MouseDragMaxDistanceAbs[i_1].y = _105;
  _108 = ImLengthSqr (&mouse_delta);
  _109 = g_19->IO.MouseDragMaxDistanceSqr[i_1];
  _111 = ImMax (_109, _108);
  g_19->IO.MouseDragMaxDistanceSqr[i_1] = _111;
  mouse_delta ={v} {CLOBBER};

  <bb 43>:
  _114 = g_19->IO.MouseClicked[i_1];
  if (_114 != 0)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  g_19->NavDisableMouseHover = 0;

  <bb 45>:
  i_116 = i_1 + 1;
  goto <bb 13>;

  <bb 46>:
  return;

}



;; Function void ImGui::NewFrameUpdateHoveredWindowAndCaptureFlags() (_ZN5ImGui42NewFrameUpdateHoveredWindowAndCaptureFlagsEv, funcdef_no=711, decl_uid=13754, cgraph_uid=610, symbol_order=616)

void ImGui::NewFrameUpdateHoveredWindowAndCaptureFlags() ()
{
  struct ImGuiWindow * D.27151;
  int i;
  const bool mouse_dragging_extern_payload;
  const bool mouse_avail_to_imgui;
  bool mouse_any_down;
  int mouse_earliest_button_down;
  struct ImGuiWindow * modal_window;
  struct ImGuiContext & g;
  int D.27149;
  int D.27147;
  bool iftmp.290;
  int D.27140;
  int D.27139;
  int D.27136;
  int D.27135;
  bool D.27132;
  unsigned int D.27130;
  bool iftmp.289;
  bool D.27124;
  int D.27123;
  int D.27120;
  bool D.27119;
  bool D.27118;
  struct ImVector * D.27117;
  struct ImGuiWindow * D.27115;
  bool iftmp.288;
  bool D.27107;
  int D.27106;
  int D.27103;
  struct ImGuiWindow * D.27101;
  bool D.27098;
  bool D.27095;
  int D.27093;
  int D.27092;
  bool D.27090;
  bool iftmp.287;
  bool D.27086;
  bool iftmp.286;
  float D.27079;
  float D.27078;
  bool D.27072;
  bool D.27071;
  bool D.27069;
  bool D.27068;
  struct ImVector * D.27067;
  struct ImGuiWindow * D.27065;
  bool iftmp.285;
  bool D.27058;
  struct ImGuiWindow * D.27054;
  int D.27051;
  int D.27050;
  struct ImGuiWindow * D.27047;
  bool D.27043;
  bool D.27042;
  struct ImGuiWindow * D.27041;
  struct ImGuiWindow * D.27039;
  bool iftmp.284;
  bool retval.283;
  struct ImGuiWindow * D.27031;
  struct ImGuiWindow * D.27028;
  struct ImGuiWindow * iftmp.282;
  int D.27025;
  int D.27024;
  struct ImGuiWindow * D.27023;
  struct ImGuiWindow * D.27021;
  struct ImGuiWindow * iftmp.281;
  struct ImGuiWindow * iftmp.281_6;
  struct ImGuiWindow * iftmp.282_7;
  bool iftmp.284_8;
  bool iftmp.285_9;
  bool iftmp.286_10;
  bool iftmp.287_11;
  bool iftmp.288_12;
  bool iftmp.289_13;
  bool iftmp.290_14;
  struct ImGuiWindow * _32;
  struct ImGuiWindow * _33;
  int _34;
  int _35;
  struct ImGuiWindow * iftmp.281_36;
  struct ImGuiWindow * _38;
  struct ImGuiWindow * iftmp.281_39;
  struct ImGuiWindow * _41;
  struct ImGuiWindow * _42;
  struct ImGuiWindow * iftmp.282_43;
  struct ImGuiWindow * iftmp.282_44;
  struct ImGuiWindow * _48;
  struct ImGuiWindow * _49;
  bool _51;
  bool _52;
  bool iftmp.284_53;
  bool iftmp.284_54;
  bool retval.283_55;
  struct ImGuiWindow * _57;
  int _59;
  int _60;
  struct ImGuiWindow * _62;
  bool _67;
  struct ImGuiWindow * _68;
  struct ImVector * _69;
  bool _71;
  bool _72;
  bool iftmp.285_73;
  bool iftmp.285_74;
  bool _76;
  bool _78;
  float _79;
  float _80;
  bool _83;
  bool iftmp.286_84;
  bool iftmp.286_85;
  bool _87;
  int _88;
  int _89;
  bool iftmp.287_90;
  bool iftmp.287_91;
  bool _93;
  bool _94;
  struct ImGuiWindow * _96;
  int _98;
  int _99;
  bool _100;
  struct ImGuiWindow * _102;
  struct ImVector * _103;
  bool _105;
  bool _106;
  bool iftmp.288_107;
  bool iftmp.288_108;
  int _110;
  int _111;
  bool _112;
  unsigned int _114;
  bool iftmp.289_115;
  bool iftmp.289_116;
  bool _118;
  int _119;
  int _120;
  int _121;
  int _122;
  int _124;
  int _125;
  bool iftmp.290_126;
  bool iftmp.290_127;

  <bb 2>:
  g_31 = GImGui;
  _32 = g_31->MovingWindow;
  if (_32 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _33 = g_31->MovingWindow;
  _34 = _33->Flags;
  _35 = _34 & 512;
  if (_35 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.281_36 = g_31->MovingWindow;
  goto <bb 6>;

  <bb 5>:
  _38 = FindHoveredWindow ();
  iftmp.281_39 = _38;

  <bb 6>:
  # iftmp.281_6 = PHI <iftmp.281_36(4), iftmp.281_39(5)>
  g_31->HoveredWindow = iftmp.281_6;
  _41 = g_31->HoveredWindow;
  if (_41 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _42 = g_31->HoveredWindow;
  iftmp.282_43 = _42->RootWindow;
  goto <bb 9>;

  <bb 8>:
  iftmp.282_44 = 0B;

  <bb 9>:
  # iftmp.282_7 = PHI <iftmp.282_43(7), iftmp.282_44(8)>
  g_31->HoveredRootWindow = iftmp.282_7;
  modal_window_47 = GetFrontMostModalRootWindow ();
  if (modal_window_47 != 0B)
    goto <bb 10>;
  else
    goto <bb 16>;

  <bb 10>:
  _48 = g_31->HoveredRootWindow;
  if (_48 != 0B)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  _49 = g_31->HoveredRootWindow;
  _51 = ImGui::IsWindowChildOf (_49, modal_window_47);
  _52 = ~_51;
  if (_52 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.284_53 = 1;
  goto <bb 14>;

  <bb 13>:
  iftmp.284_54 = 0;

  <bb 14>:
  # iftmp.284_8 = PHI <iftmp.284_53(12), iftmp.284_54(13)>
  retval.283_55 = iftmp.284_8;
  if (retval.283_55 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  g_31->HoveredWindow = 0B;
  _57 = g_31->HoveredWindow;
  g_31->HoveredRootWindow = _57;

  <bb 16>:
  _59 = g_31->IO.ConfigFlags;
  _60 = _59 & 16;
  if (_60 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  g_31->HoveredRootWindow = 0B;
  _62 = g_31->HoveredRootWindow;
  g_31->HoveredWindow = _62;

  <bb 18>:
  mouse_earliest_button_down_64 = -1;
  mouse_any_down_65 = 0;
  i_66 = 0;

  <bb 19>:
  # mouse_earliest_button_down_1 = PHI <mouse_earliest_button_down_64(18), mouse_earliest_button_down_3(31)>
  # mouse_any_down_4 = PHI <mouse_any_down_65(18), mouse_any_down_77(31)>
  # i_5 = PHI <i_66(18), i_82(31)>
  if (i_5 > 4)
    goto <bb 32>;
  else
    goto <bb 20>;

  <bb 20>:
  _67 = g_31->IO.MouseClicked[i_5];
  if (_67 != 0)
    goto <bb 21>;
  else
    goto <bb 26>;

  <bb 21>:
  _68 = g_31->HoveredWindow;
  if (_68 != 0B)
    goto <bb 23>;
  else
    goto <bb 22>;

  <bb 22>:
  _69 = &g_31->OpenPopupStack;
  _71 = ImVector<ImGuiPopupRef>::empty (_69);
  _72 = ~_71;
  if (_72 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.285_74 = 1;
  goto <bb 25>;

  <bb 24>:
  iftmp.285_73 = 0;

  <bb 25>:
  # iftmp.285_9 = PHI <iftmp.285_74(23), iftmp.285_73(24)>
  g_31->IO.MouseDownOwned[i_5] = iftmp.285_9;

  <bb 26>:
  _76 = g_31->IO.MouseDown[i_5];
  mouse_any_down_77 = _76 | mouse_any_down_4;
  _78 = g_31->IO.MouseDown[i_5];
  if (_78 != 0)
    goto <bb 27>;
  else
    goto <bb 31>;

  <bb 27>:
  if (mouse_earliest_button_down_1 == -1)
    goto <bb 29>;
  else
    goto <bb 28>;

  <bb 28>:
  _79 = g_31->IO.MouseClickedTime[i_5];
  _80 = g_31->IO.MouseClickedTime[mouse_earliest_button_down_1];
  if (_79 < _80)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  mouse_earliest_button_down_81 = i_5;

  <bb 30>:
  # mouse_earliest_button_down_2 = PHI <mouse_earliest_button_down_1(28), mouse_earliest_button_down_81(29)>

  <bb 31>:
  # mouse_earliest_button_down_3 = PHI <mouse_earliest_button_down_1(26), mouse_earliest_button_down_2(30)>
  i_82 = i_5 + 1;
  goto <bb 19>;

  <bb 32>:
  if (mouse_earliest_button_down_1 == -1)
    goto <bb 34>;
  else
    goto <bb 33>;

  <bb 33>:
  _83 = g_31->IO.MouseDownOwned[mouse_earliest_button_down_1];
  if (_83 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  iftmp.286_85 = 1;
  goto <bb 36>;

  <bb 35>:
  iftmp.286_84 = 0;

  <bb 36>:
  # iftmp.286_10 = PHI <iftmp.286_85(34), iftmp.286_84(35)>
  mouse_avail_to_imgui_86 = iftmp.286_10;
  _87 = g_31->DragDropActive;
  if (_87 != 0)
    goto <bb 37>;
  else
    goto <bb 39>;

  <bb 37>:
  _88 = g_31->DragDropSourceFlags;
  _89 = _88 & 16;
  if (_89 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  iftmp.287_90 = 1;
  goto <bb 40>;

  <bb 39>:
  iftmp.287_91 = 0;

  <bb 40>:
  # iftmp.287_11 = PHI <iftmp.287_90(38), iftmp.287_91(39)>
  mouse_dragging_extern_payload_92 = iftmp.287_11;
  _93 = ~mouse_avail_to_imgui_86;
  if (_93 != 0)
    goto <bb 41>;
  else
    goto <bb 43>;

  <bb 41>:
  _94 = ~mouse_dragging_extern_payload_92;
  if (_94 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  g_31->HoveredRootWindow = 0B;
  _96 = g_31->HoveredRootWindow;
  g_31->HoveredWindow = _96;

  <bb 43>:
  _98 = g_31->WantCaptureMouseNextFrame;
  if (_98 != -1)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  _99 = g_31->WantCaptureMouseNextFrame;
  _100 = _99 != 0;
  g_31->IO.WantCaptureMouse = _100;
  goto <bb 52>;

  <bb 45>:
  if (mouse_avail_to_imgui_86 != 0)
    goto <bb 46>;
  else
    goto <bb 48>;

  <bb 46>:
  _102 = g_31->HoveredWindow;
  if (_102 != 0B)
    goto <bb 49>;
  else
    goto <bb 47>;

  <bb 47>:
  if (mouse_any_down_4 != 0)
    goto <bb 49>;
  else
    goto <bb 48>;

  <bb 48>:
  _103 = &g_31->OpenPopupStack;
  _105 = ImVector<ImGuiPopupRef>::empty (_103);
  _106 = ~_105;
  if (_106 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.288_108 = 1;
  goto <bb 51>;

  <bb 50>:
  iftmp.288_107 = 0;

  <bb 51>:
  # iftmp.288_12 = PHI <iftmp.288_108(49), iftmp.288_107(50)>
  g_31->IO.WantCaptureMouse = iftmp.288_12;

  <bb 52>:
  _110 = g_31->WantCaptureKeyboardNextFrame;
  if (_110 != -1)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  _111 = g_31->WantCaptureKeyboardNextFrame;
  _112 = _111 != 0;
  g_31->IO.WantCaptureKeyboard = _112;
  goto <bb 59>;

  <bb 54>:
  _114 = g_31->ActiveId;
  if (_114 != 0)
    goto <bb 56>;
  else
    goto <bb 55>;

  <bb 55>:
  if (modal_window_47 != 0B)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  iftmp.289_116 = 1;
  goto <bb 58>;

  <bb 57>:
  iftmp.289_115 = 0;

  <bb 58>:
  # iftmp.289_13 = PHI <iftmp.289_116(56), iftmp.289_115(57)>
  g_31->IO.WantCaptureKeyboard = iftmp.289_13;

  <bb 59>:
  _118 = g_31->IO.NavActive;
  if (_118 != 0)
    goto <bb 60>;
  else
    goto <bb 63>;

  <bb 60>:
  _119 = g_31->IO.ConfigFlags;
  _120 = _119 & 1;
  if (_120 != 0)
    goto <bb 61>;
  else
    goto <bb 63>;

  <bb 61>:
  _121 = g_31->IO.ConfigFlags;
  _122 = _121 & 8;
  if (_122 == 0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  g_31->IO.WantCaptureKeyboard = 1;

  <bb 63>:
  _124 = g_31->WantTextInputNextFrame;
  if (_124 != -1)
    goto <bb 64>;
  else
    goto <bb 66>;

  <bb 64>:
  _125 = g_31->WantTextInputNextFrame;
  if (_125 != 0)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  iftmp.290_126 = 1;
  goto <bb 67>;

  <bb 66>:
  iftmp.290_127 = 0;

  <bb 67>:
  # iftmp.290_14 = PHI <iftmp.290_126(65), iftmp.290_127(66)>
  g_31->IO.WantTextInput = iftmp.290_14;
  return;

}



;; Function void ImGui::NewFrame() (_ZN5ImGui8NewFrameEv, funcdef_no=712, decl_uid=2429, cgraph_uid=611, symbol_order=617)

void ImGui::NewFrame() ()
{
  bool D.27526;
  struct ImFont * D.27525;
  struct ImGuiWindow * window;
  int i;
  float scroll_amount;
  float scroll_amount;
  const struct ImVec2 offset;
  const float scale;
  const float new_font_scale;
  const bool scroll_allowed;
  struct ImGuiWindow * scroll_window;
  struct ImGuiWindow * window;
  int i;
  int n;
  struct ImGuiContext & g;
  static const char __PRETTY_FUNCTION__[23] = "void ImGui::NewFrame()";
  struct ImVec2 D.16461;
  struct ImGuiWindow * D.27524;
  struct ImVector * D.27523;
  struct ImVector * D.27522;
  bool D.27518;
  bool D.27517;
  struct ImGuiWindow * D.27516;
  struct ImGuiWindow * D.27513;
  bool D.27512;
  struct ImGuiWindow * & D.27511;
  struct ImVector * D.27510;
  int D.27508;
  bool D.27502;
  int iftmp.301;
  struct ImGuiWindow * D.27500;
  int D.27499;
  bool D.27495;
  int iftmp.300;
  int D.27493;
  int D.27492;
  struct ImGuiWindow * D.27491;
  int D.27489;
  unsigned int D.27487;
  bool D.27481;
  bool D.27479;
  bool D.27478;
  int D.27476;
  int D.27475;
  struct ImGuiWindow * D.27474;
  bool D.27472;
  struct ImGuiWindow * D.27471;
  struct ImGuiWindow * D.27469;
  unsigned int D.27467;
  bool iftmp.299;
  bool retval.298;
  float D.27460;
  float D.27459;
  float D.27458;
  float D.27457;
  int D.27454;
  int D.27453;
  bool D.27450;
  bool D.27449;
  float D.27444;
  float D.27441;
  float D.27440;
  float D.27439;
  float D.27438;
  int D.27437;
  float D.27436;
  float D.27435;
  float D.27434;
  float D.27433;
  float D.27432;
  float D.27431;
  struct ImRect * D.27430;
  float D.27429;
  bool D.27424;
  bool D.27423;
  struct ImVec2 * D.27422;
  struct ImVec2 * D.27421;
  struct ImVec2 * D.27420;
  struct ImVec2 * D.27419;
  struct ImVec2 * D.27418;
  float D.27417;
  struct ImVec2 D.16453;
  struct ImVec2 * D.27416;
  struct ImVec2 * D.27415;
  struct ImVec2 D.16454;
  struct ImVec2 D.16455;
  struct ImVec2 * D.27414;
  float D.27413;
  float D.27412;
  float D.27411;
  float D.27410;
  float D.27409;
  bool D.27407;
  bool D.27405;
  float D.27400;
  int D.27398;
  int D.27397;
  int D.27395;
  int D.27394;
  bool iftmp.297;
  struct ImGuiWindow * D.27389;
  int D.27387;
  int D.27386;
  int D.27384;
  int D.27383;
  int D.27381;
  int D.27380;
  int D.27378;
  int D.27377;
  float D.27375;
  float D.27373;
  bool D.27370;
  bool D.27369;
  struct ImGuiWindow * D.27368;
  struct ImGuiWindow * D.27365;
  struct ImVec2 D.16446;
  int D.27362;
  int D.27361;
  float D.27359;
  float D.27358;
  float D.27357;
  float D.27356;
  float D.27355;
  struct ImGuiWindow * D.27352;
  bool retval.296;
  float D.27350;
  float D.27349;
  float D.27348;
  int D.27347;
  int D.27346;
  int D.27345;
  float D.27344;
  int D.27343;
  float D.27342;
  float D.27341;
  float D.27340;
  int D.27339;
  float D.27338;
  float D.27337;
  float D.27335;
  float D.27334;
  float D.27330;
  float iftmp.295;
  bool D.27326;
  float iftmp.294;
  float[512] * D.27322;
  float[512] * D.27321;
  unsigned int D.27320;
  unsigned char[8] * D.27318;
  struct ImVector * D.27317;
  int D.27314;
  int D.27313;
  int D.27312;
  bool D.27309;
  unsigned int D.27305;
  unsigned int D.27304;
  unsigned int D.27301;
  unsigned int D.27300;
  float D.27298;
  float D.27297;
  float D.27296;
  unsigned int D.27293;
  unsigned int D.27289;
  unsigned int D.27286;
  unsigned int D.27285;
  bool D.27282;
  bool D.27281;
  unsigned int D.27280;
  unsigned int D.27276;
  struct ImDrawData * D.27275;
  int D.27274;
  bool D.27270;
  int iftmp.293;
  bool D.27265;
  int iftmp.292;
  struct ImDrawList * D.27263;
  struct ImDrawList * D.27262;
  void * D.27261;
  struct ImFontAtlas * D.27260;
  struct ImDrawList * D.27259;
  float D.27258;
  float D.27257;
  float D.27256;
  struct ImVec4 D.16444;
  bool D.27252;
  struct ImFont * D.27251;
  struct ImFont * D.27250;
  int D.27249;
  int D.27248;
  float D.27247;
  float D.27246;
  float D.27245;
  const char * D.27242;
  float D.27239;
  float D.27238;
  float D.27237;
  float D.27236;
  float D.27233;
  const char * D.27231;
  bool D.27227;
  struct ImVector * D.27226;
  bool D.27223;
  bool D.27222;
  int D.27217;
  int D.27214;
  int D.27213;
  int D.27211;
  int D.27209;
  int D.27201;
  int D.27200;
  int D.27197;
  float D.27195;
  float D.27193;
  float D.27187;
  bool D.27184;
  struct ImFont * D.27183;
  struct ImFont * & D.27182;
  struct ImVector * D.27181;
  struct ImFontAtlas * D.27180;
  int D.27174;
  struct ImFontAtlas * D.27173;
  float D.27171;
  float D.27169;
  float D.27163;
  bool D.27159;
  struct ImGuiContext * GImGui.291;
  int iftmp.292_5;
  int iftmp.293_6;
  float iftmp.294_7;
  float iftmp.295_8;
  bool iftmp.297_9;
  bool iftmp.299_10;
  int iftmp.300_11;
  int iftmp.301_12;
  struct ImGuiContext * GImGui.291_33;
  bool _35;
  float _36;
  float _37;
  float _38;
  struct ImFontAtlas * _39;
  int _40;
  struct ImFontAtlas * _41;
  struct ImVector * _42;
  struct ImFont * & _44;
  struct ImFont * _45;
  bool _47;
  float _48;
  float _49;
  float _50;
  int _51;
  int _52;
  int _53;
  int _56;
  int _57;
  int _60;
  int _61;
  int _62;
  bool _64;
  bool _65;
  struct ImVector * _66;
  bool _68;
  const char * _69;
  float _73;
  float _74;
  float _75;
  float _76;
  float _78;
  const char * _79;
  float _81;
  float _82;
  float _83;
  int _85;
  int _86;
  struct ImFont * _91;
  struct ImFont * _92;
  struct ImFont * _94;
  bool _96;
  float _97;
  float _98;
  float _102;
  struct ImDrawList * _104;
  struct ImFontAtlas * _106;
  void * _107;
  struct ImDrawList * _108;
  struct ImDrawList * _110;
  bool _112;
  int iftmp.292_113;
  int iftmp.292_114;
  bool _115;
  int iftmp.293_116;
  int iftmp.293_117;
  int _118;
  struct ImDrawData * _120;
  unsigned int _122;
  unsigned int _124;
  bool _128;
  bool _129;
  unsigned int _130;
  unsigned int _131;
  unsigned int _132;
  unsigned int _134;
  float _135;
  float _136;
  float _137;
  unsigned int _139;
  unsigned int _143;
  unsigned int _144;
  unsigned int _145;
  bool _147;
  int _148;
  int _149;
  int _150;
  struct ImVector * _152;
  unsigned char[8] * _154;
  unsigned int _156;
  float[512] * _160;
  float[512] * _161;
  bool _164;
  float _165;
  float iftmp.295_166;
  float _167;
  float _168;
  float iftmp.295_169;
  float iftmp.294_170;
  float iftmp.294_171;
  float _176;
  float _177;
  int _178;
  float _179;
  float _180;
  float _181;
  int _183;
  float _184;
  int _186;
  int _187;
  int _188;
  float _190;
  float _191;
  float _192;
  struct ImGuiWindow * _197;
  bool retval.296_198;
  float _199;
  float _200;
  float _201;
  float _202;
  float _204;
  int _209;
  int _211;
  struct ImGuiWindow * _216;
  struct ImGuiWindow * _217;
  bool _218;
  bool _219;
  float _220;
  float _221;
  int _224;
  int _225;
  int _226;
  int _227;
  int _228;
  int _229;
  int _230;
  int _231;
  struct ImGuiWindow * _232;
  int _234;
  int _235;
  int _236;
  int _237;
  bool iftmp.297_238;
  bool iftmp.297_239;
  float _241;
  bool _242;
  bool _243;
  float _244;
  float _245;
  float _246;
  float _247;
  float _250;
  struct ImVec2 * _253;
  struct ImVec2 * _254;
  struct ImVec2 * _255;
  float _257;
  struct ImVec2 * _258;
  struct ImVec2 * _265;
  struct ImVec2 * _267;
  struct ImVec2 * _269;
  struct ImVec2 * _271;
  bool _274;
  bool _275;
  float _277;
  struct ImRect * _279;
  float _281;
  float _282;
  float _283;
  float _284;
  float _285;
  float _287;
  int _288;
  float _290;
  float _291;
  float _292;
  float _293;
  float _295;
  bool _298;
  bool _299;
  int _300;
  int _301;
  float _302;
  float _303;
  float _304;
  float _305;
  unsigned int _307;
  struct ImGuiWindow * _308;
  struct ImGuiWindow * _309;
  bool _310;
  struct ImGuiWindow * _311;
  int _312;
  int _313;
  bool _314;
  bool _315;
  bool _317;
  bool _318;
  bool iftmp.299_319;
  bool iftmp.299_320;
  bool retval.298_321;
  unsigned int _322;
  int _323;
  struct ImGuiWindow * _324;
  int _325;
  int _326;
  bool _327;
  int iftmp.300_328;
  int iftmp.300_329;
  int _330;
  struct ImGuiWindow * _332;
  bool _333;
  int iftmp.301_334;
  int iftmp.301_335;
  int _339;
  struct ImVector * _340;
  struct ImGuiWindow * & _342;
  bool _344;
  struct ImGuiWindow * _349;
  struct ImGuiWindow * _350;
  bool _351;
  bool _352;
  struct ImVector * _354;
  struct ImVector * _356;
  struct ImGuiWindow * _358;

  <bb 2>:
  GImGui.291_33 = GImGui;
  if (GImGui.291_33 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("GImGui != __null && \"No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3405, &__PRETTY_FUNCTION__);

  <bb 4>:
  g_34 = GImGui;
  _35 = g_34->Initialized;
  if (_35 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("g.Initialized", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3410, &__PRETTY_FUNCTION__);

  <bb 6>:
  _36 = g_34->IO.DeltaTime;
  if (_36 >= 0.0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("g.IO.DeltaTime >= 0.0f && \"Need a positive DeltaTime (zero is tolerated but will cause some timing issues)\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3411, &__PRETTY_FUNCTION__);

  <bb 8>:
  _37 = g_34->IO.DisplaySize.x;
  if (_37 >= 0.0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _38 = g_34->IO.DisplaySize.y;
  if (_38 >= 0.0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 12>;

  <bb 11>:
  __assert_fail ("g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && \"Invalid DisplaySize value\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3412, &__PRETTY_FUNCTION__);

  <bb 12>:
  _39 = g_34->IO.Fonts;
  _40 = _39->Fonts.Size;
  if (_40 > 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  __assert_fail ("g.IO.Fonts->Fonts.Size > 0 && \"Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3413, &__PRETTY_FUNCTION__);

  <bb 14>:
  _41 = g_34->IO.Fonts;
  _42 = &_41->Fonts;
  _44 = ImVector<ImFont*>::operator[] (_42, 0);
  _45 = *_44;
  _47 = ImFont::IsLoaded (_45);
  if (_47 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  goto <bb 17>;

  <bb 16>:
  __assert_fail ("g.IO.Fonts->Fonts[0]->IsLoaded() && \"Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3414, &__PRETTY_FUNCTION__);

  <bb 17>:
  _48 = g_34->Style.CurveTessellationTol;
  if (_48 > 0.0)
    goto <bb 19>;
  else
    goto <bb 18>;

  <bb 18>:
  __assert_fail ("g.Style.CurveTessellationTol > 0.0f && \"Invalid style setting\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3415, &__PRETTY_FUNCTION__);

  <bb 19>:
  _49 = g_34->Style.Alpha;
  if (_49 >= 0.0)
    goto <bb 20>;
  else
    goto <bb 22>;

  <bb 20>:
  _50 = g_34->Style.Alpha;
  if (_50 <= 1.0e+0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  goto <bb 23>;

  <bb 22>:
  __assert_fail ("g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && \"Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3416, &__PRETTY_FUNCTION__);

  <bb 23>:
  _51 = g_34->FrameCount;
  if (_51 == 0)
    goto <bb 26>;
  else
    goto <bb 24>;

  <bb 24>:
  _52 = g_34->FrameCountEnded;
  _53 = g_34->FrameCount;
  if (_52 == _53)
    goto <bb 26>;
  else
    goto <bb 25>;

  <bb 25>:
  __assert_fail ("(g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && \"Forgot to call Render() or EndFrame() at the end of the previous frame?\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3417, &__PRETTY_FUNCTION__);

  <bb 26>:
  n_55 = 0;

  <bb 27>:
  # n_1 = PHI <n_55(26), n_58(32)>
  if (n_1 > 20)
    goto <bb 33>;
  else
    goto <bb 28>;

  <bb 28>:
  _56 = g_34->IO.KeyMap[n_1];
  if (_56 >= -1)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 29>:
  _57 = g_34->IO.KeyMap[n_1];
  if (_57 <= 511)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  goto <bb 32>;

  <bb 31>:
  __assert_fail ("g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < ((int)(sizeof(g.IO.KeysDown)/sizeof(*g.IO.KeysDown))) && \"io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3419, &__PRETTY_FUNCTION__);

  <bb 32>:
  n_58 = n_1 + 1;
  goto <bb 27>;

  <bb 33>:
  _60 = g_34->IO.ConfigFlags;
  _61 = _60 & 1;
  if (_61 != 0)
    goto <bb 34>;
  else
    goto <bb 36>;

  <bb 34>:
  _62 = g_34->IO.KeyMap[12];
  if (_62 != -1)
    goto <bb 36>;
  else
    goto <bb 35>;

  <bb 35>:
  __assert_fail ("g.IO.KeyMap[ImGuiKey_Space] != -1 && \"ImGuiKey_Space is not mapped, required for keyboard navigation.\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3423, &__PRETTY_FUNCTION__);

  <bb 36>:
  _64 = g_34->SettingsLoaded;
  _65 = ~_64;
  if (_65 != 0)
    goto <bb 37>;
  else
    goto <bb 40>;

  <bb 37>:
  _66 = &g_34->SettingsWindows;
  _68 = ImVector<ImGuiWindowSettings>::empty (_66);
  if (_68 != 0)
    goto <bb 39>;
  else
    goto <bb 38>;

  <bb 38>:
  __assert_fail ("g.SettingsWindows.empty()", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3428, &__PRETTY_FUNCTION__);

  <bb 39>:
  _69 = g_34->IO.IniFilename;
  LoadIniSettingsFromDisk (_69);
  g_34->SettingsLoaded = 1;

  <bb 40>:
  _73 = g_34->SettingsDirtyTimer;
  if (_73 > 0.0)
    goto <bb 41>;
  else
    goto <bb 43>;

  <bb 41>:
  _74 = g_34->SettingsDirtyTimer;
  _75 = g_34->IO.DeltaTime;
  _76 = _74 - _75;
  g_34->SettingsDirtyTimer = _76;
  _78 = g_34->SettingsDirtyTimer;
  if (_78 <= 0.0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  _79 = g_34->IO.IniFilename;
  SaveIniSettingsToDisk (_79);

  <bb 43>:
  _81 = g_34->Time;
  _82 = g_34->IO.DeltaTime;
  _83 = _81 + _82;
  g_34->Time = _83;
  _85 = g_34->FrameCount;
  _86 = _85 + 1;
  g_34->FrameCount = _86;
  g_34->TooltipOverrideCount = 0;
  g_34->WindowsActiveCount = 0;
  _91 = GetDefaultFont ();
  _92 = _91;
  ImGui::SetCurrentFont (_92);
  _94 = g_34->Font;
  _96 = ImFont::IsLoaded (_94);
  if (_96 != 0)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  __assert_fail ("g.Font->IsLoaded()", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3447, &__PRETTY_FUNCTION__);

  <bb 45>:
  _97 = g_34->IO.DisplaySize.y;
  _98 = g_34->IO.DisplaySize.x;
  ImVec4::ImVec4 (&D.16444, 0.0, 0.0, _98, _97);
  g_34->DrawListSharedData.ClipRectFullscreen = D.16444;
  D.16444 ={v} {CLOBBER};
  _102 = g_34->Style.CurveTessellationTol;
  g_34->DrawListSharedData.CurveTessellationTol = _102;
  _104 = &g_34->OverlayDrawList;
  ImDrawList::Clear (_104);
  _106 = g_34->IO.Fonts;
  _107 = _106->TexID;
  _108 = &g_34->OverlayDrawList;
  ImDrawList::PushTextureID (_108, _107);
  _110 = &g_34->OverlayDrawList;
  ImDrawList::PushClipRectFullScreen (_110);
  _112 = g_34->Style.AntiAliasedLines;
  if (_112 != 0)
    goto <bb 46>;
  else
    goto <bb 47>;

  <bb 46>:
  iftmp.292_113 = 1;
  goto <bb 48>;

  <bb 47>:
  iftmp.292_114 = 0;

  <bb 48>:
  # iftmp.292_5 = PHI <iftmp.292_113(46), iftmp.292_114(47)>
  _115 = g_34->Style.AntiAliasedFill;
  if (_115 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.293_116 = 2;
  goto <bb 51>;

  <bb 50>:
  iftmp.293_117 = 0;

  <bb 51>:
  # iftmp.293_6 = PHI <iftmp.293_116(49), iftmp.293_117(50)>
  _118 = iftmp.292_5 | iftmp.293_6;
  g_34->OverlayDrawList.Flags = _118;
  _120 = &g_34->DrawData;
  ImDrawData::Clear (_120);
  _122 = g_34->HoveredIdPreviousFrame;
  if (_122 == 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  g_34->HoveredIdTimer = 0.0;

  <bb 53>:
  _124 = g_34->HoveredId;
  g_34->HoveredIdPreviousFrame = _124;
  g_34->HoveredId = 0;
  g_34->HoveredIdAllowOverlap = 0;
  _128 = g_34->ActiveIdIsAlive;
  _129 = ~_128;
  if (_129 != 0)
    goto <bb 54>;
  else
    goto <bb 57>;

  <bb 54>:
  _130 = g_34->ActiveIdPreviousFrame;
  _131 = g_34->ActiveId;
  if (_130 == _131)
    goto <bb 55>;
  else
    goto <bb 57>;

  <bb 55>:
  _132 = g_34->ActiveId;
  if (_132 != 0)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  ImGui::ClearActiveID ();

  <bb 57>:
  _134 = g_34->ActiveId;
  if (_134 != 0)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  _135 = g_34->ActiveIdTimer;
  _136 = g_34->IO.DeltaTime;
  _137 = _135 + _136;
  g_34->ActiveIdTimer = _137;

  <bb 59>:
  _139 = g_34->ActiveId;
  g_34->ActiveIdPreviousFrame = _139;
  g_34->ActiveIdIsAlive = 0;
  g_34->ActiveIdIsJustActivated = 0;
  _143 = g_34->ScalarAsInputTextId;
  if (_143 != 0)
    goto <bb 60>;
  else
    goto <bb 62>;

  <bb 60>:
  _144 = g_34->ActiveId;
  _145 = g_34->ScalarAsInputTextId;
  if (_144 != _145)
    goto <bb 61>;
  else
    goto <bb 62>;

  <bb 61>:
  g_34->ScalarAsInputTextId = 0;

  <bb 62>:
  _147 = g_34->DragDropActive;
  if (_147 != 0)
    goto <bb 63>;
  else
    goto <bb 65>;

  <bb 63>:
  _148 = g_34->DragDropPayload.DataFrameCount;
  _149 = _148 + 1;
  _150 = g_34->FrameCount;
  if (_149 < _150)
    goto <bb 64>;
  else
    goto <bb 65>;

  <bb 64>:
  ImGui::ClearDragDrop ();
  _152 = &g_34->DragDropPayloadBufHeap;
  ImVector<unsigned char>::clear (_152);
  _154 = &g_34->DragDropPayloadBufLocal;
  memset (_154, 0, 8);

  <bb 65>:
  _156 = g_34->DragDropAcceptIdCurr;
  g_34->DragDropAcceptIdPrev = _156;
  g_34->DragDropAcceptIdCurr = 0;
  g_34->DragDropAcceptIdCurrRectSurface = 3.4028234663852885981170418348451692544e+38;
  _160 = &g_34->IO.KeysDownDuration;
  _161 = &g_34->IO.KeysDownDurationPrev;
  memcpy (_161, _160, 2048);
  i_163 = 0;

  <bb 66>:
  # i_2 = PHI <i_163(65), i_173(73)>
  if (i_2 > 511)
    goto <bb 74>;
  else
    goto <bb 67>;

  <bb 67>:
  _164 = g_34->IO.KeysDown[i_2];
  if (_164 != 0)
    goto <bb 68>;
  else
    goto <bb 72>;

  <bb 68>:
  _165 = g_34->IO.KeysDownDuration[i_2];
  if (_165 < 0.0)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  iftmp.295_166 = 0.0;
  goto <bb 71>;

  <bb 70>:
  _167 = g_34->IO.KeysDownDuration[i_2];
  _168 = g_34->IO.DeltaTime;
  iftmp.295_169 = _167 + _168;

  <bb 71>:
  # iftmp.295_8 = PHI <iftmp.295_166(69), iftmp.295_169(70)>
  iftmp.294_170 = iftmp.295_8;
  goto <bb 73>;

  <bb 72>:
  iftmp.294_171 = -1.0e+0;

  <bb 73>:
  # iftmp.294_7 = PHI <iftmp.294_170(71), iftmp.294_171(72)>
  g_34->IO.KeysDownDuration[i_2] = iftmp.294_7;
  i_173 = i_2 + 1;
  goto <bb 66>;

  <bb 74>:
  ImGui::NavUpdate ();
  ImGui::NewFrameUpdateMouseInputs ();
  _176 = g_34->FramerateSecPerFrameAccum;
  _177 = g_34->IO.DeltaTime;
  _178 = g_34->FramerateSecPerFrameIdx;
  _179 = g_34->FramerateSecPerFrame[_178];
  _180 = _177 - _179;
  _181 = _176 + _180;
  g_34->FramerateSecPerFrameAccum = _181;
  _183 = g_34->FramerateSecPerFrameIdx;
  _184 = g_34->IO.DeltaTime;
  g_34->FramerateSecPerFrame[_183] = _184;
  _186 = g_34->FramerateSecPerFrameIdx;
  _187 = _186 + 1;
  _188 = _187 % 120;
  g_34->FramerateSecPerFrameIdx = _188;
  _190 = g_34->FramerateSecPerFrameAccum;
  _191 = _190 / 1.2e+2;
  _192 = 1.0e+0 / _191;
  g_34->IO.Framerate = _192;
  ImGui::NewFrameUpdateMovingWindow ();
  ImGui::NewFrameUpdateHoveredWindowAndCaptureFlags ();
  _197 = GetFrontMostModalRootWindow ();
  retval.296_198 = _197 != 0B;
  if (retval.296_198 != 0)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 75>:
  _199 = g_34->ModalWindowDarkeningRatio;
  _200 = g_34->IO.DeltaTime;
  _201 = _200 * 6.0e+0;
  _202 = _199 + _201;
  _204 = ImMin (_202, 1.0e+0);
  g_34->ModalWindowDarkeningRatio = _204;
  goto <bb 77>;

  <bb 76>:
  g_34->ModalWindowDarkeningRatio = 0.0;

  <bb 77>:
  g_34->MouseCursor = 0;
  g_34->WantTextInputNextFrame = -1;
  _209 = g_34->WantTextInputNextFrame;
  g_34->WantCaptureKeyboardNextFrame = _209;
  _211 = g_34->WantCaptureKeyboardNextFrame;
  g_34->WantCaptureMouseNextFrame = _211;
  ImVec2::ImVec2 (&D.16446, 1.0e+0, 1.0e+0);
  g_34->OsImePosRequest = D.16446;
  D.16446 ={v} {CLOBBER};
  _216 = g_34->HoveredWindow;
  if (_216 != 0B)
    goto <bb 78>;
  else
    goto <bb 106>;

  <bb 78>:
  _217 = g_34->HoveredWindow;
  _218 = _217->Collapsed;
  _219 = ~_218;
  if (_219 != 0)
    goto <bb 79>;
  else
    goto <bb 106>;

  <bb 79>:
  _220 = g_34->IO.MouseWheel;
  if (_220 != 0.0)
    goto <bb 81>;
  else
    goto <bb 80>;

  <bb 80>:
  _221 = g_34->IO.MouseWheelH;
  if (_221 != 0.0)
    goto <bb 81>;
  else
    goto <bb 106>;

  <bb 81>:
  window_222 = g_34->HoveredWindow;
  scroll_window_223 = window_222;

  <bb 82>:
  # scroll_window_3 = PHI <scroll_window_223(81), scroll_window_233(87)>
  _224 = scroll_window_3->Flags;
  _225 = _224 & 16777216;
  if (_225 == 0)
    goto <bb 88>;
  else
    goto <bb 83>;

  <bb 83>:
  _226 = scroll_window_3->Flags;
  _227 = _226 & 16;
  if (_227 == 0)
    goto <bb 88>;
  else
    goto <bb 84>;

  <bb 84>:
  _228 = scroll_window_3->Flags;
  _229 = _228 & 8;
  if (_229 != 0)
    goto <bb 88>;
  else
    goto <bb 85>;

  <bb 85>:
  _230 = scroll_window_3->Flags;
  _231 = _230 & 512;
  if (_231 != 0)
    goto <bb 88>;
  else
    goto <bb 86>;

  <bb 86>:
  _232 = scroll_window_3->ParentWindow;
  if (_232 == 0B)
    goto <bb 88>;
  else
    goto <bb 87>;

  <bb 87>:
  scroll_window_233 = scroll_window_3->ParentWindow;
  goto <bb 82>;

  <bb 88>:
  _234 = scroll_window_3->Flags;
  _235 = _234 & 16;
  if (_235 == 0)
    goto <bb 89>;
  else
    goto <bb 91>;

  <bb 89>:
  _236 = scroll_window_3->Flags;
  _237 = _236 & 512;
  if (_237 == 0)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  iftmp.297_238 = 1;
  goto <bb 92>;

  <bb 91>:
  iftmp.297_239 = 0;

  <bb 92>:
  # iftmp.297_9 = PHI <iftmp.297_238(90), iftmp.297_239(91)>
  scroll_allowed_240 = iftmp.297_9;
  _241 = g_34->IO.MouseWheel;
  if (_241 != 0.0)
    goto <bb 93>;
  else
    goto <bb 100>;

  <bb 93>:
  _242 = g_34->IO.KeyCtrl;
  if (_242 != 0)
    goto <bb 94>;
  else
    goto <bb 96>;

  <bb 94>:
  _243 = g_34->IO.FontAllowUserScaling;
  if (_243 != 0)
    goto <bb 95>;
  else
    goto <bb 96>;

  <bb 95>:
  _244 = window_222->FontWindowScale;
  _245 = g_34->IO.MouseWheel;
  _246 = _245 * 1.00000001490116119384765625e-1;
  _247 = _244 + _246;
  new_font_scale_249 = ImClamp (_247, 5.0e-1, 2.5e+0);
  _250 = window_222->FontWindowScale;
  scale_251 = new_font_scale_249 / _250;
  window_222->FontWindowScale = new_font_scale_249;
  _253 = &window_222->Size;
  _254 = &window_222->Pos;
  _255 = &g_34->IO.MousePos;
  D.16454 = operator- (_255, _254);
  _257 = 1.0e+0 - scale_251;
  _258 = &window_222->Size;
  D.16453 = operator* (_258, _257);
  D.16455 = operator* (&D.16453, &D.16454);
  offset = operator/ (&D.16455, _253);
  D.16455 ={v} {CLOBBER};
  D.16453 ={v} {CLOBBER};
  D.16454 ={v} {CLOBBER};
  _265 = &window_222->Pos;
  operator+= (_265, &offset);
  _267 = &window_222->PosFloat;
  operator+= (_267, &offset);
  _269 = &window_222->Size;
  operator*= (_269, scale_251);
  _271 = &window_222->SizeFull;
  operator*= (_271, scale_251);
  offset ={v} {CLOBBER};
  goto <bb 99>;

  <bb 96>:
  _274 = g_34->IO.KeyCtrl;
  _275 = ~_274;
  if (_275 != 0)
    goto <bb 97>;
  else
    goto <bb 99>;

  <bb 97>:
  if (scroll_allowed_240 != 0)
    goto <bb 98>;
  else
    goto <bb 99>;

  <bb 98>:
  _277 = ImGuiWindow::CalcFontSize (scroll_window_3);
  scroll_amount_278 = _277 * 5.0e+0;
  _279 = &scroll_window_3->ContentsRegionRect;
  _281 = ImRect::GetHeight (_279);
  _282 = scroll_window_3->WindowPadding.y;
  _283 = _282 * 2.0e+0;
  _284 = _281 + _283;
  _285 = _284 * 6.70000016689300537109375e-1;
  _287 = ImMin (scroll_amount_278, _285);
  _288 = (int) _287;
  scroll_amount_289 = (float) _288;
  _290 = scroll_window_3->Scroll.y;
  _291 = g_34->IO.MouseWheel;
  _292 = _291 * scroll_amount_289;
  _293 = _290 - _292;
  SetWindowScrollY (scroll_window_3, _293);

  <bb 99>:

  <bb 100>:
  _295 = g_34->IO.MouseWheelH;
  if (_295 != 0.0)
    goto <bb 101>;
  else
    goto <bb 106>;

  <bb 101>:
  if (scroll_allowed_240 != 0)
    goto <bb 102>;
  else
    goto <bb 106>;

  <bb 102>:
  scroll_amount_297 = ImGuiWindow::CalcFontSize (scroll_window_3);
  _298 = g_34->IO.KeyCtrl;
  _299 = ~_298;
  if (_299 != 0)
    goto <bb 103>;
  else
    goto <bb 105>;

  <bb 103>:
  _300 = window_222->Flags;
  _301 = _300 & 16;
  if (_301 == 0)
    goto <bb 104>;
  else
    goto <bb 105>;

  <bb 104>:
  _302 = window_222->Scroll.x;
  _303 = g_34->IO.MouseWheelH;
  _304 = _303 * scroll_amount_297;
  _305 = _302 - _304;
  SetWindowScrollX (window_222, _305);

  <bb 105>:

  <bb 106>:
  _307 = g_34->ActiveId;
  if (_307 == 0)
    goto <bb 107>;
  else
    goto <bb 113>;

  <bb 107>:
  _308 = g_34->NavWindow;
  if (_308 != 0B)
    goto <bb 108>;
  else
    goto <bb 113>;

  <bb 108>:
  _309 = g_34->NavWindow;
  _310 = _309->Active;
  if (_310 != 0)
    goto <bb 109>;
  else
    goto <bb 113>;

  <bb 109>:
  _311 = g_34->NavWindow;
  _312 = _311->Flags;
  _313 = _312 & 262144;
  if (_313 == 0)
    goto <bb 110>;
  else
    goto <bb 113>;

  <bb 110>:
  _314 = g_34->IO.KeyCtrl;
  _315 = ~_314;
  if (_315 != 0)
    goto <bb 111>;
  else
    goto <bb 113>;

  <bb 111>:
  _317 = IsKeyPressedMap (0, 0);
  _318 = _317;
  if (_318 != 0)
    goto <bb 112>;
  else
    goto <bb 113>;

  <bb 112>:
  iftmp.299_319 = 1;
  goto <bb 114>;

  <bb 113>:
  iftmp.299_320 = 0;

  <bb 114>:
  # iftmp.299_10 = PHI <iftmp.299_319(112), iftmp.299_320(113)>
  retval.298_321 = iftmp.299_10;
  if (retval.298_321 != 0)
    goto <bb 115>;
  else
    goto <bb 126>;

  <bb 115>:
  _322 = g_34->NavId;
  if (_322 != 0)
    goto <bb 116>;
  else
    goto <bb 121>;

  <bb 116>:
  _323 = g_34->NavIdTabCounter;
  if (_323 != 2147483647)
    goto <bb 117>;
  else
    goto <bb 121>;

  <bb 117>:
  _324 = g_34->NavWindow;
  _325 = g_34->NavIdTabCounter;
  _326 = _325 + 1;
  _327 = g_34->IO.KeyShift;
  if (_327 != 0)
    goto <bb 118>;
  else
    goto <bb 119>;

  <bb 118>:
  iftmp.300_328 = -1;
  goto <bb 120>;

  <bb 119>:
  iftmp.300_329 = 1;

  <bb 120>:
  # iftmp.300_11 = PHI <iftmp.300_328(118), iftmp.300_329(119)>
  _330 = _326 + iftmp.300_11;
  _324->FocusIdxTabRequestNext = _330;
  goto <bb 125>;

  <bb 121>:
  _332 = g_34->NavWindow;
  _333 = g_34->IO.KeyShift;
  if (_333 != 0)
    goto <bb 122>;
  else
    goto <bb 123>;

  <bb 122>:
  iftmp.301_334 = -1;
  goto <bb 124>;

  <bb 123>:
  iftmp.301_335 = 0;

  <bb 124>:
  # iftmp.301_12 = PHI <iftmp.301_334(122), iftmp.301_335(123)>
  _332->FocusIdxTabRequestNext = iftmp.301_12;

  <bb 125>:

  <bb 126>:
  g_34->NavIdTabCounter = 2147483647;
  i_338 = 0;

  <bb 127>:
  # i_4 = PHI <i_338(126), i_348(128)>
  _339 = g_34->Windows.Size;
  if (_339 == i_4)
    goto <bb 129>;
  else
    goto <bb 128>;

  <bb 128>:
  _340 = &g_34->Windows;
  _342 = ImVector<ImGuiWindow*>::operator[] (_340, i_4);
  window_343 = *_342;
  _344 = window_343->Active;
  window_343->WasActive = _344;
  window_343->Active = 0;
  window_343->WriteAccessed = 0;
  i_348 = i_4 + 1;
  goto <bb 127>;

  <bb 129>:
  _349 = g_34->NavWindow;
  if (_349 != 0B)
    goto <bb 130>;
  else
    goto <bb 132>;

  <bb 130>:
  _350 = g_34->NavWindow;
  _351 = _350->WasActive;
  _352 = ~_351;
  if (_352 != 0)
    goto <bb 131>;
  else
    goto <bb 132>;

  <bb 131>:
  ImGui::FocusFrontMostActiveWindow (0B);

  <bb 132>:
  _354 = &g_34->CurrentWindowStack;
  ImVector<ImGuiWindow*>::resize (_354, 0);
  _356 = &g_34->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::resize (_356, 0);
  _358 = g_34->NavWindow;
  ImGui::ClosePopupsOverWindow (_358);
  ImVec2::ImVec2 (&D.16461, 4.0e+2, 4.0e+2);
  ImGui::SetNextWindowSize (&D.16461, 4);
  D.16461 ={v} {CLOBBER};
  ImGui::Begin ("Debug##Default", 0B, 0);
  return;

}



;; Function void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char*) (_ZL30SettingsHandlerWindow_ReadOpenP12ImGuiContextP20ImGuiSettingsHandlerPKc, funcdef_no=713, decl_uid=16473, cgraph_uid=612, symbol_order=618)

void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char*) (struct ImGuiContext * D.16470, struct ImGuiSettingsHandler * D.16471, const char * name)
{
  struct ImGuiWindowSettings * D.27643;
  struct ImGuiWindowSettings * D.27642;
  struct ImGuiWindowSettings * settings;
  void * D.27640;
  unsigned int D.27636;
  unsigned int _6;
  struct ImGuiWindowSettings * _8;
  struct ImGuiWindowSettings * _11;
  void * _13;

  <bb 2>:
  _6 = ImHash (name_4(D), 0, 0);
  _8 = ImGui::FindWindowSettings (_6);
  settings_9 = _8;
  if (settings_9 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = AddWindowSettings (name_4(D));
  settings_12 = _11;

  <bb 4>:
  # settings_1 = PHI <settings_9(2), settings_12(3)>
  _13 = settings_1;

<L3>:
  return _13;

}



;; Function void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*, const char*) (_ZL30SettingsHandlerWindow_ReadLineP12ImGuiContextP20ImGuiSettingsHandlerPvPKc, funcdef_no=714, decl_uid=16480, cgraph_uid=613, symbol_order=619)

void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*, const char*) (struct ImGuiContext * D.16476, struct ImGuiSettingsHandler * D.16477, void * entry, const char * line)
{
  int i;
  float y;
  float x;
  struct ImGuiWindowSettings * settings;
  bool D.27665;
  int i.314;
  int D.27661;
  bool retval.313;
  float x.312;
  float y.311;
  struct ImVec2 D.16487;
  struct ImVec2 * D.27656;
  struct ImGuiContext * GImGui.310;
  int D.27652;
  bool retval.309;
  float x.308;
  float y.307;
  struct ImVec2 D.16486;
  int D.27645;
  bool retval.306;
  int _7;
  bool retval.306_8;
  float y.307_9;
  float x.308_10;
  int _15;
  bool retval.309_16;
  struct ImGuiContext * GImGui.310_17;
  struct ImVec2 * _18;
  float y.311_19;
  float x.312_20;
  int _25;
  bool retval.313_26;
  int i.314_27;
  bool _28;

  <bb 2>:
  settings_3 = entry_2(D);
  _7 = sscanf (line_5(D), "Pos=%f,%f", &x, &y);
  retval.306_8 = _7 == 2;
  if (retval.306_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  y.307_9 = y;
  x.308_10 = x;
  ImVec2::ImVec2 (&D.16486, x.308_10, y.307_9);
  settings_3->Pos = D.16486;
  D.16486 ={v} {CLOBBER};
  goto <bb 8>;

  <bb 4>:
  _15 = sscanf (line_5(D), "Size=%f,%f", &x, &y);
  retval.309_16 = _15 == 2;
  if (retval.309_16 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  GImGui.310_17 = GImGui;
  _18 = &GImGui.310_17->Style.WindowMinSize;
  y.311_19 = y;
  x.312_20 = x;
  ImVec2::ImVec2 (&D.16487, x.312_20, y.311_19);
  settings_3->Size = ImMax (&D.16487, _18);
  D.16487 ={v} {CLOBBER};
  goto <bb 8>;

  <bb 6>:
  _25 = sscanf (line_5(D), "Collapsed=%d", &i);
  retval.313_26 = _25 == 1;
  if (retval.313_26 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  i.314_27 = i;
  _28 = i.314_27 != 0;
  settings_3->Collapsed = _28;

  <bb 8>:
  x ={v} {CLOBBER};
  y ={v} {CLOBBER};
  i ={v} {CLOBBER};
  return;

}



;; Function void SettingsHandlerWindow_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*) (_ZL30SettingsHandlerWindow_WriteAllP12ImGuiContextP20ImGuiSettingsHandlerP15ImGuiTextBuffer, funcdef_no=715, decl_uid=16492, cgraph_uid=614, symbol_order=620)

void SettingsHandlerWindow_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*) (struct ImGuiContext * imgui_ctx, struct ImGuiSettingsHandler * handler, struct ImGuiTextBuffer * buf)
{
  struct ImGuiWindowSettings * D.27708;
  struct ImGuiWindowSettings * D.27707;
  const char * p;
  const char * name;
  const struct ImGuiWindowSettings * settings;
  int i;
  struct ImGuiWindowSettings * settings;
  struct ImGuiWindow * window;
  int i;
  struct ImGuiContext & g;
  int D.27706;
  bool D.27705;
  int D.27704;
  float D.27703;
  int D.27702;
  float D.27701;
  int D.27700;
  float D.27699;
  int D.27698;
  float D.27697;
  const char * D.27696;
  float D.27690;
  struct ImVector * D.27689;
  int D.27687;
  int D.27685;
  int D.27684;
  int D.27683;
  int D.27682;
  bool D.27681;
  char * D.27679;
  unsigned int D.27676;
  int D.27673;
  int D.27672;
  struct ImGuiWindow * & D.27671;
  struct ImVector * D.27670;
  int D.27668;
  int _14;
  struct ImVector * _15;
  struct ImGuiWindow * & _17;
  int _19;
  int _20;
  unsigned int _21;
  struct ImGuiWindowSettings * _23;
  char * _25;
  struct ImGuiWindowSettings * _27;
  bool _31;
  int _36;
  int _37;
  int _38;
  int _39;
  int _42;
  struct ImVector * _43;
  float _46;
  const char * _51;
  float _53;
  int _54;
  float _55;
  int _56;
  float _58;
  int _59;
  float _60;
  int _61;
  bool _63;
  int _64;

  <bb 2>:
  g_11 = imgui_ctx_10(D);
  i_12 = 0;

  <bb 3>:
  # i_1 = PHI <i_12(2), i_33(9)>
  _14 = g_11->Windows.Size;
  if (_14 == i_1)
    goto <bb 10>;
  else
    goto <bb 4>;

  <bb 4>:
  _15 = &g_11->Windows;
  _17 = ImVector<ImGuiWindow*>::operator[] (_15, i_1);
  window_18 = *_17;
  _19 = window_18->Flags;
  _20 = _19 & 256;
  if (_20 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 9>;

  <bb 6>:
  _21 = window_18->ID;
  _23 = ImGui::FindWindowSettings (_21);
  settings_24 = _23;
  if (settings_24 == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _25 = window_18->Name;
  _27 = AddWindowSettings (_25);
  settings_28 = _27;

  <bb 8>:
  # settings_2 = PHI <settings_24(6), settings_28(7)>
  settings_2->Pos = window_18->Pos;
  settings_2->Size = window_18->SizeFull;
  _31 = window_18->Collapsed;
  settings_2->Collapsed = _31;

  <bb 9>:
  i_33 = i_1 + 1;
  goto <bb 3>;

  <bb 10>:
  _36 = ImGuiTextBuffer::size (buf_34(D));
  _37 = g_11->SettingsWindows.Size;
  _38 = _37 * 96;
  _39 = _36 + _38;
  ImGuiTextBuffer::reserve (buf_34(D), _39);
  i_41 = 0;

  <bb 11>:
  # i_3 = PHI <i_41(10), i_67(17)>
  _42 = g_11->SettingsWindows.Size;
  if (_42 == i_3)
    goto <bb 18>;
  else
    goto <bb 12>;

  <bb 12>:
  _43 = &g_11->SettingsWindows;
  settings_45 = ImVector<ImGuiWindowSettings>::operator[] (_43, i_3);
  _46 = settings_45->Pos.x;
  if (_46 == 3.4028234663852885981170418348451692544e+38)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  goto <bb 17>;

  <bb 14>:
  name_47 = settings_45->Name;
  p_48 = strstr (name_47, "###");
  if (p_48 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  name_49 = p_48;

  <bb 16>:
  # name_4 = PHI <name_47(14), name_49(15)>
  _51 = handler_50(D)->TypeName;
  ImGuiTextBuffer::appendf (buf_34(D), "[%s][%s]\n", _51, name_4);
  _53 = settings_45->Pos.y;
  _54 = (int) _53;
  _55 = settings_45->Pos.x;
  _56 = (int) _55;
  ImGuiTextBuffer::appendf (buf_34(D), "Pos=%d,%d\n", _56, _54);
  _58 = settings_45->Size.y;
  _59 = (int) _58;
  _60 = settings_45->Size.x;
  _61 = (int) _60;
  ImGuiTextBuffer::appendf (buf_34(D), "Size=%d,%d\n", _61, _59);
  _63 = settings_45->Collapsed;
  _64 = (int) _63;
  ImGuiTextBuffer::appendf (buf_34(D), "Collapsed=%d\n", _64);
  ImGuiTextBuffer::appendf (buf_34(D), "\n");

  <bb 17>:
  i_67 = i_3 + 1;
  goto <bb 11>;

  <bb 18>:
  return;

}



;; Function void ImGui::Initialize(ImGuiContext*) (_ZN5ImGui10InitializeEP12ImGuiContext, funcdef_no=716, decl_uid=13751, cgraph_uid=615, symbol_order=621)

void ImGui::Initialize(ImGuiContext*) (struct ImGuiContext * context)
{
  void * D.46342;
  void * D.27734;
  struct ImGuiSettingsHandler ini_handler;
  static const char __PRETTY_FUNCTION__[38] = "void ImGui::Initialize(ImGuiContext*)";
  struct ImGuiContext & g;
  struct ImVector * D.27733;
  unsigned int D.27732;
  struct ImNewDummy D.27731;
  void * D.16512;
  void * D.16514;
  struct ImNewDummy D.27730;
  struct ImNewDummy D.16511;
  struct ImNewDummy D.16513;
  bool D.27728;
  bool D.27727;
  bool D.27725;
  bool D.27724;
  bool _6;
  bool _7;
  bool _8;
  bool _9;
  void * _12;
  void * _13;
  void * _15;
  unsigned int _23;
  struct ImVector * _28;

  <bb 2>:
  g_4 = context_3(D);
  _6 = g_4->Initialized;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = g_4->SettingsLoaded;
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("!g.Initialized && !g.SettingsLoaded", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3650, &__PRETTY_FUNCTION__);

  <bb 6>:
  D.16513 = D.27730;
  _12 = ImGui::MemAlloc (16);

  <bb 7>:
  _13 = _12;
  _15 = operator new (16, D.16513, _13);
  ImGuiTextBuffer::ImGuiTextBuffer (_15);

  <bb 8>:
  g_4->LogClipboard = _15;
  D.16513 ={v} {CLOBBER};
  D.16511 ={v} {CLOBBER};
  ImGuiSettingsHandler::ImGuiSettingsHandler (&ini_handler);
  ini_handler.TypeName = "Window";
  _23 = ImHash ("Window", 0, 0);
  ini_handler.TypeHash = _23;
  ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
  ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
  ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
  _28 = &g_4->SettingsHandlers;
  ImVector<ImGuiSettingsHandler>::push_front (_28, &ini_handler);
  g_4->Initialized = 1;
  ini_handler ={v} {CLOBBER};
  return;

<L4>:
  operator delete (_15, D.27731, _13);
  __builtin_eh_copy_values (2, 4);

<L5>:
  _2 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_2);

}



;; Function void ImGui::Shutdown(ImGuiContext*) (_ZN5ImGui8ShutdownEP12ImGuiContext, funcdef_no=717, decl_uid=13753, cgraph_uid=616, symbol_order=622)

void ImGui::Shutdown(ImGuiContext*) (struct ImGuiContext * context)
{
  int i;
  int i;
  struct ImGuiContext & g;
  struct ImGuiTextBuffer * * D.27914;
  struct ImGuiTextBuffer * D.27911;
  struct FILE * D.27909;
  struct _IO_FILE * stdout.323;
  struct FILE * D.27905;
  struct FILE * D.27902;
  struct ImVector * D.27901;
  struct ImVector * D.27900;
  struct ImVector * D.27899;
  struct ImVector * D.27898;
  struct ImVector * D.27897;
  struct ImVector * D.27896;
  struct ImDrawList * D.27895;
  struct ImDrawDataBuilder * D.27894;
  struct ImVector * D.27893;
  struct ImVector * D.27892;
  struct ImVector * D.27891;
  struct ImVector * D.27890;
  struct ImVector * D.27889;
  char * * D.27888;
  struct value_type & D.27887;
  struct ImVector * D.27886;
  int D.27884;
  struct ImGuiStorage * D.27882;
  struct ImVector * D.27881;
  struct ImVector * D.27880;
  struct ImVector * D.27879;
  struct ImGuiWindow * & D.27878;
  struct ImVector * D.27877;
  int D.27875;
  const char * D.27873;
  bool D.27870;
  bool D.27869;
  struct ImFontAtlas * * D.27867;
  bool D.27864;
  struct ImFontAtlas * D.27861;
  struct ImFontAtlas * _12;
  bool _13;
  struct ImFontAtlas * * _14;
  bool _16;
  bool _17;
  const char * _18;
  int _21;
  struct ImVector * _22;
  struct ImGuiWindow * & _24;
  struct ImVector * _27;
  struct ImVector * _29;
  struct ImVector * _32;
  struct ImGuiStorage * _34;
  int _42;
  struct ImVector * _43;
  struct value_type & _45;
  char * * _46;
  struct ImVector * _49;
  struct ImVector * _51;
  struct ImVector * _53;
  struct ImVector * _55;
  struct ImVector * _57;
  struct ImDrawDataBuilder * _59;
  struct ImDrawList * _61;
  struct ImVector * _63;
  struct ImVector * _65;
  struct ImVector * _67;
  struct ImVector * _69;
  struct ImVector * _71;
  struct ImVector * _73;
  struct FILE * _75;
  struct FILE * _76;
  struct _IO_FILE * stdout.323_77;
  struct FILE * _78;
  struct ImGuiTextBuffer * _81;
  struct ImGuiTextBuffer * * _82;

  <bb 2>:
  g_10 = context_9(D);
  _12 = g_10->IO.Fonts;
  if (_12 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _13 = g_10->FontAtlasOwnedByContext;
  if (_13 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _14 = &g_10->IO.Fonts;
  IM_DELETE<ImFontAtlas> (_14);

  <bb 5>:
  _16 = g_10->Initialized;
  _17 = ~_16;
  if (_17 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 19> (<L21>);

  <bb 7>:
  _18 = g_10->IO.IniFilename;
  SaveIniSettingsToDisk (_18);
  i_20 = 0;

  <bb 8>:
  # i_1 = PHI <i_20(7), i_26(9)>
  _21 = g_10->Windows.Size;
  if (_21 <= i_1)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  _22 = &g_10->Windows;
  _24 = ImVector<ImGuiWindow*>::operator[] (_22, i_1);
  IM_DELETE<ImGuiWindow> (_24);
  i_26 = i_1 + 1;
  goto <bb 8>;

  <bb 10>:
  _27 = &g_10->Windows;
  ImVector<ImGuiWindow*>::clear (_27);
  _29 = &g_10->WindowsSortBuffer;
  ImVector<ImGuiWindow*>::clear (_29);
  g_10->CurrentWindow = 0B;
  _32 = &g_10->CurrentWindowStack;
  ImVector<ImGuiWindow*>::clear (_32);
  _34 = &g_10->WindowsById;
  ImGuiStorage::Clear (_34);
  g_10->NavWindow = 0B;
  g_10->HoveredWindow = 0B;
  g_10->HoveredRootWindow = 0B;
  g_10->ActiveIdWindow = 0B;
  g_10->MovingWindow = 0B;
  i_41 = 0;

  <bb 11>:
  # i_2 = PHI <i_41(10), i_48(12)>
  _42 = g_10->SettingsWindows.Size;
  if (_42 <= i_2)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  _43 = &g_10->SettingsWindows;
  _45 = ImVector<ImGuiWindowSettings>::operator[] (_43, i_2);
  _46 = &_45->Name;
  IM_DELETE<char> (_46);
  i_48 = i_2 + 1;
  goto <bb 11>;

  <bb 13>:
  _49 = &g_10->ColorModifiers;
  ImVector<ImGuiColMod>::clear (_49);
  _51 = &g_10->StyleModifiers;
  ImVector<ImGuiStyleMod>::clear (_51);
  _53 = &g_10->FontStack;
  ImVector<ImFont*>::clear (_53);
  _55 = &g_10->OpenPopupStack;
  ImVector<ImGuiPopupRef>::clear (_55);
  _57 = &g_10->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::clear (_57);
  _59 = &g_10->DrawDataBuilder;
  ImDrawDataBuilder::ClearFreeMemory (_59);
  _61 = &g_10->OverlayDrawList;
  ImDrawList::ClearFreeMemory (_61);
  _63 = &g_10->PrivateClipboard;
  ImVector<char>::clear (_63);
  _65 = &g_10->InputTextState.Text;
  ImVector<short unsigned int>::clear (_65);
  _67 = &g_10->InputTextState.InitialText;
  ImVector<char>::clear (_67);
  _69 = &g_10->InputTextState.TempTextBuffer;
  ImVector<char>::clear (_69);
  _71 = &g_10->SettingsWindows;
  ImVector<ImGuiWindowSettings>::clear (_71);
  _73 = &g_10->SettingsHandlers;
  ImVector<ImGuiSettingsHandler>::clear (_73);
  _75 = g_10->LogFile;
  if (_75 != 0B)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  _76 = g_10->LogFile;
  stdout.323_77 = stdout;
  if (_76 != stdout.323_77)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _78 = g_10->LogFile;
  fclose (_78);
  g_10->LogFile = 0B;

  <bb 16>:
  _81 = g_10->LogClipboard;
  if (_81 != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _82 = &g_10->LogClipboard;
  IM_DELETE<ImGuiTextBuffer> (_82);

  <bb 18>:
  g_10->Initialized = 0;

<L21>:
  return;

}



;; Function ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID) (_ZN5ImGui18FindWindowSettingsEj, funcdef_no=718, decl_uid=13759, cgraph_uid=617, symbol_order=623)

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID) (ImGuiID id)
{
  int i;
  struct ImGuiContext & g;
  struct ImVector * D.28016;
  struct ImGuiWindowSettings * D.28015;
  unsigned int D.28012;
  struct value_type & D.28011;
  struct ImVector * D.28010;
  bool retval.324;
  int D.28007;
  struct ImGuiWindowSettings * _2;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  unsigned int _12;
  bool retval.324_14;
  struct ImVector * _16;
  struct ImGuiWindowSettings * _18;
  struct ImGuiWindowSettings * _19;

  <bb 2>:
  g_6 = GImGui;
  i_7 = 0;

  <bb 3>:
  # i_1 = PHI <i_7(2), i_15(6)>
  _8 = g_6->SettingsWindows.Size;
  if (_8 == i_1)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _9 = &g_6->SettingsWindows;
  _11 = ImVector<ImGuiWindowSettings>::operator[] (_9, i_1);
  _12 = _11->Id;
  retval.324_14 = _12 == id_13(D);
  if (retval.324_14 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _16 = &g_6->SettingsWindows;
  _18 = ImVector<ImGuiWindowSettings>::operator[] (_16, i_1);
  goto <bb 8> (<L5>);

  <bb 6>:
  i_15 = i_1 + 1;
  goto <bb 3>;

  <bb 7>:
  _19 = 0B;

  # _2 = PHI <_18(5), _19(7)>
<L5>:
  return _2;

}



;; Function ImGuiWindowSettings* AddWindowSettings(const char*) (_ZL17AddWindowSettingsPKc, funcdef_no=719, decl_uid=15059, cgraph_uid=618, symbol_order=624)

ImGuiWindowSettings* AddWindowSettings(const char*) (const char * name)
{
  char * D.28025;
  struct ImGuiWindowSettings * settings;
  struct ImGuiContext & g;
  struct ImGuiWindowSettings * D.28022;
  unsigned int D.28021;
  char * D.28020;
  struct ImVector * D.28019;
  struct ImVector * D.28018;
  struct ImGuiWindowSettings D.16607;
  struct ImVector * _4;
  struct ImVector * _7;
  char * _12;
  char * _13;
  unsigned int _16;
  struct ImGuiWindowSettings * _18;

  <bb 2>:
  g_2 = GImGui;
  ImGuiWindowSettings::ImGuiWindowSettings (&D.16607);
  _4 = &g_2->SettingsWindows;
  ImVector<ImGuiWindowSettings>::push_back (_4, &D.16607);
  D.16607 ={v} {CLOBBER};
  _7 = &g_2->SettingsWindows;
  settings_9 = ImVector<ImGuiWindowSettings>::back (_7);
  _12 = ImStrdup (name_10(D));
  _13 = _12;
  settings_9->Name = _13;
  _16 = ImHash (name_10(D), 0, 0);
  settings_9->Id = _16;
  _18 = settings_9;

<L0>:
  return _18;

}



;; Function void LoadIniSettingsFromDisk(const char*) (_ZL23LoadIniSettingsFromDiskPKc, funcdef_no=720, decl_uid=15061, cgraph_uid=619, symbol_order=625)

void LoadIniSettingsFromDisk(const char*) (const char * ini_filename)
{
  char * D.28090;
  char * file_data;
  char * _5;

  <bb 2>:
  if (ini_filename_2(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L4>);

  <bb 4>:
  _5 = ImFileLoadToMemory (ini_filename_2(D), "rb", 0B, 1);
  file_data_6 = _5;
  if (file_data_6 == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 7> (<L4>);

  <bb 6>:
  LoadIniSettingsFromMemory (file_data_6);
  ImGui::MemFree (file_data_6);

<L4>:
  return;

}



;; Function ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char*) (_ZN5ImGui19FindSettingsHandlerEPKc, funcdef_no=721, decl_uid=13757, cgraph_uid=620, symbol_order=626)

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char*) (const char * type_name)
{
  int handler_n;
  const ImGuiID type_hash;
  struct ImGuiContext & g;
  struct ImVector * D.28101;
  struct ImGuiSettingsHandler * D.28100;
  unsigned int D.28097;
  struct value_type & D.28096;
  struct ImVector * D.28095;
  bool retval.327;
  int D.28092;
  struct ImGuiSettingsHandler * _2;
  int _11;
  struct ImVector * _12;
  struct value_type & _14;
  unsigned int _15;
  bool retval.327_16;
  struct ImVector * _18;
  struct ImGuiSettingsHandler * _20;
  struct ImGuiSettingsHandler * _21;

  <bb 2>:
  g_6 = GImGui;
  type_hash_9 = ImHash (type_name_7(D), 0, 0);
  handler_n_10 = 0;

  <bb 3>:
  # handler_n_1 = PHI <handler_n_10(2), handler_n_17(6)>
  _11 = g_6->SettingsHandlers.Size;
  if (_11 <= handler_n_1)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _12 = &g_6->SettingsHandlers;
  _14 = ImVector<ImGuiSettingsHandler>::operator[] (_12, handler_n_1);
  _15 = _14->TypeHash;
  retval.327_16 = _15 == type_hash_9;
  if (retval.327_16 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _18 = &g_6->SettingsHandlers;
  _20 = ImVector<ImGuiSettingsHandler>::operator[] (_18, handler_n_1);
  goto <bb 8> (<L5>);

  <bb 6>:
  handler_n_17 = handler_n_1 + 1;
  goto <bb 3>;

  <bb 7>:
  _21 = 0B;

  # _2 = PHI <_20(5), _21(7)>
<L5>:
  return _2;

}



;; Function void LoadIniSettingsFromMemory(const char*) (_ZL25LoadIniSettingsFromMemoryPKc, funcdef_no=722, decl_uid=15063, cgraph_uid=621, symbol_order=627)

void LoadIniSettingsFromMemory(const char*) (const char * buf_readonly)
{
  void * D.28158;
  struct ImGuiSettingsHandler * D.28157;
  char * D.28156;
  const char * name_start;
  char * type_end;
  const char * type_start;
  const char * name_end;
  char * line;
  char * line_end;
  struct ImGuiSettingsHandler * entry_handler;
  void * entry_data;
  struct ImGuiContext & g;
  char * buf_end;
  char * buf;
  void (*<T1961>) (struct ImGuiContext *, struct ImGuiSettingsHandler *, void *, const char *) D.28154;
  void * (*<T195f>) (struct ImGuiContext *, struct ImGuiSettingsHandler *, const char *) D.28148;
  void * iftmp.329;
  char * D.28139;
  const char * iftmp.328;
  char * D.28135;
  char D.28133;
  char * D.28132;
  char D.28129;
  char D.28125;
  char D.28123;
  char D.28119;
  char D.28116;
  long unsigned int D.28112;
  const char * iftmp.328_10;
  void * iftmp.329_11;
  char * _20;
  long unsigned int _22;
  char _29;
  char _31;
  char _33;
  char _34;
  char _37;
  char * _38;
  char _39;
  char * _40;
  char * _46;
  const char * iftmp.328_48;
  const char * iftmp.328_49;
  struct ImGuiSettingsHandler * _56;
  void * (*<T195f>) (struct ImGuiContext *, struct ImGuiSettingsHandler *, const char *) _58;
  void * _60;
  void * iftmp.329_61;
  void * iftmp.329_62;
  void (*<T1961>) (struct ImGuiContext *, struct ImGuiSettingsHandler *, void *, const char *) _64;

  <bb 2>:
  _20 = ImStrdup (buf_readonly_18(D));
  buf_21 = _20;
  _22 = strlen (buf_21);
  buf_end_23 = buf_21 + _22;
  g_24 = GImGui;
  entry_data_25 = 0B;
  entry_handler_26 = 0B;
  line_end_27 = 0B;
  line_28 = buf_21;

  <bb 3>:
  # entry_data_1 = PHI <entry_data_25(2), entry_data_2(29)>
  # entry_handler_3 = PHI <entry_handler_26(2), entry_handler_4(29)>
  # line_6 = PHI <line_28(2), line_66(29)>
  if (line_6 >= buf_end_23)
    goto <bb 30>;
  else
    goto <bb 4>;

  <bb 4>:
  # line_7 = PHI <line_6(3), line_30(6)>
  _29 = *line_7;
  if (_29 != 10)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _31 = *line_7;
  if (_31 != 13)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  line_30 = line_7 + 1;
  goto <bb 4>;

  <bb 7>:
  line_end_32 = line_7;

  <bb 8>:
  # line_end_5 = PHI <line_end_32(7), line_end_35(11)>
  if (line_end_5 >= buf_end_23)
    goto <bb 12>;
  else
    goto <bb 9>;

  <bb 9>:
  _33 = *line_end_5;
  if (_33 == 10)
    goto <bb 12>;
  else
    goto <bb 10>;

  <bb 10>:
  _34 = *line_end_5;
  if (_34 == 13)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  line_end_35 = line_end_5 + 1;
  goto <bb 8>;

  <bb 12>:
  *line_end_5 = 0;
  _37 = *line_7;
  if (_37 == 91)
    goto <bb 13>;
  else
    goto <bb 26>;

  <bb 13>:
  if (line_end_5 > line_7)
    goto <bb 14>;
  else
    goto <bb 26>;

  <bb 14>:
  _38 = line_end_5 + 18446744073709551615;
  _39 = *_38;
  if (_39 == 93)
    goto <bb 15>;
  else
    goto <bb 26>;

  <bb 15>:
  _40 = line_end_5 + 18446744073709551615;
  *_40 = 0;
  name_end_42 = line_end_5 + 18446744073709551615;
  type_start_43 = line_7 + 1;
  type_end_45 = ImStrchrRange (type_start_43, name_end_42, 93);
  if (type_end_45 != 0B)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _46 = type_end_45 + 1;
  iftmp.328_48 = ImStrchrRange (_46, name_end_42, 91);
  goto <bb 18>;

  <bb 17>:
  iftmp.328_49 = 0B;

  <bb 18>:
  # iftmp.328_10 = PHI <iftmp.328_48(16), iftmp.328_49(17)>
  name_start_50 = iftmp.328_10;
  if (type_end_45 == 0B)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  if (name_start_50 == 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  name_start_53 = type_start_43;
  type_start_54 = "Window";
  goto <bb 22>;

  <bb 21>:
  *type_end_45 = 0;
  name_start_52 = name_start_50 + 1;

  <bb 22>:
  # type_start_8 = PHI <type_start_54(20), type_start_43(21)>
  # name_start_9 = PHI <name_start_53(20), name_start_52(21)>
  _56 = ImGui::FindSettingsHandler (type_start_8);
  entry_handler_57 = _56;
  if (entry_handler_57 != 0B)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _58 = entry_handler_57->ReadOpenFn;
  _60 = _58 (g_24, entry_handler_57, name_start_9);
  iftmp.329_61 = _60;
  goto <bb 25>;

  <bb 24>:
  iftmp.329_62 = 0B;

  <bb 25>:
  # iftmp.329_11 = PHI <iftmp.329_61(23), iftmp.329_62(24)>
  entry_data_63 = iftmp.329_11;
  goto <bb 29>;

  <bb 26>:
  if (entry_handler_3 != 0B)
    goto <bb 27>;
  else
    goto <bb 29>;

  <bb 27>:
  if (entry_data_1 != 0B)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  _64 = entry_handler_3->ReadLineFn;
  _64 (g_24, entry_handler_3, entry_data_1, line_7);

  <bb 29>:
  # entry_data_2 = PHI <entry_data_63(25), entry_data_1(26), entry_data_1(27), entry_data_1(28)>
  # entry_handler_4 = PHI <entry_handler_57(25), entry_handler_3(26), entry_handler_3(27), entry_handler_3(28)>
  line_66 = line_end_5 + 1;
  goto <bb 3>;

  <bb 30>:
  ImGui::MemFree (buf_21);
  g_24->SettingsLoaded = 1;
  return;

}



;; Function void SaveIniSettingsToDisk(const char*) (_ZL21SaveIniSettingsToDiskPKc, funcdef_no=723, decl_uid=15065, cgraph_uid=622, symbol_order=628)

void SaveIniSettingsToDisk(const char*) (const char * ini_filename)
{
  void * D.46349;
  int finally_tmp.330;
  struct FILE * D.28167;
  struct FILE * f;
  struct ImVector buf;
  struct ImGuiContext & g;
  char * D.28165;
  long unsigned int D.28164;
  int D.28163;
  int finally_tmp.330_1;
  struct FILE * _13;
  int finally_tmp.330_15;
  int _16;
  long unsigned int _17;
  char * _18;
  int finally_tmp.330_21;

  <bb 2>:
  g_7 = GImGui;
  g_7->SettingsDirtyTimer = 0.0;
  if (ini_filename_9(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 14> (<L13>);

  <bb 4>:
  ImVector<char>::ImVector (&buf);
  SaveIniSettingsToMemory (&buf);

  <bb 5>:
  _13 = ImFileOpen (ini_filename_9(D), "wt");

  <bb 6>:
  f_14 = _13;
  if (f_14 == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  finally_tmp.330_15 = 0;
  goto <bb 11>;

  <bb 8>:
  _16 = buf.Size;
  _17 = (long unsigned int) _16;
  _18 = buf.Data;
  fwrite (_18, 1, _17, f_14);

  <bb 9>:
  fclose (f_14);

  <bb 10>:
  finally_tmp.330_21 = 1;

  <bb 11>:
  # finally_tmp.330_1 = PHI <finally_tmp.330_15(7), finally_tmp.330_21(10)>
  ImVector<char>::~ImVector (&buf);
  switch (finally_tmp.330_1) <default: <L13>, case 1: <L5>>

<L5>:

  <bb 13>:
  buf ={v} {CLOBBER};
  goto <bb 15> (<L10>);

<L13>:
  buf ={v} {CLOBBER};

<L10>:
  return;

<L11>:
  ImVector<char>::~ImVector (&buf);
  _25 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_25);

}



;; Function ImGuiTextBuffer::~ImGuiTextBuffer() (_ZN15ImGuiTextBufferD2Ev, funcdef_no=726, decl_uid=16667, cgraph_uid=624, symbol_order=630)

ImGuiTextBuffer::~ImGuiTextBuffer() (struct ImGuiTextBuffer * const this)
{
  struct ImVector * D.28005;
  struct ImVector * _2;

  <bb 2>:
  _2 = &this_1(D)->Buf;
  ImVector<char>::~ImVector (_2);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function void SaveIniSettingsToMemory(ImVector<char>&) (_ZL23SaveIniSettingsToMemoryR8ImVectorIcE, funcdef_no=724, decl_uid=15067, cgraph_uid=626, symbol_order=632)

void SaveIniSettingsToMemory(ImVector<char>&) (struct ImVector & out_buf)
{
  void * D.46352;
  struct ImGuiSettingsHandler * handler;
  int handler_n;
  struct ImGuiTextBuffer buf;
  struct ImGuiContext & g;
  void (*<T1963>) (struct ImGuiContext *, struct ImGuiSettingsHandler *, struct ImGuiTextBuffer *) D.28182;
  struct ImVector * D.28181;
  int D.28179;
  int _9;
  struct ImVector * _10;
  void (*<T1963>) (struct ImGuiContext *, struct ImGuiSettingsHandler *, struct ImGuiTextBuffer *) _13;

  <bb 2>:
  g_5 = GImGui;
  g_5->SettingsDirtyTimer = 0.0;
  ImGuiTextBuffer::ImGuiTextBuffer (&buf);
  handler_n_8 = 0;

  <bb 3>:
  # handler_n_1 = PHI <handler_n_8(2), handler_n_15(5)>
  _9 = g_5->SettingsHandlers.Size;
  if (_9 <= handler_n_1)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  _10 = &g_5->SettingsHandlers;
  handler_12 = ImVector<ImGuiSettingsHandler>::operator[] (_10, handler_n_1);
  _13 = handler_12->WriteAllFn;
  _13 (g_5, handler_12, &buf);

  <bb 5>:
  handler_n_15 = handler_n_1 + 1;
  goto <bb 3>;

  <bb 6>:
  ImVector<char>::pop_back (&buf.Buf);
  ImVector<char>::swap (out_buf_18(D), &buf.Buf);
  ImGuiTextBuffer::~ImGuiTextBuffer (&buf);
  buf ={v} {CLOBBER};
  return;

<L3>:
  ImGuiTextBuffer::~ImGuiTextBuffer (&buf);
  _3 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_3);

}



;; Function void ImGui::MarkIniSettingsDirty() (_ZN5ImGui20MarkIniSettingsDirtyEv, funcdef_no=728, decl_uid=13755, cgraph_uid=627, symbol_order=633)

void ImGui::MarkIniSettingsDirty() ()
{
  struct ImGuiContext & g;
  float D.28197;
  float D.28194;
  float _4;
  float _5;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->SettingsDirtyTimer;
  if (_4 <= 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = g_3->IO.IniSavingRate;
  g_3->SettingsDirtyTimer = _5;

  <bb 4>:
  return;

}



;; Function void MarkIniSettingsDirty(ImGuiWindow*) (_ZL20MarkIniSettingsDirtyP11ImGuiWindow, funcdef_no=729, decl_uid=15069, cgraph_uid=628, symbol_order=634)

void MarkIniSettingsDirty(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  float D.28206;
  float D.28203;
  int D.28200;
  int D.28199;
  int _5;
  int _6;
  float _7;
  float _8;

  <bb 2>:
  g_3 = GImGui;
  _5 = window_4(D)->Flags;
  _6 = _5 & 256;
  if (_6 == 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = g_3->SettingsDirtyTimer;
  if (_7 <= 0.0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _8 = g_3->IO.IniSavingRate;
  g_3->SettingsDirtyTimer = _8;

  <bb 5>:
  return;

}



;; Function int ChildWindowComparer(const void*, const void*) (_ZL19ChildWindowComparerPKvS0_, funcdef_no=730, decl_uid=16690, cgraph_uid=629, symbol_order=635)

int ChildWindowComparer(const void*, const void*) (const void * lhs, const void * rhs)
{
  int d;
  int d;
  const struct ImGuiWindow * const b;
  const struct ImGuiWindow * const a;
  int D.28223;
  int D.28222;
  int D.28219;
  int D.28218;
  int D.28217;
  int D.28216;
  int D.28215;
  int D.28212;
  int D.28211;
  int D.28210;
  int D.28209;
  int _1;
  int _7;
  int _8;
  int _9;
  int _10;
  int _12;
  int _13;
  int _14;
  int _15;
  int _16;
  int _18;
  int _19;
  int _20;
  int _21;

  <bb 2>:
  a_4 = MEM[(const struct ImGuiWindow * const *)lhs_3(D)];
  b_6 = MEM[(const struct ImGuiWindow * const *)rhs_5(D)];
  _7 = a_4->Flags;
  _8 = _7 & 67108864;
  _9 = b_6->Flags;
  _10 = _9 & 67108864;
  d_11 = _8 - _10;
  if (d_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = d_11;
  goto <bb 7> (<L4>);

  <bb 4>:
  _13 = a_4->Flags;
  _14 = _13 & 33554432;
  _15 = b_6->Flags;
  _16 = _15 & 33554432;
  d_17 = _14 - _16;
  if (d_17 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _18 = d_17;
  goto <bb 7> (<L4>);

  <bb 6>:
  _19 = a_4->BeginOrderWithinParent;
  _20 = b_6->BeginOrderWithinParent;
  _21 = _19 - _20;

  # _1 = PHI <_12(3), _18(5), _21(6)>
<L4>:
  return _1;

}



;; Function void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>*, ImGuiWindow*) (_ZL23AddWindowToSortedBufferP8ImVectorIP11ImGuiWindowES1_, funcdef_no=731, decl_uid=15057, cgraph_uid=630, symbol_order=636)

void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>*, ImGuiWindow*) (struct ImVector * out_sorted_windows, struct ImGuiWindow * window)
{
  struct ImGuiWindow * child;
  int i;
  int count;
  bool D.28242;
  struct ImGuiWindow * & D.28241;
  struct ImVector * D.28240;
  struct ImGuiWindow * window.334;
  struct ImGuiWindow * * D.28235;
  struct ImVector * D.28234;
  struct ImGuiWindow * window.333;
  long unsigned int D.28232;
  struct ImGuiWindow * window.332;
  bool D.28226;
  struct ImGuiWindow * window.331;
  struct ImGuiWindow * window.331_9;
  bool _10;
  struct ImGuiWindow * window.332_11;
  long unsigned int _13;
  struct ImGuiWindow * window.333_14;
  struct ImVector * _15;
  struct ImGuiWindow * * _17;
  struct ImGuiWindow * window.334_20;
  struct ImVector * _21;
  struct ImGuiWindow * & _23;
  bool _25;

  <bb 2>:
  ImVector<ImGuiWindow*>::push_back (out_sorted_windows_7(D), &window);
  window.331_9 = window;
  _10 = window.331_9->Active;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 11>;

  <bb 3>:
  window.332_11 = window;
  count_12 = window.332_11->DC.ChildWindows.Size;
  if (count_12 > 1)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _13 = (long unsigned int) count_12;
  window.333_14 = window;
  _15 = &window.333_14->DC.ChildWindows;
  _17 = ImVector<ImGuiWindow*>::begin (_15);
  qsort (_17, _13, 8, ChildWindowComparer);

  <bb 5>:
  i_19 = 0;

  <bb 6>:
  # i_1 = PHI <i_19(5), i_27(9)>
  if (i_1 >= count_12)
    goto <bb 10>;
  else
    goto <bb 7>;

  <bb 7>:
  window.334_20 = window;
  _21 = &window.334_20->DC.ChildWindows;
  _23 = ImVector<ImGuiWindow*>::operator[] (_21, i_1);
  child_24 = *_23;
  _25 = child_24->Active;
  if (_25 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  AddWindowToSortedBuffer (out_sorted_windows_7(D), child_24);

  <bb 9>:
  i_27 = i_1 + 1;
  goto <bb 6>;

  <bb 10>:

  <bb 11>:
  return;

}



;; Function void AddDrawListToDrawData(ImVector<ImDrawList*>*, ImDrawList*) (_ZL21AddDrawListToDrawDataP8ImVectorIP10ImDrawListES1_, funcdef_no=732, decl_uid=15051, cgraph_uid=631, symbol_order=637)

void AddDrawListToDrawData(ImVector<ImDrawList*>*, ImDrawList*) (struct ImVector * out_render_list, struct ImDrawList * draw_list)
{
  static const char __PRETTY_FUNCTION__[64] = "void AddDrawListToDrawData(ImVector<ImDrawList*>*, ImDrawList*)";
  struct ImDrawCmd & last_cmd;
  unsigned int D.28327;
  struct ImDrawList * draw_list.351;
  int D.28322;
  struct ImDrawList * draw_list.350;
  int D.28320;
  unsigned int D.28319;
  struct ImDrawList * draw_list.349;
  short unsigned int * D.28314;
  long unsigned int D.28313;
  long unsigned int D.28312;
  int D.28311;
  struct ImDrawList * draw_list.348;
  short unsigned int * D.28309;
  struct ImDrawList * draw_list.347;
  ImDrawIdx * D.28307;
  struct ImDrawList * draw_list.346;
  int D.28303;
  struct ImDrawList * draw_list.345;
  struct ImDrawVert * D.28298;
  long unsigned int D.28297;
  long unsigned int D.28296;
  int D.28295;
  struct ImDrawList * draw_list.344;
  struct ImDrawVert * D.28293;
  struct ImDrawList * draw_list.343;
  struct ImDrawVert * D.28291;
  struct ImDrawList * draw_list.342;
  int D.28287;
  struct ImDrawList * draw_list.341;
  struct ImVector * D.28282;
  struct ImDrawList * draw_list.340;
  bool retval.339;
  struct ImVector * D.28279;
  struct ImDrawList * draw_list.338;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) D.28275;
  unsigned int D.28272;
  struct ImVector * D.28271;
  struct ImDrawList * draw_list.337;
  struct ImVector * D.28267;
  struct ImDrawList * draw_list.336;
  bool retval.335;
  struct ImDrawList * draw_list.336_4;
  struct ImVector * _5;
  bool retval.335_7;
  struct ImDrawList * draw_list.337_8;
  struct ImVector * _9;
  unsigned int _12;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) _13;
  struct ImDrawList * draw_list.338_14;
  struct ImVector * _15;
  struct ImDrawList * draw_list.340_17;
  struct ImVector * _18;
  bool retval.339_20;
  struct ImDrawList * draw_list.341_21;
  int _22;
  struct ImDrawList * draw_list.342_23;
  struct ImDrawVert * _24;
  struct ImDrawList * draw_list.343_25;
  struct ImDrawVert * _26;
  struct ImDrawList * draw_list.344_27;
  int _28;
  long unsigned int _29;
  long unsigned int _30;
  struct ImDrawVert * _31;
  struct ImDrawList * draw_list.345_33;
  int _34;
  struct ImDrawList * draw_list.346_35;
  ImDrawIdx * _36;
  struct ImDrawList * draw_list.347_37;
  short unsigned int * _38;
  struct ImDrawList * draw_list.348_39;
  int _40;
  long unsigned int _41;
  long unsigned int _42;
  short unsigned int * _43;
  struct ImDrawList * draw_list.349_45;
  unsigned int _46;
  int _47;
  struct ImDrawList * draw_list.350_48;
  int _49;
  struct ImDrawList * draw_list.351_50;
  unsigned int _51;

  <bb 2>:
  draw_list.336_4 = draw_list;
  _5 = &draw_list.336_4->CmdBuffer;
  retval.335_7 = ImVector<ImDrawCmd>::empty (_5);
  if (retval.335_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 19> (<L25>);

  <bb 4>:
  draw_list.337_8 = draw_list;
  _9 = &draw_list.337_8->CmdBuffer;
  last_cmd_11 = ImVector<ImDrawCmd>::back (_9);
  _12 = last_cmd_11->ElemCount;
  if (_12 == 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _13 = last_cmd_11->UserCallback;
  if (_13 == 0B)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  draw_list.338_14 = draw_list;
  _15 = &draw_list.338_14->CmdBuffer;
  ImVector<ImDrawCmd>::pop_back (_15);
  draw_list.340_17 = draw_list;
  _18 = &draw_list.340_17->CmdBuffer;
  retval.339_20 = ImVector<ImDrawCmd>::empty (_18);
  if (retval.339_20 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 19> (<L25>);

  <bb 8>:
  draw_list.341_21 = draw_list;
  _22 = draw_list.341_21->VtxBuffer.Size;
  if (_22 == 0)
    goto <bb 11>;
  else
    goto <bb 9>;

  <bb 9>:
  draw_list.342_23 = draw_list;
  _24 = draw_list.342_23->_VtxWritePtr;
  draw_list.343_25 = draw_list;
  _26 = draw_list.343_25->VtxBuffer.Data;
  draw_list.344_27 = draw_list;
  _28 = draw_list.344_27->VtxBuffer.Size;
  _29 = (long unsigned int) _28;
  _30 = _29 * 20;
  _31 = _26 + _30;
  if (_24 == _31)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  __assert_fail ("draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3906, &__PRETTY_FUNCTION__);

  <bb 11>:
  draw_list.345_33 = draw_list;
  _34 = draw_list.345_33->IdxBuffer.Size;
  if (_34 == 0)
    goto <bb 14>;
  else
    goto <bb 12>;

  <bb 12>:
  draw_list.346_35 = draw_list;
  _36 = draw_list.346_35->_IdxWritePtr;
  draw_list.347_37 = draw_list;
  _38 = draw_list.347_37->IdxBuffer.Data;
  draw_list.348_39 = draw_list;
  _40 = draw_list.348_39->IdxBuffer.Size;
  _41 = (long unsigned int) _40;
  _42 = _41 * 2;
  _43 = _38 + _42;
  if (_36 == _43)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  __assert_fail ("draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3907, &__PRETTY_FUNCTION__);

  <bb 14>:
  draw_list.349_45 = draw_list;
  _46 = draw_list.349_45->_VtxCurrentIdx;
  _47 = (int) _46;
  draw_list.350_48 = draw_list;
  _49 = draw_list.350_48->VtxBuffer.Size;
  if (_47 == _49)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  __assert_fail ("(int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3908, &__PRETTY_FUNCTION__);

  <bb 16>:
  draw_list.351_50 = draw_list;
  _51 = draw_list.351_50->_VtxCurrentIdx;
  if (_51 <= 65535)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  __assert_fail ("draw_list->_VtxCurrentIdx < (1 << 16) && \"Too many vertices in ImDrawList using 16-bit indices. Read comment above\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3919, &__PRETTY_FUNCTION__);

  <bb 18>:
  ImVector<ImDrawList*>::push_back (out_render_list_52(D), &draw_list);

<L25>:
  return;

}



;; Function void AddWindowToDrawData(ImVector<ImDrawList*>*, ImGuiWindow*) (_ZL19AddWindowToDrawDataP8ImVectorIP10ImDrawListEP11ImGuiWindow, funcdef_no=733, decl_uid=15054, cgraph_uid=632, symbol_order=638)

void AddWindowToDrawData(ImVector<ImDrawList*>*, ImGuiWindow*) (struct ImVector * out_render_list, struct ImGuiWindow * window)
{
  struct ImGuiWindow * child;
  int i;
  int D.28407;
  bool D.28404;
  struct ImGuiWindow * & D.28403;
  struct ImVector * D.28402;
  int D.28400;
  struct ImDrawList * D.28398;
  struct ImDrawList * _6;
  int _10;
  struct ImVector * _11;
  struct ImGuiWindow * & _13;
  bool _15;
  int _16;

  <bb 2>:
  _6 = window_5(D)->DrawList;
  AddDrawListToDrawData (out_render_list_7(D), _6);
  i_9 = 0;

  <bb 3>:
  # i_1 = PHI <i_9(2), i_18(7)>
  _10 = window_5(D)->DC.ChildWindows.Size;
  if (_10 <= i_1)
    goto <bb 8>;
  else
    goto <bb 4>;

  <bb 4>:
  _11 = &window_5(D)->DC.ChildWindows;
  _13 = ImVector<ImGuiWindow*>::operator[] (_11, i_1);
  child_14 = *_13;
  _15 = child_14->Active;
  if (_15 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _16 = child_14->HiddenFrames;
  if (_16 == 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  AddWindowToDrawData (out_render_list_7(D), child_14);

  <bb 7>:
  i_18 = i_1 + 1;
  goto <bb 3>;

  <bb 8>:
  return;

}



;; Function void AddWindowToDrawDataSelectLayer(ImGuiWindow*) (_ZL30AddWindowToDrawDataSelectLayerP11ImGuiWindow, funcdef_no=734, decl_uid=16720, cgraph_uid=633, symbol_order=639)

void AddWindowToDrawDataSelectLayer(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  struct ImVector * D.28419;
  struct ImVector * D.28417;
  int D.28414;
  int D.28413;
  int D.28412;
  int D.28411;
  int _4;
  int _5;
  int _8;
  int _9;
  struct ImVector * _10;
  struct ImVector * _12;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->IO.MetricsActiveWindows;
  _5 = _4 + 1;
  g_3->IO.MetricsActiveWindows = _5;
  _8 = window_7(D)->Flags;
  _9 = _8 & 33554432;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = &g_3->DrawDataBuilder.Layers[1];
  AddWindowToDrawData (_10, window_7(D));
  goto <bb 5>;

  <bb 4>:
  _12 = &g_3->DrawDataBuilder.Layers[0];
  AddWindowToDrawData (_12, window_7(D));

  <bb 5>:
  return;

}



;; Function void ImDrawDataBuilder::FlattenIntoSingleLayer() (_ZN17ImDrawDataBuilder22FlattenIntoSingleLayerEv, funcdef_no=735, decl_uid=11643, cgraph_uid=634, symbol_order=640)

void ImDrawDataBuilder::FlattenIntoSingleLayer() (struct ImDrawDataBuilder * const this)
{
  struct ImVector & layer;
  int layer_n;
  int i;
  int size;
  int n;
  int D.28435;
  struct ImDrawList * & D.28434;
  struct ImVector * D.28433;
  struct ImDrawList * & D.28432;
  long unsigned int D.28431;
  long unsigned int D.28430;
  int D.28429;
  bool retval.354;
  struct ImVector * D.28423;
  int D.28422;
  int _13;
  struct ImVector * _16;
  bool retval.354_21;
  int _22;
  long unsigned int _23;
  long unsigned int _24;
  struct ImDrawList * & _26;
  struct ImVector * _27;
  struct ImDrawList * & _29;
  int _31;

  <bb 2>:
  n_10 = this_9(D)->Layers[0].Size;
  size_11 = n_10;
  i_12 = 1;

  <bb 3>:
  # size_3 = PHI <size_11(2), size_14(4)>
  # i_4 = PHI <i_12(2), i_15(4)>
  if (i_4 > 1)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _13 = this_9(D)->Layers[i_4].Size;
  size_14 = _13 + size_3;
  i_15 = i_4 + 1;
  goto <bb 3>;

  <bb 5>:
  _16 = &this_9(D)->Layers[0];
  ImVector<ImDrawList*>::resize (_16, size_3);
  layer_n_18 = 1;

  <bb 6>:
  # n_1 = PHI <n_10(5), n_2(10)>
  # layer_n_5 = PHI <layer_n_18(5), layer_n_34(10)>
  if (layer_n_5 > 1)
    goto <bb 11>;
  else
    goto <bb 7>;

  <bb 7>:
  layer_19 = &this_9(D)->Layers[layer_n_5];
  retval.354_21 = ImVector<ImDrawList*>::empty (layer_19);
  if (retval.354_21 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 10>;

  <bb 9>:
  _22 = layer_19->Size;
  _23 = (long unsigned int) _22;
  _24 = _23 * 8;
  _26 = ImVector<ImDrawList*>::operator[] (layer_19, 0);
  _27 = &this_9(D)->Layers[0];
  _29 = ImVector<ImDrawList*>::operator[] (_27, n_1);
  memcpy (_29, _26, _24);
  _31 = layer_19->Size;
  n_32 = _31 + n_1;
  ImVector<ImDrawList*>::resize (layer_19, 0);

  <bb 10>:
  # n_2 = PHI <n_1(8), n_32(9)>
  layer_n_34 = layer_n_5 + 1;
  goto <bb 6>;

  <bb 11>:
  return;

}



;; Function void SetupDrawData(ImVector<ImDrawList*>*, ImDrawData*) (_ZL13SetupDrawDataP8ImVectorIP10ImDrawListEP10ImDrawData, funcdef_no=736, decl_uid=16737, cgraph_uid=635, symbol_order=641)

void SetupDrawData(ImVector<ImDrawList*>*, ImDrawData*) (struct ImVector * draw_lists, struct ImDrawData * out_draw_data)
{
  int n;
  int D.28478;
  int D.28477;
  struct ImDrawList * D.28476;
  struct ImDrawList * * D.28475;
  long unsigned int D.28474;
  long unsigned int D.28473;
  struct ImDrawList * * D.28472;
  int D.28471;
  int D.28470;
  int D.28469;
  struct ImDrawList * D.28468;
  struct ImDrawList * * D.28467;
  long unsigned int D.28466;
  long unsigned int D.28465;
  struct ImDrawList * * D.28464;
  int D.28463;
  int D.28461;
  int D.28459;
  int D.28458;
  int D.28454;
  struct ImDrawList * * iftmp.355;
  struct ImDrawList * * iftmp.355_2;
  int _8;
  struct ImDrawList * * iftmp.355_9;
  struct ImDrawList * * iftmp.355_10;
  int _12;
  int _15;
  int _18;
  int _19;
  struct ImDrawList * * _20;
  long unsigned int _21;
  long unsigned int _22;
  struct ImDrawList * * _23;
  struct ImDrawList * _24;
  int _25;
  int _26;
  int _28;
  struct ImDrawList * * _29;
  long unsigned int _30;
  long unsigned int _31;
  struct ImDrawList * * _32;
  struct ImDrawList * _33;
  int _34;
  int _35;

  <bb 2>:
  out_draw_data_5(D)->Valid = 1;
  _8 = draw_lists_7(D)->Size;
  if (_8 > 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.355_9 = draw_lists_7(D)->Data;
  goto <bb 5>;

  <bb 4>:
  iftmp.355_10 = 0B;

  <bb 5>:
  # iftmp.355_2 = PHI <iftmp.355_9(3), iftmp.355_10(4)>
  out_draw_data_5(D)->CmdLists = iftmp.355_2;
  _12 = draw_lists_7(D)->Size;
  out_draw_data_5(D)->CmdListsCount = _12;
  out_draw_data_5(D)->TotalIdxCount = 0;
  _15 = out_draw_data_5(D)->TotalIdxCount;
  out_draw_data_5(D)->TotalVtxCount = _15;
  n_17 = 0;

  <bb 6>:
  # n_1 = PHI <n_17(5), n_37(7)>
  _18 = draw_lists_7(D)->Size;
  if (_18 <= n_1)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _19 = out_draw_data_5(D)->TotalVtxCount;
  _20 = draw_lists_7(D)->Data;
  _21 = (long unsigned int) n_1;
  _22 = _21 * 8;
  _23 = _20 + _22;
  _24 = *_23;
  _25 = _24->VtxBuffer.Size;
  _26 = _19 + _25;
  out_draw_data_5(D)->TotalVtxCount = _26;
  _28 = out_draw_data_5(D)->TotalIdxCount;
  _29 = draw_lists_7(D)->Data;
  _30 = (long unsigned int) n_1;
  _31 = _30 * 8;
  _32 = _29 + _31;
  _33 = *_32;
  _34 = _33->IdxBuffer.Size;
  _35 = _28 + _34;
  out_draw_data_5(D)->TotalIdxCount = _35;
  n_37 = n_1 + 1;
  goto <bb 6>;

  <bb 8>:
  return;

}



;; Function void ImGui::PushClipRect(const ImVec2&, const ImVec2&, bool) (_ZN5ImGui12PushClipRectERK6ImVec2S2_b, funcdef_no=737, decl_uid=3297, cgraph_uid=636, symbol_order=642)

void ImGui::PushClipRect(const ImVec2&, const ImVec2&, bool) (const struct ImVec2 & clip_rect_min, const struct ImVec2 & clip_rect_max, bool intersect_with_current_clip_rect)
{
  struct ImGuiWindow * window;
  struct value_type & D.28483;
  struct ImVector * D.28482;
  struct ImDrawList * D.28481;
  struct ImRect D.16750;
  struct ImDrawList * D.28480;
  int D.28479;
  int _5;
  struct ImDrawList * _6;
  struct ImDrawList * _10;
  struct ImVector * _11;
  struct value_type & _13;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _5 = (int) intersect_with_current_clip_rect_4(D);
  _6 = window_3->DrawList;
  ImDrawList::PushClipRect (_6, *clip_rect_min_7(D), *clip_rect_max_8(D), _5);
  _10 = window_3->DrawList;
  _11 = &_10->_ClipRectStack;
  _13 = ImVector<ImVec4>::back (_11);
  ImRect::ImRect (&D.16750, _13);
  window_3->ClipRect = D.16750;
  D.16750 ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PopClipRect() (_ZN5ImGui11PopClipRectEv, funcdef_no=738, decl_uid=3298, cgraph_uid=637, symbol_order=643)

void ImGui::PopClipRect() ()
{
  struct ImGuiWindow * window;
  struct value_type & D.28504;
  struct ImVector * D.28503;
  struct ImDrawList * D.28502;
  struct ImRect D.16754;
  struct ImDrawList * D.28501;
  struct ImDrawList * _4;
  struct ImDrawList * _6;
  struct ImVector * _7;
  struct value_type & _9;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = window_3->DrawList;
  ImDrawList::PopClipRect (_4);
  _6 = window_3->DrawList;
  _7 = &_6->_ClipRectStack;
  _9 = ImVector<ImVec4>::back (_7);
  ImRect::ImRect (&D.16754, _9);
  window_3->ClipRect = D.16754;
  D.16754 ={v} {CLOBBER};
  return;

}



;; Function void ImGui::EndFrame() (_ZN5ImGui8EndFrameEv, funcdef_no=739, decl_uid=2432, cgraph_uid=638, symbol_order=644)

void ImGui::EndFrame() ()
{
  struct ImGuiWindow * window;
  int i;
  struct ImGuiWindow * window;
  int i;
  bool hovered_window_above_modal;
  struct ImGuiWindow * modal;
  static const char __PRETTY_FUNCTION__[23] = "void ImGui::EndFrame()";
  struct ImGuiContext & g;
  int D.28646;
  float[21] * D.28645;
  ImWchar[17] * D.28644;
  float D.28643;
  struct ImVector * D.28642;
  struct ImVector * D.28641;
  int D.28637;
  int D.28636;
  struct ImVector * D.28635;
  int D.28632;
  int D.28631;
  bool D.28628;
  struct ImGuiWindow * & D.28627;
  struct ImVector * D.28626;
  int D.28624;
  struct ImVector * D.28622;
  int D.28621;
  struct ImVector * D.28620;
  struct ImGuiWindow * iftmp.360;
  struct ImGuiWindow * D.28610;
  struct ImGuiWindow * & D.28607;
  struct ImVector * D.28606;
  int D.28602;
  bool D.28596;
  struct ImGuiWindow * D.28590;
  struct ImGuiWindow * D.28588;
  bool iftmp.359;
  bool retval.358;
  struct ImGuiWindow * D.28581;
  int D.28578;
  int D.28577;
  struct ImGuiWindow * D.28576;
  int D.28573;
  int D.28572;
  struct ImGuiWindow * D.28571;
  struct ImVec2 * D.28570;
  struct ImVec2 * D.28569;
  struct ImGuiWindow * D.28568;
  unsigned int D.28567;
  struct ImGuiWindow * D.28566;
  struct ImGuiWindow * D.28565;
  struct ImGuiWindow * D.28564;
  struct ImGuiWindow * D.28561;
  bool D.28558;
  bool D.28557;
  bool D.28556;
  struct ImGuiWindow * D.28555;
  struct ImGuiWindow * D.28553;
  unsigned int D.28548;
  unsigned int D.28545;
  struct ImGuiWindow * D.28543;
  bool D.28540;
  bool D.28539;
  struct ImGuiWindow * D.28538;
  struct ImGuiWindow * D.28535;
  int D.28531;
  int D.28529;
  float D.28528;
  int D.28527;
  float D.28526;
  void (*<T879>) (int, int) D.28525;
  float D.28521;
  struct ImVec2 * D.28520;
  struct ImVec2 * D.28519;
  struct ImVec2 D.16759;
  void (*<T879>) (int, int) D.28517;
  bool iftmp.357;
  bool retval.356;
  int D.28510;
  int D.28509;
  bool D.28505;
  bool iftmp.357_6;
  bool iftmp.359_7;
  struct ImGuiWindow * iftmp.360_8;
  bool _25;
  int _26;
  int _27;
  void (*<T879>) (int, int) _28;
  struct ImVec2 * _29;
  struct ImVec2 * _30;
  float _33;
  bool iftmp.357_34;
  bool iftmp.357_35;
  bool retval.356_36;
  void (*<T879>) (int, int) _38;
  float _39;
  int _40;
  float _41;
  int _42;
  int _45;
  struct ImGuiWindow * _46;
  struct ImGuiWindow * _47;
  bool _48;
  bool _49;
  struct ImGuiWindow * _50;
  unsigned int _53;
  unsigned int _54;
  struct ImGuiWindow * _55;
  struct ImGuiWindow * _56;
  bool _57;
  bool _58;
  bool _59;
  struct ImGuiWindow * _60;
  struct ImGuiWindow * _61;
  struct ImGuiWindow * _63;
  bool iftmp.359_64;
  bool iftmp.359_65;
  bool retval.358_66;
  struct ImGuiWindow * _68;
  struct ImGuiWindow * _70;
  struct ImGuiWindow * _71;
  unsigned int _72;
  struct ImGuiWindow * _75;
  struct ImVec2 * _76;
  struct ImVec2 * _77;
  struct ImGuiWindow * _79;
  int _80;
  int _81;
  struct ImGuiWindow * _82;
  int _83;
  int _84;
  struct ImGuiWindow * _85;
  bool _87;
  int _92;
  struct ImVector * _94;
  struct ImGuiWindow * & _96;
  struct ImGuiWindow * _98;
  struct ImGuiWindow * iftmp.360_101;
  struct ImGuiWindow * iftmp.360_102;
  struct ImVector * _104;
  int _106;
  struct ImVector * _107;
  int _110;
  struct ImVector * _111;
  struct ImGuiWindow * & _113;
  bool _115;
  int _116;
  int _117;
  struct ImVector * _118;
  int _121;
  int _122;
  struct ImVector * _123;
  struct ImVector * _124;
  float _127;
  ImWchar[17] * _129;
  float[21] * _131;
  int _133;

  <bb 2>:
  g_24 = GImGui;
  _25 = g_24->Initialized;
  if (_25 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.Initialized", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 3995, &__PRETTY_FUNCTION__);

  <bb 4>:
  _26 = g_24->FrameCountEnded;
  _27 = g_24->FrameCount;
  if (_26 == _27)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 58> (<L75>);

  <bb 6>:
  _28 = g_24->IO.ImeSetInputScreenPosFn;
  if (_28 != 0B)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _29 = &g_24->OsImePosSet;
  _30 = &g_24->OsImePosRequest;
  D.16759 = operator- (_30, _29);
  _33 = ImLengthSqr (&D.16759);
  if (_33 > 9.99999974737875163555145263671875e-5)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.357_34 = 1;
  goto <bb 10>;

  <bb 9>:
  iftmp.357_35 = 0;

  <bb 10>:
  # iftmp.357_6 = PHI <iftmp.357_34(8), iftmp.357_35(9)>
  retval.356_36 = iftmp.357_6;
  D.16759 ={v} {CLOBBER};
  if (retval.356_36 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _38 = g_24->IO.ImeSetInputScreenPosFn;
  _39 = g_24->OsImePosRequest.y;
  _40 = (int) _39;
  _41 = g_24->OsImePosRequest.x;
  _42 = (int) _41;
  _38 (_42, _40);
  g_24->OsImePosSet = g_24->OsImePosRequest;

  <bb 12>:
  _45 = g_24->CurrentWindowStack.Size;
  if (_45 == 1)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  __assert_fail ("g.CurrentWindowStack.Size == 1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4007, &__PRETTY_FUNCTION__);

  <bb 14>:
  _46 = g_24->CurrentWindow;
  if (_46 != 0B)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  _47 = g_24->CurrentWindow;
  _48 = _47->WriteAccessed;
  _49 = ~_48;
  if (_49 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _50 = g_24->CurrentWindow;
  _50->Active = 0;

  <bb 17>:
  ImGui::End ();
  _53 = g_24->ActiveId;
  if (_53 == 0)
    goto <bb 18>;
  else
    goto <bb 48>;

  <bb 18>:
  _54 = g_24->HoveredId;
  if (_54 == 0)
    goto <bb 19>;
  else
    goto <bb 48>;

  <bb 19>:
  _55 = g_24->NavWindow;
  if (_55 == 0B)
    goto <bb 21>;
  else
    goto <bb 20>;

  <bb 20>:
  _56 = g_24->NavWindow;
  _57 = _56->Appearing;
  _58 = ~_57;
  if (_58 != 0)
    goto <bb 21>;
  else
    goto <bb 47>;

  <bb 21>:
  _59 = g_24->IO.MouseClicked[0];
  if (_59 != 0)
    goto <bb 22>;
  else
    goto <bb 32>;

  <bb 22>:
  _60 = g_24->HoveredRootWindow;
  if (_60 != 0B)
    goto <bb 23>;
  else
    goto <bb 26>;

  <bb 23>:
  _68 = g_24->HoveredWindow;
  ImGui::FocusWindow (_68);
  _70 = g_24->HoveredWindow;
  _71 = g_24->HoveredWindow;
  _72 = _71->MoveId;
  ImGui::SetActiveID (_72, _70);
  g_24->NavDisableHighlight = 1;
  _75 = g_24->HoveredRootWindow;
  _76 = &_75->Pos;
  _77 = &g_24->IO.MousePos;
  g_24->ActiveIdClickOffset = operator- (_77, _76);
  _79 = g_24->HoveredWindow;
  _80 = _79->Flags;
  _81 = _80 & 4;
  if (_81 == 0)
    goto <bb 24>;
  else
    goto <bb 32>;

  <bb 24>:
  _82 = g_24->HoveredRootWindow;
  _83 = _82->Flags;
  _84 = _83 & 4;
  if (_84 == 0)
    goto <bb 25>;
  else
    goto <bb 32>;

  <bb 25>:
  _85 = g_24->HoveredWindow;
  g_24->MovingWindow = _85;
  goto <bb 32>;

  <bb 26>:
  _61 = g_24->NavWindow;
  if (_61 != 0B)
    goto <bb 27>;
  else
    goto <bb 29>;

  <bb 27>:
  _63 = GetFrontMostModalRootWindow ();
  if (_63 == 0B)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  iftmp.359_64 = 1;
  goto <bb 30>;

  <bb 29>:
  iftmp.359_65 = 0;

  <bb 30>:
  # iftmp.359_7 = PHI <iftmp.359_64(28), iftmp.359_65(29)>
  retval.358_66 = iftmp.359_7;
  if (retval.358_66 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  ImGui::FocusWindow (0B);

  <bb 32>:
  _87 = g_24->IO.MouseClicked[1];
  if (_87 != 0)
    goto <bb 33>;
  else
    goto <bb 47>;

  <bb 33>:
  modal_89 = GetFrontMostModalRootWindow ();
  hovered_window_above_modal_90 = 0;
  if (modal_89 == 0B)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  hovered_window_above_modal_91 = 1;

  <bb 35>:
  # hovered_window_above_modal_1 = PHI <hovered_window_above_modal_90(33), hovered_window_above_modal_91(34)>
  _92 = g_24->Windows.Size;
  i_93 = _92 + -1;

  <bb 36>:
  # hovered_window_above_modal_2 = PHI <hovered_window_above_modal_1(35), hovered_window_above_modal_3(42)>
  # i_4 = PHI <i_93(35), i_100(42)>
  if (i_4 < 0)
    goto <bb 43>;
  else
    goto <bb 37>;

  <bb 37>:
  if (hovered_window_above_modal_2 != 0)
    goto <bb 43>;
  else
    goto <bb 38>;

  <bb 38>:
  _94 = &g_24->Windows;
  _96 = ImVector<ImGuiWindow*>::operator[] (_94, i_4);
  window_97 = *_96;
  if (window_97 == modal_89)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  goto <bb 43>;

  <bb 40>:
  _98 = g_24->HoveredWindow;
  if (_98 == window_97)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  hovered_window_above_modal_99 = 1;

  <bb 42>:
  # hovered_window_above_modal_3 = PHI <hovered_window_above_modal_2(40), hovered_window_above_modal_99(41)>
  i_100 = i_4 + -1;
  goto <bb 36>;

  <bb 43>:
  if (hovered_window_above_modal_2 != 0)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  iftmp.360_101 = g_24->HoveredWindow;
  goto <bb 46>;

  <bb 45>:
  iftmp.360_102 = modal_89;

  <bb 46>:
  # iftmp.360_8 = PHI <iftmp.360_101(44), iftmp.360_102(45)>
  ImGui::ClosePopupsOverWindow (iftmp.360_8);

  <bb 47>:

  <bb 48>:
  _104 = &g_24->WindowsSortBuffer;
  ImVector<ImGuiWindow*>::resize (_104, 0);
  _106 = g_24->Windows.Size;
  _107 = &g_24->WindowsSortBuffer;
  ImVector<ImGuiWindow*>::reserve (_107, _106);
  i_109 = 0;

  <bb 49>:
  # i_5 = PHI <i_109(48), i_120(54)>
  _110 = g_24->Windows.Size;
  if (_110 == i_5)
    goto <bb 55>;
  else
    goto <bb 50>;

  <bb 50>:
  _111 = &g_24->Windows;
  _113 = ImVector<ImGuiWindow*>::operator[] (_111, i_5);
  window_114 = *_113;
  _115 = window_114->Active;
  if (_115 != 0)
    goto <bb 51>;
  else
    goto <bb 53>;

  <bb 51>:
  _116 = window_114->Flags;
  _117 = _116 & 16777216;
  if (_117 != 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  goto <bb 54>;

  <bb 53>:
  _118 = &g_24->WindowsSortBuffer;
  AddWindowToSortedBuffer (_118, window_114);

  <bb 54>:
  i_120 = i_5 + 1;
  goto <bb 49>;

  <bb 55>:
  _121 = g_24->Windows.Size;
  _122 = g_24->WindowsSortBuffer.Size;
  if (_121 == _122)
    goto <bb 57>;
  else
    goto <bb 56>;

  <bb 56>:
  __assert_fail ("g.Windows.Size == g.WindowsSortBuffer.Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4071, &__PRETTY_FUNCTION__);

  <bb 57>:
  _123 = &g_24->WindowsSortBuffer;
  _124 = &g_24->Windows;
  ImVector<ImGuiWindow*>::swap (_124, _123);
  g_24->IO.MouseWheelH = 0.0;
  _127 = g_24->IO.MouseWheelH;
  g_24->IO.MouseWheel = _127;
  _129 = &g_24->IO.InputCharacters;
  memset (_129, 0, 34);
  _131 = &g_24->IO.NavInputs;
  memset (_131, 0, 84);
  _133 = g_24->FrameCount;
  g_24->FrameCountEnded = _133;

<L75>:
  return;

}



;; Function void ImGui::Render() (_ZN5ImGui6RenderEv, funcdef_no=740, decl_uid=2430, cgraph_uid=639, symbol_order=645)

void ImGui::Render() ()
{
  bool D.28746;
  const float sc;
  void * const tex_id;
  const struct ImVec2 pos;
  struct ImGuiWindow * window;
  int n;
  struct ImVec2 uv[4];
  struct ImVec2 size;
  struct ImVec2 offset;
  struct ImGuiWindow * window_to_render_front_most;
  static const char __PRETTY_FUNCTION__[21] = "void ImGui::Render()";
  struct ImGuiContext & g;
  struct ImDrawData * D.28744;
  void (*<T87b>) (struct ImDrawData *) D.28743;
  void (*<T87b>) (struct ImDrawData *) D.28740;
  int D.28737;
  int D.28736;
  int D.28735;
  struct ImVector * D.28734;
  struct ImDrawData * D.28733;
  struct ImVector * D.28731;
  struct ImDrawList * D.28730;
  bool D.28727;
  struct ImVector * D.28726;
  bool retval.365;
  struct ImDrawList * D.28723;
  struct ImDrawList * D.28722;
  struct ImVec2 D.16806;
  struct ImVec2 D.16807;
  struct ImDrawList * D.28721;
  struct ImVec2 D.16804;
  struct ImVec2 D.16805;
  struct ImDrawList * D.28720;
  struct ImVec2 D.16796;
  struct ImVec2 D.16797;
  struct ImVec2 D.16798;
  struct ImVec2 D.16799;
  struct ImVec2 D.16800;
  struct ImVec2 D.16801;
  struct ImVec2 D.16802;
  struct ImVec2 D.16803;
  struct ImDrawList * D.28719;
  struct ImVec2 D.16788;
  struct ImVec2 D.16789;
  struct ImVec2 D.16790;
  struct ImVec2 D.16791;
  struct ImVec2 D.16792;
  struct ImVec2 D.16793;
  struct ImVec2 D.16794;
  struct ImVec2 D.16795;
  struct ImDrawList * D.28718;
  struct ImFontAtlas * D.28717;
  struct ImVec2 * D.28716;
  bool D.28712;
  struct ImFontAtlas * D.28711;
  int D.28710;
  bool D.28708;
  bool iftmp.364;
  bool retval.363;
  long int D.16783;
  struct ImVec2 * D.16782;
  struct ImVec2 * D.16781;
  struct ImVec2 * retval.362;
  struct ImDrawDataBuilder * D.28700;
  int D.28696;
  bool D.28693;
  int D.28685;
  int D.28684;
  int D.28681;
  bool D.28678;
  struct ImGuiWindow * & D.28677;
  struct ImVector * D.28676;
  int D.28674;
  int D.28671;
  int D.28670;
  struct ImGuiWindow * D.28669;
  struct ImGuiWindow * D.28667;
  struct ImGuiWindow * iftmp.361;
  struct ImDrawDataBuilder * D.28663;
  int D.28662;
  int D.28661;
  int D.28660;
  int D.28656;
  int D.28655;
  bool D.28651;
  struct ImVec2 * _2;
  long int _3;
  struct ImGuiWindow * iftmp.361_4;
  bool iftmp.364_5;
  bool _20;
  int _21;
  int _22;
  int _24;
  int _27;
  int _29;
  struct ImDrawDataBuilder * _31;
  struct ImGuiWindow * _33;
  struct ImGuiWindow * _34;
  int _35;
  int _36;
  struct ImGuiWindow * iftmp.361_37;
  struct ImGuiWindow * iftmp.361_38;
  int _41;
  struct ImVector * _42;
  struct ImGuiWindow * & _44;
  bool _46;
  int _47;
  int _48;
  int _49;
  bool _52;
  int _53;
  struct ImDrawDataBuilder * _55;
  struct ImVec2 * _59;
  struct ImVec2 * _60;
  long int _61;
  struct ImVec2 * _63;
  long int _64;
  struct ImVec2 * retval.362_65;
  bool _66;
  int _67;
  struct ImFontAtlas * _68;
  bool _70;
  bool _71;
  bool iftmp.364_72;
  bool iftmp.364_73;
  bool retval.363_74;
  struct ImVec2 * _75;
  struct ImFontAtlas * _77;
  struct ImDrawList * _80;
  struct ImDrawList * _90;
  struct ImDrawList * _108;
  struct ImDrawList * _120;
  struct ImDrawList * _126;
  struct ImDrawList * _130;
  struct ImVector * _154;
  bool _156;
  bool retval.365_157;
  struct ImDrawList * _158;
  struct ImVector * _159;
  struct ImDrawData * _161;
  struct ImVector * _162;
  int _164;
  int _166;
  int _168;
  void (*<T87b>) (struct ImDrawData *) _169;
  void (*<T87b>) (struct ImDrawData *) _170;
  struct ImDrawData * _171;

  <bb 2>:
  g_19 = GImGui;
  _20 = g_19->Initialized;
  if (_20 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.Initialized", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4085, &__PRETTY_FUNCTION__);

  <bb 4>:
  _21 = g_19->FrameCountEnded;
  _22 = g_19->FrameCount;
  if (_21 != _22)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::EndFrame ();

  <bb 6>:
  _24 = g_19->FrameCount;
  g_19->FrameCountRendered = _24;
  g_19->IO.MetricsActiveWindows = 0;
  _27 = g_19->IO.MetricsActiveWindows;
  g_19->IO.MetricsRenderIndices = _27;
  _29 = g_19->IO.MetricsRenderIndices;
  g_19->IO.MetricsRenderVertices = _29;
  _31 = &g_19->DrawDataBuilder;
  ImDrawDataBuilder::Clear (_31);
  _33 = g_19->NavWindowingTarget;
  if (_33 != 0B)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _34 = g_19->NavWindowingTarget;
  _35 = _34->Flags;
  _36 = _35 & 8192;
  if (_36 == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.361_37 = g_19->NavWindowingTarget;
  goto <bb 10>;

  <bb 9>:
  iftmp.361_38 = 0B;

  <bb 10>:
  # iftmp.361_4 = PHI <iftmp.361_37(8), iftmp.361_38(9)>
  window_to_render_front_most_39 = iftmp.361_4;
  n_40 = 0;

  <bb 11>:
  # n_1 = PHI <n_40(10), n_51(17)>
  _41 = g_19->Windows.Size;
  if (_41 == n_1)
    goto <bb 18>;
  else
    goto <bb 12>;

  <bb 12>:
  _42 = &g_19->Windows;
  _44 = ImVector<ImGuiWindow*>::operator[] (_42, n_1);
  window_45 = *_44;
  _46 = window_45->Active;
  if (_46 != 0)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:
  _47 = window_45->HiddenFrames;
  if (_47 == 0)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 14>:
  _48 = window_45->Flags;
  _49 = _48 & 16777216;
  if (_49 == 0)
    goto <bb 15>;
  else
    goto <bb 17>;

  <bb 15>:
  if (window_45 != window_to_render_front_most_39)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  AddWindowToDrawDataSelectLayer (window_45);

  <bb 17>:
  n_51 = n_1 + 1;
  goto <bb 11>;

  <bb 18>:
  if (window_to_render_front_most_39 != 0B)
    goto <bb 19>;
  else
    goto <bb 22>;

  <bb 19>:
  _52 = window_to_render_front_most_39->Active;
  if (_52 != 0)
    goto <bb 20>;
  else
    goto <bb 22>;

  <bb 20>:
  _53 = window_to_render_front_most_39->HiddenFrames;
  if (_53 == 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  AddWindowToDrawDataSelectLayer (window_to_render_front_most_39);

  <bb 22>:
  _55 = &g_19->DrawDataBuilder;
  ImDrawDataBuilder::FlattenIntoSingleLayer (_55);
  ImVec2::ImVec2 (&offset);
  ImVec2::ImVec2 (&size);
  _59 = &uv;
  _60 = _59;
  _61 = 3;

  <bb 23>:
  # _2 = PHI <_60(22), _63(24)>
  # _3 = PHI <_61(22), _64(24)>
  if (_3 < 0)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  ImVec2::ImVec2 (_2);
  _63 = _2 + 8;
  _64 = _3 + -1;
  goto <bb 23>;

  <bb 25>:
  retval.362_65 = _59;
  _66 = g_19->IO.MouseDrawCursor;
  if (_66 != 0)
    goto <bb 26>;
  else
    goto <bb 28>;

  <bb 26>:
  _67 = g_19->MouseCursor;
  _68 = g_19->IO.Fonts;
  _70 = ImFontAtlas::GetMouseCursorTexData (_68, _67, &offset, &size, &uv[0], &uv[2]);
  _71 = _70;
  if (_71 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  iftmp.364_72 = 1;
  goto <bb 29>;

  <bb 28>:
  iftmp.364_73 = 0;

  <bb 29>:
  # iftmp.364_5 = PHI <iftmp.364_72(27), iftmp.364_73(28)>
  retval.363_74 = iftmp.364_5;
  if (retval.363_74 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _75 = &g_19->IO.MousePos;
  pos = operator- (_75, &offset);
  _77 = g_19->IO.Fonts;
  tex_id_78 = _77->TexID;
  sc_79 = g_19->Style.MouseCursorScale;
  _80 = &g_19->OverlayDrawList;
  ImDrawList::PushTextureID (_80, tex_id_78);
  D.16794 = operator* (&size, sc_79);
  ImVec2::ImVec2 (&D.16791, 1.0e+0, 0.0);
  D.16792 = operator* (&D.16791, sc_79);
  D.16793 = operator+ (&pos, &D.16792);
  D.16795 = operator+ (&D.16793, &D.16794);
  ImVec2::ImVec2 (&D.16788, 1.0e+0, 0.0);
  D.16789 = operator* (&D.16788, sc_79);
  D.16790 = operator+ (&pos, &D.16789);
  _90 = &g_19->OverlayDrawList;
  ImDrawList::AddImage (_90, tex_id_78, &D.16790, &D.16795, &uv[2], &uv[3], 805306368);
  D.16790 ={v} {CLOBBER};
  D.16789 ={v} {CLOBBER};
  D.16788 ={v} {CLOBBER};
  D.16795 ={v} {CLOBBER};
  D.16793 ={v} {CLOBBER};
  D.16792 ={v} {CLOBBER};
  D.16791 ={v} {CLOBBER};
  D.16794 ={v} {CLOBBER};
  D.16802 = operator* (&size, sc_79);
  ImVec2::ImVec2 (&D.16799, 2.0e+0, 0.0);
  D.16800 = operator* (&D.16799, sc_79);
  D.16801 = operator+ (&pos, &D.16800);
  D.16803 = operator+ (&D.16801, &D.16802);
  ImVec2::ImVec2 (&D.16796, 2.0e+0, 0.0);
  D.16797 = operator* (&D.16796, sc_79);
  D.16798 = operator+ (&pos, &D.16797);
  _108 = &g_19->OverlayDrawList;
  ImDrawList::AddImage (_108, tex_id_78, &D.16798, &D.16803, &uv[2], &uv[3], 805306368);
  D.16798 ={v} {CLOBBER};
  D.16797 ={v} {CLOBBER};
  D.16796 ={v} {CLOBBER};
  D.16803 ={v} {CLOBBER};
  D.16801 ={v} {CLOBBER};
  D.16800 ={v} {CLOBBER};
  D.16799 ={v} {CLOBBER};
  D.16802 ={v} {CLOBBER};
  D.16804 = operator* (&size, sc_79);
  D.16805 = operator+ (&pos, &D.16804);
  _120 = &g_19->OverlayDrawList;
  ImDrawList::AddImage (_120, tex_id_78, &pos, &D.16805, &uv[2], &uv[3], 4278190080);
  D.16805 ={v} {CLOBBER};
  D.16804 ={v} {CLOBBER};
  D.16806 = operator* (&size, sc_79);
  D.16807 = operator+ (&pos, &D.16806);
  _126 = &g_19->OverlayDrawList;
  ImDrawList::AddImage (_126, tex_id_78, &pos, &D.16807, &uv[0], &uv[1], 4294967295);
  D.16807 ={v} {CLOBBER};
  D.16806 ={v} {CLOBBER};
  _130 = &g_19->OverlayDrawList;
  ImDrawList::PopTextureID (_130);
  pos ={v} {CLOBBER};

  <bb 31>:
  _154 = &g_19->OverlayDrawList.VtxBuffer;
  _156 = ImVector<ImDrawVert>::empty (_154);
  retval.365_157 = ~_156;
  if (retval.365_157 != 0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  _158 = &g_19->OverlayDrawList;
  _159 = &g_19->DrawDataBuilder.Layers[0];
  AddDrawListToDrawData (_159, _158);

  <bb 33>:
  _161 = &g_19->DrawData;
  _162 = &g_19->DrawDataBuilder.Layers[0];
  SetupDrawData (_162, _161);
  _164 = g_19->DrawData.TotalVtxCount;
  g_19->IO.MetricsRenderVertices = _164;
  _166 = g_19->DrawData.TotalIdxCount;
  g_19->IO.MetricsRenderIndices = _166;
  _168 = g_19->DrawData.CmdListsCount;
  if (_168 > 0)
    goto <bb 34>;
  else
    goto <bb 36>;

  <bb 34>:
  _169 = g_19->IO.RenderDrawListsFn;
  if (_169 != 0B)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  _170 = g_19->IO.RenderDrawListsFn;
  _171 = &g_19->DrawData;
  _170 (_171);

  <bb 36>:
  offset ={v} {CLOBBER};
  size ={v} {CLOBBER};
  uv ={v} {CLOBBER};
  return;

}



;; Function const char* ImGui::FindRenderedTextEnd(const char*, const char*) (_ZN5ImGui19FindRenderedTextEndEPKcS1_, funcdef_no=741, decl_uid=13929, cgraph_uid=640, symbol_order=646)

const char* ImGui::FindRenderedTextEnd(const char*, const char*) (const char * text, const char * text_end)
{
  const char * text_display_end;
  const char * D.28787;
  char D.28786;
  const char * D.28785;
  char D.28783;
  char D.28781;
  char _8;
  char _9;
  const char * _10;
  char _11;
  const char * _13;

  <bb 2>:
  text_display_end_4 = text_3(D);
  if (text_end_5(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  text_end_6 = -1B;

  <bb 4>:
  # text_end_1 = PHI <text_end_5(D)(2), text_end_6(3), text_end_1(8)>
  # text_display_end_2 = PHI <text_display_end_4(2), text_display_end_4(3), text_display_end_12(8)>
  if (text_display_end_2 >= text_end_1)
    goto <bb 9>;
  else
    goto <bb 5>;

  <bb 5>:
  _8 = *text_display_end_2;
  if (_8 == 0)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 6>:
  _9 = *text_display_end_2;
  if (_9 == 35)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _10 = text_display_end_2 + 1;
  _11 = *_10;
  if (_11 == 35)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  text_display_end_12 = text_display_end_2 + 1;
  goto <bb 4>;

  <bb 9>:
  _13 = text_display_end_2;

<L9>:
  return _13;

}



;; Function void ImGui::LogText(const char*, ...) (_ZN5ImGui7LogTextEPKcz, funcdef_no=742, decl_uid=3280, cgraph_uid=641, symbol_order=647)

void ImGui::LogText(const char*, ...) (const char * fmt)
{
  struct  args[1];
  struct ImGuiContext & g;
  struct ImGuiTextBuffer * D.28798;
  struct FILE * D.28796;
  struct FILE * D.28793;
  bool D.28790;
  bool D.28789;
  bool _6;
  bool _7;
  struct FILE * _9;
  struct FILE * _10;
  struct ImGuiTextBuffer * _13;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->LogEnabled;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  args ={v} {CLOBBER};
  goto <bb 8> (<L7>);

  <bb 4>:
  __builtin_va_start (&args, 0);
  _9 = g_5->LogFile;
  if (_9 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _10 = g_5->LogFile;
  vfprintf (_10, fmt_11(D), &args);
  goto <bb 7>;

  <bb 6>:
  _13 = g_5->LogClipboard;
  ImGuiTextBuffer::appendfv (_13, fmt_11(D), &args);

  <bb 7>:
  __builtin_va_end (&args);
  args ={v} {CLOBBER};

<L7>:
  return;

}



;; Function void LogRenderedText(const ImVec2*, const char*, const char*) (_ZL15LogRenderedTextPK6ImVec2PKcS3_, funcdef_no=743, decl_uid=16827, cgraph_uid=642, symbol_order=648)

void LogRenderedText(const ImVec2*, const char*, const char*) (const struct ImVec2 * ref_pos, const char * text, const char * text_end)
{
  const int char_count;
  bool is_last_line;
  const bool is_first_line;
  const char * line_end;
  const int tree_depth;
  const char * text_remaining;
  const bool log_new_line;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.28854;
  bool D.28853;
  long int D.28848;
  long int text_remaining.370;
  long int line_end.369;
  long int text_remaining.368;
  long int line_end.367;
  bool D.28842;
  char D.28829;
  int D.28825;
  int D.28824;
  int D.28822;
  int D.28819;
  int D.28818;
  float D.28816;
  float D.28812;
  float D.28811;
  float D.28810;
  bool iftmp.366;
  bool iftmp.366_7;
  float _21;
  float _22;
  float _23;
  bool iftmp.366_24;
  bool iftmp.366_25;
  float _27;
  int _30;
  int _31;
  int _32;
  int _34;
  int _35;
  char _38;
  bool _45;
  long int line_end.367_46;
  long int text_remaining.368_47;
  long int line_end.369_48;
  long int text_remaining.370_49;
  long int _50;
  bool _52;
  int _54;

  <bb 2>:
  g_14 = GImGui;
  window_15 = g_14->CurrentWindow;
  if (text_end_16(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  text_end_19 = ImGui::FindRenderedTextEnd (text_17(D), text_end_16(D));

  <bb 4>:
  # text_end_1 = PHI <text_end_16(D)(2), text_end_19(3)>
  if (ref_pos_20(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _21 = ref_pos_20(D)->y;
  _22 = window_15->DC.LogLinePosY;
  _23 = _22 + 1.0e+0;
  if (_21 > _23)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.366_24 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.366_25 = 0;

  <bb 8>:
  # iftmp.366_7 = PHI <iftmp.366_24(6), iftmp.366_25(7)>
  log_new_line_26 = iftmp.366_7;
  if (ref_pos_20(D) != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _27 = ref_pos_20(D)->y;
  window_15->DC.LogLinePosY = _27;

  <bb 10>:
  text_remaining_29 = text_17(D);
  _30 = g_14->LogStartDepth;
  _31 = window_15->DC.TreeDepth;
  if (_30 > _31)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _32 = window_15->DC.TreeDepth;
  g_14->LogStartDepth = _32;

  <bb 12>:
  _34 = window_15->DC.TreeDepth;
  _35 = g_14->LogStartDepth;
  tree_depth_36 = _34 - _35;

  <bb 13>:
  # text_remaining_2 = PHI <text_remaining_29(12), text_remaining_56(31)>
  line_end_37 = text_remaining_2;

  <bb 14>:
  # line_end_3 = PHI <line_end_37(13), line_end_39(17)>
  if (line_end_3 >= text_end_1)
    goto <bb 18>;
  else
    goto <bb 15>;

  <bb 15>:
  _38 = *line_end_3;
  if (_38 == 10)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  goto <bb 18>;

  <bb 17>:
  line_end_39 = line_end_3 + 1;
  goto <bb 14>;

  <bb 18>:
  if (line_end_3 >= text_end_1)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  line_end_40 = 0B;

  <bb 20>:
  # line_end_4 = PHI <line_end_3(18), line_end_40(19)>
  is_first_line_41 = text_17(D) == text_remaining_2;
  is_last_line_42 = 0;
  if (line_end_4 == 0B)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  is_last_line_43 = 1;
  line_end_44 = text_end_1;

  <bb 22>:
  # line_end_5 = PHI <line_end_4(20), line_end_44(21)>
  # is_last_line_6 = PHI <is_last_line_42(20), is_last_line_43(21)>
  if (line_end_5 != 0B)
    goto <bb 23>;
  else
    goto <bb 29>;

  <bb 23>:
  _45 = ~is_last_line_6;
  if (_45 != 0)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  line_end.367_46 = (long int) line_end_5;
  text_remaining.368_47 = (long int) text_remaining_2;
  if (line_end.367_46 != text_remaining.368_47)
    goto <bb 25>;
  else
    goto <bb 29>;

  <bb 25>:
  line_end.369_48 = (long int) line_end_5;
  text_remaining.370_49 = (long int) text_remaining_2;
  _50 = line_end.369_48 - text_remaining.370_49;
  char_count_51 = (const int) _50;
  if (log_new_line_26 != 0)
    goto <bb 27>;
  else
    goto <bb 26>;

  <bb 26>:
  _52 = ~is_first_line_41;
  if (_52 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _54 = tree_depth_36 * 4;
  ImGui::LogText ("\n%*s%.*s", _54, "", char_count_51, text_remaining_2);
  goto <bb 29>;

  <bb 28>:
  ImGui::LogText (" %.*s", char_count_51, text_remaining_2);

  <bb 29>:
  if (is_last_line_6 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  goto <bb 32>;

  <bb 31>:
  text_remaining_56 = line_end_5 + 1;
  goto <bb 13>;

  <bb 32>:
  return;

}



;; Function void ImGui::RenderText(ImVec2, const char*, const char*, bool) (_ZN5ImGui10RenderTextE6ImVec2PKcS2_b, funcdef_no=744, decl_uid=13873, cgraph_uid=643, symbol_order=649)

void ImGui::RenderText(ImVec2, const char*, const char*, bool) (struct ImVec2 pos, const char * text, const char * text_end, bool hide_text_after_hash)
{
  const int text_len;
  const char * text_display_end;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.28873;
  struct ImDrawList * D.28872;
  struct ImFont * D.28871;
  float D.28870;
  unsigned int D.28869;
  long int D.28866;
  long int text.372;
  long int text_display_end.371;
  long unsigned int D.28862;
  long unsigned int _13;
  long int text_display_end.371_16;
  long int text.372_17;
  long int _18;
  unsigned int _21;
  float _22;
  struct ImFont * _23;
  struct ImDrawList * _24;
  bool _26;

  <bb 2>:
  g_6 = GImGui;
  window_7 = g_6->CurrentWindow;
  if (hide_text_after_hash_8(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  text_display_end_12 = ImGui::FindRenderedTextEnd (text_9(D), text_end_10(D));
  goto <bb 7>;

  <bb 4>:
  if (text_end_10(D) == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = strlen (text_9(D));
  text_end_14 = text_9(D) + _13;

  <bb 6>:
  # text_end_1 = PHI <text_end_10(D)(4), text_end_14(5)>
  text_display_end_15 = text_end_1;

  <bb 7>:
  # text_display_end_2 = PHI <text_display_end_12(3), text_display_end_15(6)>
  text_display_end.371_16 = (long int) text_display_end_2;
  text.372_17 = (long int) text_9(D);
  _18 = text_display_end.371_16 - text.372_17;
  text_len_19 = (const int) _18;
  if (text_len_19 > 0)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _21 = ImGui::GetColorU32 (0, 1.0e+0);
  _22 = g_6->FontSize;
  _23 = g_6->Font;
  _24 = window_7->DrawList;
  ImDrawList::AddText (_24, _23, _22, &pos, _21, text_9(D), text_display_end_2, 0.0, 0B);
  _26 = g_6->LogEnabled;
  if (_26 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  LogRenderedText (&pos, text_9(D), text_display_end_2);

  <bb 10>:
  return;

}



;; Function void ImGui::RenderTextWrapped(ImVec2, const char*, const char*, float) (_ZN5ImGui17RenderTextWrappedE6ImVec2PKcS2_f, funcdef_no=745, decl_uid=13878, cgraph_uid=644, symbol_order=650)

void ImGui::RenderTextWrapped(ImVec2, const char*, const char*, float) (struct ImVec2 pos, const char * text, const char * text_end, float wrap_width)
{
  const int text_len;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.28891;
  struct ImDrawList * D.28890;
  struct ImFont * D.28889;
  float D.28888;
  unsigned int D.28887;
  long int D.28884;
  long int text.374;
  long int text_end.373;
  long unsigned int D.28880;
  long unsigned int _8;
  long int text_end.373_10;
  long int text.374_11;
  long int _12;
  unsigned int _15;
  float _16;
  struct ImFont * _17;
  struct ImDrawList * _18;
  bool _21;

  <bb 2>:
  g_4 = GImGui;
  window_5 = g_4->CurrentWindow;
  if (text_end_6(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = strlen (text_7(D));
  text_end_9 = text_7(D) + _8;

  <bb 4>:
  # text_end_1 = PHI <text_end_6(D)(2), text_end_9(3)>
  text_end.373_10 = (long int) text_end_1;
  text.374_11 = (long int) text_7(D);
  _12 = text_end.373_10 - text.374_11;
  text_len_13 = (const int) _12;
  if (text_len_13 > 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _15 = ImGui::GetColorU32 (0, 1.0e+0);
  _16 = g_4->FontSize;
  _17 = g_4->Font;
  _18 = window_5->DrawList;
  ImDrawList::AddText (_18, _17, _16, &pos, _15, text_7(D), text_end_1, wrap_width_19(D), 0B);
  _21 = g_4->LogEnabled;
  if (_21 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  LogRenderedText (&pos, text_7(D), text_end_1);

  <bb 7>:
  return;

}



;; Function void ImGui::RenderTextClipped(const ImVec2&, const ImVec2&, const char*, const char*, const ImVec2*, const ImVec2&, const ImRect*) (_ZN5ImGui17RenderTextClippedERK6ImVec2S2_PKcS4_PS1_S2_PK6ImRect, funcdef_no=746, decl_uid=13887, cgraph_uid=645, symbol_order=651)

void ImGui::RenderTextClipped(const ImVec2&, const ImVec2&, const char*, const char*, const ImVec2*, const ImVec2&, const ImRect*) (const struct ImVec2 & pos_min, const struct ImVec2 & pos_max, const char * text, const char * text_end, const struct ImVec2 * text_size_if_known, const struct ImVec2 & align, const struct ImRect * clip_rect)
{
  struct ImVec4 fine_clip_rect;
  bool need_clipping;
  const struct ImVec2 * clip_max;
  const struct ImVec2 * clip_min;
  const struct ImVec2 text_size;
  struct ImVec2 pos;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  const int text_len;
  const char * text_display_end;
  bool D.28982;
  struct ImDrawList * D.28981;
  struct ImFont * D.28980;
  float D.28979;
  unsigned int D.28978;
  struct ImDrawList * D.28976;
  struct ImFont * D.28975;
  float D.28974;
  unsigned int D.28973;
  float D.28972;
  float D.28971;
  float D.28970;
  float D.28969;
  float D.28965;
  float D.28964;
  float D.28963;
  float D.28962;
  float D.28961;
  float D.28960;
  float D.28959;
  float D.28958;
  float D.28957;
  float D.28956;
  float D.28955;
  float D.28952;
  float D.28950;
  float D.28949;
  float D.28948;
  float D.28947;
  float D.28946;
  float D.28945;
  float D.28944;
  float D.28943;
  float D.28942;
  float D.28941;
  float D.28940;
  float D.28937;
  float D.28935;
  float D.28934;
  float D.28932;
  float D.28931;
  bool iftmp.380;
  float D.28924;
  float D.28923;
  float D.28922;
  float D.28921;
  float D.28919;
  float D.28918;
  float D.28917;
  float D.28916;
  bool iftmp.379;
  const struct ImVec2 * iftmp.378;
  const struct ImVec2 * iftmp.377;
  long int D.28898;
  long int text.376;
  long int text_display_end.375;
  const struct ImVec2 * iftmp.377_2;
  const struct ImVec2 * iftmp.378_3;
  bool iftmp.379_4;
  bool iftmp.380_5;
  long int text_display_end.375_18;
  long int text.376_19;
  long int _20;
  const struct ImVec2 * iftmp.377_30;
  const struct ImVec2 * iftmp.377_31;
  const struct ImVec2 * iftmp.378_33;
  const struct ImVec2 * iftmp.378_35;
  float _37;
  float _38;
  float _39;
  float _40;
  float _41;
  float _42;
  float _43;
  float _44;
  bool iftmp.379_45;
  bool iftmp.379_46;
  float _48;
  float _49;
  float _50;
  float _51;
  bool iftmp.380_52;
  bool iftmp.380_53;
  float _56;
  float _57;
  float _58;
  float _59;
  float _60;
  float _61;
  float _62;
  float _63;
  float _64;
  float _65;
  float _66;
  float _68;
  float _70;
  float _71;
  float _72;
  float _73;
  float _74;
  float _75;
  float _76;
  float _77;
  float _78;
  float _79;
  float _80;
  float _82;
  float _84;
  float _85;
  float _86;
  float _87;
  unsigned int _90;
  float _91;
  struct ImFont * _92;
  struct ImDrawList * _93;
  unsigned int _98;
  float _99;
  struct ImFont * _100;
  struct ImDrawList * _101;
  bool _103;

  <bb 2>:
  text_display_end_17 = ImGui::FindRenderedTextEnd (text_14(D), text_end_15(D));
  text_display_end.375_18 = (long int) text_display_end_17;
  text.376_19 = (long int) text_14(D);
  _20 = text_display_end.375_18 - text.376_19;
  text_len_21 = (const int) _20;
  if (text_len_21 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  pos ={v} {CLOBBER};
  text_size ={v} {CLOBBER};
  goto <bb 33> (<L36>);

  <bb 4>:
  g_22 = GImGui;
  window_23 = g_22->CurrentWindow;
  pos = *pos_min_24(D);
  if (text_size_if_known_26(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  text_size = *text_size_if_known_26(D);
  goto <bb 7>;

  <bb 6>:
  text_size = ImGui::CalcTextSize (text_14(D), text_display_end_17, 0, 0.0);

  <bb 7>:
  if (clip_rect_29(D) != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.377_30 = &clip_rect_29(D)->Min;
  goto <bb 10>;

  <bb 9>:
  iftmp.377_31 = pos_min_24(D);

  <bb 10>:
  # iftmp.377_2 = PHI <iftmp.377_30(8), iftmp.377_31(9)>
  clip_min_32 = iftmp.377_2;
  if (clip_rect_29(D) != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.378_33 = &clip_rect_29(D)->Max;
  goto <bb 13>;

  <bb 12>:
  iftmp.378_35 = pos_max_34(D);

  <bb 13>:
  # iftmp.378_3 = PHI <iftmp.378_33(11), iftmp.378_35(12)>
  clip_max_36 = iftmp.378_3;
  _37 = pos.x;
  _38 = text_size.x;
  _39 = _37 + _38;
  _40 = clip_max_36->x;
  if (_39 >= _40)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  _41 = pos.y;
  _42 = text_size.y;
  _43 = _41 + _42;
  _44 = clip_max_36->y;
  if (_43 >= _44)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.379_46 = 1;
  goto <bb 17>;

  <bb 16>:
  iftmp.379_45 = 0;

  <bb 17>:
  # iftmp.379_4 = PHI <iftmp.379_46(15), iftmp.379_45(16)>
  need_clipping_47 = iftmp.379_4;
  if (clip_rect_29(D) != 0B)
    goto <bb 18>;
  else
    goto <bb 23>;

  <bb 18>:
  _48 = pos.x;
  _49 = clip_min_32->x;
  if (_48 < _49)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  _50 = pos.y;
  _51 = clip_min_32->y;
  if (_50 < _51)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  iftmp.380_53 = 1;
  goto <bb 22>;

  <bb 21>:
  iftmp.380_52 = 0;

  <bb 22>:
  # iftmp.380_5 = PHI <iftmp.380_53(20), iftmp.380_52(21)>
  need_clipping_54 = iftmp.380_5 | need_clipping_47;

  <bb 23>:
  # need_clipping_1 = PHI <need_clipping_47(17), need_clipping_54(22)>
  _56 = align_55(D)->x;
  if (_56 > 0.0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _57 = pos.x;
  _58 = pos_max_34(D)->x;
  _59 = pos.x;
  _60 = _58 - _59;
  _61 = text_size.x;
  _62 = _60 - _61;
  _63 = align_55(D)->x;
  _64 = _62 * _63;
  _65 = _57 + _64;
  _66 = pos.x;
  _68 = ImMax (_66, _65);
  pos.x = _68;

  <bb 25>:
  _70 = align_55(D)->y;
  if (_70 > 0.0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _71 = pos.y;
  _72 = pos_max_34(D)->y;
  _73 = pos.y;
  _74 = _72 - _73;
  _75 = text_size.y;
  _76 = _74 - _75;
  _77 = align_55(D)->y;
  _78 = _76 * _77;
  _79 = _71 + _78;
  _80 = pos.y;
  _82 = ImMax (_80, _79);
  pos.y = _82;

  <bb 27>:
  if (need_clipping_1 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  _84 = clip_max_36->y;
  _85 = clip_max_36->x;
  _86 = clip_min_32->y;
  _87 = clip_min_32->x;
  ImVec4::ImVec4 (&fine_clip_rect, _87, _86, _85, _84);
  _90 = ImGui::GetColorU32 (0, 1.0e+0);
  _91 = g_22->FontSize;
  _92 = g_22->Font;
  _93 = window_23->DrawList;
  ImDrawList::AddText (_93, _92, _91, &pos, _90, text_14(D), text_display_end_17, 0.0, &fine_clip_rect);
  fine_clip_rect ={v} {CLOBBER};
  goto <bb 30>;

  <bb 29>:
  _98 = ImGui::GetColorU32 (0, 1.0e+0);
  _99 = g_22->FontSize;
  _100 = g_22->Font;
  _101 = window_23->DrawList;
  ImDrawList::AddText (_101, _100, _99, &pos, _98, text_14(D), text_display_end_17, 0.0, 0B);

  <bb 30>:
  _103 = g_22->LogEnabled;
  if (_103 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  LogRenderedText (&pos, text_14(D), text_display_end_17);

  <bb 32>:
  pos ={v} {CLOBBER};
  text_size ={v} {CLOBBER};

<L36>:
  return;

}



;; Function void ImGui::RenderFrame(ImVec2, ImVec2, ImU32, bool, float) (_ZN5ImGui11RenderFrameE6ImVec2S0_jbf, funcdef_no=747, decl_uid=13893, cgraph_uid=646, symbol_order=652)

void ImGui::RenderFrame(ImVec2, ImVec2, ImU32, bool, float) (struct ImVec2 p_min, struct ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
  const float border_size;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.28999;
  unsigned int D.28998;
  struct ImDrawList * D.28997;
  struct ImVec2 D.16894;
  struct ImVec2 D.16895;
  struct ImVec2 D.16896;
  struct ImVec2 D.16897;
  unsigned int D.28996;
  struct ImDrawList * D.28991;
  struct ImDrawList * _5;
  unsigned int _12;
  struct ImDrawList * _17;
  unsigned int _24;
  struct ImDrawList * _25;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->CurrentWindow;
  _5 = window_4->DrawList;
  ImDrawList::AddRectFilled (_5, &p_min, &p_max, fill_col_6(D), rounding_7(D), 15);
  border_size_9 = g_3->Style.FrameBorderSize;
  if (border_10(D) != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (border_size_9 > 0.0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _12 = ImGui::GetColorU32 (6, 1.0e+0);
  ImVec2::ImVec2 (&D.16896, 1.0e+0, 1.0e+0);
  D.16897 = operator+ (&p_max, &D.16896);
  ImVec2::ImVec2 (&D.16894, 1.0e+0, 1.0e+0);
  D.16895 = operator+ (&p_min, &D.16894);
  _17 = window_4->DrawList;
  ImDrawList::AddRect (_17, &D.16895, &D.16897, _12, rounding_7(D), 15, border_size_9);
  D.16895 ={v} {CLOBBER};
  D.16894 ={v} {CLOBBER};
  D.16897 ={v} {CLOBBER};
  D.16896 ={v} {CLOBBER};
  _24 = ImGui::GetColorU32 (5, 1.0e+0);
  _25 = window_4->DrawList;
  ImDrawList::AddRect (_25, &p_min, &p_max, _24, rounding_7(D), 15, border_size_9);

  <bb 5>:
  return;

}



;; Function void ImGui::RenderFrameBorder(ImVec2, ImVec2, float) (_ZN5ImGui17RenderFrameBorderE6ImVec2S0_f, funcdef_no=748, decl_uid=13897, cgraph_uid=647, symbol_order=653)

void ImGui::RenderFrameBorder(ImVec2, ImVec2, float) (struct ImVec2 p_min, struct ImVec2 p_max, float rounding)
{
  const float border_size;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.29010;
  unsigned int D.29009;
  struct ImDrawList * D.29008;
  struct ImVec2 D.16906;
  struct ImVec2 D.16907;
  struct ImVec2 D.16908;
  struct ImVec2 D.16909;
  unsigned int D.29007;
  unsigned int _7;
  struct ImDrawList * _12;
  unsigned int _20;
  struct ImDrawList * _21;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->CurrentWindow;
  border_size_5 = g_3->Style.FrameBorderSize;
  if (border_size_5 > 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImGui::GetColorU32 (6, 1.0e+0);
  ImVec2::ImVec2 (&D.16908, 1.0e+0, 1.0e+0);
  D.16909 = operator+ (&p_max, &D.16908);
  ImVec2::ImVec2 (&D.16906, 1.0e+0, 1.0e+0);
  D.16907 = operator+ (&p_min, &D.16906);
  _12 = window_4->DrawList;
  ImDrawList::AddRect (_12, &D.16907, &D.16909, _7, rounding_13(D), 15, border_size_5);
  D.16907 ={v} {CLOBBER};
  D.16906 ={v} {CLOBBER};
  D.16909 ={v} {CLOBBER};
  D.16908 ={v} {CLOBBER};
  _20 = ImGui::GetColorU32 (5, 1.0e+0);
  _21 = window_4->DrawList;
  ImDrawList::AddRect (_21, &p_min, &p_max, _20, rounding_13(D), 15, border_size_5);

  <bb 4>:
  return;

}



;; Function void ImGui::RenderArrow(ImVec2, ImGuiDir, float) (_ZN5ImGui11RenderArrowE6ImVec2if, funcdef_no=749, decl_uid=13909, cgraph_uid=648, symbol_order=654)

void ImGui::RenderArrow(ImVec2, ImGuiDir, float) (struct ImVec2 p_min, ImGuiDir dir, float scale)
{
  static const char __PRETTY_FUNCTION__[49] = "void ImGui::RenderArrow(ImVec2, ImGuiDir, float)";
  struct ImVec2 c;
  struct ImVec2 b;
  struct ImVec2 a;
  struct ImVec2 center;
  float r;
  const float h;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.29037;
  struct ImVec2 D.16944;
  struct ImVec2 D.16945;
  struct ImVec2 D.16946;
  unsigned int D.29036;
  struct ImVec2 D.16939;
  struct ImVec2 D.16937;
  struct ImVec2 D.16935;
  float D.29031;
  float D.29030;
  float D.29029;
  struct ImVec2 D.16931;
  struct ImVec2 D.16929;
  struct ImVec2 D.16927;
  float D.29025;
  float D.29024;
  float D.29023;
  float D.29019;
  float D.29018;
  float D.29017;
  struct ImVec2 D.16920;
  float D.29016;
  float _8;
  float _11;
  float _12;
  float _13;
  float _22;
  float _23;
  float _24;
  float _36;
  float _37;
  float _38;
  unsigned int _50;
  struct ImDrawList * _54;

  <bb 2>:
  g_5 = GImGui;
  window_6 = g_5->CurrentWindow;
  h_7 = g_5->FontSize;
  _8 = h_7 * 4.000000059604644775390625e-1;
  r_10 = _8 * scale_9(D);
  _11 = h_7 * 5.0e-1;
  _12 = _11 * scale_9(D);
  _13 = h_7 * 5.0e-1;
  ImVec2::ImVec2 (&D.16920, _13, _12);
  center = operator+ (&p_min, &D.16920);
  D.16920 ={v} {CLOBBER};
  ImVec2::ImVec2 (&a);
  ImVec2::ImVec2 (&b);
  ImVec2::ImVec2 (&c);
  switch (dir_20(D)) <default: <L15>, case -1: <L10>, case 0 ... 1: <L5>, case 2 ... 3: <L0>, case 4: <L10>>

<L0>:
  if (dir_20(D) == 2)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  r_21 = -r_10;

  <bb 5>:
  # r_1 = PHI <r_10(3), r_21(4)>
  _22 = center.y;
  _23 = r_1 * 2.5e-1;
  _24 = _22 - _23;
  center.y = _24;
  ImVec2::ImVec2 (&D.16927, 0.0, 1.0e+0);
  a = operator* (&D.16927, r_1);
  D.16927 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.16929, -8.65999996662139892578125e-1, -5.0e-1);
  b = operator* (&D.16929, r_1);
  D.16929 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.16931, 8.65999996662139892578125e-1, -5.0e-1);
  c = operator* (&D.16931, r_1);
  D.16931 ={v} {CLOBBER};
  goto <bb 10> (<L15>);

<L5>:
  if (dir_20(D) == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  r_35 = -r_10;

  <bb 8>:
  # r_2 = PHI <r_10(6), r_35(7)>
  _36 = center.x;
  _37 = r_2 * 2.5e-1;
  _38 = _36 - _37;
  center.x = _38;
  ImVec2::ImVec2 (&D.16935, 1.0e+0, 0.0);
  a = operator* (&D.16935, r_2);
  D.16935 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.16937, -5.0e-1, 8.65999996662139892578125e-1);
  b = operator* (&D.16937, r_2);
  D.16937 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.16939, -5.0e-1, -8.65999996662139892578125e-1);
  c = operator* (&D.16939, r_2);
  D.16939 ={v} {CLOBBER};
  goto <bb 10> (<L15>);

<L10>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4361, &__PRETTY_FUNCTION__);

<L15>:
  _50 = ImGui::GetColorU32 (0, 1.0e+0);
  D.16946 = operator+ (&center, &c);
  D.16945 = operator+ (&center, &b);
  D.16944 = operator+ (&center, &a);
  _54 = window_6->DrawList;
  ImDrawList::AddTriangleFilled (_54, &D.16944, &D.16945, &D.16946, _50);
  D.16944 ={v} {CLOBBER};
  D.16945 ={v} {CLOBBER};
  D.16946 ={v} {CLOBBER};
  center ={v} {CLOBBER};
  a ={v} {CLOBBER};
  b ={v} {CLOBBER};
  c ={v} {CLOBBER};
  return;

}



;; Function void ImGui::RenderBullet(ImVec2) (_ZN5ImGui12RenderBulletE6ImVec2, funcdef_no=750, decl_uid=13911, cgraph_uid=649, symbol_order=655)

void ImGui::RenderBullet(ImVec2) (struct ImVec2 pos)
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.29046;
  float D.29045;
  float D.29044;
  struct ImGuiContext * GImGui.381;
  unsigned int D.29042;
  unsigned int _5;
  struct ImGuiContext * GImGui.381_6;
  float _7;
  float _8;
  struct ImDrawList * _9;

  <bb 2>:
  g_2 = GImGui;
  window_3 = g_2->CurrentWindow;
  _5 = ImGui::GetColorU32 (0, 1.0e+0);
  GImGui.381_6 = GImGui;
  _7 = GImGui.381_6->FontSize;
  _8 = _7 * 2.0000000298023223876953125e-1;
  _9 = window_3->DrawList;
  ImDrawList::AddCircleFilled (_9, &pos, _8, _5, 8);
  return;

}



;; Function void ImGui::RenderCheckMark(ImVec2, ImU32, float) (_ZN5ImGui15RenderCheckMarkE6ImVec2jf, funcdef_no=751, decl_uid=13915, cgraph_uid=650, symbol_order=656)

void ImGui::RenderCheckMark(ImVec2, ImU32, float) (struct ImVec2 pos, ImU32 col, float sz)
{
  float by;
  float bx;
  float third;
  float thickness;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.29064;
  struct ImDrawList * D.29063;
  float D.29062;
  float D.29061;
  float D.29060;
  float D.29059;
  struct ImVec2 D.16967;
  struct ImDrawList * D.29058;
  struct ImVec2 D.16966;
  struct ImDrawList * D.29057;
  float D.29056;
  float D.29055;
  struct ImVec2 D.16965;
  float D.29054;
  float D.29053;
  float D.29052;
  float D.29051;
  float D.29050;
  float D.29049;
  struct ImVec2 D.16961;
  float D.29048;
  float D.29047;
  float _5;
  float _8;
  float _10;
  float _11;
  float _16;
  float _18;
  float _19;
  float _20;
  float _22;
  float _23;
  struct ImDrawList * _25;
  struct ImDrawList * _29;
  float _32;
  float _33;
  float _34;
  float _35;
  struct ImDrawList * _37;
  struct ImDrawList * _40;

  <bb 2>:
  g_2 = GImGui;
  window_3 = g_2->CurrentWindow;
  _5 = sz_4(D) / 5.0e+0;
  thickness_7 = ImMax (_5, 1.0e+0);
  _8 = thickness_7 * 5.0e-1;
  sz_9 = sz_4(D) - _8;
  _10 = thickness_7 * 2.5e-1;
  _11 = thickness_7 * 2.5e-1;
  ImVec2::ImVec2 (&D.16961, _11, _10);
  operator+= (&pos, &D.16961);
  D.16961 ={v} {CLOBBER};
  third_15 = sz_9 / 3.0e+0;
  _16 = pos.x;
  bx_17 = _16 + third_15;
  _18 = pos.y;
  _19 = _18 + sz_9;
  _20 = third_15 * 5.0e-1;
  by_21 = _19 - _20;
  _22 = by_21 - third_15;
  _23 = bx_17 - third_15;
  ImVec2::ImVec2 (&D.16965, _23, _22);
  _25 = window_3->DrawList;
  ImDrawList::PathLineTo (_25, &D.16965);
  D.16965 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.16966, bx_17, by_21);
  _29 = window_3->DrawList;
  ImDrawList::PathLineTo (_29, &D.16966);
  D.16966 ={v} {CLOBBER};
  _32 = third_15 * 2.0e+0;
  _33 = by_21 - _32;
  _34 = third_15 * 2.0e+0;
  _35 = _34 + bx_17;
  ImVec2::ImVec2 (&D.16967, _35, _33);
  _37 = window_3->DrawList;
  ImDrawList::PathLineTo (_37, &D.16967);
  D.16967 ={v} {CLOBBER};
  _40 = window_3->DrawList;
  ImDrawList::PathStroke (_40, col_41(D), 0, thickness_7);
  return;

}



;; Function void ImGui::RenderNavHighlight(const ImRect&, ImGuiID, ImGuiNavHighlightFlags) (_ZN5ImGui18RenderNavHighlightERK6ImRectji, funcdef_no=752, decl_uid=13919, cgraph_uid=651, symbol_order=657)

void ImGui::RenderNavHighlight(const ImRect&, ImGuiID, ImGuiNavHighlightFlags) (const struct ImRect & bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
  bool fully_visible;
  const float DISTANCE;
  const float THICKNESS;
  struct ImRect display_rect;
  float rounding;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.29163;
  unsigned int D.29162;
  int D.29159;
  struct ImDrawList * D.29156;
  bool D.29153;
  struct ImDrawList * D.29152;
  struct ImVec2 D.16984;
  struct ImVec2 D.16985;
  struct ImVec2 D.16986;
  struct ImVec2 D.16987;
  unsigned int D.29151;
  struct ImDrawList * D.29149;
  bool D.29146;
  struct ImRect * D.29145;
  struct ImVec2 D.16980;
  int D.29142;
  struct ImRect * D.29141;
  int D.29137;
  float iftmp.384;
  bool D.29133;
  int D.29130;
  bool D.29127;
  unsigned int D.29124;
  float iftmp.384_1;
  unsigned int _11;
  bool _13;
  int _15;
  bool _18;
  int _19;
  float iftmp.384_20;
  float iftmp.384_21;
  struct ImRect * _25;
  int _27;
  struct ImRect * _33;
  bool _36;
  struct ImDrawList * _37;
  unsigned int _40;
  struct ImDrawList * _45;
  bool _51;
  struct ImDrawList * _52;
  int _58;
  unsigned int _60;
  struct ImDrawList * _61;

  <bb 2>:
  g_10 = GImGui;
  _11 = g_10->NavId;
  if (_11 != id_12(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 21>;

  <bb 4>:
  _13 = g_10->NavDisableHighlight;
  if (_13 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _15 = flags_14(D) & 4;
  if (_15 == 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 21>;

  <bb 7>:
  window_17 = ImGui::GetCurrentWindow ();
  _18 = window_17->DC.NavHideHighlightOneFrame;
  if (_18 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 21>;

  <bb 9>:
  _19 = flags_14(D) & 8;
  if (_19 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.384_20 = g_10->Style.FrameRounding;
  goto <bb 12>;

  <bb 11>:
  iftmp.384_21 = 0.0;

  <bb 12>:
  # iftmp.384_1 = PHI <iftmp.384_20(10), iftmp.384_21(11)>
  rounding_22 = iftmp.384_1;
  display_rect = *bb_23(D);
  _25 = &window_17->ClipRect;
  ImRect::ClipWith (&display_rect, _25);
  _27 = flags_14(D) & 1;
  if (_27 != 0)
    goto <bb 13>;
  else
    goto <bb 18>;

  <bb 13>:
  THICKNESS_28 = 2.0e+0;
  DISTANCE_29 = 4.0e+0;
  ImVec2::ImVec2 (&D.16980, 4.0e+0, 4.0e+0);
  ImRect::Expand (&display_rect, &D.16980);
  D.16980 ={v} {CLOBBER};
  _33 = &window_17->ClipRect;
  fully_visible_35 = ImRect::Contains (_33, &display_rect);
  _36 = ~fully_visible_35;
  if (_36 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _37 = window_17->DrawList;
  ImDrawList::PushClipRect (_37, display_rect.Min, display_rect.Max, 0);

  <bb 15>:
  _40 = ImGui::GetColorU32 (40, 1.0e+0);
  ImVec2::ImVec2 (&D.16986, 1.0e+0, 1.0e+0);
  D.16987 = operator- (&display_rect.Max, &D.16986);
  ImVec2::ImVec2 (&D.16984, 1.0e+0, 1.0e+0);
  D.16985 = operator+ (&display_rect.Min, &D.16984);
  _45 = window_17->DrawList;
  ImDrawList::AddRect (_45, &D.16985, &D.16987, _40, rounding_22, 15, 2.0e+0);
  D.16985 ={v} {CLOBBER};
  D.16984 ={v} {CLOBBER};
  D.16987 ={v} {CLOBBER};
  D.16986 ={v} {CLOBBER};
  _51 = ~fully_visible_35;
  if (_51 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _52 = window_17->DrawList;
  ImDrawList::PopClipRect (_52);

  <bb 17>:

  <bb 18>:
  _58 = flags_14(D) & 2;
  if (_58 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _60 = ImGui::GetColorU32 (40, 1.0e+0);
  _61 = window_17->DrawList;
  ImDrawList::AddRect (_61, &display_rect.Min, &display_rect.Max, _60, rounding_22, -1, 1.0e+0);

  <bb 20>:
  display_rect ={v} {CLOBBER};
  goto <bb 22> (<L25>);

  <bb 21>:
  display_rect ={v} {CLOBBER};

<L25>:
  return;

}



;; Function ImVec2 ImGui::CalcTextSize(const char*, const char*, bool, float) (_ZN5ImGui12CalcTextSizeEPKcS1_bf, funcdef_no=753, decl_uid=3334, cgraph_uid=652, symbol_order=658)

ImVec2 ImGui::CalcTextSize(const char*, const char*, bool, float) (const char * text, const char * text_end, bool hide_text_after_double_hash, float wrap_width)
{
  const float character_spacing_x;
  const float font_scale;
  struct ImVec2 text_size;
  const float font_size;
  struct ImFont * font;
  const char * text_display_end;
  struct ImGuiContext & g;
  float D.29189;
  int D.29188;
  float D.29187;
  float D.29186;
  float D.29184;
  float D.29183;
  float D.29180;
  float D.29179;
  struct ImVec2 D.16998;
  struct ImVec2 D.29178;
  float _20;
  float _23;
  float _24;
  float _25;
  float _27;
  float _28;
  int _29;
  float _30;

  <bb 2>:
  g_6 = GImGui;
  if (hide_text_after_double_hash_7(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  text_display_end_11 = ImGui::FindRenderedTextEnd (text_8(D), text_end_9(D));
  goto <bb 5>;

  <bb 4>:
  text_display_end_12 = text_end_9(D);

  <bb 5>:
  # text_display_end_1 = PHI <text_display_end_11(3), text_display_end_12(4)>
  font_13 = g_6->Font;
  font_size_14 = g_6->FontSize;
  if (text_8(D) == text_display_end_1)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  ImVec2::ImVec2 (&D.16998, 0.0, font_size_14);
  D.29178 = D.16998;
  D.16998 ={v} {CLOBBER};
  goto <bb 10>;

  <bb 7>:
  text_size = ImFont::CalcTextSizeA (font_13, font_size_14, 3.4028234663852885981170418348451692544e+38, wrap_width_18(D), text_8(D), text_display_end_1, 0B);
  _20 = font_13->FontSize;
  font_scale_21 = font_size_14 / _20;
  character_spacing_x_22 = font_scale_21;
  _23 = text_size.x;
  if (_23 > 0.0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _24 = text_size.x;
  _25 = _24 - character_spacing_x_22;
  text_size.x = _25;

  <bb 9>:
  _27 = text_size.x;
  _28 = _27 + 9.49999988079071044921875e-1;
  _29 = (int) _28;
  _30 = (float) _29;
  text_size.x = _30;
  D.29178 = text_size;

  <bb 10>:
  text_size ={v} {CLOBBER};

<L10>:
  return D.29178;

}



;; Function void ImGui::CalcListClipping(int, float, int*, int*) (_ZN5ImGui16CalcListClippingEifPiS0_, funcdef_no=754, decl_uid=3339, cgraph_uid=653, symbol_order=659)

void ImGui::CalcListClipping(int, float, int*, int*) (int items_count, float items_height, int * out_items_display_start, int * out_items_display_end)
{
  int end;
  int start;
  const struct ImVec2 pos;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.29223;
  int D.29219;
  bool D.29216;
  int D.29212;
  bool D.29209;
  float D.29208;
  float D.29207;
  float D.29206;
  float D.29205;
  float D.29204;
  float D.29203;
  float D.29202;
  float D.29201;
  int D.29200;
  bool D.29197;
  bool D.29194;
  bool _8;
  bool _9;
  float _11;
  float _12;
  float _13;
  float _15;
  float _17;
  float _18;
  float _19;
  float _20;
  bool _22;
  int _23;
  bool _25;
  int _26;
  int _31;
  int _40;

  <bb 2>:
  g_6 = GImGui;
  window_7 = g_6->CurrentWindow;
  _8 = g_6->LogEnabled;
  if (_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  *out_items_display_start_34(D) = 0;
  *out_items_display_end_36(D) = items_count_28(D);
  goto <bb 13>;

  <bb 4>:
  _9 = window_7->SkipItems;
  if (_9 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  *out_items_display_end_36(D) = 0;
  _40 = *out_items_display_end_36(D);
  *out_items_display_start_34(D) = _40;
  goto <bb 13>;

  <bb 6>:
  pos = window_7->DC.CursorPos;
  _11 = window_7->ClipRect.Min.y;
  _12 = pos.y;
  _13 = _11 - _12;
  _15 = _13 / items_height_14(D);
  start_16 = (int) _15;
  _17 = window_7->ClipRect.Max.y;
  _18 = pos.y;
  _19 = _17 - _18;
  _20 = _19 / items_height_14(D);
  end_21 = (int) _20;
  _22 = g_6->NavMoveRequest;
  if (_22 != 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _23 = g_6->NavMoveDir;
  if (_23 == 2)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  start_24 = start_16 + -1;

  <bb 9>:
  # start_1 = PHI <start_16(6), start_16(7), start_24(8)>
  _25 = g_6->NavMoveRequest;
  if (_25 != 0)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _26 = g_6->NavMoveDir;
  if (_26 == 3)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  end_27 = end_21 + 1;

  <bb 12>:
  # end_2 = PHI <end_21(9), end_21(10), end_27(11)>
  start_30 = ImClamp (start_1, 0, items_count_28(D));
  _31 = end_2 + 1;
  end_33 = ImClamp (_31, start_30, items_count_28(D));
  *out_items_display_start_34(D) = start_30;
  *out_items_display_end_36(D) = end_33;
  pos ={v} {CLOBBER};
  goto <bb 14> (<L16>);

  <bb 13>:
  pos ={v} {CLOBBER};

<L16>:
  return;

}



;; Function ImGuiWindow* FindHoveredWindow() (_ZL17FindHoveredWindowv, funcdef_no=755, decl_uid=15039, cgraph_uid=654, symbol_order=660)

ImGuiWindow* FindHoveredWindow() ()
{
  struct ImRect bb;
  struct ImGuiWindow * window;
  int i;
  struct ImGuiContext & g;
  struct ImGuiWindow * D.29258;
  struct ImVec2 * D.29255;
  bool retval.387;
  struct ImVec2 * D.29253;
  struct ImVec2 * D.29252;
  struct ImVec2 D.17022;
  struct ImVec2 * D.29251;
  struct ImVec2 * D.29250;
  struct ImVec2 D.17023;
  int D.29247;
  int D.29246;
  bool D.29243;
  bool D.29242;
  struct ImGuiWindow * & D.29241;
  struct ImVector * D.29240;
  int D.29237;
  struct ImGuiWindow * _2;
  int _8;
  struct ImVector * _10;
  struct ImGuiWindow * & _12;
  bool _14;
  bool _15;
  int _18;
  int _19;
  struct ImVec2 * _20;
  struct ImVec2 * _21;
  struct ImVec2 * _23;
  struct ImVec2 * _24;
  struct ImVec2 * _29;
  bool retval.387_31;
  struct ImGuiWindow * _33;
  struct ImGuiWindow * _35;

  <bb 2>:
  g_7 = GImGui;
  _8 = g_7->Windows.Size;
  i_9 = _8 + -1;

  <bb 3>:
  # i_1 = PHI <i_9(2), i_17(12)>
  if (i_1 < 0)
    goto <bb 13>;
  else
    goto <bb 4>;

  <bb 4>:
  _10 = &g_7->Windows;
  _12 = ImVector<ImGuiWindow*>::operator[] (_10, i_1);
  window_13 = *_12;
  _14 = window_13->Active;
  _15 = ~_14;
  if (_15 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 11>;

  <bb 6>:
  _18 = window_13->Flags;
  _19 = _18 & 512;
  if (_19 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 11>;

  <bb 8>:
  _20 = &g_7->Style.TouchExtraPadding;
  _21 = &window_13->WindowRectClipped.Max;
  D.17023 = operator+ (_21, _20);
  _23 = &g_7->Style.TouchExtraPadding;
  _24 = &window_13->WindowRectClipped.Min;
  D.17022 = operator- (_24, _23);
  ImRect::ImRect (&bb, &D.17022, &D.17023);
  D.17022 ={v} {CLOBBER};
  D.17023 ={v} {CLOBBER};
  _29 = &g_7->IO.MousePos;
  retval.387_31 = ImRect::Contains (&bb, _29);
  if (retval.387_31 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _33 = window_13;
  bb ={v} {CLOBBER};
  goto <bb 14> (<L13>);

  <bb 10>:
  bb ={v} {CLOBBER};
  goto <bb 12>;

  <bb 11>:
  bb ={v} {CLOBBER};

  <bb 12>:
  i_17 = i_1 + -1;
  goto <bb 3>;

  <bb 13>:
  _35 = 0B;

  # _2 = PHI <_33(9), _35(13)>
<L13>:
  return _2;

}



;; Function bool ImGui::IsMouseHoveringRect(const ImVec2&, const ImVec2&, bool) (_ZN5ImGui19IsMouseHoveringRectERK6ImVec2S2_b, funcdef_no=756, decl_uid=3392, cgraph_uid=655, symbol_order=661)

bool ImGui::IsMouseHoveringRect(const ImVec2&, const ImVec2&, bool) (const struct ImVec2 & r_min, const struct ImVec2 & r_max, bool clip)
{
  const struct ImRect rect_for_touch;
  struct ImRect rect_clipped;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImVec2 * D.29287;
  bool D.29286;
  struct ImVec2 * D.29285;
  struct ImVec2 D.17035;
  struct ImVec2 * D.29284;
  struct ImVec2 D.17036;
  struct ImRect * D.29282;
  struct ImRect * _9;
  struct ImVec2 * _11;
  struct ImVec2 * _13;
  struct ImVec2 * _18;
  bool _20;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->CurrentWindow;
  ImRect::ImRect (&rect_clipped, r_min_5(D), r_max_6(D));
  if (clip_8(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _9 = &window_4->ClipRect;
  ImRect::ClipWith (&rect_clipped, _9);

  <bb 4>:
  _11 = &g_3->Style.TouchExtraPadding;
  D.17036 = operator+ (&rect_clipped.Max, _11);
  _13 = &g_3->Style.TouchExtraPadding;
  D.17035 = operator- (&rect_clipped.Min, _13);
  ImRect::ImRect (&rect_for_touch, &D.17035, &D.17036);
  D.17035 ={v} {CLOBBER};
  D.17036 ={v} {CLOBBER};
  _18 = &g_3->IO.MousePos;
  _20 = ImRect::Contains (&rect_for_touch, _18);
  rect_clipped ={v} {CLOBBER};
  rect_for_touch ={v} {CLOBBER};

<L4>:
  return _20;

}



;; Function bool IsKeyPressedMap(ImGuiKey, bool) (_ZL15IsKeyPressedMapib, funcdef_no=757, decl_uid=15017, cgraph_uid=656, symbol_order=662)

bool IsKeyPressedMap(ImGuiKey, bool) (ImGuiKey key, bool repeat)
{
  const int key_index;
  int D.29295;
  bool iftmp.390;
  bool D.29291;
  struct ImGuiContext * GImGui.389;
  bool iftmp.390_1;
  struct ImGuiContext * GImGui.389_4;
  int _8;
  bool iftmp.390_10;
  bool iftmp.390_11;
  bool _12;

  <bb 2>:
  GImGui.389_4 = GImGui;
  key_index_6 = GImGui.389_4->IO.KeyMap[key_5(D)];
  if (key_index_6 >= 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = (int) repeat_7(D);
  iftmp.390_10 = ImGui::IsKeyPressed (key_index_6, _8);
  goto <bb 5>;

  <bb 4>:
  iftmp.390_11 = 0;

  <bb 5>:
  # iftmp.390_1 = PHI <iftmp.390_10(3), iftmp.390_11(4)>
  _12 = iftmp.390_1;

<L3>:
  return _12;

}



;; Function int ImGui::GetKeyIndex(ImGuiKey) (_ZN5ImGui11GetKeyIndexEi, funcdef_no=758, decl_uid=3364, cgraph_uid=657, symbol_order=663)

int ImGui::GetKeyIndex(ImGuiKey) (ImGuiKey imgui_key)
{
  static const char __PRETTY_FUNCTION__[33] = "int ImGui::GetKeyIndex(ImGuiKey)";
  struct ImGuiContext * GImGui.391;
  int D.29302;
  struct ImGuiContext * GImGui.391_3;
  int _4;

  <bb 2>:
  if (imgui_key_1(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (imgui_key_1(D) <= 20)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("imgui_key >= 0 && imgui_key < ImGuiKey_COUNT", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4534, &__PRETTY_FUNCTION__);

  <bb 6>:
  GImGui.391_3 = GImGui;
  _4 = GImGui.391_3->IO.KeyMap[imgui_key_1(D)];

<L4>:
  return _4;

}



;; Function bool ImGui::IsKeyDown(int) (_ZN5ImGui9IsKeyDownEi, funcdef_no=759, decl_uid=3366, cgraph_uid=658, symbol_order=664)

bool ImGui::IsKeyDown(int) (int user_key_index)
{
  static const char __PRETTY_FUNCTION__[27] = "bool ImGui::IsKeyDown(int)";
  struct ImGuiContext * GImGui.392;
  bool D.29307;
  bool _1;
  bool _3;
  struct ImGuiContext * GImGui.392_5;
  bool _6;

  <bb 2>:
  if (user_key_index_2(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _3 = 0;
  goto <bb 9> (<L6>);

  <bb 4>:
  if (user_key_index_2(D) >= 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  if (user_key_index_2(D) <= 511)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 8>;

  <bb 7>:
  __assert_fail ("user_key_index >= 0 && user_key_index < ((int)(sizeof(GImGui->IO.KeysDown)/sizeof(*GImGui->IO.KeysDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4542, &__PRETTY_FUNCTION__);

  <bb 8>:
  GImGui.392_5 = GImGui;
  _6 = GImGui.392_5->IO.KeysDown[user_key_index_2(D)];

  # _1 = PHI <_3(3), _6(8)>
<L6>:
  return _1;

}



;; Function int ImGui::CalcTypematicPressedRepeatAmount(float, float, float, float) (_ZN5ImGui32CalcTypematicPressedRepeatAmountEffff, funcdef_no=760, decl_uid=13844, cgraph_uid=659, symbol_order=665)

int ImGui::CalcTypematicPressedRepeatAmount(float, float, float, float) (float t, float t_prev, float repeat_delay, float repeat_rate)
{
  const int count;
  int D.29325;
  float D.29324;
  float D.29323;
  int D.29322;
  float D.29321;
  float D.29320;
  int D.29316;
  int _1;
  int _3;
  float _6;
  float _7;
  int _8;
  float _10;
  float _11;
  int _12;
  int _14;
  int _15;

  <bb 2>:
  if (t_2(D) == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _3 = 1;
  goto <bb 8> (<L5>);

  <bb 4>:
  if (t_2(D) <= repeat_delay_4(D))
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  if (repeat_rate_5(D) <= 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _15 = 0;
  goto <bb 8> (<L5>);

  <bb 7>:
  _6 = t_2(D) - repeat_delay_4(D);
  _7 = _6 / repeat_rate_5(D);
  _8 = (int) _7;
  _10 = t_prev_9(D) - repeat_delay_4(D);
  _11 = _10 / repeat_rate_5(D);
  _12 = (int) _11;
  count_13 = _8 - _12;
  _14 = MAX_EXPR <count_13, 0>;

  # _1 = PHI <_3(3), _15(6), _14(7)>
<L5>:
  return _1;

}



;; Function int ImGui::GetKeyPressedAmount(int, float, float) (_ZN5ImGui19GetKeyPressedAmountEiff, funcdef_no=761, decl_uid=3375, cgraph_uid=660, symbol_order=666)

int ImGui::GetKeyPressedAmount(int, float, float) (int key_index, float repeat_delay, float repeat_rate)
{
  const float t;
  static const char __PRETTY_FUNCTION__[50] = "int ImGui::GetKeyPressedAmount(int, float, float)";
  struct ImGuiContext & g;
  float D.29335;
  float D.29334;
  int D.29329;
  int _1;
  int _6;
  float _8;
  float _9;
  int _13;

  <bb 2>:
  g_4 = GImGui;
  if (key_index_5(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = 0;
  goto <bb 9> (<L6>);

  <bb 4>:
  if (key_index_5(D) >= 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  if (key_index_5(D) <= 511)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 8>;

  <bb 7>:
  __assert_fail ("key_index >= 0 && key_index < ((int)(sizeof(g.IO.KeysDown)/sizeof(*g.IO.KeysDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4560, &__PRETTY_FUNCTION__);

  <bb 8>:
  t_7 = g_4->IO.KeysDownDuration[key_index_5(D)];
  _8 = g_4->IO.DeltaTime;
  _9 = t_7 - _8;
  _13 = ImGui::CalcTypematicPressedRepeatAmount (t_7, _9, repeat_delay_10(D), repeat_rate_11(D));

  # _1 = PHI <_6(3), _13(8)>
<L6>:
  return _1;

}



;; Function bool ImGui::IsKeyPressed(int, bool) (_ZN5ImGui12IsKeyPressedEib, funcdef_no=762, decl_uid=3369, cgraph_uid=661, symbol_order=667)

bool ImGui::IsKeyPressed(int, bool) (int user_key_index, bool repeat)
{
  const float t;
  static const char __PRETTY_FUNCTION__[36] = "bool ImGui::IsKeyPressed(int, bool)";
  struct ImGuiContext & g;
  int D.29353;
  float D.29352;
  float D.29351;
  float D.29348;
  bool D.29339;
  bool _1;
  bool _6;
  bool _8;
  float _10;
  float _11;
  float _12;
  int _14;
  bool _15;
  bool _16;

  <bb 2>:
  g_4 = GImGui;
  if (user_key_index_5(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = 0;
  goto <bb 14> (<L12>);

  <bb 4>:
  if (user_key_index_5(D) >= 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  if (user_key_index_5(D) <= 511)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 8>;

  <bb 7>:
  __assert_fail ("user_key_index >= 0 && user_key_index < ((int)(sizeof(g.IO.KeysDown)/sizeof(*g.IO.KeysDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4569, &__PRETTY_FUNCTION__);

  <bb 8>:
  t_7 = g_4->IO.KeysDownDuration[user_key_index_5(D)];
  if (t_7 == 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _8 = 1;
  goto <bb 14> (<L12>);

  <bb 10>:
  if (repeat_9(D) != 0)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  _10 = g_4->IO.KeyRepeatDelay;
  if (_10 < t_7)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _11 = g_4->IO.KeyRepeatRate;
  _12 = g_4->IO.KeyRepeatDelay;
  _14 = ImGui::GetKeyPressedAmount (user_key_index_5(D), _12, _11);
  _15 = _14 > 0;
  goto <bb 14> (<L12>);

  <bb 13>:
  _16 = 0;

  # _1 = PHI <_6(3), _8(9), _15(12), _16(13)>
<L12>:
  return _1;

}



;; Function bool ImGui::IsKeyReleased(int) (_ZN5ImGui13IsKeyReleasedEi, funcdef_no=763, decl_uid=3371, cgraph_uid=662, symbol_order=668)

bool ImGui::IsKeyReleased(int) (int user_key_index)
{
  static const char __PRETTY_FUNCTION__[31] = "bool ImGui::IsKeyReleased(int)";
  struct ImGuiContext & g;
  bool D.29368;
  bool D.29367;
  float D.29365;
  bool iftmp.393;
  bool D.29357;
  bool _1;
  bool iftmp.393_2;
  bool _6;
  float _7;
  bool _8;
  bool _9;
  bool iftmp.393_10;
  bool iftmp.393_11;
  bool _12;

  <bb 2>:
  g_4 = GImGui;
  if (user_key_index_5(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = 0;
  goto <bb 13> (<L10>);

  <bb 4>:
  if (user_key_index_5(D) >= 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  if (user_key_index_5(D) <= 511)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 8>;

  <bb 7>:
  __assert_fail ("user_key_index >= 0 && user_key_index < ((int)(sizeof(g.IO.KeysDown)/sizeof(*g.IO.KeysDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4582, &__PRETTY_FUNCTION__);

  <bb 8>:
  _7 = g_4->IO.KeysDownDurationPrev[user_key_index_5(D)];
  if (_7 >= 0.0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _8 = g_4->IO.KeysDown[user_key_index_5(D)];
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.393_10 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.393_11 = 0;

  <bb 12>:
  # iftmp.393_2 = PHI <iftmp.393_10(10), iftmp.393_11(11)>
  _12 = iftmp.393_2;

  # _1 = PHI <_6(3), _12(12)>
<L10>:
  return _1;

}



;; Function bool ImGui::IsMouseDown(int) (_ZN5ImGui11IsMouseDownEi, funcdef_no=764, decl_uid=3377, cgraph_uid=663, symbol_order=669)

bool ImGui::IsMouseDown(int) (int button)
{
  static const char __PRETTY_FUNCTION__[29] = "bool ImGui::IsMouseDown(int)";
  struct ImGuiContext & g;
  bool D.29375;
  bool _4;

  <bb 2>:
  g_2 = GImGui;
  if (button_3(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_3(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4589, &__PRETTY_FUNCTION__);

  <bb 6>:
  _4 = g_2->IO.MouseDown[button_3(D)];

<L4>:
  return _4;

}



;; Function bool ImGui::IsAnyMouseDown() (_ZN5ImGui14IsAnyMouseDownEv, funcdef_no=765, decl_uid=3378, cgraph_uid=664, symbol_order=670)

bool ImGui::IsAnyMouseDown() ()
{
  int n;
  struct ImGuiContext & g;
  bool D.29382;
  bool D.29379;
  bool _2;
  bool _6;
  bool _8;
  bool _9;

  <bb 2>:
  g_4 = GImGui;
  n_5 = 0;

  <bb 3>:
  # n_1 = PHI <n_5(2), n_7(6)>
  if (n_1 > 4)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _6 = g_4->IO.MouseDown[n_1];
  if (_6 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _8 = 1;
  goto <bb 8> (<L5>);

  <bb 6>:
  n_7 = n_1 + 1;
  goto <bb 3>;

  <bb 7>:
  _9 = 0;

  # _2 = PHI <_8(5), _9(7)>
<L5>:
  return _2;

}



;; Function bool ImGui::IsMouseClicked(int, bool) (_ZN5ImGui14IsMouseClickedEib, funcdef_no=766, decl_uid=3381, cgraph_uid=665, symbol_order=671)

bool ImGui::IsMouseClicked(int, bool) (int button, bool repeat)
{
  float rate;
  float delay;
  const float t;
  static const char __PRETTY_FUNCTION__[38] = "bool ImGui::IsMouseClicked(int, bool)";
  struct ImGuiContext & g;
  bool D.29406;
  float D.29405;
  float D.29404;
  float D.29403;
  float D.29402;
  float D.29401;
  bool D.29400;
  float D.29399;
  float D.29398;
  float D.29397;
  bool retval.394;
  float D.29393;
  bool D.29390;
  bool _1;
  bool _8;
  float _10;
  float _13;
  float _15;
  float _16;
  bool _17;
  float _18;
  float _19;
  float _20;
  float _22;
  float _23;
  bool _24;
  bool retval.394_25;
  bool _26;
  bool _27;

  <bb 2>:
  g_5 = GImGui;
  if (button_6(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_6(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4605, &__PRETTY_FUNCTION__);

  <bb 6>:
  t_7 = g_5->IO.MouseDownDuration[button_6(D)];
  if (t_7 == 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _8 = 1;
  goto <bb 14> (<L13>);

  <bb 8>:
  if (repeat_9(D) != 0)
    goto <bb 9>;
  else
    goto <bb 13>;

  <bb 9>:
  _10 = g_5->IO.KeyRepeatDelay;
  if (_10 < t_7)
    goto <bb 10>;
  else
    goto <bb 13>;

  <bb 10>:
  delay_11 = g_5->IO.KeyRepeatDelay;
  rate_12 = g_5->IO.KeyRepeatRate;
  _13 = t_7 - delay_11;
  _15 = fmodf (_13, rate_12);
  _16 = rate_12 * 5.0e-1;
  _17 = _15 > _16;
  _18 = t_7 - delay_11;
  _19 = g_5->IO.DeltaTime;
  _20 = _18 - _19;
  _22 = fmodf (_20, rate_12);
  _23 = rate_12 * 5.0e-1;
  _24 = _22 > _23;
  retval.394_25 = _17 ^ _24;
  if (retval.394_25 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _26 = 1;
  goto <bb 14> (<L13>);

  <bb 12>:

  <bb 13>:
  _27 = 0;

  # _1 = PHI <_8(7), _26(11), _27(13)>
<L13>:
  return _1;

}



;; Function bool ImGui::IsMouseReleased(int) (_ZN5ImGui15IsMouseReleasedEi, funcdef_no=767, decl_uid=3385, cgraph_uid=666, symbol_order=672)

bool ImGui::IsMouseReleased(int) (int button)
{
  static const char __PRETTY_FUNCTION__[33] = "bool ImGui::IsMouseReleased(int)";
  struct ImGuiContext & g;
  bool D.29415;
  bool _4;

  <bb 2>:
  g_2 = GImGui;
  if (button_3(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_3(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4623, &__PRETTY_FUNCTION__);

  <bb 6>:
  _4 = g_2->IO.MouseReleased[button_3(D)];

<L4>:
  return _4;

}



;; Function bool ImGui::IsMouseDoubleClicked(int) (_ZN5ImGui20IsMouseDoubleClickedEi, funcdef_no=768, decl_uid=3383, cgraph_uid=667, symbol_order=673)

bool ImGui::IsMouseDoubleClicked(int) (int button)
{
  static const char __PRETTY_FUNCTION__[38] = "bool ImGui::IsMouseDoubleClicked(int)";
  struct ImGuiContext & g;
  bool D.29421;
  bool _4;

  <bb 2>:
  g_2 = GImGui;
  if (button_3(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_3(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4630, &__PRETTY_FUNCTION__);

  <bb 6>:
  _4 = g_2->IO.MouseDoubleClicked[button_3(D)];

<L4>:
  return _4;

}



;; Function bool ImGui::IsMouseDragging(int, float) (_ZN5ImGui15IsMouseDraggingEif, funcdef_no=769, decl_uid=3388, cgraph_uid=668, symbol_order=674)

bool ImGui::IsMouseDragging(int, float) (int button, float lock_threshold)
{
  static const char __PRETTY_FUNCTION__[40] = "bool ImGui::IsMouseDragging(int, float)";
  struct ImGuiContext & g;
  float D.29436;
  float D.29435;
  bool D.29431;
  bool D.29428;
  bool D.29427;
  bool _2;
  bool _6;
  bool _7;
  bool _8;
  float _11;
  float _12;
  bool _13;

  <bb 2>:
  g_4 = GImGui;
  if (button_5(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_5(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4637, &__PRETTY_FUNCTION__);

  <bb 6>:
  _6 = g_4->IO.MouseDown[button_5(D)];
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _8 = 0;
  goto <bb 11> (<L9>);

  <bb 8>:
  if (lock_threshold_9(D) < 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  lock_threshold_10 = g_4->IO.MouseDragThreshold;

  <bb 10>:
  # lock_threshold_1 = PHI <lock_threshold_9(D)(8), lock_threshold_10(9)>
  _11 = g_4->IO.MouseDragMaxDistanceSqr[button_5(D)];
  _12 = lock_threshold_1 * lock_threshold_1;
  _13 = _11 >= _12;

  # _2 = PHI <_8(7), _13(10)>
<L9>:
  return _2;

}



;; Function ImVec2 ImGui::GetMousePos() (_ZN5ImGui11GetMousePosEv, funcdef_no=770, decl_uid=3395, cgraph_uid=669, symbol_order=675)

ImVec2 ImGui::GetMousePos() ()
{
  struct ImGuiContext * GImGui.395;
  struct ImVec2 D.29438;
  struct ImGuiContext * GImGui.395_2;

  <bb 2>:
  GImGui.395_2 = GImGui;
  D.29438 = GImGui.395_2->IO.MousePos;

<L0>:
  return D.29438;

}



;; Function ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup() (_ZN5ImGui32GetMousePosOnOpeningCurrentPopupEv, funcdef_no=771, decl_uid=3396, cgraph_uid=670, symbol_order=676)

ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup() ()
{
  struct ImGuiContext & g;
  struct value_type & D.29448;
  struct ImVector * D.29447;
  int D.29446;
  int D.29445;
  struct ImVec2 D.29444;
  int D.29441;
  int _4;
  int _5;
  int _6;
  struct ImVector * _7;
  struct value_type & _9;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->CurrentPopupStack.Size;
  if (_4 > 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = g_3->CurrentPopupStack.Size;
  _6 = _5 + -1;
  _7 = &g_3->OpenPopupStack;
  _9 = ImVector<ImGuiPopupRef>::operator[] (_7, _6);
  D.29444 = _9->OpenMousePos;
  goto <bb 5> (<L2>);

  <bb 4>:
  D.29444 = g_3->IO.MousePos;

<L2>:
  return D.29444;

}



;; Function bool ImGui::IsMousePosValid(const ImVec2*) (_ZN5ImGui15IsMousePosValidEPK6ImVec2, funcdef_no=772, decl_uid=3394, cgraph_uid=671, symbol_order=677)

bool ImGui::IsMousePosValid(const ImVec2*) (const struct ImVec2 * mouse_pos)
{
  const float MOUSE_INVALID;
  float D.29469;
  float D.29467;
  bool iftmp.397;
  bool D.29463;
  struct ImGuiContext * GImGui.396;
  bool iftmp.397_2;
  struct ImGuiContext * GImGui.396_5;
  float _8;
  float _9;
  bool iftmp.397_10;
  bool iftmp.397_11;
  bool _12;

  <bb 2>:
  if (mouse_pos_3(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  GImGui.396_5 = GImGui;
  mouse_pos_6 = &GImGui.396_5->IO.MousePos;

  <bb 4>:
  # mouse_pos_1 = PHI <mouse_pos_3(D)(2), mouse_pos_6(3)>
  MOUSE_INVALID_7 = -2.56e+5;
  _8 = mouse_pos_1->x;
  if (_8 >= -2.56e+5)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _9 = mouse_pos_1->y;
  if (_9 >= -2.56e+5)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.397_10 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.397_11 = 0;

  <bb 8>:
  # iftmp.397_2 = PHI <iftmp.397_10(6), iftmp.397_11(7)>
  _12 = iftmp.397_2;

<L7>:
  return _12;

}



;; Function ImVec2 ImGui::GetMouseDragDelta(int, float) (_ZN5ImGui17GetMouseDragDeltaEif, funcdef_no=773, decl_uid=3399, cgraph_uid=672, symbol_order=678)

ImVec2 ImGui::GetMouseDragDelta(int, float) (int button, float lock_threshold)
{
  static const char __PRETTY_FUNCTION__[44] = "ImVec2 ImGui::GetMouseDragDelta(int, float)";
  struct ImGuiContext & g;
  struct ImVec2 D.17132;
  struct ImVec2 * D.29488;
  struct ImVec2 * D.29487;
  struct ImVec2 D.29486;
  float D.29483;
  float D.29482;
  bool D.29479;
  bool _8;
  float _9;
  float _10;
  struct ImVec2 * _11;
  struct ImVec2 * _12;

  <bb 2>:
  g_4 = GImGui;
  if (button_5(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_5(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4672, &__PRETTY_FUNCTION__);

  <bb 6>:
  if (lock_threshold_6(D) < 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  lock_threshold_7 = g_4->IO.MouseDragThreshold;

  <bb 8>:
  # lock_threshold_1 = PHI <lock_threshold_6(D)(6), lock_threshold_7(7)>
  _8 = g_4->IO.MouseDown[button_5(D)];
  if (_8 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _9 = g_4->IO.MouseDragMaxDistanceSqr[button_5(D)];
  _10 = lock_threshold_1 * lock_threshold_1;
  if (_9 >= _10)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _11 = &g_4->IO.MouseClickedPos[button_5(D)];
  _12 = &g_4->IO.MousePos;
  D.29486 = operator- (_12, _11);
  goto <bb 12> (<L13>);

  <bb 11>:
  ImVec2::ImVec2 (&D.17132, 0.0, 0.0);
  D.29486 = D.17132;
  D.17132 ={v} {CLOBBER};

<L13>:
  return D.29486;

}



;; Function void ImGui::ResetMouseDragDelta(int) (_ZN5ImGui19ResetMouseDragDeltaEi, funcdef_no=774, decl_uid=3401, cgraph_uid=673, symbol_order=679)

void ImGui::ResetMouseDragDelta(int) (int button)
{
  static const char __PRETTY_FUNCTION__[37] = "void ImGui::ResetMouseDragDelta(int)";
  struct ImGuiContext & g;

  <bb 2>:
  g_2 = GImGui;
  if (button_3(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (button_3(D) <= 4)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("button >= 0 && button < ((int)(sizeof(g.IO.MouseDown)/sizeof(*g.IO.MouseDown)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4684, &__PRETTY_FUNCTION__);

  <bb 6>:
  g_2->IO.MouseClickedPos[button_3(D)] = g_2->IO.MousePos;
  return;

}



;; Function ImGuiMouseCursor ImGui::GetMouseCursor() (_ZN5ImGui14GetMouseCursorEv, funcdef_no=775, decl_uid=3402, cgraph_uid=674, symbol_order=680)

ImGuiMouseCursor ImGui::GetMouseCursor() ()
{
  struct ImGuiContext * GImGui.398;
  ImGuiMouseCursor D.29496;
  struct ImGuiContext * GImGui.398_2;
  ImGuiMouseCursor _3;

  <bb 2>:
  GImGui.398_2 = GImGui;
  _3 = GImGui.398_2->MouseCursor;

<L0>:
  return _3;

}



;; Function void ImGui::SetMouseCursor(ImGuiMouseCursor) (_ZN5ImGui14SetMouseCursorEi, funcdef_no=776, decl_uid=3404, cgraph_uid=675, symbol_order=681)

void ImGui::SetMouseCursor(ImGuiMouseCursor) (ImGuiMouseCursor cursor_type)
{
  struct ImGuiContext * GImGui.399;
  struct ImGuiContext * GImGui.399_2;

  <bb 2>:
  GImGui.399_2 = GImGui;
  GImGui.399_2->MouseCursor = cursor_type_3(D);
  return;

}



;; Function void ImGui::CaptureKeyboardFromApp(bool) (_ZN5ImGui22CaptureKeyboardFromAppEb, funcdef_no=777, decl_uid=3406, cgraph_uid=676, symbol_order=682)

void ImGui::CaptureKeyboardFromApp(bool) (bool capture)
{
  int iftmp.401;
  struct ImGuiContext * GImGui.400;
  int iftmp.401_1;
  struct ImGuiContext * GImGui.400_3;
  int iftmp.401_5;
  int iftmp.401_6;

  <bb 2>:
  GImGui.400_3 = GImGui;
  if (capture_4(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.401_5 = 1;
  goto <bb 5>;

  <bb 4>:
  iftmp.401_6 = 0;

  <bb 5>:
  # iftmp.401_1 = PHI <iftmp.401_5(3), iftmp.401_6(4)>
  GImGui.400_3->WantCaptureKeyboardNextFrame = iftmp.401_1;
  return;

}



;; Function void ImGui::CaptureMouseFromApp(bool) (_ZN5ImGui19CaptureMouseFromAppEb, funcdef_no=778, decl_uid=3408, cgraph_uid=677, symbol_order=683)

void ImGui::CaptureMouseFromApp(bool) (bool capture)
{
  int iftmp.403;
  struct ImGuiContext * GImGui.402;
  int iftmp.403_1;
  struct ImGuiContext * GImGui.402_3;
  int iftmp.403_5;
  int iftmp.403_6;

  <bb 2>:
  GImGui.402_3 = GImGui;
  if (capture_4(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.403_5 = 1;
  goto <bb 5>;

  <bb 4>:
  iftmp.403_6 = 0;

  <bb 5>:
  # iftmp.403_1 = PHI <iftmp.403_5(3), iftmp.403_6(4)>
  GImGui.402_3->WantCaptureMouseNextFrame = iftmp.403_1;
  return;

}



;; Function bool ImGui::IsItemActive() (_ZN5ImGui12IsItemActiveEv, funcdef_no=779, decl_uid=3304, cgraph_uid=678, symbol_order=684)

bool ImGui::IsItemActive() ()
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  unsigned int D.29515;
  unsigned int D.29514;
  bool D.29513;
  unsigned int D.29510;
  bool _1;
  unsigned int _4;
  unsigned int _6;
  unsigned int _7;
  bool _8;
  bool _9;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->ActiveId;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  window_5 = g_3->CurrentWindow;
  _6 = g_3->ActiveId;
  _7 = window_5->DC.LastItemId;
  _8 = _6 == _7;
  goto <bb 5> (<L2>);

  <bb 4>:
  _9 = 0;

  # _1 = PHI <_8(3), _9(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::IsItemFocused() (_ZN5ImGui13IsItemFocusedEv, funcdef_no=780, decl_uid=3305, cgraph_uid=679, symbol_order=685)

bool ImGui::IsItemFocused() ()
{
  struct ImGuiContext & g;
  unsigned int D.29528;
  struct ImGuiWindow * D.29527;
  unsigned int D.29526;
  bool D.29524;
  bool D.29523;
  unsigned int D.29521;
  bool iftmp.404;
  bool D.29517;
  bool iftmp.404_1;
  unsigned int _4;
  bool _5;
  bool _6;
  unsigned int _7;
  struct ImGuiWindow * _8;
  unsigned int _9;
  bool iftmp.404_10;
  bool iftmp.404_11;
  bool _12;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->NavId;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _5 = g_3->NavDisableHighlight;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _7 = g_3->NavId;
  _8 = g_3->CurrentWindow;
  _9 = _8->DC.LastItemId;
  if (_7 == _9)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.404_10 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.404_11 = 0;

  <bb 7>:
  # iftmp.404_1 = PHI <iftmp.404_10(5), iftmp.404_11(6)>
  _12 = iftmp.404_1;

<L5>:
  return _12;

}



;; Function bool ImGui::IsItemClicked(int) (_ZN5ImGui13IsItemClickedEi, funcdef_no=781, decl_uid=3307, cgraph_uid=680, symbol_order=686)

bool ImGui::IsItemClicked(int) (int mouse_button)
{
  bool D.29540;
  bool D.29537;
  bool D.29535;
  bool iftmp.405;
  bool D.29531;
  bool iftmp.405_1;
  bool _7;
  bool _9;
  bool _10;
  bool iftmp.405_11;
  bool iftmp.405_12;
  bool _13;

  <bb 2>:
  _7 = ImGui::IsMouseClicked (mouse_button_5(D), 0);
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _9 = ImGui::IsItemHovered (0);
  _10 = _9;
  if (_10 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.405_11 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.405_12 = 0;

  <bb 6>:
  # iftmp.405_1 = PHI <iftmp.405_11(4), iftmp.405_12(5)>
  _13 = iftmp.405_1;

<L4>:
  return _13;

}



;; Function bool ImGui::IsAnyItemHovered() (_ZN5ImGui16IsAnyItemHoveredEv, funcdef_no=782, decl_uid=3309, cgraph_uid=681, symbol_order=687)

bool ImGui::IsAnyItemHovered() ()
{
  struct ImGuiContext & g;
  unsigned int D.29548;
  unsigned int D.29546;
  bool iftmp.406;
  bool D.29541;
  bool iftmp.406_1;
  unsigned int _4;
  unsigned int _5;
  bool iftmp.406_6;
  bool iftmp.406_7;
  bool _8;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->HoveredId;
  if (_4 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _5 = g_3->HoveredIdPreviousFrame;
  if (_5 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.406_7 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.406_6 = 0;

  <bb 6>:
  # iftmp.406_1 = PHI <iftmp.406_7(4), iftmp.406_6(5)>
  _8 = iftmp.406_1;

<L4>:
  return _8;

}



;; Function bool ImGui::IsAnyItemActive() (_ZN5ImGui15IsAnyItemActiveEv, funcdef_no=783, decl_uid=3310, cgraph_uid=682, symbol_order=688)

bool ImGui::IsAnyItemActive() ()
{
  struct ImGuiContext & g;
  unsigned int D.29551;
  bool D.29550;
  unsigned int _3;
  bool _4;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->ActiveId;
  _4 = _3 != 0;

<L0>:
  return _4;

}



;; Function bool ImGui::IsAnyItemFocused() (_ZN5ImGui16IsAnyItemFocusedEv, funcdef_no=784, decl_uid=3311, cgraph_uid=683, symbol_order=689)

bool ImGui::IsAnyItemFocused() ()
{
  struct ImGuiContext & g;
  bool D.29560;
  bool D.29559;
  unsigned int D.29557;
  bool iftmp.407;
  bool D.29553;
  bool iftmp.407_1;
  unsigned int _4;
  bool _5;
  bool _6;
  bool iftmp.407_7;
  bool iftmp.407_8;
  bool _9;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->NavId;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _5 = g_3->NavDisableHighlight;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.407_7 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.407_8 = 0;

  <bb 6>:
  # iftmp.407_1 = PHI <iftmp.407_7(4), iftmp.407_8(5)>
  _9 = iftmp.407_1;

<L4>:
  return _9;

}



;; Function bool ImGui::IsItemVisible() (_ZN5ImGui13IsItemVisibleEv, funcdef_no=785, decl_uid=3308, cgraph_uid=684, symbol_order=690)

bool ImGui::IsItemVisible() ()
{
  struct ImGuiWindow * window;
  struct ImRect * D.29565;
  struct ImRect * D.29564;
  bool D.29563;
  struct ImRect * _4;
  struct ImRect * _5;
  bool _7;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->DC.LastItemRect;
  _5 = &window_3->ClipRect;
  _7 = ImRect::Overlaps (_5, _4);

<L0>:
  return _7;

}



;; Function void ImGui::SetItemAllowOverlap() (_ZN5ImGui19SetItemAllowOverlapEv, funcdef_no=786, decl_uid=3315, cgraph_uid=685, symbol_order=691)

void ImGui::SetItemAllowOverlap() ()
{
  struct ImGuiContext & g;
  unsigned int D.29575;
  struct ImGuiWindow * D.29574;
  unsigned int D.29573;
  unsigned int D.29569;
  struct ImGuiWindow * D.29568;
  unsigned int D.29567;
  unsigned int _5;
  struct ImGuiWindow * _6;
  unsigned int _7;
  unsigned int _9;
  struct ImGuiWindow * _10;
  unsigned int _11;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->HoveredId;
  _6 = g_4->CurrentWindow;
  _7 = _6->DC.LastItemId;
  if (_5 == _7)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  g_4->HoveredIdAllowOverlap = 1;

  <bb 4>:
  _9 = g_4->ActiveId;
  _10 = g_4->CurrentWindow;
  _11 = _10->DC.LastItemId;
  if (_9 == _11)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  g_4->ActiveIdAllowOverlap = 1;

  <bb 6>:
  return;

}



;; Function ImVec2 ImGui::GetItemRectMin() (_ZN5ImGui14GetItemRectMinEv, funcdef_no=787, decl_uid=3312, cgraph_uid=686, symbol_order=692)

ImVec2 ImGui::GetItemRectMin() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.29579;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  D.29579 = window_3->DC.LastItemRect.Min;

<L0>:
  return D.29579;

}



;; Function ImVec2 ImGui::GetItemRectMax() (_ZN5ImGui14GetItemRectMaxEv, funcdef_no=788, decl_uid=3313, cgraph_uid=687, symbol_order=693)

ImVec2 ImGui::GetItemRectMax() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.29581;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  D.29581 = window_3->DC.LastItemRect.Max;

<L0>:
  return D.29581;

}



;; Function ImVec2 ImGui::GetItemRectSize() (_ZN5ImGui15GetItemRectSizeEv, funcdef_no=789, decl_uid=3314, cgraph_uid=688, symbol_order=694)

ImVec2 ImGui::GetItemRectSize() ()
{
  struct ImGuiWindow * window;
  struct ImRect * D.29584;
  struct ImVec2 D.29583;
  struct ImRect * _4;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->DC.LastItemRect;
  D.29583 = ImRect::GetSize (_4);

<L0>:
  return D.29583;

}



;; Function ImRect GetViewportRect() (_ZL15GetViewportRectv, funcdef_no=790, decl_uid=15070, cgraph_uid=689, symbol_order=695)

ImRect GetViewportRect() ()
{
  struct ImGuiContext & g;
  float D.29598;
  float D.29597;
  struct ImRect D.17190;
  struct ImVec2 * D.29596;
  struct ImVec2 * D.29595;
  struct ImRect D.17189;
  struct ImRect D.29594;
  float D.29591;
  float D.29590;
  float D.29587;
  float D.29586;
  float _4;
  float _5;
  float _6;
  float _7;
  struct ImVec2 * _8;
  struct ImVec2 * _9;
  float _13;
  float _14;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->IO.DisplayVisibleMin.x;
  _5 = g_3->IO.DisplayVisibleMax.x;
  if (_4 != _5)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _6 = g_3->IO.DisplayVisibleMin.y;
  _7 = g_3->IO.DisplayVisibleMax.y;
  if (_6 != _7)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _8 = &g_3->IO.DisplayVisibleMax;
  _9 = &g_3->IO.DisplayVisibleMin;
  ImRect::ImRect (&D.17189, _9, _8);
  D.29594 = D.17189;
  D.17189 ={v} {CLOBBER};
  goto <bb 6> (<L6>);

  <bb 5>:
  _13 = g_3->IO.DisplaySize.y;
  _14 = g_3->IO.DisplaySize.x;
  ImRect::ImRect (&D.17190, 0.0, 0.0, _14, _13);
  D.29594 = D.17190;
  D.17190 ={v} {CLOBBER};

<L6>:
  return D.29594;

}



;; Function void ImGui::BeginTooltipEx(ImGuiWindowFlags, bool) (_ZN5ImGui14BeginTooltipExEib, funcdef_no=791, decl_uid=13825, cgraph_uid=690, symbol_order=696)

void ImGui::BeginTooltipEx(ImGuiWindowFlags, bool) (ImGuiWindowFlags extra_flags, bool override_previous_tooltip)
{
  struct ImGuiWindow * D.29617;
  struct ImGuiWindow * window;
  ImGuiWindowFlags flags;
  char window_name[16];
  struct ImGuiContext & g;
  int D.29616;
  int D.29612;
  int D.29611;
  int D.29610;
  bool D.29607;
  int D.29602;
  int _6;
  struct ImGuiWindow * _10;
  bool _12;
  int _14;
  int _15;
  int _17;
  int _21;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->TooltipOverrideCount;
  ImFormatString (&window_name, 16, "##Tooltip_%02d", _6);
  if (override_previous_tooltip_8(D) != 0)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _10 = ImGui::FindWindowByName (&window_name);
  window_11 = _10;
  if (window_11 != 0B)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _12 = window_11->Active;
  if (_12 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  window_11->HiddenFrames = 1;
  _14 = g_5->TooltipOverrideCount;
  _15 = _14 + 1;
  g_5->TooltipOverrideCount = _15;
  _17 = g_5->TooltipOverrideCount;
  ImFormatString (&window_name, 16, "##Tooltip_%02d", _17);

  <bb 6>:

  <bb 7>:
  flags_19 = 34341703;
  _21 = flags_19 | extra_flags_20(D);
  ImGui::Begin (&window_name, 0B, _21);
  window_name ={v} {CLOBBER};
  return;

}



;; Function void ImGui::SetTooltipV(const char*, __va_list_tag*) (_ZN5ImGui11SetTooltipVEPKcP13__va_list_tag, funcdef_no=792, decl_uid=3206, cgraph_uid=691, symbol_order=697)

void ImGui::SetTooltipV(const char*, __va_list_tag*) (const char * fmt, struct  * args)
{
  <bb 2>:
  ImGui::BeginTooltipEx (0, 1);
  ImGui::TextV (fmt_3(D), args_4(D));
  ImGui::EndTooltip ();
  return;

}



;; Function void ImGui::SetTooltip(const char*, ...) (_ZN5ImGui10SetTooltipEPKcz, funcdef_no=793, decl_uid=3203, cgraph_uid=692, symbol_order=698)

void ImGui::SetTooltip(const char*, ...) (const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::SetTooltipV (fmt_3(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function void ImGui::BeginTooltip() (_ZN5ImGui12BeginTooltipEv, funcdef_no=794, decl_uid=3207, cgraph_uid=693, symbol_order=699)

void ImGui::BeginTooltip() ()
{
  <bb 2>:
  ImGui::BeginTooltipEx (0, 0);
  return;

}



;; Function void ImGui::EndTooltip() (_ZN5ImGui10EndTooltipEv, funcdef_no=795, decl_uid=3208, cgraph_uid=694, symbol_order=700)

void ImGui::EndTooltip() ()
{
  static const char __PRETTY_FUNCTION__[25] = "void ImGui::EndTooltip()";
  int D.29622;
  int D.29621;
  struct ImGuiWindow * D.29620;
  struct ImGuiWindow * _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = ImGui::GetCurrentWindowRead ();
  _4 = _3->Flags;
  _5 = _4 & 33554432;
  if (_5 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4831, &__PRETTY_FUNCTION__);

  <bb 4>:
  ImGui::End ();
  return;

}



;; Function ImGuiPopupRef::ImGuiPopupRef() (_ZN13ImGuiPopupRefC2Ev, funcdef_no=798, decl_uid=17223, cgraph_uid=696, symbol_order=702)

ImGuiPopupRef::ImGuiPopupRef() (struct ImGuiPopupRef * const this)
{
  struct ImVec2 * D.29669;
  struct ImVec2 * D.29668;
  struct ImVec2 * _2;
  struct ImVec2 * _5;

  <bb 2>:
  _2 = &this_1(D)->OpenPopupPos;
  ImVec2::ImVec2 (_2);
  _5 = &this_1(D)->OpenMousePos;
  ImVec2::ImVec2 (_5);
  return;

}



;; Function void ImGui::OpenPopupEx(ImGuiID) (_ZN5ImGui11OpenPopupExEj, funcdef_no=796, decl_uid=13813, cgraph_uid=698, symbol_order=704)

void ImGui::OpenPopupEx(ImGuiID) (ImGuiID id)
{
  struct ImGuiPopupRef popup_ref;
  int current_stack_size;
  struct ImGuiWindow * parent_window;
  struct ImGuiContext & g;
  struct value_type & D.29666;
  struct ImVector * D.29665;
  int D.29663;
  struct value_type & D.29662;
  struct ImVector * D.29661;
  int D.29657;
  int D.29656;
  int D.29655;
  struct value_type & D.29654;
  struct ImVector * D.29653;
  unsigned int D.29651;
  struct value_type & D.29650;
  struct ImVector * D.29649;
  bool iftmp.409;
  bool retval.408;
  struct ImVector * D.29644;
  int D.29643;
  struct ImVector * D.29641;
  int D.29638;
  int D.29637;
  bool D.29635;
  bool D.29633;
  bool D.29632;
  unsigned int D.29629;
  value_type & D.29628;
  struct ImVector * D.29627;
  int D.29626;
  bool iftmp.409_1;
  int _16;
  struct ImVector * _18;
  value_type & _20;
  unsigned int _21;
  bool _24;
  bool _25;
  bool _26;
  int _29;
  int _30;
  struct ImVector * _31;
  int _33;
  struct ImVector * _34;
  struct ImVector * _36;
  struct value_type & _38;
  unsigned int _39;
  struct ImVector * _40;
  struct value_type & _42;
  int _43;
  int _44;
  int _45;
  bool iftmp.409_46;
  bool iftmp.409_47;
  bool retval.408_48;
  struct ImVector * _49;
  struct value_type & _51;
  int _52;
  struct ImVector * _54;
  struct value_type & _56;

  <bb 2>:
  g_8 = GImGui;
  parent_window_9 = g_8->CurrentWindow;
  current_stack_size_10 = g_8->CurrentPopupStack.Size;
  ImGuiPopupRef::ImGuiPopupRef (&popup_ref);
  popup_ref.PopupId = id_12(D);
  popup_ref.Window = 0B;
  popup_ref.ParentWindow = parent_window_9;
  _16 = g_8->FrameCount;
  popup_ref.OpenFrameCount = _16;
  _18 = &parent_window_9->IDStack;
  _20 = ImVector<unsigned int>::back (_18);
  _21 = *_20;
  popup_ref.OpenParentId = _21;
  popup_ref.OpenMousePos = g_8->IO.MousePos;
  _24 = g_8->NavDisableHighlight;
  _25 = ~_24;
  if (_25 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _26 = g_8->NavDisableMouseHover;
  if (_26 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  popup_ref.OpenPopupPos = NavCalcPreferredMousePos ();
  goto <bb 6>;

  <bb 5>:
  popup_ref.OpenPopupPos = g_8->IO.MousePos;

  <bb 6>:
  _29 = g_8->OpenPopupStack.Size;
  _30 = current_stack_size_10 + 1;
  if (_29 < _30)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _31 = &g_8->OpenPopupStack;
  ImVector<ImGuiPopupRef>::push_back (_31, &popup_ref);
  goto <bb 15>;

  <bb 8>:
  _33 = current_stack_size_10 + 1;
  _34 = &g_8->OpenPopupStack;
  ImVector<ImGuiPopupRef>::resize (_34, _33);
  _36 = &g_8->OpenPopupStack;
  _38 = ImVector<ImGuiPopupRef>::operator[] (_36, current_stack_size_10);
  _39 = _38->PopupId;
  if (_39 == id_12(D))
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _40 = &g_8->OpenPopupStack;
  _42 = ImVector<ImGuiPopupRef>::operator[] (_40, current_stack_size_10);
  _43 = _42->OpenFrameCount;
  _44 = g_8->FrameCount;
  _45 = _44 + -1;
  if (_43 == _45)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.409_46 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.409_47 = 0;

  <bb 12>:
  # iftmp.409_1 = PHI <iftmp.409_46(10), iftmp.409_47(11)>
  retval.408_48 = iftmp.409_1;
  if (retval.408_48 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _49 = &g_8->OpenPopupStack;
  _51 = ImVector<ImGuiPopupRef>::operator[] (_49, current_stack_size_10);
  _52 = popup_ref.OpenFrameCount;
  _51->OpenFrameCount = _52;
  goto <bb 15>;

  <bb 14>:
  _54 = &g_8->OpenPopupStack;
  _56 = ImVector<ImGuiPopupRef>::operator[] (_54, current_stack_size_10);
  *_56 = popup_ref;

  <bb 15>:
  popup_ref ={v} {CLOBBER};
  return;

}



;; Function void ImGui::OpenPopup(const char*) (_ZN5ImGui9OpenPopupEPKc, funcdef_no=800, decl_uid=3228, cgraph_uid=699, symbol_order=705)

void ImGui::OpenPopup(const char*) (const char * str_id)
{
  unsigned int D.29687;
  struct ImGuiContext & g;
  unsigned int D.29686;
  struct ImGuiWindow * D.29685;
  struct ImGuiWindow * _3;
  unsigned int _6;
  unsigned int _7;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->CurrentWindow;
  _6 = ImGuiWindow::GetID (_3, str_id_4(D), 0B);
  _7 = _6;
  ImGui::OpenPopupEx (_7);
  return;

}



;; Function void ImGui::ClosePopupsOverWindow(ImGuiWindow*) (_ZN5ImGui21ClosePopupsOverWindowEP11ImGuiWindow, funcdef_no=801, decl_uid=13817, cgraph_uid=700, symbol_order=706)

void ImGui::ClosePopupsOverWindow(ImGuiWindow*) (struct ImGuiWindow * ref_window)
{
  int m;
  bool has_focus;
  struct ImGuiPopupRef & popup;
  static const char __PRETTY_FUNCTION__[48] = "void ImGui::ClosePopupsOverWindow(ImGuiWindow*)";
  int n;
  struct ImGuiContext & g;
  int D.29733;
  bool D.29729;
  struct ImGuiWindow * D.29727;
  struct ImGuiWindow * D.29726;
  struct ImGuiWindow * D.29725;
  struct value_type & D.29724;
  struct ImVector * D.29723;
  struct ImGuiWindow * D.29721;
  struct value_type & D.29720;
  struct ImVector * D.29719;
  bool iftmp.411;
  int D.29713;
  int D.29709;
  int D.29708;
  struct ImGuiWindow * D.29707;
  int D.29703;
  int D.29702;
  struct ImGuiWindow * D.29701;
  struct ImGuiWindow * D.29698;
  struct ImVector * D.29697;
  int D.29695;
  struct ImVector * D.29689;
  bool retval.410;
  bool iftmp.411_5;
  struct ImVector * _16;
  bool retval.410_18;
  int _22;
  struct ImVector * _23;
  struct ImGuiWindow * _26;
  struct ImGuiWindow * _27;
  int _28;
  int _29;
  struct ImGuiWindow * _30;
  int _31;
  int _32;
  int _35;
  struct ImVector * _36;
  struct value_type & _38;
  struct ImGuiWindow * _39;
  struct ImVector * _40;
  struct value_type & _42;
  struct ImGuiWindow * _43;
  struct ImGuiWindow * _44;
  struct ImGuiWindow * _45;
  bool iftmp.411_46;
  bool iftmp.411_47;
  bool _50;
  int _53;

  <bb 2>:
  g_15 = GImGui;
  _16 = &g_15->OpenPopupStack;
  retval.410_18 = ImVector<ImGuiPopupRef>::empty (_16);
  if (retval.410_18 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 27> (<L29>);

  <bb 4>:
  n_19 = 0;
  if (ref_window_20(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 25>;

  <bb 5>:
  n_21 = 0;

  <bb 6>:
  # n_1 = PHI <n_21(5), n_52(23)>
  _22 = g_15->OpenPopupStack.Size;
  if (_22 <= n_1)
    goto <bb 24>;
  else
    goto <bb 7>;

  <bb 7>:
  _23 = &g_15->OpenPopupStack;
  popup_25 = ImVector<ImGuiPopupRef>::operator[] (_23, n_1);
  _26 = popup_25->Window;
  if (_26 == 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 23>;

  <bb 9>:
  _27 = popup_25->Window;
  _28 = _27->Flags;
  _29 = _28 & 67108864;
  if (_29 != 0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  __assert_fail ("(popup.Window->Flags & ImGuiWindowFlags_Popup) != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4900, &__PRETTY_FUNCTION__);

  <bb 11>:
  _30 = popup_25->Window;
  _31 = _30->Flags;
  _32 = _31 & 16777216;
  if (_32 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  goto <bb 23>;

  <bb 13>:
  has_focus_33 = 0;
  m_34 = n_1;

  <bb 14>:
  # has_focus_3 = PHI <has_focus_33(13), has_focus_48(20)>
  # m_4 = PHI <m_34(13), m_49(20)>
  _35 = g_15->OpenPopupStack.Size;
  if (_35 <= m_4)
    goto <bb 21>;
  else
    goto <bb 15>;

  <bb 15>:
  if (has_focus_3 != 0)
    goto <bb 21>;
  else
    goto <bb 16>;

  <bb 16>:
  _36 = &g_15->OpenPopupStack;
  _38 = ImVector<ImGuiPopupRef>::operator[] (_36, m_4);
  _39 = _38->Window;
  if (_39 != 0B)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  _40 = &g_15->OpenPopupStack;
  _42 = ImVector<ImGuiPopupRef>::operator[] (_40, m_4);
  _43 = _42->Window;
  _44 = _43->RootWindow;
  _45 = ref_window_20(D)->RootWindow;
  if (_44 == _45)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  iftmp.411_46 = 1;
  goto <bb 20>;

  <bb 19>:
  iftmp.411_47 = 0;

  <bb 20>:
  # iftmp.411_5 = PHI <iftmp.411_46(18), iftmp.411_47(19)>
  has_focus_48 = iftmp.411_5;
  m_49 = m_4 + 1;
  goto <bb 14>;

  <bb 21>:
  _50 = ~has_focus_3;
  if (_50 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  goto <bb 24>;

  <bb 23>:
  n_52 = n_1 + 1;
  goto <bb 6>;

  <bb 24>:

  <bb 25>:
  # n_2 = PHI <n_19(4), n_1(24)>
  _53 = g_15->OpenPopupStack.Size;
  if (_53 > n_2)
    goto <bb 26>;
  else
    goto <bb 27> (<L29>);

  <bb 26>:
  ClosePopupToLevel (n_2);

<L29>:
  return;

}



;; Function ImGuiWindow* GetFrontMostModalRootWindow() (_ZL27GetFrontMostModalRootWindowv, funcdef_no=802, decl_uid=15073, cgraph_uid=701, symbol_order=707)

ImGuiWindow* GetFrontMostModalRootWindow() ()
{
  struct ImGuiWindow * popup;
  int n;
  struct ImGuiContext & g;
  struct ImGuiWindow * D.29751;
  int D.29748;
  int D.29747;
  struct ImGuiPopupRef * D.29744;
  long unsigned int D.29743;
  long unsigned int D.29742;
  struct ImGuiPopupRef * D.29741;
  int D.29738;
  struct ImGuiWindow * _2;
  int _5;
  struct ImGuiPopupRef * _7;
  long unsigned int _8;
  long unsigned int _9;
  struct ImGuiPopupRef * _10;
  int _13;
  int _14;
  struct ImGuiWindow * _15;
  struct ImGuiWindow * _16;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->OpenPopupStack.Size;
  n_6 = _5 + -1;

  <bb 3>:
  # n_1 = PHI <n_6(2), n_12(7)>
  if (n_1 < 0)
    goto <bb 8>;
  else
    goto <bb 4>;

  <bb 4>:
  _7 = g_4->OpenPopupStack.Data;
  _8 = (long unsigned int) n_1;
  _9 = _8 * 48;
  _10 = _7 + _9;
  popup_11 = _10->Window;
  if (popup_11 != 0B)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _13 = popup_11->Flags;
  _14 = _13 & 134217728;
  if (_14 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _15 = popup_11;
  goto <bb 9> (<L8>);

  <bb 7>:
  n_12 = n_1 + -1;
  goto <bb 3>;

  <bb 8>:
  _16 = 0B;

  # _2 = PHI <_15(6), _16(8)>
<L8>:
  return _2;

}



;; Function void ClosePopupToLevel(int) (_ZL17ClosePopupToLeveli, funcdef_no=803, decl_uid=15072, cgraph_uid=702, symbol_order=708)

void ClosePopupToLevel(int) (int remaining)
{
  struct ImGuiWindow * focus_window;
  struct ImGuiContext & g;
  static const char __PRETTY_FUNCTION__[28] = "void ClosePopupToLevel(int)";
  struct ImVector * D.29770;
  int D.29766;
  struct value_type & D.29765;
  struct ImVector * D.29764;
  struct value_type & D.29762;
  struct ImVector * D.29761;
  int D.29760;
  struct ImGuiWindow * iftmp.412;
  struct ImGuiWindow * iftmp.412_2;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  struct ImGuiWindow * iftmp.412_12;
  struct ImVector * _13;
  struct value_type & _15;
  struct ImGuiWindow * iftmp.412_16;
  int _18;
  struct ImVector * _23;

  <bb 2>:
  if (remaining_5(D) >= 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("remaining >= 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 4928, &__PRETTY_FUNCTION__);

  <bb 4>:
  g_7 = GImGui;
  if (remaining_5(D) > 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _8 = remaining_5(D) + -1;
  _9 = &g_7->OpenPopupStack;
  _11 = ImVector<ImGuiPopupRef>::operator[] (_9, _8);
  iftmp.412_12 = _11->Window;
  goto <bb 7>;

  <bb 6>:
  _13 = &g_7->OpenPopupStack;
  _15 = ImVector<ImGuiPopupRef>::operator[] (_13, 0);
  iftmp.412_16 = _15->ParentWindow;

  <bb 7>:
  # iftmp.412_2 = PHI <iftmp.412_12(5), iftmp.412_16(6)>
  focus_window_17 = iftmp.412_2;
  _18 = g_7->NavLayer;
  if (_18 == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  focus_window_20 = NavRestoreLastChildNavWindow (focus_window_17);

  <bb 9>:
  # focus_window_1 = PHI <focus_window_17(7), focus_window_20(8)>
  ImGui::FocusWindow (focus_window_1);
  focus_window_1->DC.NavHideHighlightOneFrame = 1;
  _23 = &g_7->OpenPopupStack;
  ImVector<ImGuiPopupRef>::resize (_23, remaining_5(D));
  return;

}



;; Function void ImGui::ClosePopup(ImGuiID) (_ZN5ImGui10ClosePopupEj, funcdef_no=804, decl_uid=13815, cgraph_uid=703, symbol_order=709)

void ImGui::ClosePopup(ImGuiID) (ImGuiID id)
{
  bool D.29778;
  struct ImGuiContext & g;
  int D.29776;
  int D.29775;
  bool D.29772;
  bool retval.413;
  bool _5;
  bool _6;
  bool retval.413_7;
  int _9;
  int _10;

  <bb 2>:
  _5 = ImGui::IsPopupOpen (id_3(D));
  _6 = _5;
  retval.413_7 = ~_6;
  if (retval.413_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 5> (<L2>);

  <bb 4>:
  g_8 = GImGui;
  _9 = g_8->OpenPopupStack.Size;
  _10 = _9 + -1;
  ClosePopupToLevel (_10);

<L2>:
  return;

}



;; Function void ImGui::CloseCurrentPopup() (_ZN5ImGui17CloseCurrentPopupEv, funcdef_no=805, decl_uid=3252, cgraph_uid=704, symbol_order=710)

void ImGui::CloseCurrentPopup() ()
{
  int popup_idx;
  struct ImGuiContext & g;
  int D.29810;
  int D.29809;
  struct ImGuiWindow * D.29808;
  struct value_type & D.29807;
  struct ImVector * D.29806;
  struct ImGuiWindow * D.29804;
  struct value_type & D.29803;
  struct ImVector * D.29802;
  bool iftmp.417;
  bool retval.416;
  unsigned int D.29793;
  struct value_type & D.29792;
  struct ImVector * D.29791;
  unsigned int D.29790;
  struct value_type & D.29789;
  struct ImVector * D.29788;
  int D.29786;
  bool iftmp.415;
  bool retval.414;
  int D.29779;
  bool iftmp.415_2;
  bool iftmp.417_3;
  int _12;
  int _14;
  struct ImVector * _15;
  struct value_type & _17;
  unsigned int _18;
  struct ImVector * _19;
  struct value_type & _21;
  unsigned int _22;
  bool iftmp.415_23;
  bool iftmp.415_24;
  bool retval.414_25;
  struct ImVector * _26;
  struct value_type & _28;
  struct ImGuiWindow * _29;
  struct ImVector * _30;
  struct value_type & _32;
  struct ImGuiWindow * _33;
  int _34;
  int _35;
  bool iftmp.417_36;
  bool iftmp.417_37;
  bool retval.416_38;

  <bb 2>:
  g_11 = GImGui;
  _12 = g_11->CurrentPopupStack.Size;
  popup_idx_13 = _12 + -1;
  if (popup_idx_13 < 0)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _14 = g_11->OpenPopupStack.Size;
  if (_14 <= popup_idx_13)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _15 = &g_11->CurrentPopupStack;
  _17 = ImVector<ImGuiPopupRef>::operator[] (_15, popup_idx_13);
  _18 = _17->PopupId;
  _19 = &g_11->OpenPopupStack;
  _21 = ImVector<ImGuiPopupRef>::operator[] (_19, popup_idx_13);
  _22 = _21->PopupId;
  if (_18 != _22)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.415_24 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.415_23 = 0;

  <bb 7>:
  # iftmp.415_2 = PHI <iftmp.415_24(5), iftmp.415_23(6)>
  retval.414_25 = iftmp.415_2;
  if (retval.414_25 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 17> (<L15>);

  <bb 9>:
  # popup_idx_1 = PHI <popup_idx_13(7), popup_idx_39(15)>
  if (popup_idx_1 > 0)
    goto <bb 10>;
  else
    goto <bb 13>;

  <bb 10>:
  _26 = &g_11->OpenPopupStack;
  _28 = ImVector<ImGuiPopupRef>::operator[] (_26, popup_idx_1);
  _29 = _28->Window;
  if (_29 != 0B)
    goto <bb 11>;
  else
    goto <bb 13>;

  <bb 11>:
  _30 = &g_11->OpenPopupStack;
  _32 = ImVector<ImGuiPopupRef>::operator[] (_30, popup_idx_1);
  _33 = _32->Window;
  _34 = _33->Flags;
  _35 = _34 & 268435456;
  if (_35 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.417_36 = 1;
  goto <bb 14>;

  <bb 13>:
  iftmp.417_37 = 0;

  <bb 14>:
  # iftmp.417_3 = PHI <iftmp.417_36(12), iftmp.417_37(13)>
  retval.416_38 = iftmp.417_3;
  if (retval.416_38 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  popup_idx_39 = popup_idx_1 + -1;
  goto <bb 9>;

  <bb 16>:
  ClosePopupToLevel (popup_idx_1);

<L15>:
  return;

}



;; Function bool ImGui::BeginPopupEx(ImGuiID, ImGuiWindowFlags) (_ZN5ImGui12BeginPopupExEji, funcdef_no=806, decl_uid=13822, cgraph_uid=705, symbol_order=711)

bool ImGui::BeginPopupEx(ImGuiID, ImGuiWindowFlags) (ImGuiID id, ImGuiWindowFlags extra_flags)
{
  bool D.29832;
  bool D.29831;
  bool is_open;
  char name[20];
  struct ImGuiContext & g;
  bool D.29826;
  int D.29825;
  int D.29823;
  int D.29820;
  bool D.29819;
  struct ImGuiNextWindowData * D.29818;
  bool D.29815;
  bool retval.418;
  bool _1;
  bool _10;
  bool _11;
  bool retval.418_12;
  struct ImGuiNextWindowData * _13;
  bool _15;
  int _17;
  int _18;
  int _21;
  bool _23;
  bool _25;
  bool _27;

  <bb 2>:
  g_7 = GImGui;
  _10 = ImGui::IsPopupOpen (id_8(D));
  _11 = _10;
  retval.418_12 = ~_11;
  if (retval.418_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = &g_7->NextWindowData;
  ImGuiNextWindowData::Clear (_13);
  _15 = 0;
  goto <bb 10>;

  <bb 4>:
  _17 = extra_flags_16(D) & 268435456;
  if (_17 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _18 = g_7->CurrentPopupStack.Size;
  ImFormatString (&name, 20, "##Menu_%02d", _18);
  goto <bb 7>;

  <bb 6>:
  ImFormatString (&name, 20, "##Popup_%08x", id_8(D));

  <bb 7>:
  _21 = extra_flags_16(D) | 67108864;
  _23 = ImGui::Begin (&name, 0B, _21);
  is_open_24 = _23;
  _25 = ~is_open_24;
  if (_25 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  ImGui::EndPopup ();

  <bb 9>:
  _27 = is_open_24;

  <bb 10>:
  # _1 = PHI <_15(3), _27(9)>
  name ={v} {CLOBBER};

<L9>:
  return _1;

}



;; Function bool ImGui::BeginPopup(const char*, ImGuiWindowFlags) (_ZN5ImGui10BeginPopupEPKci, funcdef_no=807, decl_uid=3231, cgraph_uid=706, symbol_order=712)

bool ImGui::BeginPopup(const char*, ImGuiWindowFlags) (const char * str_id, ImGuiWindowFlags flags)
{
  bool D.29852;
  unsigned int D.29851;
  struct ImGuiContext & g;
  unsigned int D.29849;
  struct ImGuiWindow * D.29848;
  int D.29847;
  bool D.29846;
  struct ImGuiNextWindowData * D.29845;
  int D.29842;
  int D.29841;
  bool _1;
  int _5;
  int _6;
  struct ImGuiNextWindowData * _7;
  bool _9;
  int _11;
  struct ImGuiWindow * _12;
  unsigned int _15;
  unsigned int _16;
  bool _18;
  bool _19;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->OpenPopupStack.Size;
  _6 = g_4->CurrentPopupStack.Size;
  if (_5 <= _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = &g_4->NextWindowData;
  ImGuiNextWindowData::Clear (_7);
  _9 = 0;
  goto <bb 5> (<L2>);

  <bb 4>:
  _11 = flags_10(D) | 321;
  _12 = g_4->CurrentWindow;
  _15 = ImGuiWindow::GetID (_12, str_id_13(D), 0B);
  _16 = _15;
  _18 = ImGui::BeginPopupEx (_16, _11);
  _19 = _18;

  # _1 = PHI <_9(3), _19(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::IsPopupOpen(ImGuiID) (_ZN5ImGui11IsPopupOpenEj, funcdef_no=808, decl_uid=13819, cgraph_uid=707, symbol_order=713)

bool ImGui::IsPopupOpen(ImGuiID) (ImGuiID id)
{
  struct ImGuiContext & g;
  unsigned int D.29863;
  struct value_type & D.29862;
  struct ImVector * D.29861;
  int D.29860;
  int D.29858;
  int D.29857;
  bool iftmp.419;
  bool D.29853;
  bool iftmp.419_1;
  int _6;
  int _7;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  unsigned int _12;
  bool iftmp.419_14;
  bool iftmp.419_15;
  bool _16;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->OpenPopupStack.Size;
  _7 = g_5->CurrentPopupStack.Size;
  if (_6 > _7)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = g_5->CurrentPopupStack.Size;
  _9 = &g_5->OpenPopupStack;
  _11 = ImVector<ImGuiPopupRef>::operator[] (_9, _8);
  _12 = _11->PopupId;
  if (_12 == id_13(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.419_14 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.419_15 = 0;

  <bb 6>:
  # iftmp.419_1 = PHI <iftmp.419_14(4), iftmp.419_15(5)>
  _16 = iftmp.419_1;

<L4>:
  return _16;

}



;; Function bool ImGui::IsPopupOpen(const char*) (_ZN5ImGui11IsPopupOpenEPKc, funcdef_no=809, decl_uid=3251, cgraph_uid=708, symbol_order=714)

bool ImGui::IsPopupOpen(const char*) (const char * str_id)
{
  unsigned int D.29881;
  struct ImGuiContext & g;
  unsigned int D.29878;
  struct ImGuiWindow * D.29877;
  unsigned int D.29876;
  struct value_type & D.29875;
  struct ImVector * D.29874;
  int D.29873;
  int D.29871;
  int D.29870;
  bool iftmp.420;
  bool D.29866;
  bool iftmp.420_1;
  int _6;
  int _7;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  unsigned int _12;
  struct ImGuiWindow * _13;
  unsigned int _16;
  unsigned int _17;
  bool iftmp.420_18;
  bool iftmp.420_19;
  bool _20;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->OpenPopupStack.Size;
  _7 = g_5->CurrentPopupStack.Size;
  if (_6 > _7)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = g_5->CurrentPopupStack.Size;
  _9 = &g_5->OpenPopupStack;
  _11 = ImVector<ImGuiPopupRef>::operator[] (_9, _8);
  _12 = _11->PopupId;
  _13 = g_5->CurrentWindow;
  _16 = ImGuiWindow::GetID (_13, str_id_14(D), 0B);
  _17 = _16;
  if (_12 == _17)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.420_18 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.420_19 = 0;

  <bb 6>:
  # iftmp.420_1 = PHI <iftmp.420_18(4), iftmp.420_19(5)>
  _20 = iftmp.420_1;

<L4>:
  return _20;

}



;; Function bool ImGui::BeginPopupModal(const char*, bool*, ImGuiWindowFlags) (_ZN5ImGui15BeginPopupModalEPKcPbi, funcdef_no=810, decl_uid=3245, cgraph_uid=709, symbol_order=715)

bool ImGui::BeginPopupModal(const char*, bool*, ImGuiWindowFlags) (const char * name, bool * p_open, ImGuiWindowFlags flags)
{
  bool D.29907;
  bool D.29906;
  const ImGuiID D.29905;
  bool is_open;
  const ImGuiID id;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.29900;
  bool D.29899;
  bool D.29896;
  int D.29893;
  struct ImVec2 * D.29891;
  struct ImVec2 D.17332;
  struct ImVec2 D.17333;
  int D.29888;
  bool D.29887;
  struct ImGuiNextWindowData * D.29886;
  bool D.29883;
  bool retval.421;
  bool _1;
  const ImGuiID _10;
  bool _13;
  bool _14;
  bool retval.421_15;
  struct ImGuiNextWindowData * _16;
  bool _18;
  int _19;
  struct ImVec2 * _21;
  int _27;
  bool _30;
  bool _32;
  bool _33;
  bool _34;
  bool _35;
  bool _38;

  <bb 2>:
  g_6 = GImGui;
  window_7 = g_6->CurrentWindow;
  _10 = ImGuiWindow::GetID (window_7, name_8(D), 0B);
  id_11 = _10;
  _13 = ImGui::IsPopupOpen (id_11);
  _14 = _13;
  retval.421_15 = ~_14;
  if (retval.421_15 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _16 = &g_6->NextWindowData;
  ImGuiNextWindowData::Clear (_16);
  _18 = 0;
  goto <bb 13> (<L12>);

  <bb 4>:
  _19 = g_6->NextWindowData.PosCond;
  if (_19 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImVec2::ImVec2 (&D.17333, 5.0e-1, 5.0e-1);
  _21 = &g_6->IO.DisplaySize;
  D.17332 = operator* (_21, 5.0e-1);
  ImGui::SetNextWindowPos (&D.17332, 8, &D.17333);
  D.17332 ={v} {CLOBBER};
  D.17333 ={v} {CLOBBER};

  <bb 6>:
  _27 = flags_26(D) | 201326880;
  _30 = ImGui::Begin (name_8(D), p_open_28(D), _27);
  is_open_31 = _30;
  _32 = ~is_open_31;
  if (_32 != 0)
    goto <bb 9>;
  else
    goto <bb 7>;

  <bb 7>:
  if (p_open_28(D) != 0B)
    goto <bb 8>;
  else
    goto <bb 12>;

  <bb 8>:
  _33 = *p_open_28(D);
  _34 = ~_33;
  if (_34 != 0)
    goto <bb 9>;
  else
    goto <bb 12>;

  <bb 9>:
  ImGui::EndPopup ();
  if (is_open_31 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  ImGui::ClosePopup (id_11);

  <bb 11>:
  _38 = 0;
  goto <bb 13> (<L12>);

  <bb 12>:
  _35 = is_open_31;

  # _1 = PHI <_18(3), _38(11), _35(12)>
<L12>:
  return _1;

}



;; Function void NavProcessMoveRequestWrapAround(ImGuiWindow*) (_ZL31NavProcessMoveRequestWrapAroundP11ImGuiWindow, funcdef_no=811, decl_uid=17336, cgraph_uid=710, symbol_order=716)

void NavProcessMoveRequestWrapAround(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  float D.29940;
  float D.29939;
  float D.29938;
  float D.29936;
  float D.29935;
  int D.29932;
  float iftmp.424;
  struct ImGuiWindow * D.29930;
  struct ImGuiWindow * D.29929;
  int D.29926;
  ImGuiNavForward D.29923;
  int D.29922;
  int D.29920;
  bool D.29914;
  struct ImGuiWindow * D.29912;
  bool iftmp.423;
  bool retval.422;
  bool iftmp.423_1;
  float iftmp.424_2;
  struct ImGuiWindow * _9;
  bool _12;
  bool iftmp.423_13;
  bool iftmp.423_14;
  bool retval.422_15;
  int _16;
  int _17;
  ImGuiNavForward _18;
  int _19;
  struct ImGuiWindow * _22;
  struct ImGuiWindow * _23;
  int _24;
  float _25;
  float _26;
  float iftmp.424_28;
  float iftmp.424_29;
  float _30;
  float _31;
  float _33;

  <bb 2>:
  g_8 = GImGui;
  _9 = g_8->NavWindow;
  if (_9 == window_10(D))
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _12 = NavMoveRequestButNoResultYet ();
  if (_12 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.423_13 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.423_14 = 0;

  <bb 6>:
  # iftmp.423_1 = PHI <iftmp.423_13(4), iftmp.423_14(5)>
  retval.422_15 = iftmp.423_1;
  if (retval.422_15 != 0)
    goto <bb 7>;
  else
    goto <bb 15>;

  <bb 7>:
  _16 = g_8->NavMoveDir;
  if (_16 == 2)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  _17 = g_8->NavMoveDir;
  if (_17 == 3)
    goto <bb 9>;
  else
    goto <bb 15>;

  <bb 9>:
  _18 = g_8->NavMoveRequestForward;
  if (_18 == 0)
    goto <bb 10>;
  else
    goto <bb 15>;

  <bb 10>:
  _19 = g_8->NavLayer;
  if (_19 == 0)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  g_8->NavMoveRequestForward = 1;
  ImGui::NavMoveRequestCancel ();
  _22 = g_8->NavWindow;
  _23 = g_8->NavWindow;
  _24 = g_8->NavMoveDir;
  if (_24 == 2)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _25 = window_10(D)->SizeContents.y;
  _26 = window_10(D)->SizeFull.y;
  iftmp.424_28 = ImMax (_26, _25);
  goto <bb 14>;

  <bb 13>:
  iftmp.424_29 = 0.0;

  <bb 14>:
  # iftmp.424_2 = PHI <iftmp.424_28(12), iftmp.424_29(13)>
  _30 = window_10(D)->Scroll.y;
  _31 = iftmp.424_2 - _30;
  _23->NavRectRel[0].Max.y = _31;
  _33 = _23->NavRectRel[0].Max.y;
  _22->NavRectRel[0].Min.y = _33;

  <bb 15>:
  return;

}



;; Function void ImGui::EndPopup() (_ZN5ImGui8EndPopupEv, funcdef_no=812, decl_uid=3246, cgraph_uid=711, symbol_order=717)

void ImGui::EndPopup() ()
{
  static const char __PRETTY_FUNCTION__[23] = "void ImGui::EndPopup()";
  struct ImGuiContext & g;
  struct ImGuiWindow * D.29953;
  int D.29949;
  int D.29945;
  int D.29944;
  struct ImGuiWindow * D.29943;
  struct ImGuiWindow * _3;
  int _4;
  int _5;
  int _6;
  struct ImGuiWindow * _7;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->CurrentWindow;
  _4 = _3->Flags;
  _5 = _4 & 67108864;
  if (_5 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.CurrentWindow->Flags & ImGuiWindowFlags_Popup", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5046, &__PRETTY_FUNCTION__);

  <bb 4>:
  _6 = g_2->CurrentPopupStack.Size;
  if (_6 > 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("g.CurrentPopupStack.Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5047, &__PRETTY_FUNCTION__);

  <bb 6>:
  _7 = g_2->CurrentWindow;
  NavProcessMoveRequestWrapAround (_7);
  ImGui::End ();
  return;

}



;; Function bool ImGui::OpenPopupOnItemClick(const char*, int) (_ZN5ImGui20OpenPopupOnItemClickEPKci, funcdef_no=813, decl_uid=3249, cgraph_uid=712, symbol_order=718)

bool ImGui::OpenPopupOnItemClick(const char*, int) (const char * str_id, int mouse_button)
{
  ImGuiID D.29975;
  bool D.29974;
  ImGuiID id;
  static const char __PRETTY_FUNCTION__[51] = "bool ImGui::OpenPopupOnItemClick(const char*, int)";
  struct ImGuiWindow * window;
  bool D.29972;
  ImGuiID iftmp.428;
  bool D.29961;
  bool D.29959;
  bool iftmp.427;
  bool retval.426;
  struct ImGuiContext * GImGui.425;
  bool iftmp.427_1;
  ImGuiID iftmp.428_2;
  bool _3;
  struct ImGuiContext * GImGui.425_9;
  bool _13;
  bool _15;
  bool _16;
  bool iftmp.427_17;
  bool iftmp.427_18;
  bool retval.426_19;
  ImGuiID _22;
  ImGuiID iftmp.428_23;
  ImGuiID iftmp.428_24;
  bool _27;
  bool _29;

  <bb 2>:
  GImGui.425_9 = GImGui;
  window_10 = GImGui.425_9->CurrentWindow;
  _13 = ImGui::IsMouseReleased (mouse_button_11(D));
  if (_13 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _15 = ImGui::IsItemHovered (8);
  _16 = _15;
  if (_16 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.427_17 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.427_18 = 0;

  <bb 6>:
  # iftmp.427_1 = PHI <iftmp.427_17(4), iftmp.427_18(5)>
  retval.426_19 = iftmp.427_1;
  if (retval.426_19 != 0)
    goto <bb 7>;
  else
    goto <bb 13>;

  <bb 7>:
  if (str_id_20(D) != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _22 = ImGuiWindow::GetID (window_10, str_id_20(D), 0B);
  iftmp.428_23 = _22;
  goto <bb 10>;

  <bb 9>:
  iftmp.428_24 = window_10->DC.LastItemId;

  <bb 10>:
  # iftmp.428_2 = PHI <iftmp.428_23(8), iftmp.428_24(9)>
  id_25 = iftmp.428_2;
  if (id_25 != 0)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  __assert_fail ("id != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5061, &__PRETTY_FUNCTION__);

  <bb 12>:
  ImGui::OpenPopupEx (id_25);
  _27 = 1;
  goto <bb 14> (<L12>);

  <bb 13>:
  _29 = 0;

  # _3 = PHI <_27(12), _29(13)>
<L12>:
  return _3;

}



;; Function bool ImGui::BeginPopupContextItem(const char*, int) (_ZN5ImGui21BeginPopupContextItemEPKci, funcdef_no=814, decl_uid=3234, cgraph_uid=713, symbol_order=719)

bool ImGui::BeginPopupContextItem(const char*, int) (const char * str_id, int mouse_button)
{
  bool D.29999;
  bool D.29998;
  ImGuiID D.29997;
  static const char __PRETTY_FUNCTION__[52] = "bool ImGui::BeginPopupContextItem(const char*, int)";
  ImGuiID id;
  struct ImGuiWindow * window;
  bool D.29995;
  bool D.29990;
  bool D.29988;
  bool iftmp.432;
  bool retval.431;
  ImGuiID iftmp.430;
  struct ImGuiContext * GImGui.429;
  ImGuiID iftmp.430_1;
  bool iftmp.432_2;
  struct ImGuiContext * GImGui.429_8;
  ImGuiID _12;
  ImGuiID iftmp.430_13;
  ImGuiID iftmp.430_14;
  bool _18;
  bool _20;
  bool _21;
  bool iftmp.432_22;
  bool iftmp.432_23;
  bool retval.431_24;
  bool _27;
  bool _28;

  <bb 2>:
  GImGui.429_8 = GImGui;
  window_9 = GImGui.429_8->CurrentWindow;
  if (str_id_10(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = ImGuiWindow::GetID (window_9, str_id_10(D), 0B);
  iftmp.430_13 = _12;
  goto <bb 5>;

  <bb 4>:
  iftmp.430_14 = window_9->DC.LastItemId;

  <bb 5>:
  # iftmp.430_1 = PHI <iftmp.430_13(3), iftmp.430_14(4)>
  id_15 = iftmp.430_1;
  if (id_15 != 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  __assert_fail ("id != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5075, &__PRETTY_FUNCTION__);

  <bb 7>:
  _18 = ImGui::IsMouseReleased (mouse_button_16(D));
  if (_18 != 0)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _20 = ImGui::IsItemHovered (8);
  _21 = _20;
  if (_21 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.432_22 = 1;
  goto <bb 11>;

  <bb 10>:
  iftmp.432_23 = 0;

  <bb 11>:
  # iftmp.432_2 = PHI <iftmp.432_22(9), iftmp.432_23(10)>
  retval.431_24 = iftmp.432_2;
  if (retval.431_24 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  ImGui::OpenPopupEx (id_15);

  <bb 13>:
  _27 = ImGui::BeginPopupEx (id_15, 321);
  _28 = _27;

<L13>:
  return _28;

}



;; Function bool ImGui::BeginPopupContextWindow(const char*, int, bool) (_ZN5ImGui23BeginPopupContextWindowEPKcib, funcdef_no=815, decl_uid=3238, cgraph_uid=714, symbol_order=720)

bool ImGui::BeginPopupContextWindow(const char*, int, bool) (const char * str_id, int mouse_button, bool also_over_items)
{
  bool D.30030;
  ImGuiID D.30029;
  ImGuiID id;
  bool D.30027;
  bool D.30022;
  bool D.30021;
  bool iftmp.437;
  bool retval.436;
  bool D.30011;
  bool D.30009;
  bool iftmp.435;
  bool retval.434;
  struct ImGuiWindow * D.30004;
  struct ImGuiContext * GImGui.433;
  bool iftmp.435_2;
  bool iftmp.437_3;
  struct ImGuiContext * GImGui.433_12;
  struct ImGuiWindow * _13;
  ImGuiID _15;
  bool _19;
  bool _21;
  bool iftmp.435_22;
  bool iftmp.435_23;
  bool retval.434_24;
  bool _27;
  bool _28;
  bool iftmp.437_29;
  bool iftmp.437_30;
  bool retval.436_31;
  bool _34;
  bool _35;

  <bb 2>:
  if (str_id_9(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  str_id_10 = "window_context";

  <bb 4>:
  # str_id_1 = PHI <str_id_9(D)(2), str_id_10(3)>
  GImGui.433_12 = GImGui;
  _13 = GImGui.433_12->CurrentWindow;
  _15 = ImGuiWindow::GetID (_13, str_id_1, 0B);
  id_16 = _15;
  _19 = ImGui::IsMouseReleased (mouse_button_17(D));
  if (_19 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _21 = ImGui::IsWindowHovered (8);
  if (_21 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.435_22 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.435_23 = 0;

  <bb 8>:
  # iftmp.435_2 = PHI <iftmp.435_22(6), iftmp.435_23(7)>
  retval.434_24 = iftmp.435_2;
  if (retval.434_24 != 0)
    goto <bb 9>;
  else
    goto <bb 15>;

  <bb 9>:
  if (also_over_items_25(D) != 0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  _27 = ImGui::IsAnyItemHovered ();
  _28 = ~_27;
  if (_28 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.437_30 = 1;
  goto <bb 13>;

  <bb 12>:
  iftmp.437_29 = 0;

  <bb 13>:
  # iftmp.437_3 = PHI <iftmp.437_30(11), iftmp.437_29(12)>
  retval.436_31 = iftmp.437_3;
  if (retval.436_31 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  ImGui::OpenPopupEx (id_16);

  <bb 15>:
  _34 = ImGui::BeginPopupEx (id_16, 321);
  _35 = _34;

<L17>:
  return _35;

}



;; Function bool ImGui::BeginPopupContextVoid(const char*, int) (_ZN5ImGui21BeginPopupContextVoidEPKci, funcdef_no=816, decl_uid=3241, cgraph_uid=715, symbol_order=721)

bool ImGui::BeginPopupContextVoid(const char*, int) (const char * str_id, int mouse_button)
{
  bool D.30051;
  ImGuiID D.30050;
  ImGuiID id;
  bool D.30048;
  bool D.30043;
  bool D.30042;
  bool D.30040;
  bool iftmp.440;
  bool retval.439;
  struct ImGuiWindow * D.30035;
  struct ImGuiContext * GImGui.438;
  bool iftmp.440_2;
  struct ImGuiContext * GImGui.438_9;
  struct ImGuiWindow * _10;
  ImGuiID _12;
  bool _16;
  bool _18;
  bool _19;
  bool iftmp.440_20;
  bool iftmp.440_21;
  bool retval.439_22;
  bool _25;
  bool _26;

  <bb 2>:
  if (str_id_6(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  str_id_7 = "void_context";

  <bb 4>:
  # str_id_1 = PHI <str_id_6(D)(2), str_id_7(3)>
  GImGui.438_9 = GImGui;
  _10 = GImGui.438_9->CurrentWindow;
  _12 = ImGuiWindow::GetID (_10, str_id_1, 0B);
  id_13 = _12;
  _16 = ImGui::IsMouseReleased (mouse_button_14(D));
  if (_16 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _18 = ImGui::IsWindowHovered (4);
  _19 = ~_18;
  if (_19 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.440_20 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.440_21 = 0;

  <bb 8>:
  # iftmp.440_2 = PHI <iftmp.440_20(6), iftmp.440_21(7)>
  retval.439_22 = iftmp.440_2;
  if (retval.439_22 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  ImGui::OpenPopupEx (id_13);

  <bb 10>:
  _25 = ImGui::BeginPopupEx (id_13, 321);
  _26 = _25;

<L10>:
  return _26;

}



;; Function bool BeginChildEx(const char*, ImGuiID, const ImVec2&, bool, ImGuiWindowFlags) (_ZL12BeginChildExPKcjRK6ImVec2bi, funcdef_no=817, decl_uid=17373, cgraph_uid=716, symbol_order=722)

bool BeginChildEx(const char*, ImGuiID, const ImVec2&, bool, ImGuiWindowFlags) (const char * name, ImGuiID id, const struct ImVec2 & size_arg, bool border, ImGuiWindowFlags extra_flags)
{
  bool D.30104;
  struct ImGuiWindow * child_window;
  bool ret;
  char title[256];
  const float backup_border_size;
  const int auto_fit_axises;
  struct ImVec2 size;
  const struct ImVec2 content_avail;
  ImGuiWindowFlags flags;
  struct ImGuiWindow * parent_window;
  struct ImGuiContext & g;
  bool D.30102;
  unsigned int D.30100;
  unsigned int D.30097;
  bool D.30096;
  int D.30094;
  int D.30091;
  char * D.30088;
  char * D.30086;
  bool D.30080;
  float D.30078;
  float D.30077;
  float D.30076;
  float D.30075;
  float D.30072;
  float D.30070;
  float D.30069;
  float D.30068;
  float D.30067;
  float D.30064;
  float D.30060;
  int iftmp.442;
  float D.30055;
  int iftmp.441;
  int D.30053;
  int D.30052;
  int iftmp.441_1;
  int iftmp.442_2;
  int _14;
  int _15;
  float _20;
  int iftmp.441_21;
  int iftmp.441_22;
  float _23;
  int iftmp.442_24;
  int iftmp.442_25;
  float _27;
  float _28;
  float _29;
  float _30;
  float _32;
  float _34;
  float _35;
  float _36;
  float _37;
  float _39;
  bool _43;
  char * _48;
  char * _50;
  bool _55;
  int _62;
  int _63;
  bool _64;
  unsigned int _65;
  unsigned int _68;
  bool _71;

  <bb 2>:
  g_10 = GImGui;
  parent_window_12 = ImGui::GetCurrentWindow ();
  flags_13 = 16777475;
  _14 = parent_window_12->Flags;
  _15 = _14 & 4;
  flags_16 = _15 | flags_13;
  content_avail = ImGui::GetContentRegionAvail ();
  size = ImFloor (size_arg_18(D));
  _20 = size.x;
  if (_20 == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.441_21 = 1;
  goto <bb 5>;

  <bb 4>:
  iftmp.441_22 = 0;

  <bb 5>:
  # iftmp.441_1 = PHI <iftmp.441_21(3), iftmp.441_22(4)>
  _23 = size.y;
  if (_23 == 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.442_24 = 2;
  goto <bb 8>;

  <bb 7>:
  iftmp.442_25 = 0;

  <bb 8>:
  # iftmp.442_2 = PHI <iftmp.442_24(6), iftmp.442_25(7)>
  auto_fit_axises_26 = iftmp.441_1 | iftmp.442_2;
  _27 = size.x;
  if (_27 <= 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _28 = content_avail.x;
  _29 = size.x;
  _30 = _28 + _29;
  _32 = ImMax (_30, 4.0e+0);
  size.x = _32;

  <bb 10>:
  _34 = size.y;
  if (_34 <= 0.0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _35 = content_avail.y;
  _36 = size.y;
  _37 = _35 + _36;
  _39 = ImMax (_37, 4.0e+0);
  size.y = _39;

  <bb 12>:
  backup_border_size_41 = g_10->Style.ChildBorderSize;
  _43 = ~border_42(D);
  if (_43 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  g_10->Style.ChildBorderSize = 0.0;

  <bb 14>:
  flags_46 = flags_16 | extra_flags_45(D);
  if (name_47(D) != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _48 = parent_window_12->Name;
  ImFormatString (&title, 256, "%s/%s", _48, name_47(D));
  goto <bb 17>;

  <bb 16>:
  _50 = parent_window_12->Name;
  ImFormatString (&title, 256, "%s/%08X", _50, id_51(D));

  <bb 17>:
  ImGui::SetNextWindowSize (&size, 0);
  _55 = ImGui::Begin (&title, 0B, flags_46);
  ret_56 = _55;
  child_window_58 = ImGui::GetCurrentWindow ();
  child_window_58->ChildId = id_51(D);
  child_window_58->AutoFitChildAxises = auto_fit_axises_26;
  g_10->Style.ChildBorderSize = backup_border_size_41;
  _62 = flags_46 & 8388608;
  if (_62 == 0)
    goto <bb 18>;
  else
    goto <bb 22>;

  <bb 18>:
  _63 = child_window_58->DC.NavLayerActiveMask;
  if (_63 != 0)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  _64 = child_window_58->DC.NavHasScroll;
  if (_64 != 0)
    goto <bb 20>;
  else
    goto <bb 22>;

  <bb 20>:
  _65 = g_10->NavActivateId;
  if (_65 == id_51(D))
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  ImGui::FocusWindow (child_window_58);
  ImGui::NavInitWindow (child_window_58, 0);
  _68 = id_51(D) + 1;
  ImGui::SetActiveID (_68, child_window_58);
  g_10->ActiveIdSource = 2;

  <bb 22>:
  _71 = ret_56;
  content_avail ={v} {CLOBBER};
  size ={v} {CLOBBER};
  title ={v} {CLOBBER};

<L27>:
  return _71;

}



;; Function bool ImGui::BeginChild(const char*, const ImVec2&, bool, ImGuiWindowFlags) (_ZN5ImGui10BeginChildEPKcRK6ImVec2bi, funcdef_no=818, decl_uid=2488, cgraph_uid=717, symbol_order=723)

bool ImGui::BeginChild(const char*, const ImVec2&, bool, ImGuiWindowFlags) (const char * str_id, const struct ImVec2 & size_arg, bool border, ImGuiWindowFlags extra_flags)
{
  bool D.30112;
  unsigned int D.30111;
  struct ImGuiWindow * window;
  unsigned int D.30109;
  int D.30108;
  bool D.30107;
  int _5;
  unsigned int _8;
  unsigned int _9;
  bool _13;
  bool _14;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _5 = (int) border_4(D);
  _8 = ImGuiWindow::GetID (window_3, str_id_6(D), 0B);
  _9 = _8;
  _13 = BeginChildEx (str_id_6(D), _9, size_arg_10(D), _5, extra_flags_11(D));
  _14 = _13;

<L0>:
  return _14;

}



;; Function bool ImGui::BeginChild(ImGuiID, const ImVec2&, bool, ImGuiWindowFlags) (_ZN5ImGui10BeginChildEjRK6ImVec2bi, funcdef_no=819, decl_uid=2494, cgraph_uid=718, symbol_order=724)

bool ImGui::BeginChild(ImGuiID, const ImVec2&, bool, ImGuiWindowFlags) (ImGuiID id, const struct ImVec2 & size_arg, bool border, ImGuiWindowFlags extra_flags)
{
  bool D.30119;
  static const char __PRETTY_FUNCTION__[71] = "bool ImGui::BeginChild(ImGuiID, const ImVec2&, bool, ImGuiWindowFlags)";
  int D.30117;
  bool D.30116;
  int _3;
  bool _8;
  bool _9;

  <bb 2>:
  if (id_1(D) != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("id != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5155, &__PRETTY_FUNCTION__);

  <bb 4>:
  _3 = (int) border_2(D);
  _8 = BeginChildEx (0B, id_1(D), size_arg_5(D), _3, extra_flags_6(D));
  _9 = _8;

<L3>:
  return _9;

}



;; Function void ImGui::EndChild() (_ZN5ImGui8EndChildEv, funcdef_no=820, decl_uid=2495, cgraph_uid=719, symbol_order=725)

void ImGui::EndChild() ()
{
  struct ImRect bb;
  struct ImGuiWindow * parent_window;
  struct ImVec2 sz;
  static const char __PRETTY_FUNCTION__[23] = "void ImGui::EndChild()";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImVec2 D.17411;
  struct ImVec2 D.17412;
  struct ImVec2 D.17413;
  struct ImVec2 D.17414;
  struct ImRect D.17415;
  unsigned int D.30162;
  struct ImGuiWindow * D.30159;
  int D.30156;
  unsigned int D.30155;
  unsigned int D.30154;
  int D.30152;
  int D.30151;
  bool D.30150;
  int D.30148;
  struct ImVec2 * D.30144;
  struct ImVec2 * D.30143;
  struct ImVec2 D.17410;
  float D.30141;
  float D.30140;
  int D.30137;
  int D.30136;
  float D.30134;
  float D.30133;
  int D.30130;
  int D.30129;
  int D.30125;
  int D.30121;
  int D.30120;
  int _10;
  int _11;
  int _12;
  int _15;
  int _16;
  float _17;
  float _19;
  int _21;
  int _22;
  float _23;
  float _25;
  struct ImVec2 * _29;
  struct ImVec2 * _31;
  int _35;
  bool _36;
  int _37;
  int _38;
  unsigned int _39;
  unsigned int _41;
  int _43;
  struct ImGuiWindow * _44;
  unsigned int _45;

  <bb 2>:
  g_8 = GImGui;
  window_9 = g_8->CurrentWindow;
  _10 = window_9->Flags;
  _11 = _10 & 16777216;
  if (_11 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("window->Flags & ImGuiWindowFlags_ChildWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5164, &__PRETTY_FUNCTION__);

  <bb 4>:
  _12 = window_9->BeginCount;
  if (_12 > 1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::End ();
  goto <bb 19>;

  <bb 6>:
  sz = ImGui::GetWindowSize ();
  _15 = window_9->AutoFitChildAxises;
  _16 = _15 & 1;
  if (_16 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _17 = sz.x;
  _19 = ImMax (4.0e+0, _17);
  sz.x = _19;

  <bb 8>:
  _21 = window_9->AutoFitChildAxises;
  _22 = _21 & 2;
  if (_22 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _23 = sz.y;
  _25 = ImMax (4.0e+0, _23);
  sz.y = _25;

  <bb 10>:
  ImGui::End ();
  parent_window_28 = g_8->CurrentWindow;
  _29 = &parent_window_28->DC.CursorPos;
  D.17410 = operator+ (_29, &sz);
  _31 = &parent_window_28->DC.CursorPos;
  ImRect::ImRect (&bb, _31, &D.17410);
  D.17410 ={v} {CLOBBER};
  ImGui::ItemSize (&sz, 0.0);
  _35 = window_9->DC.NavLayerActiveMask;
  if (_35 != 0)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  _36 = window_9->DC.NavHasScroll;
  if (_36 != 0)
    goto <bb 12>;
  else
    goto <bb 17>;

  <bb 12>:
  _37 = window_9->Flags;
  _38 = _37 & 8388608;
  if (_38 == 0)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:
  _39 = window_9->ChildId;
  ImGui::ItemAdd (&bb, _39, 0B);
  _41 = window_9->ChildId;
  ImGui::RenderNavHighlight (&bb, _41, 1);
  _43 = window_9->DC.NavLayerActiveMask;
  if (_43 == 0)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  _44 = g_8->NavWindow;
  if (_44 == window_9)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _45 = g_8->NavId;
  ImVec2::ImVec2 (&D.17413, 2.0e+0, 2.0e+0);
  D.17414 = operator+ (&bb.Max, &D.17413);
  ImVec2::ImVec2 (&D.17411, 2.0e+0, 2.0e+0);
  D.17412 = operator- (&bb.Min, &D.17411);
  ImRect::ImRect (&D.17415, &D.17412, &D.17414);
  ImGui::RenderNavHighlight (&D.17415, _45, 2);
  D.17415 ={v} {CLOBBER};
  D.17412 ={v} {CLOBBER};
  D.17411 ={v} {CLOBBER};
  D.17414 ={v} {CLOBBER};
  D.17413 ={v} {CLOBBER};

  <bb 16>:
  goto <bb 18>;

  <bb 17>:
  ImGui::ItemAdd (&bb, 0, 0B);

  <bb 18>:
  sz ={v} {CLOBBER};
  bb ={v} {CLOBBER};

  <bb 19>:
  return;

}



;; Function bool ImGui::BeginChildFrame(ImGuiID, const ImVec2&, ImGuiWindowFlags) (_ZN5ImGui15BeginChildFrameEjRK6ImVec2i, funcdef_no=821, decl_uid=3343, cgraph_uid=720, symbol_order=726)

bool ImGui::BeginChildFrame(ImGuiID, const ImVec2&, ImGuiWindowFlags) (ImGuiID id, const struct ImVec2 & size, ImGuiWindowFlags extra_flags)
{
  bool D.30177;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  int D.30175;
  bool D.30174;
  const struct ImVec2 * D.30173;
  float D.30172;
  float D.30171;
  const struct ImVec4 * D.30170;
  const struct ImVec4 * _4;
  float _6;
  float _8;
  const struct ImVec2 * _10;
  int _13;
  bool _17;
  bool _18;

  <bb 2>:
  g_2 = GImGui;
  style_3 = &g_2->Style;
  _4 = &style_3->Colors[7];
  ImGui::PushStyleColor (3, _4);
  _6 = style_3->FrameRounding;
  ImGui::PushStyleVar (6, _6);
  _8 = style_3->FrameBorderSize;
  ImGui::PushStyleVar (7, _8);
  _10 = &style_3->FramePadding;
  ImGui::PushStyleVar (1, _10);
  _13 = extra_flags_12(D) | 65540;
  _17 = ImGui::BeginChild (id_14(D), size_15(D), 1, _13);
  _18 = _17;

<L0>:
  return _18;

}



;; Function void ImGui::EndChildFrame() (_ZN5ImGui13EndChildFrameEv, funcdef_no=822, decl_uid=3344, cgraph_uid=721, symbol_order=727)

void ImGui::EndChildFrame() ()
{
  <bb 2>:
  ImGui::EndChild ();
  ImGui::PopStyleVar (3);
  ImGui::PopStyleColor (1);
  return;

}



;; Function void CheckStacksSize(ImGuiWindow*, bool) (_ZL15CheckStacksSizeP11ImGuiWindowb, funcdef_no=823, decl_uid=15046, cgraph_uid=722, symbol_order=728)

void CheckStacksSize(ImGuiWindow*, bool) (struct ImGuiWindow * window, bool write)
{
  int current;
  int current;
  int current;
  int current;
  int current;
  int current;
  static const char __PRETTY_FUNCTION__[41] = "void CheckStacksSize(ImGuiWindow*, bool)";
  int * p_backup;
  struct ImGuiContext & g;
  int * D.30221;
  int[6] * D.30220;
  int D.30216;
  int D.30209;
  int D.30202;
  int D.30195;
  int D.30188;
  int D.30181;
  int _14;
  int _19;
  int _24;
  int _29;
  int _34;
  int _39;
  int[6] * _42;
  int * _43;

  <bb 2>:
  g_8 = GImGui;
  p_backup_10 = &window_9(D)->DC.StackSizesBackup[0];
  current_11 = window_9(D)->IDStack.Size;
  if (write_12(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  *p_backup_10 = current_11;
  goto <bb 6>;

  <bb 4>:
  _14 = *p_backup_10;
  if (_14 == current_11)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("*p_backup == current && \"PushID/PopID or TreeNode/TreePop Mismatch!\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5224, &__PRETTY_FUNCTION__);

  <bb 6>:
  p_backup_16 = p_backup_10 + 4;
  current_17 = window_9(D)->DC.GroupStack.Size;
  if (write_12(D) != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  *p_backup_16 = current_17;
  goto <bb 10>;

  <bb 8>:
  _19 = *p_backup_16;
  if (_19 == current_17)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  __assert_fail ("*p_backup == current && \"BeginGroup/EndGroup Mismatch!\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5225, &__PRETTY_FUNCTION__);

  <bb 10>:
  p_backup_21 = p_backup_16 + 4;
  current_22 = g_8->CurrentPopupStack.Size;
  if (write_12(D) != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  *p_backup_21 = current_22;
  goto <bb 14>;

  <bb 12>:
  _24 = *p_backup_21;
  if (_24 == current_22)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  __assert_fail ("*p_backup == current && \"BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5226, &__PRETTY_FUNCTION__);

  <bb 14>:
  p_backup_26 = p_backup_21 + 4;
  current_27 = g_8->ColorModifiers.Size;
  if (write_12(D) != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  *p_backup_26 = current_27;
  goto <bb 18>;

  <bb 16>:
  _29 = *p_backup_26;
  if (_29 == current_27)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  __assert_fail ("*p_backup == current && \"PushStyleColor/PopStyleColor Mismatch!\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5227, &__PRETTY_FUNCTION__);

  <bb 18>:
  p_backup_31 = p_backup_26 + 4;
  current_32 = g_8->StyleModifiers.Size;
  if (write_12(D) != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  *p_backup_31 = current_32;
  goto <bb 22>;

  <bb 20>:
  _34 = *p_backup_31;
  if (_34 == current_32)
    goto <bb 22>;
  else
    goto <bb 21>;

  <bb 21>:
  __assert_fail ("*p_backup == current && \"PushStyleVar/PopStyleVar Mismatch!\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5228, &__PRETTY_FUNCTION__);

  <bb 22>:
  p_backup_36 = p_backup_31 + 4;
  current_37 = g_8->FontStack.Size;
  if (write_12(D) != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  *p_backup_36 = current_37;
  goto <bb 26>;

  <bb 24>:
  _39 = *p_backup_36;
  if (_39 == current_37)
    goto <bb 26>;
  else
    goto <bb 25>;

  <bb 25>:
  __assert_fail ("*p_backup == current && \"PushFont/PopFont Mismatch!\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5229, &__PRETTY_FUNCTION__);

  <bb 26>:
  p_backup_41 = p_backup_36 + 4;
  _42 = &window_9(D)->DC.StackSizesBackup;
  _43 = _42 + 24;
  if (_43 == p_backup_41)
    goto <bb 28>;
  else
    goto <bb 27>;

  <bb 27>:
  __assert_fail ("p_backup == window->DC.StackSizesBackup + ((int)(sizeof(window->DC.StackSizesBackup)/sizeof(*window->DC.StackSizesBackup)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5230, &__PRETTY_FUNCTION__);

  <bb 28>:
  return;

}



;; Function ImVec2 FindBestWindowPosForPopup(const ImVec2&, const ImVec2&, ImGuiDir*, const ImRect&, ImGuiPopupPositionPolicy) (_ZL25FindBestWindowPosForPopupRK6ImVec2S1_PiRK6ImRect24ImGuiPopupPositionPolicy, funcdef_no=824, decl_uid=17446, cgraph_uid=723, symbol_order=729)

ImVec2 FindBestWindowPosForPopup(const ImVec2&, const ImVec2&, ImGuiDir*, const ImRect&, ImGuiPopupPositionPolicy) (const struct ImVec2 & ref_pos, const struct ImVec2 & size, ImGuiDir * last_dir, const struct ImRect & r_avoid, ImGuiPopupPositionPolicy policy)
{
  struct ImVec2 pos;
  float avail_h;
  float avail_w;
  const ImGuiDir dir;
  int n;
  struct ImVec2 pos;
  const ImGuiDir dir;
  int n;
  const ImGuiDir dir_prefered_order[4];
  struct ImVec2 pos;
  const ImGuiDir dir_prefered_order[4];
  struct ImVec2 base_pos_clamped;
  struct ImRect r_outer;
  struct ImVec2 safe_padding;
  const struct ImGuiStyle & style;
  float D.30373;
  float D.30372;
  float D.30371;
  float D.30370;
  float D.30369;
  float D.30368;
  float D.30367;
  float D.30366;
  float D.30365;
  float D.30364;
  float D.30363;
  float D.30362;
  float D.30361;
  float D.30360;
  float D.30359;
  float D.30358;
  float D.30357;
  float D.30356;
  const float iftmp.462;
  float D.30350;
  float D.30349;
  float iftmp.461;
  const float iftmp.460;
  float D.30340;
  float D.30339;
  float iftmp.459;
  float D.30335;
  float D.30333;
  const float iftmp.458;
  const float iftmp.457;
  const float iftmp.456;
  const float iftmp.455;
  int D.30312;
  ImGuiDir iftmp.454;
  int D.30300;
  int iftmp.453;
  struct ImVec2 D.30297;
  bool D.30294;
  struct ImVec2 D.17465;
  struct ImRect D.17466;
  bool retval.452;
  float D.30291;
  float D.30290;
  float D.30289;
  float D.30288;
  float D.30287;
  float D.30286;
  struct ImVec2 pos.451;
  float D.30282;
  float D.30281;
  float D.30280;
  float D.30279;
  struct ImVec2 pos.450;
  float D.30275;
  float D.30274;
  float D.30273;
  float D.30272;
  struct ImVec2 pos.449;
  float D.30268;
  float D.30267;
  struct ImVec2 pos.448;
  int D.30262;
  ImGuiDir iftmp.447;
  int D.30250;
  int iftmp.446;
  struct ImVec2 D.30246;
  float D.30244;
  float D.30241;
  float D.30240;
  float D.30239;
  float D.30238;
  float D.30237;
  float iftmp.445;
  float D.30234;
  float D.30231;
  float D.30230;
  float D.30229;
  float D.30228;
  float D.30227;
  float iftmp.444;
  struct ImVec2 D.17453;
  struct ImGuiContext * GImGui.443;
  float iftmp.444_3;
  float iftmp.445_4;
  int iftmp.446_5;
  ImGuiDir iftmp.447_6;
  int iftmp.453_7;
  ImGuiDir iftmp.454_8;
  const float iftmp.455_9;
  const float iftmp.456_10;
  const float iftmp.457_11;
  const float iftmp.458_12;
  float iftmp.459_13;
  const float iftmp.460_14;
  float iftmp.461_15;
  const float iftmp.462_16;
  struct ImGuiContext * GImGui.443_27;
  float _32;
  float _34;
  float _35;
  float _36;
  float _37;
  float _38;
  float iftmp.444_39;
  float iftmp.444_40;
  float _41;
  float _43;
  float _44;
  float _45;
  float _46;
  float _47;
  float iftmp.445_48;
  float iftmp.445_49;
  int _62;
  int iftmp.446_63;
  int iftmp.446_64;
  ImGuiDir iftmp.447_66;
  ImGuiDir iftmp.447_67;
  int _69;
  float _74;
  float _75;
  float _79;
  float _80;
  float _81;
  float _82;
  float _86;
  float _87;
  float _88;
  float _89;
  float _93;
  float _94;
  float _95;
  float _96;
  float _97;
  float _98;
  bool _105;
  bool retval.452_106;
  int _118;
  int iftmp.453_119;
  int iftmp.453_120;
  ImGuiDir iftmp.454_122;
  ImGuiDir iftmp.454_123;
  int _125;
  const float iftmp.455_128;
  const float iftmp.455_129;
  const float iftmp.456_130;
  const float iftmp.456_131;
  const float iftmp.457_133;
  const float iftmp.457_134;
  const float iftmp.458_135;
  const float iftmp.458_136;
  float _138;
  float _139;
  float _141;
  float _142;
  float iftmp.459_143;
  const float iftmp.460_144;
  const float iftmp.460_145;
  float iftmp.459_146;
  float _148;
  float _149;
  float iftmp.461_150;
  const float iftmp.462_151;
  const float iftmp.462_152;
  float iftmp.461_153;
  float _160;
  float _161;
  float _162;
  float _163;
  float _164;
  float _166;
  float _167;
  float _168;
  float _170;
  float _172;
  float _173;
  float _174;
  float _175;
  float _176;
  float _178;
  float _179;
  float _180;
  float _182;

  <bb 2>:
  GImGui.443_27 = GImGui;
  style_28 = &GImGui.443_27->Style;
  safe_padding = style_28->DisplaySafeAreaPadding;
  r_outer = GetViewportRect ();
  _32 = size_31(D)->y;
  _34 = ImRect::GetHeight (&r_outer);
  _35 = _32 - _34;
  _36 = safe_padding.y;
  _37 = _36 * 2.0e+0;
  if (_35 > _37)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _38 = safe_padding.y;
  iftmp.444_39 = -_38;
  goto <bb 5>;

  <bb 4>:
  iftmp.444_40 = 0.0;

  <bb 5>:
  # iftmp.444_3 = PHI <iftmp.444_39(3), iftmp.444_40(4)>
  _41 = size_31(D)->x;
  _43 = ImRect::GetWidth (&r_outer);
  _44 = _41 - _43;
  _45 = safe_padding.x;
  _46 = _45 * 2.0e+0;
  if (_44 > _46)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _47 = safe_padding.x;
  iftmp.445_48 = -_47;
  goto <bb 8>;

  <bb 7>:
  iftmp.445_49 = 0.0;

  <bb 8>:
  # iftmp.445_4 = PHI <iftmp.445_48(6), iftmp.445_49(7)>
  ImVec2::ImVec2 (&D.17453, iftmp.445_4, iftmp.444_3);
  ImRect::Expand (&r_outer, &D.17453);
  D.17453 ={v} {CLOBBER};
  D.30246 = operator- (&r_outer.Max, size_31(D));
  base_pos_clamped = ImClamp (ref_pos_54(D), &r_outer.Min, D.30246);
  if (policy_56(D) == 1)
    goto <bb 9>;
  else
    goto <bb 33>;

  <bb 9>:
  dir_prefered_order[0] = 3;
  dir_prefered_order[1] = 1;
  dir_prefered_order[2] = 0;
  dir_prefered_order[3] = 2;
  _62 = *last_dir_61(D);
  if (_62 != -1)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.446_63 = -1;
  goto <bb 12>;

  <bb 11>:
  iftmp.446_64 = 0;

  <bb 12>:
  # iftmp.446_5 = PHI <iftmp.446_63(10), iftmp.446_64(11)>
  n_65 = iftmp.446_5;

  <bb 13>:
  # n_1 = PHI <n_65(12), n_71(31)>
  if (n_1 > 3)
    goto <bb 32>;
  else
    goto <bb 14>;

  <bb 14>:
  if (n_1 == -1)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.447_66 = MEM[(const ImGuiDir &)last_dir_61(D)];
  goto <bb 17>;

  <bb 16>:
  iftmp.447_67 = dir_prefered_order[n_1];

  <bb 17>:
  # iftmp.447_6 = PHI <iftmp.447_66(15), iftmp.447_67(16)>
  dir_68 = iftmp.447_6;
  if (n_1 != -1)
    goto <bb 18>;
  else
    goto <bb 20>;

  <bb 18>:
  _69 = *last_dir_61(D);
  if (_69 == dir_68)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  goto <bb 31>;

  <bb 20>:
  ImVec2::ImVec2 (&pos);
  if (dir_68 == 3)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _74 = r_avoid_73(D)->Max.y;
  _75 = r_avoid_73(D)->Min.x;
  ImVec2::ImVec2 (&pos.448, _75, _74);
  pos = pos.448;
  pos.448 ={v} {CLOBBER};

  <bb 22>:
  if (dir_68 == 1)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _79 = r_avoid_73(D)->Min.y;
  _80 = size_31(D)->y;
  _81 = _79 - _80;
  _82 = r_avoid_73(D)->Min.x;
  ImVec2::ImVec2 (&pos.449, _82, _81);
  pos = pos.449;
  pos.449 ={v} {CLOBBER};

  <bb 24>:
  if (dir_68 == 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _86 = r_avoid_73(D)->Max.y;
  _87 = r_avoid_73(D)->Max.x;
  _88 = size_31(D)->x;
  _89 = _87 - _88;
  ImVec2::ImVec2 (&pos.450, _89, _86);
  pos = pos.450;
  pos.450 ={v} {CLOBBER};

  <bb 26>:
  if (dir_68 == 2)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _93 = r_avoid_73(D)->Min.y;
  _94 = size_31(D)->y;
  _95 = _93 - _94;
  _96 = r_avoid_73(D)->Max.x;
  _97 = size_31(D)->x;
  _98 = _96 - _97;
  ImVec2::ImVec2 (&pos.451, _98, _95);
  pos = pos.451;
  pos.451 ={v} {CLOBBER};

  <bb 28>:
  D.17465 = operator+ (&pos, size_31(D));
  ImRect::ImRect (&D.17466, &pos, &D.17465);
  _105 = ImRect::Contains (&r_outer, &D.17466);
  retval.452_106 = ~_105;
  D.17466 ={v} {CLOBBER};
  D.17465 ={v} {CLOBBER};
  if (retval.452_106 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  goto <bb 31>;

  <bb 30>:
  *last_dir_61(D) = dir_68;
  D.30297 = pos;
  pos ={v} {CLOBBER};
  dir_prefered_order ={v} {CLOBBER};
  goto <bb 74>;

  <bb 31>:
  pos ={v} {CLOBBER};
  n_71 = n_1 + 1;
  goto <bb 13>;

  <bb 32>:
  dir_prefered_order ={v} {CLOBBER};

  <bb 33>:
  dir_prefered_order[0] = 1;
  dir_prefered_order[1] = 3;
  dir_prefered_order[2] = 2;
  dir_prefered_order[3] = 0;
  _118 = *last_dir_61(D);
  if (_118 != -1)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  iftmp.453_119 = -1;
  goto <bb 36>;

  <bb 35>:
  iftmp.453_120 = 0;

  <bb 36>:
  # iftmp.453_7 = PHI <iftmp.453_119(34), iftmp.453_120(35)>
  n_121 = iftmp.453_7;

  <bb 37>:
  # n_2 = PHI <n_121(36), n_127(72)>
  if (n_2 > 3)
    goto <bb 73>;
  else
    goto <bb 38>;

  <bb 38>:
  if (n_2 == -1)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  iftmp.454_122 = MEM[(const ImGuiDir &)last_dir_61(D)];
  goto <bb 41>;

  <bb 40>:
  iftmp.454_123 = dir_prefered_order[n_2];

  <bb 41>:
  # iftmp.454_8 = PHI <iftmp.454_122(39), iftmp.454_123(40)>
  dir_124 = iftmp.454_8;
  if (n_2 != -1)
    goto <bb 42>;
  else
    goto <bb 44>;

  <bb 42>:
  _125 = *last_dir_61(D);
  if (_125 == dir_124)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  goto <bb 72>;

  <bb 44>:
  if (dir_124 == 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  iftmp.455_128 = r_avoid_73(D)->Min.x;
  goto <bb 47>;

  <bb 46>:
  iftmp.455_129 = r_outer.Max.x;

  <bb 47>:
  # iftmp.455_9 = PHI <iftmp.455_128(45), iftmp.455_129(46)>
  if (dir_124 == 1)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  iftmp.456_130 = r_avoid_73(D)->Max.x;
  goto <bb 50>;

  <bb 49>:
  iftmp.456_131 = r_outer.Min.x;

  <bb 50>:
  # iftmp.456_10 = PHI <iftmp.456_130(48), iftmp.456_131(49)>
  avail_w_132 = iftmp.455_9 - iftmp.456_10;
  if (dir_124 == 2)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  iftmp.457_133 = r_avoid_73(D)->Min.y;
  goto <bb 53>;

  <bb 52>:
  iftmp.457_134 = r_outer.Max.y;

  <bb 53>:
  # iftmp.457_11 = PHI <iftmp.457_133(51), iftmp.457_134(52)>
  if (dir_124 == 3)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  iftmp.458_135 = r_avoid_73(D)->Max.y;
  goto <bb 56>;

  <bb 55>:
  iftmp.458_136 = r_outer.Min.y;

  <bb 56>:
  # iftmp.458_12 = PHI <iftmp.458_135(54), iftmp.458_136(55)>
  avail_h_137 = iftmp.457_11 - iftmp.458_12;
  _138 = size_31(D)->x;
  if (_138 > avail_w_132)
    goto <bb 58>;
  else
    goto <bb 57>;

  <bb 57>:
  _139 = size_31(D)->y;
  if (_139 > avail_h_137)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  goto <bb 72>;

  <bb 59>:
  ImVec2::ImVec2 (&pos);
  if (dir_124 == 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  _141 = r_avoid_73(D)->Min.x;
  _142 = size_31(D)->x;
  iftmp.459_143 = _141 - _142;
  goto <bb 65>;

  <bb 61>:
  if (dir_124 == 1)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  iftmp.460_144 = r_avoid_73(D)->Max.x;
  goto <bb 64>;

  <bb 63>:
  iftmp.460_145 = base_pos_clamped.x;

  <bb 64>:
  # iftmp.460_14 = PHI <iftmp.460_144(62), iftmp.460_145(63)>
  iftmp.459_146 = iftmp.460_14;

  <bb 65>:
  # iftmp.459_13 = PHI <iftmp.459_143(60), iftmp.459_146(64)>
  pos.x = iftmp.459_13;
  if (dir_124 == 2)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  _148 = r_avoid_73(D)->Min.y;
  _149 = size_31(D)->y;
  iftmp.461_150 = _148 - _149;
  goto <bb 71>;

  <bb 67>:
  if (dir_124 == 3)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  iftmp.462_151 = r_avoid_73(D)->Max.y;
  goto <bb 70>;

  <bb 69>:
  iftmp.462_152 = base_pos_clamped.y;

  <bb 70>:
  # iftmp.462_16 = PHI <iftmp.462_151(68), iftmp.462_152(69)>
  iftmp.461_153 = iftmp.462_16;

  <bb 71>:
  # iftmp.461_15 = PHI <iftmp.461_150(66), iftmp.461_153(70)>
  pos.y = iftmp.461_15;
  *last_dir_61(D) = dir_124;
  D.30297 = pos;
  pos ={v} {CLOBBER};
  goto <bb 74>;

  <bb 72>:
  pos ={v} {CLOBBER};
  n_127 = n_2 + 1;
  goto <bb 37>;

  <bb 73>:
  *last_dir_61(D) = -1;
  pos = *ref_pos_54(D);
  _160 = r_outer.Min.x;
  _161 = r_outer.Max.x;
  _162 = pos.x;
  _163 = size_31(D)->x;
  _164 = _162 + _163;
  _166 = ImMin (_164, _161);
  _167 = size_31(D)->x;
  _168 = _166 - _167;
  _170 = ImMax (_168, _160);
  pos.x = _170;
  _172 = r_outer.Min.y;
  _173 = r_outer.Max.y;
  _174 = pos.y;
  _175 = size_31(D)->y;
  _176 = _174 + _175;
  _178 = ImMin (_176, _173);
  _179 = size_31(D)->y;
  _180 = _178 - _179;
  _182 = ImMax (_180, _172);
  pos.y = _182;
  D.30297 = pos;

  <bb 74>:
  safe_padding ={v} {CLOBBER};
  r_outer ={v} {CLOBBER};
  base_pos_clamped ={v} {CLOBBER};
  dir_prefered_order ={v} {CLOBBER};
  pos ={v} {CLOBBER};

<L85>:
  return D.30297;

}



;; Function void SetWindowConditionAllowFlags(ImGuiWindow*, ImGuiCond, bool) (_ZL28SetWindowConditionAllowFlagsP11ImGuiWindowib, funcdef_no=825, decl_uid=17485, cgraph_uid=724, symbol_order=730)

void SetWindowConditionAllowFlags(ImGuiWindow*, ImGuiCond, bool) (struct ImGuiWindow * window, ImGuiCond flags, bool enabled)
{
  int D.30402;
  int D.30401;
  int D.30399;
  ImGuiCond iftmp.465;
  int D.30395;
  int D.30394;
  int D.30392;
  ImGuiCond iftmp.464;
  int D.30388;
  int D.30387;
  int D.30385;
  ImGuiCond iftmp.463;
  ImGuiCond iftmp.463_1;
  ImGuiCond iftmp.464_2;
  ImGuiCond iftmp.465_3;
  int _7;
  ImGuiCond iftmp.463_9;
  int _10;
  int _11;
  ImGuiCond iftmp.463_12;
  int _14;
  ImGuiCond iftmp.464_15;
  int _16;
  int _17;
  ImGuiCond iftmp.464_18;
  int _20;
  ImGuiCond iftmp.465_21;
  int _22;
  int _23;
  ImGuiCond iftmp.465_24;

  <bb 2>:
  if (enabled_4(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = window_6(D)->SetWindowPosAllowFlags;
  iftmp.463_9 = _7 | flags_8(D);
  goto <bb 5>;

  <bb 4>:
  _10 = window_6(D)->SetWindowPosAllowFlags;
  _11 = ~flags_8(D);
  iftmp.463_12 = _10 & _11;

  <bb 5>:
  # iftmp.463_1 = PHI <iftmp.463_9(3), iftmp.463_12(4)>
  window_6(D)->SetWindowPosAllowFlags = iftmp.463_1;
  if (enabled_4(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _14 = window_6(D)->SetWindowSizeAllowFlags;
  iftmp.464_15 = _14 | flags_8(D);
  goto <bb 8>;

  <bb 7>:
  _16 = window_6(D)->SetWindowSizeAllowFlags;
  _17 = ~flags_8(D);
  iftmp.464_18 = _16 & _17;

  <bb 8>:
  # iftmp.464_2 = PHI <iftmp.464_15(6), iftmp.464_18(7)>
  window_6(D)->SetWindowSizeAllowFlags = iftmp.464_2;
  if (enabled_4(D) != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _20 = window_6(D)->SetWindowCollapsedAllowFlags;
  iftmp.465_21 = _20 | flags_8(D);
  goto <bb 11>;

  <bb 10>:
  _22 = window_6(D)->SetWindowCollapsedAllowFlags;
  _23 = ~flags_8(D);
  iftmp.465_24 = _22 & _23;

  <bb 11>:
  # iftmp.465_3 = PHI <iftmp.465_21(9), iftmp.465_24(10)>
  window_6(D)->SetWindowCollapsedAllowFlags = iftmp.465_3;
  return;

}



;; Function ImGuiWindow* ImGui::FindWindowByName(const char*) (_ZN5ImGui16FindWindowByNameEPKc, funcdef_no=826, decl_uid=13738, cgraph_uid=725, symbol_order=731)

ImGuiWindow* ImGui::FindWindowByName(const char*) (const char * name)
{
  struct ImGuiWindow * D.30406;
  ImGuiID id;
  struct ImGuiContext & g;
  struct ImGuiStorage * D.30404;
  struct ImGuiWindow * D.30403;
  struct ImGuiStorage * _6;
  struct ImGuiWindow * _8;
  struct ImGuiWindow * _9;

  <bb 2>:
  g_2 = GImGui;
  id_5 = ImHash (name_3(D), 0, 0);
  _6 = &g_2->WindowsById;
  _8 = ImGuiStorage::GetVoidPtr (_6, id_5);
  _9 = _8;

<L0>:
  return _9;

}



;; Function ImGuiWindow* CreateNewWindow(const char*, ImVec2, ImGuiWindowFlags) (_ZL15CreateNewWindowPKc6ImVec2i, funcdef_no=827, decl_uid=15043, cgraph_uid=726, symbol_order=732)

ImGuiWindow* CreateNewWindow(const char*, ImVec2, ImGuiWindowFlags) (const char * name, struct ImVec2 size, ImGuiWindowFlags flags)
{
  void * D.46424;
  struct ImGuiWindowSettings * D.30491;
  void * D.30487;
  struct ImGuiWindowSettings * settings;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImGuiWindow * D.30485;
  struct ImVector * D.30484;
  struct ImVector * D.30482;
  struct ImGuiWindow * * D.30481;
  struct ImVector * D.30480;
  int D.30477;
  int D.30476;
  struct ImGuiWindow * window.495;
  int D.30473;
  struct ImGuiWindow * window.494;
  bool iftmp.493;
  struct ImGuiWindow * window.492;
  struct ImGuiWindow * window.491;
  float D.30462;
  struct ImGuiWindow * window.490;
  struct ImGuiWindow * window.489;
  float D.30456;
  struct ImGuiWindow * window.488;
  struct ImGuiWindow * window.487;
  int D.30452;
  struct ImGuiWindow * window.486;
  struct ImGuiWindow * window.485;
  int D.30447;
  struct ImVec2 * D.30446;
  struct ImGuiWindow * window.484;
  struct ImVec2 * D.30444;
  struct ImGuiWindow * window.483;
  struct ImGuiWindow * window.482;
  struct ImGuiWindow * window.481;
  struct ImGuiWindow * window.480;
  float D.30434;
  struct ImVec2 * D.30433;
  bool retval.479;
  bool D.30431;
  struct ImGuiWindow * window.478;
  struct ImVec2 * D.30429;
  struct ImGuiWindow * window.477;
  struct ImGuiWindow * window.476;
  struct ImGuiWindow * window.475;
  struct ImGuiWindow * window.474;
  unsigned int D.30422;
  struct ImGuiWindow * window.473;
  struct ImVec2 * D.30420;
  struct ImGuiWindow * window.472;
  struct ImVec2 D.17503;
  struct ImGuiWindow * window.471;
  struct ImGuiWindow * window.470;
  int D.30414;
  struct ImGuiStorage * D.30413;
  unsigned int D.30412;
  struct ImGuiWindow * window.469;
  struct ImGuiWindow * window.468;
  struct ImGuiWindow * window.467;
  struct ImNewDummy D.30408;
  void * window.466;
  void * D.17502;
  struct ImNewDummy D.30407;
  struct ImNewDummy D.17499;
  struct ImNewDummy D.17501;
  bool iftmp.493_1;
  void * _14;
  void * _15;
  void * window.466_17;
  struct ImGuiWindow * window.467_23;
  struct ImGuiWindow * window.468_26;
  struct ImGuiWindow * window.469_27;
  unsigned int _28;
  struct ImGuiStorage * _29;
  int _31;
  struct ImGuiWindow * window.470_32;
  struct ImGuiWindow * window.471_33;
  struct ImGuiWindow * window.472_36;
  struct ImVec2 * _37;
  struct ImGuiWindow * window.473_40;
  unsigned int _41;
  struct ImGuiWindowSettings * _43;
  struct ImGuiWindow * window.474_45;
  struct ImGuiWindow * window.475_47;
  struct ImGuiWindow * window.476_49;
  struct ImGuiWindow * window.477_50;
  struct ImVec2 * _51;
  struct ImGuiWindow * window.478_53;
  bool _54;
  struct ImVec2 * _56;
  float _58;
  bool retval.479_59;
  struct ImGuiWindow * window.480_61;
  struct ImGuiWindow * window.481_62;
  struct ImGuiWindow * window.482_63;
  struct ImGuiWindow * window.483_65;
  struct ImVec2 * _66;
  struct ImGuiWindow * window.484_68;
  struct ImVec2 * _69;
  int _71;
  struct ImGuiWindow * window.485_72;
  struct ImGuiWindow * window.486_73;
  int _75;
  struct ImGuiWindow * window.487_77;
  struct ImGuiWindow * window.488_79;
  float _80;
  struct ImGuiWindow * window.489_81;
  struct ImGuiWindow * window.490_83;
  float _84;
  struct ImGuiWindow * window.491_85;
  struct ImGuiWindow * window.492_87;
  struct ImGuiWindow * window.494_88;
  int _89;
  struct ImGuiWindow * window.495_90;
  int _91;
  bool iftmp.493_92;
  bool iftmp.493_93;
  int _95;
  struct ImVector * _96;
  struct ImGuiWindow * * _98;
  struct ImVector * _99;
  struct ImVector * _101;
  struct ImGuiWindow * _103;

  <bb 2>:
  g_11 = GImGui;
  D.17501 = D.30407;
  _14 = ImGui::MemAlloc (808);

  <bb 3>:
  _15 = _14;
  window.466_17 = operator new (808, D.17501, _15);
  ImGuiWindow::ImGuiWindow (window.466_17, g_11, name_18(D));

  <bb 4>:
  window = window.466_17;
  D.17501 ={v} {CLOBBER};
  D.17499 ={v} {CLOBBER};
  window.467_23 = window;
  window.467_23->Flags = flags_24(D);
  window.468_26 = window;
  window.469_27 = window;
  _28 = window.469_27->ID;
  _29 = &g_11->WindowsById;
  ImGuiStorage::SetVoidPtr (_29, _28, window.468_26);
  _31 = flags_24(D) & 256;
  if (_31 == 0)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:
  window.470_32 = window;
  window.471_33 = window;
  ImVec2::ImVec2 (&D.17503, 6.0e+1, 6.0e+1);
  window.471_33->PosFloat = D.17503;
  window.472_36 = window;
  _37 = &window.472_36->PosFloat;
  window.470_32->Pos = MEM[(const struct ImVec2 &)_37];
  D.17503 ={v} {CLOBBER};
  window.473_40 = window;
  _41 = window.473_40->ID;
  _43 = ImGui::FindWindowSettings (_41);
  settings_44 = _43;
  if (settings_44 != 0B)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  window.474_45 = window;
  SetWindowConditionAllowFlags (window.474_45, 4, 0);
  window.475_47 = window;
  window.475_47->PosFloat = settings_44->Pos;
  window.476_49 = window;
  window.477_50 = window;
  _51 = &window.477_50->PosFloat;
  window.476_49->Pos = ImFloor (_51);
  window.478_53 = window;
  _54 = settings_44->Collapsed;
  window.478_53->Collapsed = _54;
  _56 = &settings_44->Size;
  _58 = ImLengthSqr (_56);
  retval.479_59 = _58 > 9.99999974737875163555145263671875e-6;
  if (retval.479_59 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  size = settings_44->Size;

  <bb 8>:

  <bb 9>:
  window.480_61 = window;
  window.481_62 = window;
  window.482_63 = window;
  window.482_63->SizeFullAtLastBegin = size;
  window.483_65 = window;
  _66 = &window.483_65->SizeFullAtLastBegin;
  window.481_62->SizeFull = MEM[(const struct ImVec2 &)_66];
  window.484_68 = window;
  _69 = &window.484_68->SizeFull;
  window.480_61->Size = MEM[(const struct ImVec2 &)_69];
  _71 = flags_24(D) & 64;
  if (_71 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  window.485_72 = window;
  window.486_73 = window;
  window.486_73->AutoFitFramesY = 2;
  _75 = window.486_73->AutoFitFramesY;
  window.485_72->AutoFitFramesX = _75;
  window.487_77 = window;
  window.487_77->AutoFitOnlyGrows = 0;
  goto <bb 20>;

  <bb 11>:
  window.488_79 = window;
  _80 = window.488_79->Size.x;
  if (_80 <= 0.0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  window.489_81 = window;
  window.489_81->AutoFitFramesX = 2;

  <bb 13>:
  window.490_83 = window;
  _84 = window.490_83->Size.y;
  if (_84 <= 0.0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  window.491_85 = window;
  window.491_85->AutoFitFramesY = 2;

  <bb 15>:
  window.492_87 = window;
  window.494_88 = window;
  _89 = window.494_88->AutoFitFramesX;
  if (_89 > 0)
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  window.495_90 = window;
  _91 = window.495_90->AutoFitFramesY;
  if (_91 > 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.493_93 = 1;
  goto <bb 19>;

  <bb 18>:
  iftmp.493_92 = 0;

  <bb 19>:
  # iftmp.493_1 = PHI <iftmp.493_93(17), iftmp.493_92(18)>
  window.492_87->AutoFitOnlyGrows = iftmp.493_1;

  <bb 20>:
  _95 = flags_24(D) & 8192;
  if (_95 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _96 = &g_11->Windows;
  _98 = ImVector<ImGuiWindow*>::begin (_96);
  _99 = &g_11->Windows;
  ImVector<ImGuiWindow*>::insert (_99, _98, &window);
  goto <bb 23>;

  <bb 22>:
  _101 = &g_11->Windows;
  ImVector<ImGuiWindow*>::push_back (_101, &window);

  <bb 23>:
  _103 = window;
  window ={v} {CLOBBER};

<L26>:
  return _103;

<L27>:
  operator delete (window.466_17, D.30408, _15);
  __builtin_eh_copy_values (2, 4);

<L28>:
  _9 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_9);

}



;; Function ImGuiSizeCallbackData::ImGuiSizeCallbackData() (_ZN21ImGuiSizeCallbackDataC2Ev, funcdef_no=830, decl_uid=17518, cgraph_uid=728, symbol_order=734)

ImGuiSizeCallbackData::ImGuiSizeCallbackData() (struct ImGuiSizeCallbackData * const this)
{
  struct ImVec2 * D.30598;
  struct ImVec2 * D.30597;
  struct ImVec2 * D.30596;
  struct ImVec2 * _2;
  struct ImVec2 * _5;
  struct ImVec2 * _7;

  <bb 2>:
  _2 = &this_1(D)->Pos;
  ImVec2::ImVec2 (_2);
  _5 = &this_1(D)->CurrentSize;
  ImVec2::ImVec2 (_5);
  _7 = &this_1(D)->DesiredSize;
  ImVec2::ImVec2 (_7);
  return;

}



;; Function ImVec2 CalcSizeAfterConstraint(ImGuiWindow*, ImVec2) (_ZL23CalcSizeAfterConstraintP11ImGuiWindow6ImVec2, funcdef_no=828, decl_uid=17508, cgraph_uid=730, symbol_order=736)

ImVec2 CalcSizeAfterConstraint(ImGuiWindow*, ImVec2) (struct ImGuiWindow * window, struct ImVec2 new_size)
{
  struct ImGuiSizeCallbackData data;
  struct ImRect cr;
  struct ImGuiContext & g;
  struct ImVec2 D.30592;
  float D.30590;
  float D.30589;
  float D.30588;
  float D.30587;
  float D.30586;
  float D.30585;
  float D.30584;
  float D.30583;
  float D.30582;
  struct ImVec2 * D.30581;
  int D.30578;
  int D.30577;
  void (*<T594>) (struct ImGuiSizeCallbackData *) D.30574;
  void * D.30573;
  void (*<T594>) (struct ImGuiSizeCallbackData *) D.30570;
  float D.30569;
  float D.30568;
  float D.30567;
  float D.30565;
  float D.30563;
  float iftmp.503;
  float D.30559;
  float D.30558;
  float D.30557;
  float D.30555;
  float D.30553;
  float iftmp.502;
  int D.30547;
  float iftmp.502_1;
  float iftmp.503_2;
  int _10;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;
  float iftmp.502_18;
  float iftmp.502_20;
  float _22;
  float _23;
  float _24;
  float _25;
  float _26;
  float iftmp.503_28;
  float iftmp.503_29;
  void (*<T594>) (struct ImGuiSizeCallbackData *) _31;
  void * _33;
  void (*<T594>) (struct ImGuiSizeCallbackData *) _38;
  int _45;
  int _46;
  struct ImVec2 * _47;
  float _50;
  float _52;
  float _53;
  float _54;
  float _55;
  float _57;
  float _58;
  float _59;
  float _61;

  <bb 2>:
  g_9 = GImGui;
  _10 = g_9->NextWindowData.SizeConstraintCond;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 14>;

  <bb 3>:
  cr = g_9->NextWindowData.SizeConstraintRect;
  _12 = cr.Min.x;
  if (_12 >= 0.0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _13 = cr.Max.x;
  if (_13 >= 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _14 = cr.Max.x;
  _15 = cr.Min.x;
  _16 = new_size.x;
  iftmp.502_18 = ImClamp (_16, _15, _14);
  goto <bb 7>;

  <bb 6>:
  iftmp.502_20 = window_19(D)->SizeFull.x;

  <bb 7>:
  # iftmp.502_1 = PHI <iftmp.502_18(5), iftmp.502_20(6)>
  new_size.x = iftmp.502_1;
  _22 = cr.Min.y;
  if (_22 >= 0.0)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _23 = cr.Max.y;
  if (_23 >= 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _24 = cr.Max.y;
  _25 = cr.Min.y;
  _26 = new_size.y;
  iftmp.503_28 = ImClamp (_26, _25, _24);
  goto <bb 11>;

  <bb 10>:
  iftmp.503_29 = window_19(D)->SizeFull.y;

  <bb 11>:
  # iftmp.503_2 = PHI <iftmp.503_28(9), iftmp.503_29(10)>
  new_size.y = iftmp.503_2;
  _31 = g_9->NextWindowData.SizeCallback;
  if (_31 != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  ImGuiSizeCallbackData::ImGuiSizeCallbackData (&data);
  _33 = g_9->NextWindowData.SizeCallbackUserData;
  data.UserData = _33;
  data.Pos = window_19(D)->Pos;
  data.CurrentSize = window_19(D)->SizeFull;
  data.DesiredSize = new_size;
  _38 = g_9->NextWindowData.SizeCallback;
  _38 (&data);
  new_size = data.DesiredSize;
  data ={v} {CLOBBER};

  <bb 13>:
  cr ={v} {CLOBBER};

  <bb 14>:
  _45 = window_19(D)->Flags;
  _46 = _45 & 16777280;
  if (_46 == 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _47 = &g_9->Style.WindowMinSize;
  new_size = ImMax (&new_size, _47);
  _50 = ImGuiWindow::TitleBarHeight (window_19(D));
  _52 = ImGuiWindow::MenuBarHeight (window_19(D));
  _53 = _50 + _52;
  _54 = g_9->Style.WindowRounding;
  _55 = _54 - 1.0e+0;
  _57 = ImMax (0.0, _55);
  _58 = _53 + _57;
  _59 = new_size.y;
  _61 = ImMax (_59, _58);
  new_size.y = _61;

  <bb 16>:
  D.30592 = new_size;

<L17>:
  return D.30592;

}



;; Function ImVec2 CalcSizeContents(ImGuiWindow*) (_ZL16CalcSizeContentsP11ImGuiWindow, funcdef_no=832, decl_uid=17553, cgraph_uid=731, symbol_order=737)

ImVec2 CalcSizeContents(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImVec2 sz;
  struct ImVec2 * D.30650;
  struct ImVec2 D.30649;
  int D.30648;
  float D.30647;
  float D.30646;
  float D.30645;
  float D.30644;
  float D.30643;
  int D.30641;
  float D.30640;
  float D.30637;
  float iftmp.509;
  int D.30635;
  float D.30634;
  float D.30633;
  float D.30632;
  float D.30631;
  float D.30630;
  int D.30628;
  float D.30627;
  float D.30624;
  float iftmp.508;
  float iftmp.508_1;
  float iftmp.509_2;
  float _6;
  float _7;
  int _8;
  float iftmp.508_9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  int _15;
  float iftmp.508_16;
  float _18;
  float _19;
  int _20;
  float iftmp.509_21;
  float _22;
  float _23;
  float _24;
  float _25;
  float _26;
  int _27;
  float iftmp.509_28;
  struct ImVec2 * _30;

  <bb 2>:
  ImVec2::ImVec2 (&sz);
  _6 = window_5(D)->SizeContentsExplicit.x;
  if (_6 != 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = window_5(D)->SizeContentsExplicit.x;
  _8 = (int) _7;
  iftmp.508_9 = (float) _8;
  goto <bb 5>;

  <bb 4>:
  _10 = window_5(D)->DC.CursorMaxPos.x;
  _11 = window_5(D)->Pos.x;
  _12 = _10 - _11;
  _13 = window_5(D)->Scroll.x;
  _14 = _12 + _13;
  _15 = (int) _14;
  iftmp.508_16 = (float) _15;

  <bb 5>:
  # iftmp.508_1 = PHI <iftmp.508_9(3), iftmp.508_16(4)>
  sz.x = iftmp.508_1;
  _18 = window_5(D)->SizeContentsExplicit.y;
  if (_18 != 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _19 = window_5(D)->SizeContentsExplicit.y;
  _20 = (int) _19;
  iftmp.509_21 = (float) _20;
  goto <bb 8>;

  <bb 7>:
  _22 = window_5(D)->DC.CursorMaxPos.y;
  _23 = window_5(D)->Pos.y;
  _24 = _22 - _23;
  _25 = window_5(D)->Scroll.y;
  _26 = _24 + _25;
  _27 = (int) _26;
  iftmp.509_28 = (float) _27;

  <bb 8>:
  # iftmp.509_2 = PHI <iftmp.509_21(6), iftmp.509_28(7)>
  sz.y = iftmp.509_2;
  _30 = &window_5(D)->WindowPadding;
  D.30649 = operator+ (&sz, _30);
  sz ={v} {CLOBBER};

<L7>:
  return D.30649;

}



;; Function ImVec2 CalcSizeAutoFit(ImGuiWindow*, const ImVec2&) (_ZL15CalcSizeAutoFitP11ImGuiWindowRK6ImVec2, funcdef_no=833, decl_uid=17559, cgraph_uid=732, symbol_order=738)

ImVec2 CalcSizeAutoFit(ImGuiWindow*, const ImVec2&) (struct ImGuiWindow * window, const struct ImVec2 & size_contents)
{
  struct ImVec2 size_auto_fit_after_constraint;
  struct ImVec2 size_auto_fit;
  ImGuiWindowFlags flags;
  struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImVec2 D.30687;
  float D.30685;
  float D.30684;
  float D.30683;
  int D.30680;
  float D.30677;
  float D.30676;
  float D.30674;
  float D.30673;
  float D.30672;
  int D.30669;
  int D.30666;
  float D.30663;
  float D.30662;
  struct ImVec2 * D.30661;
  struct ImVec2 D.30660;
  struct ImVec2 * D.30659;
  struct ImVec2 * D.30658;
  struct ImVec2 * D.30657;
  struct ImVec2 D.17565;
  int D.30653;
  int _10;
  struct ImVec2 * _13;
  struct ImVec2 * _14;
  struct ImVec2 * _16;
  struct ImVec2 * _18;
  float _22;
  float _23;
  int _24;
  int _25;
  float _26;
  float _27;
  float _28;
  float _30;
  float _31;
  int _32;
  float _33;
  float _34;
  float _35;

  <bb 2>:
  g_5 = GImGui;
  style_6 = &g_5->Style;
  flags_8 = window_7(D)->Flags;
  ImVec2::ImVec2 (&size_auto_fit);
  _10 = flags_8 & 33554432;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  size_auto_fit = *size_contents_11(D);
  goto <bb 12>;

  <bb 4>:
  _13 = &g_5->Style.DisplaySafeAreaPadding;
  _14 = &g_5->IO.DisplaySize;
  D.17565 = operator- (_14, _13);
  _16 = &style_6->WindowMinSize;
  D.30660 = ImMax (_16, &D.17565);
  _18 = &style_6->WindowMinSize;
  size_auto_fit = ImClamp (size_contents_11(D), _18, D.30660);
  D.17565 ={v} {CLOBBER};
  size_auto_fit_after_constraint = CalcSizeAfterConstraint (window_7(D), size_auto_fit);
  _22 = size_auto_fit_after_constraint.x;
  _23 = size_contents_11(D)->x;
  if (_22 < _23)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _24 = flags_8 & 8;
  if (_24 == 0)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _25 = flags_8 & 2048;
  if (_25 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _26 = size_auto_fit.y;
  _27 = style_6->ScrollbarSize;
  _28 = _26 + _27;
  size_auto_fit.y = _28;

  <bb 8>:
  _30 = size_auto_fit_after_constraint.y;
  _31 = size_contents_11(D)->y;
  if (_30 < _31)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _32 = flags_8 & 8;
  if (_32 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _33 = size_auto_fit.x;
  _34 = style_6->ScrollbarSize;
  _35 = _33 + _34;
  size_auto_fit.x = _35;

  <bb 11>:
  size_auto_fit_after_constraint ={v} {CLOBBER};

  <bb 12>:
  D.30687 = size_auto_fit;
  size_auto_fit ={v} {CLOBBER};

<L16>:
  return D.30687;

}



;; Function float GetScrollMaxX(ImGuiWindow*) (_ZL13GetScrollMaxXP11ImGuiWindow, funcdef_no=834, decl_uid=17573, cgraph_uid=733, symbol_order=739)

float GetScrollMaxX(ImGuiWindow*) (struct ImGuiWindow * window)
{
  float D.30697;
  float D.30696;
  float D.30695;
  float D.30694;
  float D.30693;
  float D.30692;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _9;

  <bb 2>:
  _3 = window_2(D)->SizeContents.x;
  _4 = window_2(D)->SizeFull.x;
  _5 = window_2(D)->ScrollbarSizes.x;
  _6 = _4 - _5;
  _7 = _3 - _6;
  _9 = ImMax (0.0, _7);

<L0>:
  return _9;

}



;; Function float GetScrollMaxY(ImGuiWindow*) (_ZL13GetScrollMaxYP11ImGuiWindow, funcdef_no=835, decl_uid=17576, cgraph_uid=734, symbol_order=740)

float GetScrollMaxY(ImGuiWindow*) (struct ImGuiWindow * window)
{
  float D.30704;
  float D.30703;
  float D.30702;
  float D.30701;
  float D.30700;
  float D.30699;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _9;

  <bb 2>:
  _3 = window_2(D)->SizeContents.y;
  _4 = window_2(D)->SizeFull.y;
  _5 = window_2(D)->ScrollbarSizes.y;
  _6 = _4 - _5;
  _7 = _3 - _6;
  _9 = ImMax (0.0, _7);

<L0>:
  return _9;

}



;; Function ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow*) (_ZL38CalcNextScrollFromScrollTargetAndClampP11ImGuiWindow, funcdef_no=836, decl_uid=15048, cgraph_uid=735, symbol_order=741)

ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow*) (struct ImGuiWindow * window)
{
  float cr_y;
  float cr_x;
  struct ImVec2 scroll;
  struct ImVec2 D.30747;
  float D.30745;
  float D.30744;
  float D.30743;
  float D.30742;
  float D.30741;
  float D.30740;
  bool D.30737;
  bool D.30736;
  bool D.30733;
  bool D.30732;
  struct ImVec2 D.17585;
  float D.30730;
  float D.30729;
  float D.30728;
  float D.30727;
  float D.30726;
  float D.30725;
  float D.30724;
  float D.30723;
  float D.30722;
  float D.30721;
  float D.30720;
  float D.30719;
  float D.30716;
  float D.30714;
  float D.30713;
  float D.30712;
  float D.30711;
  float D.30710;
  float D.30709;
  float D.30706;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  float _17;
  float _18;
  float _19;
  float _21;
  float _23;
  float _24;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  bool _36;
  bool _37;
  bool _38;
  bool _39;
  float _41;
  float _42;
  float _44;
  float _47;
  float _48;
  float _50;

  <bb 2>:
  scroll = window_5(D)->Scroll;
  cr_x_7 = window_5(D)->ScrollTargetCenterRatio.x;
  cr_y_8 = window_5(D)->ScrollTargetCenterRatio.y;
  _9 = window_5(D)->ScrollTarget.x;
  if (_9 < 3.4028234663852885981170418348451692544e+38)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = window_5(D)->ScrollTarget.x;
  _11 = window_5(D)->SizeFull.x;
  _12 = window_5(D)->ScrollbarSizes.x;
  _13 = _11 - _12;
  _14 = _13 * cr_x_7;
  _15 = _10 - _14;
  scroll.x = _15;

  <bb 4>:
  _17 = window_5(D)->ScrollTarget.y;
  if (_17 < 3.4028234663852885981170418348451692544e+38)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _18 = window_5(D)->ScrollTarget.y;
  _19 = 1.0e+0 - cr_y_8;
  _21 = ImGuiWindow::TitleBarHeight (window_5(D));
  _23 = ImGuiWindow::MenuBarHeight (window_5(D));
  _24 = _21 + _23;
  _25 = _19 * _24;
  _26 = _18 - _25;
  _27 = window_5(D)->SizeFull.y;
  _28 = window_5(D)->ScrollbarSizes.y;
  _29 = _27 - _28;
  _30 = _29 * cr_y_8;
  _31 = _26 - _30;
  scroll.y = _31;

  <bb 6>:
  ImVec2::ImVec2 (&D.17585, 0.0, 0.0);
  scroll = ImMax (&scroll, &D.17585);
  D.17585 ={v} {CLOBBER};
  _36 = window_5(D)->Collapsed;
  _37 = ~_36;
  if (_37 != 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _38 = window_5(D)->SkipItems;
  _39 = ~_38;
  if (_39 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _41 = GetScrollMaxX (window_5(D));
  _42 = scroll.x;
  _44 = ImMin (_42, _41);
  scroll.x = _44;
  _47 = GetScrollMaxY (window_5(D));
  _48 = scroll.y;
  _50 = ImMin (_48, _47);
  scroll.y = _50;

  <bb 9>:
  D.30747 = scroll;
  scroll ={v} {CLOBBER};

<L12>:
  return D.30747;

}



;; Function ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags) (_ZL28GetWindowBgColorIdxFromFlagsi, funcdef_no=837, decl_uid=17589, cgraph_uid=736, symbol_order=742)

ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags) (ImGuiWindowFlags flags)
{
  int D.30754;
  ImGuiCol D.30753;
  int D.30750;
  ImGuiCol _1;
  int _3;
  ImGuiCol _4;
  int _5;
  ImGuiCol _6;
  ImGuiCol _7;

  <bb 2>:
  _3 = flags_2(D) & 100663296;
  if (_3 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _4 = 4;
  goto <bb 7> (<L4>);

  <bb 4>:
  _5 = flags_2(D) & 16777216;
  if (_5 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _6 = 3;
  goto <bb 7> (<L4>);

  <bb 6>:
  _7 = 2;

  # _1 = PHI <_4(3), _6(5), _7(6)>
<L4>:
  return _1;

}



;; Function void CalcResizePosSizeFromAnyCorner(ImGuiWindow*, const ImVec2&, const ImVec2&, ImVec2*, ImVec2*) (_ZL30CalcResizePosSizeFromAnyCornerP11ImGuiWindowRK6ImVec2S3_PS1_S4_, funcdef_no=838, decl_uid=17596, cgraph_uid=737, symbol_order=743)

void CalcResizePosSizeFromAnyCorner(ImGuiWindow*, const ImVec2&, const ImVec2&, ImVec2*, ImVec2*) (struct ImGuiWindow * window, const struct ImVec2 & corner_target, const struct ImVec2 & corner_norm, struct ImVec2 * out_pos, struct ImVec2 * out_size)
{
  struct ImVec2 size_constrained;
  struct ImVec2 size_expected;
  struct ImVec2 pos_max;
  struct ImVec2 pos_min;
  float D.30777;
  float D.30776;
  float D.30775;
  float D.30774;
  float D.30773;
  float D.30770;
  float D.30768;
  float D.30767;
  float D.30766;
  float D.30765;
  float D.30764;
  float D.30761;
  struct ImVec2 * D.30760;
  struct ImVec2 * D.30759;
  struct ImVec2 D.17601;
  struct ImVec2 * D.30758;
  struct ImVec2 * _4;
  struct ImVec2 * _9;
  struct ImVec2 * _10;
  float _18;
  float _19;
  float _20;
  float _21;
  float _22;
  float _23;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;

  <bb 2>:
  _4 = &window_3(D)->Pos;
  pos_min = ImLerp (corner_target_6(D), _4, corner_norm_7(D));
  _9 = &window_3(D)->Size;
  _10 = &window_3(D)->Pos;
  D.17601 = operator+ (_10, _9);
  pos_max = ImLerp (&D.17601, corner_target_6(D), corner_norm_7(D));
  D.17601 ={v} {CLOBBER};
  size_expected = operator- (&pos_max, &pos_min);
  size_constrained = CalcSizeAfterConstraint (window_3(D), size_expected);
  *out_pos_16(D) = pos_min;
  _18 = corner_norm_7(D)->x;
  if (_18 == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _19 = out_pos_16(D)->x;
  _20 = size_constrained.x;
  _21 = size_expected.x;
  _22 = _20 - _21;
  _23 = _19 - _22;
  out_pos_16(D)->x = _23;

  <bb 4>:
  _25 = corner_norm_7(D)->y;
  if (_25 == 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _26 = out_pos_16(D)->y;
  _27 = size_constrained.y;
  _28 = size_expected.y;
  _29 = _27 - _28;
  _30 = _26 - _29;
  out_pos_16(D)->y = _30;

  <bb 6>:
  *out_size_32(D) = size_constrained;
  pos_min ={v} {CLOBBER};
  pos_max ={v} {CLOBBER};
  size_expected ={v} {CLOBBER};
  size_constrained ={v} {CLOBBER};
  return;

}



;; Function ImRect GetBorderRect(ImGuiWindow*, int, float, float) (_ZL13GetBorderRectP11ImGuiWindowiff, funcdef_no=839, decl_uid=17643, cgraph_uid=738, symbol_order=745)

ImRect GetBorderRect(ImGuiWindow*, int, float, float) (struct ImGuiWindow * window, int border_n, float perp_padding, float thickness)
{
  static const char __PRETTY_FUNCTION__[54] = "ImRect GetBorderRect(ImGuiWindow*, int, float, float)";
  struct ImRect rect;
  struct ImRect D.17653;
  float D.30836;
  float D.30835;
  float D.30834;
  float D.30833;
  float D.30832;
  float D.30831;
  float D.30830;
  struct ImRect D.17651;
  float D.30827;
  float D.30826;
  float D.30825;
  float D.30824;
  float D.30823;
  float D.30822;
  float D.30821;
  struct ImRect D.17650;
  float D.30818;
  float D.30817;
  float D.30816;
  float D.30815;
  float D.30814;
  float D.30813;
  float D.30812;
  struct ImRect D.17649;
  float D.30809;
  float D.30808;
  float D.30807;
  float D.30806;
  float D.30805;
  float D.30804;
  float D.30803;
  struct ImRect D.17648;
  struct ImRect D.30802;
  struct ImVec2 D.17647;
  float _11;
  float _12;
  float _13;
  float _15;
  float _16;
  float _17;
  float _18;
  float _22;
  float _23;
  float _24;
  float _25;
  float _26;
  float _27;
  float _28;
  float _32;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _38;
  float _42;
  float _43;
  float _44;
  float _45;
  float _46;
  float _47;
  float _48;

  <bb 2>:
  rect = ImGuiWindow::Rect (window_4(D));
  if (thickness_6(D) == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImVec2::ImVec2 (&D.17647, 1.0e+0, 1.0e+0);
  operator-= (&rect.Max, &D.17647);
  D.17647 ={v} {CLOBBER};

  <bb 4>:
  if (border_n_10(D) == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _11 = rect.Min.y;
  _12 = _11 + thickness_6(D);
  _13 = rect.Max.x;
  _15 = _13 - perp_padding_14(D);
  _16 = rect.Min.y;
  _17 = rect.Min.x;
  _18 = _17 + perp_padding_14(D);
  ImRect::ImRect (&D.17648, _18, _16, _15, _12);
  D.30802 = D.17648;
  D.17648 ={v} {CLOBBER};
  goto <bb 13>;

  <bb 6>:
  if (border_n_10(D) == 1)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _22 = rect.Max.y;
  _23 = _22 - perp_padding_14(D);
  _24 = rect.Max.x;
  _25 = rect.Min.y;
  _26 = _25 + perp_padding_14(D);
  _27 = rect.Max.x;
  _28 = _27 - thickness_6(D);
  ImRect::ImRect (&D.17649, _28, _26, _24, _23);
  D.30802 = D.17649;
  D.17649 ={v} {CLOBBER};
  goto <bb 13>;

  <bb 8>:
  if (border_n_10(D) == 2)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _32 = rect.Max.y;
  _33 = rect.Max.x;
  _34 = _33 - perp_padding_14(D);
  _35 = rect.Max.y;
  _36 = _35 - thickness_6(D);
  _37 = rect.Min.x;
  _38 = _37 + perp_padding_14(D);
  ImRect::ImRect (&D.17650, _38, _36, _34, _32);
  D.30802 = D.17650;
  D.17650 ={v} {CLOBBER};
  goto <bb 13>;

  <bb 10>:
  if (border_n_10(D) == 3)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _42 = rect.Max.y;
  _43 = _42 - perp_padding_14(D);
  _44 = rect.Min.x;
  _45 = _44 + thickness_6(D);
  _46 = rect.Min.y;
  _47 = _46 + perp_padding_14(D);
  _48 = rect.Min.x;
  ImRect::ImRect (&D.17651, _48, _47, _45, _43);
  D.30802 = D.17651;
  D.17651 ={v} {CLOBBER};
  goto <bb 13>;

  <bb 12>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5498, &__PRETTY_FUNCTION__);

  <bb 13>:
  rect ={v} {CLOBBER};

<L20>:
  return D.30802;

}



;; Function void ImGui::UpdateManualResize(ImGuiWindow*, const ImVec2&, int*, int, ImU32*) (_ZN5ImGuiL18UpdateManualResizeEP11ImGuiWindowRK6ImVec2PiiPj, funcdef_no=840, decl_uid=15125, cgraph_uid=739, symbol_order=746)

void ImGui::UpdateManualResize(ImGuiWindow*, const ImVec2&, int*, int, ImU32*) (struct ImGuiWindow * window, const struct ImVec2 & size_auto_fit, int * border_held, int resize_grip_count, ImU32 * resize_grip_col)
{
  unsigned int D.31043;
  unsigned int D.31040;
  const float NAV_RESIZE_SPEED;
  struct ImVec2 nav_resize_delta;
  struct ImVec2 border_posn;
  struct ImVec2 border_target;
  struct ImRect border_rect;
  bool held;
  bool hovered;
  const float BORDER_APPEAR_TIMER;
  const float BORDER_SIZE;
  int border_n;
  struct ImVec2 corner_target;
  bool held;
  bool hovered;
  struct ImRect resize_rect;
  const struct ImVec2 corner;
  const struct ImGuiResizeGripDef & grip;
  int resize_grip_n;
  struct ImVec2 size_target;
  struct ImVec2 pos_target;
  const float grip_hover_size;
  const float grip_draw_size;
  const int resize_border_count;
  ImGuiWindowFlags flags;
  struct ImGuiContext & g;
  struct ImVec2 * D.31037;
  float D.31034;
  float D.31030;
  struct ImVec2 D.31028;
  struct ImVec2 * D.31027;
  unsigned int D.31026;
  float D.31025;
  float D.31024;
  float D.31023;
  float D.31022;
  float D.31021;
  float D.31020;
  float D.31019;
  float D.31018;
  float D.31016;
  ImGuiInputSource D.31010;
  bool D.31006;
  ImGuiInputSource D.31003;
  struct ImGuiWindow * D.31000;
  float D.30997;
  float D.30996;
  float D.30995;
  struct ImVec2 border_posn.530;
  float D.30991;
  float D.30990;
  float D.30989;
  float D.30988;
  struct ImVec2 border_posn.529;
  float D.30984;
  float D.30983;
  float D.30982;
  float D.30981;
  struct ImVec2 border_posn.528;
  float D.30977;
  float D.30976;
  float D.30975;
  struct ImVec2 border_posn.527;
  bool held.526;
  bool held.525;
  int D.30962;
  ImGuiMouseCursor iftmp.524;
  bool held.523;
  float D.30959;
  bool hovered.522;
  unsigned int D.30953;
  const void * D.30952;
  long int D.30951;
  int D.30950;
  unsigned int D.30947;
  bool hovered.521;
  ImGuiCol iftmp.520;
  bool held.519;
  ImGuiCol iftmp.518;
  ImU32 * D.30936;
  long unsigned int D.30935;
  long unsigned int D.30934;
  bool hovered.517;
  bool held.516;
  const struct ImVec2 * D.30926;
  struct ImVec2 * D.30925;
  struct ImVec2 * D.30924;
  struct ImVec2 D.17681;
  struct ImVec2 D.17682;
  const struct ImVec2 * D.30923;
  struct ImVec2 D.17683;
  bool held.515;
  bool D.30917;
  bool held.514;
  struct ImGuiWindow * D.30913;
  int D.30907;
  ImGuiMouseCursor iftmp.513;
  bool held.512;
  bool hovered.511;
  unsigned int D.30900;
  const void * D.30899;
  long int D.30898;
  const struct ImVec2 * D.30897;
  struct ImVec2 D.17674;
  struct ImVec2 D.17675;
  struct ImVec2 * D.30896;
  struct ImVec2 * D.30895;
  struct ImVec2 * D.30894;
  struct ImVec2 D.17671;
  const struct ImVec2 * D.30893;
  int D.30890;
  float D.30889;
  int D.30888;
  float D.30887;
  float D.30886;
  float D.30885;
  float D.30884;
  float D.30883;
  float D.30882;
  float D.30881;
  float D.30880;
  int D.30876;
  int iftmp.510;
  int D.30874;
  int D.30872;
  int D.30870;
  int D.30868;
  int iftmp.510_3;
  ImGuiMouseCursor iftmp.513_4;
  ImGuiCol iftmp.518_5;
  ImGuiCol iftmp.520_6;
  ImGuiMouseCursor iftmp.524_7;
  int _34;
  int _35;
  int _36;
  int _37;
  int _38;
  int iftmp.510_39;
  int iftmp.510_40;
  float _42;
  float _43;
  float _44;
  float _45;
  float _46;
  float _47;
  float _48;
  float _50;
  int _51;
  float _53;
  int _54;
  const struct ImVec2 * _62;
  struct ImVec2 * _63;
  struct ImVec2 * _64;
  struct ImVec2 * _66;
  const struct ImVec2 * _69;
  long int _76;
  const void * _77;
  unsigned int _79;
  unsigned int _80;
  bool hovered.511_82;
  bool held.512_83;
  int _84;
  ImGuiMouseCursor iftmp.513_85;
  ImGuiMouseCursor iftmp.513_86;
  struct ImGuiWindow * _88;
  bool held.514_89;
  bool _90;
  bool held.515_94;
  const struct ImVec2 * _95;
  struct ImVec2 * _98;
  struct ImVec2 * _99;
  const struct ImVec2 * _105;
  bool held.516_109;
  bool hovered.517_110;
  long unsigned int _111;
  long unsigned int _112;
  ImU32 * _114;
  bool held.519_115;
  ImGuiCol iftmp.518_116;
  bool hovered.521_117;
  ImGuiCol iftmp.520_118;
  ImGuiCol iftmp.520_119;
  ImGuiCol iftmp.518_120;
  unsigned int _122;
  int _137;
  long int _138;
  const void * _139;
  unsigned int _141;
  unsigned int _142;
  bool hovered.522_144;
  float _145;
  bool held.523_146;
  int _147;
  ImGuiMouseCursor iftmp.524_148;
  ImGuiMouseCursor iftmp.524_149;
  bool held.525_151;
  bool held.526_154;
  float _160;
  float _161;
  float _162;
  float _167;
  float _168;
  float _169;
  float _170;
  float _175;
  float _176;
  float _177;
  float _178;
  float _183;
  float _184;
  float _185;
  struct ImGuiWindow * _200;
  ImGuiInputSource _202;
  bool _203;
  ImGuiInputSource _205;
  float _207;
  float _208;
  float _210;
  float _211;
  float _212;
  float _213;
  float _215;
  float _216;
  float _218;
  unsigned int _223;
  struct ImVec2 * _225;
  float _230;
  float _233;
  struct ImVec2 * _235;

  <bb 2>:
  g_31 = GImGui;
  flags_33 = window_32(D)->Flags;
  _34 = flags_33 & 2;
  if (_34 != 0)
    goto <bb 6>;
  else
    goto <bb 3>;

  <bb 3>:
  _35 = flags_33 & 64;
  if (_35 != 0)
    goto <bb 6>;
  else
    goto <bb 4>;

  <bb 4>:
  _36 = window_32(D)->AutoFitFramesX;
  if (_36 > 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _37 = window_32(D)->AutoFitFramesY;
  if (_37 > 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  pos_target ={v} {CLOBBER};
  size_target ={v} {CLOBBER};
  goto <bb 72> (<L86>);

  <bb 7>:
  _38 = flags_33 & 131072;
  if (_38 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.510_39 = 4;
  goto <bb 10>;

  <bb 9>:
  iftmp.510_40 = 0;

  <bb 10>:
  # iftmp.510_3 = PHI <iftmp.510_39(8), iftmp.510_40(9)>
  resize_border_count_41 = iftmp.510_3;
  _42 = window_32(D)->WindowRounding;
  _43 = _42 + 1.0e+0;
  _44 = g_31->FontSize;
  _45 = _44 * 2.0000000298023223876953125e-1;
  _46 = _43 + _45;
  _47 = g_31->FontSize;
  _48 = _47 * 1.35000002384185791015625e+0;
  _50 = ImMax (_48, _46);
  _51 = (int) _50;
  grip_draw_size_52 = (const float) _51;
  _53 = grip_draw_size_52 * 7.5e-1;
  _54 = (int) _53;
  grip_hover_size_55 = (const float) _54;
  ImVec2::ImVec2 (&pos_target, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  ImVec2::ImVec2 (&size_target, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  ImGui::PushID ("#RESIZE");
  resize_grip_n_59 = 0;

  <bb 11>:
  # resize_grip_n_1 = PHI <resize_grip_n_59(10), resize_grip_n_128(35)>
  if (resize_grip_n_1 >= resize_grip_count_60(D))
    goto <bb 36>;
  else
    goto <bb 12>;

  <bb 12>:
  grip_61 = &resize_grip_def[resize_grip_n_1];
  _62 = &grip_61->CornerPos;
  _63 = &window_32(D)->Size;
  _64 = &window_32(D)->Pos;
  D.17671 = operator+ (_64, _63);
  _66 = &window_32(D)->Pos;
  corner = ImLerp (_66, &D.17671, _62);
  D.17671 ={v} {CLOBBER};
  _69 = &grip_61->InnerDir;
  D.17674 = operator* (_69, grip_hover_size_55);
  D.17675 = operator+ (&corner, &D.17674);
  ImRect::ImRect (&resize_rect, &corner, &D.17675);
  D.17675 ={v} {CLOBBER};
  D.17674 ={v} {CLOBBER};
  ImRect::FixInverted (&resize_rect);
  _76 = (long int) resize_grip_n_1;
  _77 = (const void *) _76;
  _79 = ImGuiWindow::GetID (window_32(D), _77);
  _80 = _79;
  ImGui::ButtonBehavior (&resize_rect, _80, &hovered, &held, 8224);
  hovered.511_82 = hovered;
  if (hovered.511_82 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  held.512_83 = held;
  if (held.512_83 != 0)
    goto <bb 14>;
  else
    goto <bb 18>;

  <bb 14>:
  _84 = resize_grip_n_1 & 1;
  if (_84 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.513_85 = 5;
  goto <bb 17>;

  <bb 16>:
  iftmp.513_86 = 6;

  <bb 17>:
  # iftmp.513_4 = PHI <iftmp.513_85(15), iftmp.513_86(16)>
  g_31->MouseCursor = iftmp.513_4;

  <bb 18>:
  _88 = g_31->HoveredWindow;
  if (_88 == window_32(D))
    goto <bb 19>;
  else
    goto <bb 23>;

  <bb 19>:
  held.514_89 = held;
  if (held.514_89 != 0)
    goto <bb 20>;
  else
    goto <bb 23>;

  <bb 20>:
  _90 = g_31->IO.MouseDoubleClicked[0];
  if (_90 != 0)
    goto <bb 21>;
  else
    goto <bb 23>;

  <bb 21>:
  if (resize_grip_n_1 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  size_target = CalcSizeAfterConstraint (window_32(D), *size_auto_fit_91(D));
  ImGui::ClearActiveID ();
  goto <bb 25>;

  <bb 23>:
  held.515_94 = held;
  if (held.515_94 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _95 = &grip_61->CornerPos;
  D.17682 = ImRect::GetSize (&resize_rect);
  D.17683 = operator* (&D.17682, _95);
  _98 = &g_31->ActiveIdClickOffset;
  _99 = &g_31->IO.MousePos;
  D.17681 = operator- (_99, _98);
  corner_target = operator+ (&D.17681, &D.17683);
  D.17681 ={v} {CLOBBER};
  D.17683 ={v} {CLOBBER};
  D.17682 ={v} {CLOBBER};
  _105 = &grip_61->CornerPos;
  CalcResizePosSizeFromAnyCorner (window_32(D), &corner_target, _105, &pos_target, &size_target);
  corner_target ={v} {CLOBBER};

  <bb 25>:
  if (resize_grip_n_1 == 0)
    goto <bb 28>;
  else
    goto <bb 26>;

  <bb 26>:
  held.516_109 = held;
  if (held.516_109 != 0)
    goto <bb 28>;
  else
    goto <bb 27>;

  <bb 27>:
  hovered.517_110 = hovered;
  if (hovered.517_110 != 0)
    goto <bb 28>;
  else
    goto <bb 35>;

  <bb 28>:
  _111 = (long unsigned int) resize_grip_n_1;
  _112 = _111 * 4;
  _114 = resize_grip_col_113(D) + _112;
  held.519_115 = held;
  if (held.519_115 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  iftmp.518_116 = 32;
  goto <bb 34>;

  <bb 30>:
  hovered.521_117 = hovered;
  if (hovered.521_117 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  iftmp.520_118 = 31;
  goto <bb 33>;

  <bb 32>:
  iftmp.520_119 = 30;

  <bb 33>:
  # iftmp.520_6 = PHI <iftmp.520_118(31), iftmp.520_119(32)>
  iftmp.518_120 = iftmp.520_6;

  <bb 34>:
  # iftmp.518_5 = PHI <iftmp.518_116(29), iftmp.518_120(33)>
  _122 = ImGui::GetColorU32 (iftmp.518_5, 1.0e+0);
  *_114 = _122;

  <bb 35>:
  corner ={v} {CLOBBER};
  resize_rect ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  resize_grip_n_128 = resize_grip_n_1 + 1;
  goto <bb 11>;

  <bb 36>:
  border_n_133 = 0;

  <bb 37>:
  # border_n_2 = PHI <border_n_133(36), border_n_195(56)>
  if (border_n_2 >= resize_border_count_41)
    goto <bb 57>;
  else
    goto <bb 38>;

  <bb 38>:
  BORDER_SIZE_134 = 5.0e+0;
  BORDER_APPEAR_TIMER_135 = 5.00000007450580596923828125e-2;
  border_rect = GetBorderRect (window_32(D), border_n_2, grip_hover_size_55, 5.0e+0);
  _137 = border_n_2 + 4;
  _138 = (long int) _137;
  _139 = (const void *) _138;
  _141 = ImGuiWindow::GetID (window_32(D), _139);
  _142 = _141;
  ImGui::ButtonBehavior (&border_rect, _142, &hovered, &held, 32);
  hovered.522_144 = hovered;
  if (hovered.522_144 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _145 = g_31->HoveredIdTimer;
  if (_145 > 5.00000007450580596923828125e-2)
    goto <bb 41>;
  else
    goto <bb 40>;

  <bb 40>:
  held.523_146 = held;
  if (held.523_146 != 0)
    goto <bb 41>;
  else
    goto <bb 46>;

  <bb 41>:
  _147 = border_n_2 & 1;
  if (_147 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  iftmp.524_148 = 4;
  goto <bb 44>;

  <bb 43>:
  iftmp.524_149 = 3;

  <bb 44>:
  # iftmp.524_7 = PHI <iftmp.524_148(42), iftmp.524_149(43)>
  g_31->MouseCursor = iftmp.524_7;
  held.525_151 = held;
  if (held.525_151 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  *border_held_152(D) = border_n_2;

  <bb 46>:
  held.526_154 = held;
  if (held.526_154 != 0)
    goto <bb 47>;
  else
    goto <bb 56>;

  <bb 47>:
  border_target = window_32(D)->Pos;
  ImVec2::ImVec2 (&border_posn);
  if (border_n_2 == 0)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  ImVec2::ImVec2 (&border_posn.527, 0.0, 0.0);
  border_posn = border_posn.527;
  border_posn.527 ={v} {CLOBBER};
  _160 = g_31->IO.MousePos.y;
  _161 = g_31->ActiveIdClickOffset.y;
  _162 = _160 - _161;
  border_target.y = _162;

  <bb 49>:
  if (border_n_2 == 1)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  ImVec2::ImVec2 (&border_posn.528, 1.0e+0, 0.0);
  border_posn = border_posn.528;
  border_posn.528 ={v} {CLOBBER};
  _167 = g_31->IO.MousePos.x;
  _168 = g_31->ActiveIdClickOffset.x;
  _169 = _167 - _168;
  _170 = _169 + 5.0e+0;
  border_target.x = _170;

  <bb 51>:
  if (border_n_2 == 2)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  ImVec2::ImVec2 (&border_posn.529, 0.0, 1.0e+0);
  border_posn = border_posn.529;
  border_posn.529 ={v} {CLOBBER};
  _175 = g_31->IO.MousePos.y;
  _176 = g_31->ActiveIdClickOffset.y;
  _177 = _175 - _176;
  _178 = _177 + 5.0e+0;
  border_target.y = _178;

  <bb 53>:
  if (border_n_2 == 3)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  ImVec2::ImVec2 (&border_posn.530, 0.0, 0.0);
  border_posn = border_posn.530;
  border_posn.530 ={v} {CLOBBER};
  _183 = g_31->IO.MousePos.x;
  _184 = g_31->ActiveIdClickOffset.x;
  _185 = _183 - _184;
  border_target.x = _185;

  <bb 55>:
  CalcResizePosSizeFromAnyCorner (window_32(D), &border_target, &border_posn, &pos_target, &size_target);
  border_target ={v} {CLOBBER};
  border_posn ={v} {CLOBBER};

  <bb 56>:
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  border_rect ={v} {CLOBBER};
  border_n_195 = border_n_2 + 1;
  goto <bb 37>;

  <bb 57>:
  ImGui::PopID ();
  _200 = g_31->NavWindowingTarget;
  if (_200 == window_32(D))
    goto <bb 58>;
  else
    goto <bb 67>;

  <bb 58>:
  ImVec2::ImVec2 (&nav_resize_delta);
  _202 = g_31->NavInputSource;
  if (_202 == 3)
    goto <bb 59>;
  else
    goto <bb 61>;

  <bb 59>:
  _203 = g_31->IO.KeyShift;
  if (_203 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  nav_resize_delta = ImGui::GetNavInputAmount2d (1, 0, 0.0, 0.0);

  <bb 61>:
  _205 = g_31->NavInputSource;
  if (_205 == 4)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  nav_resize_delta = ImGui::GetNavInputAmount2d (2, 0, 0.0, 0.0);

  <bb 63>:
  _207 = nav_resize_delta.x;
  if (_207 != 0.0)
    goto <bb 65>;
  else
    goto <bb 64>;

  <bb 64>:
  _208 = nav_resize_delta.y;
  if (_208 != 0.0)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  NAV_RESIZE_SPEED_209 = 6.0e+2;
  _210 = g_31->IO.DeltaTime;
  _211 = _210 * 6.0e+2;
  _212 = g_31->IO.DisplayFramebufferScale.y;
  _213 = g_31->IO.DisplayFramebufferScale.x;
  _215 = ImMin (_213, _212);
  _216 = _211 * _215;
  _218 = ImFloor (_216);
  operator*= (&nav_resize_delta, _218);
  g_31->NavWindowingToggleLayer = 0;
  g_31->NavDisableMouseHover = 1;
  _223 = ImGui::GetColorU32 (32, 1.0e+0);
  *resize_grip_col_113(D) = _223;
  _225 = &window_32(D)->SizeFull;
  D.31028 = operator+ (_225, &nav_resize_delta);
  size_target = CalcSizeAfterConstraint (window_32(D), D.31028);

  <bb 66>:
  nav_resize_delta ={v} {CLOBBER};

  <bb 67>:
  _230 = size_target.x;
  if (_230 != 3.4028234663852885981170418348451692544e+38)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  window_32(D)->SizeFull = size_target;
  MarkIniSettingsDirty (window_32(D));

  <bb 69>:
  _233 = pos_target.x;
  if (_233 != 3.4028234663852885981170418348451692544e+38)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  window_32(D)->PosFloat = ImFloor (&pos_target);
  _235 = &window_32(D)->PosFloat;
  window_32(D)->Pos = MEM[(const struct ImVec2 &)_235];
  MarkIniSettingsDirty (window_32(D));

  <bb 71>:
  window_32(D)->Size = window_32(D)->SizeFull;
  pos_target ={v} {CLOBBER};
  size_target ={v} {CLOBBER};

<L86>:
  return;

}



;; Function bool ImGui::Begin(const char*, bool*, ImGuiWindowFlags) (_ZN5ImGui5BeginEPKcPbi, funcdef_no=841, decl_uid=2454, cgraph_uid=740, symbol_order=747)

bool ImGui::Begin(const char*, bool*, ImGuiWindowFlags) (const char * name, bool * p_open, ImGuiWindowFlags flags)
{
  void * D.46439;
  bool D.32749;
  unsigned int D.32748;
  bool D.32746;
  ImGuiID D.32745;
  struct ImGuiWindow * D.32717;
  struct ImGuiWindow * D.32716;
  const float rad;
  const float pad;
  struct ImRect bb;
  ImGuiID id;
  struct ImRect clip_rect;
  float pad_right;
  float pad_left;
  struct ImRect text_r;
  struct ImVec2 text_size;
  const ImGuiItemFlags item_flags_backup;
  struct ImRect bb;
  float rounding;
  struct ImRect border;
  const struct ImVec2 corner;
  const struct ImGuiResizeGripDef & grip;
  int resize_grip_n;
  struct ImRect menu_bar_rect;
  ImU32 title_bar_col;
  ImU32 bg_col;
  ImU32 title_bar_col;
  float backup_border_size;
  struct ImRect bb;
  struct ImVec2 padding;
  struct ImRect rect_to_avoid;
  struct ImVec2 ref_pos;
  float sc;
  struct ImRect rect_to_avoid;
  struct ImRect rect_to_avoid;
  struct ImGuiWindow * parent_menu;
  float horizontal_overlap;
  float size_y_for_scrollbars;
  float size_x_for_scrollbars;
  struct ImRect title_bar_rect;
  const struct ImRect title_bar_rect;
  const bool title_bar_is_highlight;
  const float window_border_size;
  const float window_rounding;
  struct ImRect viewport_rect;
  const float grip_draw_size;
  const int resize_grip_count;
  ImU32 resize_grip_col[4];
  int border_held;
  bool want_focus;
  const bool window_pos_with_pivot;
  struct ImVec2 size_full_modified;
  const struct ImVec2 size_auto_fit;
  const bool window_is_child_tooltip;
  struct ImGuiPopupRef & popup_ref;
  struct ImGuiPopupRef & popup_ref;
  struct ImVec2 size_on_first_use;
  bool window_size_y_set_by_api;
  bool window_size_x_set_by_api;
  bool window_pos_set_by_api;
  struct ImGuiWindow * parent_window;
  struct ImGuiWindow * parent_window_in_stack;
  const bool window_just_appearing_after_hidden_for_resize;
  bool window_just_activated_by_user;
  const bool first_begin_of_the_frame;
  const int current_frame;
  const bool window_just_created;
  struct ImGuiWindow * window;
  static const char __PRETTY_FUNCTION__[56] = "bool ImGui::Begin(const char*, bool*, ImGuiWindowFlags)";
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  bool D.32714;
  struct ImGuiWindow * window.1000;
  bool D.32712;
  int D.32710;
  struct ImGuiWindow * window.999;
  int D.32707;
  struct ImGuiWindow * window.998;
  bool D.32705;
  bool D.32704;
  struct ImGuiWindow * window.997;
  bool D.32701;
  struct ImGuiWindow * window.996;
  bool iftmp.995;
  struct ImGuiWindow * window.994;
  struct ImGuiWindow * window.993;
  float D.32690;
  struct ImGuiWindow * window.992;
  bool D.32684;
  struct ImGuiWindow * window.991;
  bool D.32681;
  float D.32680;
  struct ImGuiWindow * window.990;
  float D.32678;
  struct ImGuiWindow * window.989;
  float D.32675;
  struct ImGuiWindow * window.988;
  float D.32673;
  struct ImGuiWindow * window.987;
  bool iftmp.986;
  bool D.32667;
  struct ImGuiWindow * window.985;
  struct ImGuiWindow * window.984;
  int D.32662;
  struct ImGuiWindow * window.983;
  int D.32658;
  struct ImGuiWindow * window.982;
  int D.32654;
  bool D.32652;
  bool iftmp.981;
  struct ImGuiWindow * window.980;
  int D.32643;
  int D.32640;
  int D.32639;
  int D.32638;
  struct ImGuiWindow * window.979;
  struct ImGuiWindow * window.978;
  struct ImVec2 * D.32632;
  struct ImGuiWindow * window.977;
  struct ImVec2 * D.32630;
  struct ImGuiWindow * window.976;
  struct ImGuiWindow * window.975;
  bool D.32623;
  int iftmp.974;
  struct ImGuiWindow * window.973;
  unsigned int D.32620;
  struct ImGuiWindow * window.972;
  struct ImGuiWindow * window.971;
  float D.32617;
  float D.32616;
  float D.32615;
  struct ImGuiWindow * window.970;
  struct ImGuiWindow * window.969;
  float D.32612;
  float D.32611;
  float D.32610;
  float D.32609;
  float D.32608;
  float D.32607;
  struct ImGuiWindow * window.968;
  float D.32605;
  float D.32604;
  struct ImGuiWindow * window.967;
  float D.32602;
  float D.32601;
  struct ImGuiWindow * window.966;
  struct ImGuiWindow * window.965;
  float D.32598;
  float D.32597;
  float D.32596;
  struct ImGuiWindow * window.964;
  struct ImGuiWindow * window.963;
  float D.32593;
  float D.32592;
  float D.32591;
  float D.32590;
  float D.32589;
  float D.32588;
  struct ImGuiWindow * window.962;
  float D.32586;
  float D.32585;
  struct ImGuiWindow * window.961;
  float D.32583;
  float D.32582;
  struct ImGuiWindow * window.960;
  struct ImGuiWindow * window.959;
  float D.32579;
  float D.32578;
  struct ImGuiWindow * window.958;
  float D.32576;
  float D.32575;
  struct ImGuiWindow * window.957;
  float D.32573;
  float D.32572;
  struct ImGuiWindow * window.956;
  float D.32570;
  struct ImGuiWindow * window.955;
  struct ImGuiWindow * window.954;
  float D.32567;
  float D.32566;
  struct ImGuiWindow * window.953;
  float D.32564;
  float D.32563;
  struct ImGuiWindow * window.952;
  float D.32561;
  float D.32560;
  struct ImGuiWindow * window.951;
  float D.32558;
  struct ImGuiWindow * window.950;
  struct ImGuiWindow * window.949;
  float D.32555;
  struct ImGuiWindow * window.948;
  int D.32553;
  int D.32551;
  const float iftmp.947;
  float D.32546;
  float D.32545;
  struct ImGuiWindow * window.946;
  float D.32543;
  struct ImGuiWindow * window.945;
  float D.32541;
  float D.32540;
  struct ImGuiWindow * window.944;
  float D.32538;
  struct ImGuiWindow * window.943;
  struct ImRect * D.32536;
  struct ImGuiWindow * window.942;
  struct ImRect * D.32534;
  struct ImGuiWindow * window.941;
  struct ImGuiWindow * window.940;
  struct ImGuiWindow * window.939;
  const struct ImVec2 * D.32529;
  float D.32528;
  float D.32526;
  float iftmp.938;
  float D.32522;
  float D.32521;
  struct ImGuiWindow * window.937;
  float D.32519;
  struct ImGuiWindow * window.936;
  float D.32517;
  float D.32516;
  float D.32515;
  float D.32514;
  float D.32512;
  float D.32509;
  float D.32507;
  float D.32506;
  float D.32505;
  float D.32504;
  float iftmp.935;
  float D.32499;
  float D.32498;
  float D.32497;
  float D.32496;
  int D.32493;
  float iftmp.934;
  struct ImGuiWindow * window.933;
  int D.32490;
  int D.32489;
  struct ImGuiWindow * window.932;
  struct ImGuiWindow * window.931;
  int D.32486;
  int D.32485;
  struct ImGuiWindow * window.930;
  unsigned int D.32479;
  struct ImGuiWindow * window.929;
  struct ImGuiWindow * window.928;
  struct ImRect D.17863;
  struct ImVec2 D.17864;
  float D.32476;
  float D.32475;
  float D.32474;
  struct ImVec2 D.17865;
  struct ImVec2 D.17866;
  float D.32473;
  bool retval.927;
  float D.32471;
  struct ImVec2 D.32467;
  struct ImVec2 * D.32466;
  struct ImGuiWindow * window.926;
  const struct ImVec2 * D.32464;
  bool D.32460;
  struct ImGuiWindow * window.925;
  ImGuiDir iftmp.924;
  struct ImGuiWindow * window.923;
  bool retval.922;
  struct ImVec2 * D.32452;
  struct ImGuiWindow * window.921;
  const struct ImVec2 * D.32450;
  struct ImVec2 D.17852;
  struct ImVec2 D.17853;
  struct ImVec2 D.17854;
  struct ImVec2 * D.32449;
  struct ImGuiWindow * window.920;
  const struct ImVec2 * D.32447;
  struct ImVec2 D.17855;
  float D.32446;
  float D.32445;
  struct ImVec2 D.17856;
  struct ImVec2 D.17857;
  struct ImVec2 D.17858;
  struct ImVec2 D.17859;
  struct ImGuiWindow * window.919;
  int D.32441;
  int D.32440;
  int D.32439;
  struct ImGuiWindow * window.918;
  struct ImGuiWindow * window.917;
  int D.32436;
  int D.32435;
  struct ImGuiWindow * window.916;
  int D.32433;
  int D.32432;
  struct ImGuiWindow * window.915;
  struct ImGuiWindow * window.914;
  struct ImGuiWindow * window.913;
  int D.32426;
  struct ImGuiWindow * window.912;
  struct ImGuiWindow * window.911;
  int D.32419;
  int D.32418;
  struct ImGuiWindow * window.910;
  int D.32414;
  struct ImGuiWindow * window.909;
  int D.32411;
  int D.32410;
  struct ImGuiWindow * window.908;
  int D.32406;
  struct ImGuiWindow * window.907;
  struct ImVector * D.32403;
  struct ImGuiWindow * window.906;
  ImGuiItemFlags * D.32401;
  struct ImGuiWindow * window.905;
  int D.32399;
  struct ImGuiWindow * window.904;
  int D.32395;
  int D.32394;
  struct ImGuiWindow * window.903;
  int D.32390;
  struct ImGuiMenuColumns * D.32389;
  struct ImGuiWindow * window.902;
  float D.32387;
  int D.32386;
  struct ImVector * D.32385;
  struct ImGuiWindow * window.901;
  struct ImGuiStorage * D.32383;
  struct ImGuiWindow * window.900;
  struct ImGuiWindow * window.899;
  struct ImGuiWindow * window.898;
  struct ImGuiWindow * window.897;
  struct ImGuiWindow * window.896;
  struct ImVector * D.32377;
  struct ImGuiWindow * window.895;
  struct ImVector * D.32375;
  struct ImGuiWindow * window.894;
  struct ImVector * D.32373;
  struct ImGuiWindow * window.893;
  struct ImGuiWindow * window.892;
  float D.32370;
  struct ImGuiWindow * window.891;
  struct ImGuiWindow * window.890;
  struct ImGuiWindow * window.889;
  int iftmp.888;
  struct ImGuiWindow * window.887;
  struct ImGuiWindow * window.886;
  struct ImVector * D.32360;
  struct ImGuiWindow * window.885;
  float D.32358;
  float D.32357;
  struct ImGuiWindow * window.884;
  struct ImGuiWindow * window.883;
  float D.32354;
  float D.32353;
  struct ImGuiWindow * window.882;
  float D.32351;
  struct ImGuiWindow * window.881;
  struct ImGuiWindow * window.880;
  struct ImGuiWindow * window.879;
  int D.32347;
  struct ImGuiWindow * window.878;
  struct ImGuiWindow * window.877;
  bool D.32344;
  float D.32343;
  struct ImGuiWindow * window.876;
  struct ImGuiWindow * window.875;
  float D.32340;
  struct ImGuiWindow * window.874;
  struct ImGuiWindow * window.873;
  float D.32337;
  struct ImGuiWindow * window.872;
  struct ImGuiWindow * window.871;
  struct ImGuiWindow * window.870;
  struct ImGuiWindow * window.869;
  struct ImGuiWindow * window.868;
  struct ImGuiWindow * window.867;
  struct ImGuiWindow * window.866;
  struct ImGuiWindow * window.865;
  struct ImVec2 * D.32328;
  struct ImGuiWindow * window.864;
  float D.32326;
  float D.32325;
  struct ImGuiWindow * window.863;
  float D.32323;
  struct ImGuiWindow * window.862;
  float D.32321;
  float D.32320;
  struct ImGuiWindow * window.861;
  float D.32318;
  float D.32317;
  struct ImGuiWindow * window.860;
  float D.32315;
  float D.32314;
  struct ImGuiWindow * window.859;
  float D.32312;
  struct ImGuiWindow * window.858;
  struct ImVec2 D.17847;
  struct ImGuiWindow * window.857;
  struct ImGuiWindow * window.856;
  struct ImGuiWindow * window.855;
  float D.32307;
  float D.32306;
  struct ImGuiWindow * window.854;
  float D.32304;
  float D.32303;
  struct ImGuiWindow * window.853;
  struct ImGuiWindow * window.852;
  float D.32300;
  float D.32299;
  struct ImGuiWindow * window.851;
  float D.32297;
  struct ImGuiWindow * window.850;
  struct ImGuiWindow * window.849;
  float D.32291;
  struct ImGuiWindow * window.848;
  float iftmp.847;
  float D.32288;
  float D.32287;
  struct ImGuiWindow * window.846;
  float D.32285;
  float D.32284;
  struct ImGuiWindow * window.845;
  struct ImGuiWindow * window.844;
  float D.32281;
  float D.32280;
  struct ImGuiWindow * window.843;
  float D.32278;
  struct ImGuiWindow * window.842;
  struct ImGuiWindow * window.841;
  float D.32272;
  struct ImGuiWindow * window.840;
  float iftmp.839;
  float D.32269;
  float D.32268;
  struct ImGuiWindow * window.838;
  float D.32266;
  float D.32265;
  struct ImGuiWindow * window.837;
  struct ImGuiWindow * window.836;
  float D.32262;
  float D.32261;
  struct ImGuiWindow * window.835;
  float D.32259;
  float D.32258;
  struct ImGuiWindow * window.834;
  float D.32256;
  float D.32255;
  struct ImGuiWindow * window.833;
  float D.32253;
  struct ImGuiWindow * window.832;
  struct ImGuiWindow * window.831;
  float D.32250;
  float D.32249;
  struct ImGuiWindow * window.830;
  float D.32247;
  struct ImGuiWindow * window.829;
  struct ImGuiWindow * window.828;
  struct ImGuiWindow * window.827;
  struct ImGuiWindow * window.826;
  struct ImDrawList * D.32241;
  struct ImGuiWindow * window.825;
  unsigned int D.32239;
  float D.32238;
  struct ImGuiWindow * window.824;
  float D.32235;
  float D.32234;
  float D.32233;
  bool retval.823;
  float D.32229;
  struct ImGuiWindow * window.822;
  float D.32227;
  struct ImGuiWindow * window.821;
  float D.32225;
  struct ImGuiWindow * window.820;
  struct ImGuiWindow * D.32221;
  struct ImDrawList * D.32219;
  struct ImGuiWindow * window.819;
  struct ImVec2 D.17838;
  float D.32217;
  struct ImVec2 D.17839;
  struct ImVec2 D.17840;
  struct ImVec2 D.17841;
  float D.32216;
  float D.32215;
  struct ImVec2 D.17842;
  struct ImVec2 D.17843;
  unsigned int D.32214;
  float D.32213;
  int D.32210;
  float D.32207;
  struct ImDrawList * D.32205;
  struct ImGuiWindow * window.818;
  unsigned int D.32203;
  float D.32202;
  struct ImGuiWindow * window.817;
  int border_held.816;
  int border_held.815;
  struct ImDrawList * D.32195;
  struct ImGuiWindow * window.814;
  struct ImVec2 * D.32193;
  struct ImGuiWindow * window.813;
  struct ImVec2 * D.32191;
  struct ImGuiWindow * window.812;
  struct ImVec2 * D.32189;
  struct ImGuiWindow * window.811;
  struct ImVec2 D.17835;
  unsigned int D.32187;
  struct ImDrawList * D.32183;
  struct ImGuiWindow * window.810;
  unsigned int D.32181;
  struct ImDrawList * D.32180;
  struct ImGuiWindow * window.809;
  float D.32178;
  float D.32177;
  float D.32176;
  float D.32175;
  float D.32174;
  float D.32173;
  float D.32172;
  float D.32171;
  float D.32170;
  float D.32169;
  struct ImVec2 D.17834;
  int D.32168;
  int D.32167;
  struct ImDrawList * D.32166;
  struct ImGuiWindow * window.808;
  const struct ImVec2 * D.32164;
  int D.32160;
  struct ImVec2 D.17831;
  struct ImVec2 D.17832;
  struct ImVec2 D.17833;
  struct ImDrawList * D.32159;
  struct ImGuiWindow * window.807;
  const struct ImVec2 * D.32157;
  int D.32153;
  struct ImVec2 D.17826;
  struct ImVec2 D.17827;
  struct ImVec2 D.17828;
  struct ImVec2 * D.32152;
  struct ImGuiWindow * window.806;
  struct ImVec2 * D.32150;
  struct ImGuiWindow * window.805;
  struct ImVec2 * D.32148;
  struct ImGuiWindow * window.804;
  struct ImVec2 D.17822;
  const struct ImVec2 * D.32146;
  int D.32141;
  bool D.32137;
  struct ImGuiWindow * window.803;
  bool D.32132;
  struct ImGuiWindow * window.802;
  struct ImDrawList * D.32128;
  struct ImGuiWindow * window.801;
  struct ImVec2 D.17817;
  struct ImVec2 D.17818;
  unsigned int D.32126;
  float D.32125;
  float D.32122;
  float D.32121;
  struct ImGuiWindow * window.800;
  float D.32119;
  struct ImGuiWindow * window.799;
  float D.32117;
  float D.32114;
  struct ImDrawList * D.32113;
  struct ImGuiWindow * window.798;
  unsigned int D.32111;
  int D.32107;
  float iftmp.797;
  struct ImGuiWindow * window.796;
  struct ImRect D.17816;
  struct ImGuiWindow * window.795;
  int D.32101;
  struct ImDrawList * D.32099;
  struct ImGuiWindow * window.794;
  int D.32095;
  ImGuiCol iftmp.793;
  bool D.32087;
  struct ImGuiWindow * window.792;
  ImGuiCol iftmp.791;
  struct ImDrawList * D.32084;
  struct ImGuiWindow * window.790;
  struct ImVec2 * D.32082;
  struct ImGuiWindow * window.789;
  float D.32080;
  struct ImGuiWindow * window.788;
  struct ImVec2 D.17810;
  struct ImVec2 D.17811;
  struct ImVec2 * D.32078;
  struct ImGuiWindow * window.787;
  struct ImVec2 * D.32076;
  struct ImGuiWindow * window.786;
  struct ImVec2 D.17812;
  int D.32071;
  int iftmp.785;
  unsigned int D.32068;
  int D.32067;
  int D.32066;
  float D.32065;
  float D.32064;
  float D.32063;
  float D.32062;
  unsigned int D.32061;
  int D.32058;
  int D.32057;
  bool D.32054;
  bool D.32053;
  ImGuiCol iftmp.784;
  float D.32048;
  struct ImGuiWindow * window.783;
  bool D.32044;
  struct ImGuiWindow * window.782;
  struct ImGuiWindow * window.781;
  struct ImGuiWindow * D.32041;
  struct ImGuiWindow * D.32040;
  struct ImGuiWindow * D.32039;
  struct ImGuiWindow * window.780;
  struct ImGuiWindow * D.32036;
  bool iftmp.779;
  struct ImGuiWindow * window.778;
  struct ImGuiWindow * window.777;
  struct ImDrawList * D.32026;
  struct ImGuiWindow * window.776;
  unsigned int D.32024;
  float D.32023;
  float D.32022;
  float D.32021;
  bool D.32018;
  bool retval.775;
  float D.32016;
  struct ImGuiWindow * window.774;
  struct ImGuiWindow * window.773;
  struct ImGuiWindow * D.32011;
  struct ImDrawList * D.32009;
  struct ImGuiWindow * window.772;
  unsigned int D.32007;
  float D.32006;
  struct ImGuiWindow * window.771;
  struct ImGuiWindow * D.32001;
  int D.31999;
  bool iftmp.770;
  bool retval.769;
  struct ImVec2 * D.31994;
  struct ImVec2 * D.31993;
  bool D.31991;
  int D.31989;
  int D.31987;
  struct ImDrawList * D.31984;
  struct ImGuiWindow * window.768;
  void * D.31982;
  struct ImFontAtlas * D.31981;
  struct ImFont * D.31980;
  int D.31979;
  bool D.31975;
  int iftmp.767;
  bool D.31970;
  int iftmp.766;
  struct ImDrawList * D.31968;
  struct ImGuiWindow * window.765;
  struct ImDrawList * D.31966;
  struct ImGuiWindow * window.764;
  struct ImGuiWindow * window.763;
  bool D.31960;
  bool D.31959;
  struct ImGuiWindow * window.762;
  int D.31957;
  float D.31956;
  float D.31955;
  float D.31954;
  float D.31953;
  float D.31952;
  float D.31951;
  float D.31950;
  float D.31949;
  struct ImGuiWindow * window.761;
  int D.31944;
  int iftmp.760;
  int D.31941;
  int D.31939;
  int D.31934;
  struct ImVec2 D.17790;
  struct ImGuiWindow * window.759;
  struct ImGuiWindow * window.758;
  struct ImGuiWindow * window.757;
  int D.31928;
  struct ImGuiWindow * window.756;
  struct ImGuiWindow * window.755;
  int D.31925;
  struct ImGuiWindow * window.754;
  struct ImGuiWindow * window.753;
  int D.31922;
  int D.31921;
  struct ImGuiWindow * window.752;
  int D.31919;
  int D.31918;
  int D.31917;
  struct ImGuiWindow * window.751;
  int D.31915;
  struct ImGuiWindow * window.750;
  int D.31912;
  struct ImGuiWindow * window.749;
  int D.31909;
  struct ImGuiWindow * window.748;
  int iftmp.747;
  struct ImGuiWindow * window.746;
  int D.31903;
  int D.31902;
  struct ImGuiWindow * window.745;
  int D.31900;
  int D.31899;
  int D.31898;
  struct ImGuiWindow * window.744;
  int D.31896;
  struct ImGuiWindow * window.743;
  int D.31893;
  struct ImGuiWindow * window.742;
  int D.31890;
  struct ImGuiWindow * window.741;
  int iftmp.740;
  struct ImGuiWindow * window.739;
  float D.31884;
  int D.31883;
  float D.31882;
  float D.31881;
  struct ImGuiWindow * window.738;
  float D.31879;
  int D.31878;
  float D.31877;
  float D.31876;
  struct ImGuiWindow * window.737;
  struct ImGuiWindow * window.736;
  int D.31872;
  int D.31870;
  float D.31868;
  struct ImGuiWindow * window.735;
  struct ImVec2 * D.31864;
  struct ImGuiWindow * window.734;
  struct ImGuiWindow * window.733;
  struct ImVec2 * D.31859;
  struct ImGuiWindow * window.732;
  struct ImVec2 * D.31857;
  struct ImVec2 D.17786;
  struct ImGuiWindow * window.731;
  struct ImVec2 * D.31855;
  struct ImGuiWindow * window.730;
  struct ImVec2 * D.31853;
  struct ImGuiWindow * window.729;
  struct ImVec2 D.17783;
  struct ImVec2 D.17784;
  struct ImVec2 * D.31851;
  struct ImGuiWindow * window.728;
  struct ImGuiWindow * window.727;
  const struct ImVec2 * D.31848;
  const struct ImVec2 * D.31847;
  float D.31844;
  float D.31841;
  int D.31838;
  struct ImGuiWindow * window.726;
  int D.31834;
  struct ImGuiWindow * window.725;
  bool D.31830;
  bool window_pos_set_by_api.724;
  int D.31826;
  int D.31823;
  struct ImVec2 D.17779;
  struct ImGuiWindow * window.723;
  int D.31817;
  struct ImGuiWindow * window.722;
  struct ImVec2 * D.31815;
  struct ImGuiWindow * window.721;
  ImGuiDir * D.31813;
  struct ImGuiWindow * window.720;
  struct ImGuiWindow * window.719;
  float D.31810;
  float D.31809;
  float D.31808;
  float D.31807;
  float D.31806;
  float D.31805;
  float D.31804;
  float D.31803;
  float D.31802;
  float D.31801;
  struct ImRect rect_to_avoid.718;
  float D.31800;
  float D.31799;
  float D.31798;
  float D.31797;
  float D.31796;
  float D.31795;
  float D.31794;
  float D.31793;
  struct ImRect rect_to_avoid.717;
  int D.31791;
  int D.31790;
  bool D.31788;
  bool D.31786;
  bool D.31785;
  bool D.31781;
  bool D.31779;
  bool D.31778;
  bool D.31773;
  bool D.31770;
  bool window_pos_set_by_api.716;
  int D.31766;
  struct ImVec2 * D.31764;
  struct ImGuiWindow * window.715;
  struct ImVec2 * D.31762;
  struct ImGuiWindow * window.714;
  ImGuiDir * D.31760;
  struct ImGuiWindow * window.713;
  struct ImGuiWindow * window.712;
  float D.31757;
  float D.31756;
  struct ImGuiWindow * window.711;
  float D.31754;
  float D.31753;
  struct ImGuiWindow * window.710;
  float D.31751;
  float D.31750;
  struct ImGuiWindow * window.709;
  float D.31748;
  float D.31747;
  struct ImGuiWindow * window.708;
  bool D.31741;
  bool window_pos_set_by_api.707;
  int D.31737;
  struct ImVec2 * D.31735;
  struct ImGuiWindow * window.706;
  struct ImVec2 * D.31733;
  struct ImGuiWindow * window.705;
  ImGuiDir * D.31731;
  struct ImGuiWindow * window.704;
  struct ImGuiWindow * window.703;
  float D.31728;
  float D.31727;
  float D.31726;
  float D.31725;
  float D.31724;
  float D.31723;
  float D.31722;
  float D.31721;
  struct ImRect rect_to_avoid.702;
  float D.31719;
  float D.31718;
  float D.31717;
  float D.31716;
  float D.31715;
  float D.31714;
  float D.31713;
  float D.31712;
  struct ImRect rect_to_avoid.701;
  bool D.31709;
  bool window_pos_set_by_api.700;
  int D.31702;
  struct ImGuiWindow * window.699;
  const struct ImVec2 * D.31699;
  struct ImVec2 * D.31698;
  struct ImGuiWindow * window.698;
  struct ImVec2 * D.31696;
  struct ImGuiWindow * window.697;
  struct ImVec2 * D.31694;
  struct ImGuiWindow * window.696;
  struct ImVec2 D.17759;
  struct ImVec2 D.17760;
  struct ImVec2 D.17761;
  int D.31689;
  struct ImGuiWindow * window.695;
  float D.31686;
  struct ImGuiWindow * window.694;
  bool iftmp.693;
  struct ImVec2 * D.31679;
  struct ImGuiWindow * window.692;
  struct ImGuiWindow * window.691;
  struct ImGuiWindow * window.690;
  bool D.31673;
  bool D.31670;
  bool window_pos_set_by_api.689;
  int D.31666;
  struct ImVector * D.31665;
  int D.31664;
  struct ImGuiWindow * window.688;
  int D.31660;
  struct ImVec2 * D.31657;
  struct ImGuiWindow * window.687;
  struct value_type & D.31655;
  struct ImVector * D.31654;
  struct ImGuiWindow * window.686;
  struct ImGuiWindow * window.685;
  bool D.31649;
  bool window_pos_set_by_api.684;
  int D.31645;
  struct ImGuiWindow * window.683;
  bool D.31637;
  struct ImGuiWindow * window.682;
  float iftmp.681;
  bool D.31631;
  struct ImGuiWindow * window.680;
  float iftmp.679;
  struct ImVec2 D.17757;
  struct ImGuiWindow * window.678;
  int D.31625;
  float D.31623;
  float D.31622;
  float D.31621;
  struct ImGuiWindow * window.677;
  bool iftmp.676;
  struct ImGuiWindow * window.675;
  bool D.31613;
  bool D.31612;
  struct ImGuiWindow * window.674;
  bool D.31608;
  struct ImGuiWindow * window.673;
  int D.31606;
  int D.31604;
  float D.31602;
  bool D.31598;
  struct ImGuiWindow * window.672;
  float iftmp.671;
  float D.31595;
  struct ImGuiWindow * window.670;
  int D.31592;
  bool iftmp.669;
  struct ImGuiWindow * window.668;
  int D.31586;
  float D.31584;
  struct ImGuiWindow * window.667;
  int D.31581;
  bool iftmp.666;
  struct ImGuiWindow * window.665;
  struct ImGuiWindow * window.664;
  struct ImGuiWindow * window.663;
  float D.31570;
  float iftmp.662;
  struct ImGuiWindow * window.661;
  struct ImGuiWindow * window.660;
  float D.31563;
  float iftmp.659;
  bool D.31559;
  bool D.31558;
  struct ImGuiWindow * window.658;
  struct ImGuiWindow * window.657;
  struct ImGuiWindow * window.656;
  struct ImRect D.17751;
  int D.31553;
  bool D.31551;
  struct ImGuiWindow * window.655;
  struct ImGuiWindow * window.654;
  struct ImGuiWindow * window.653;
  struct ImGuiWindow * window.652;
  struct ImGuiWindow * window.651;
  struct ImGuiWindow * window.650;
  bool D.31539;
  bool D.31538;
  struct ImGuiWindow * window.649;
  float D.31535;
  float D.31533;
  struct ImGuiWindow * window.648;
  float D.31531;
  bool D.31528;
  struct ImGuiWindow * window.647;
  float iftmp.646;
  struct ImGuiWindow * window.645;
  int D.31522;
  struct ImGuiWindow * window.644;
  bool D.31518;
  float D.31516;
  float D.31514;
  struct ImGuiWindow * window.643;
  float D.31512;
  bool D.31509;
  struct ImGuiWindow * window.642;
  float iftmp.641;
  struct ImGuiWindow * window.640;
  int D.31503;
  struct ImGuiWindow * window.639;
  bool D.31499;
  int D.31498;
  struct ImGuiWindow * window.638;
  int D.31495;
  struct ImGuiWindow * window.637;
  float D.31490;
  float D.31489;
  struct ImGuiWindow * window.636;
  bool D.31485;
  float D.31483;
  float D.31482;
  struct ImGuiWindow * window.635;
  bool D.31478;
  bool D.31476;
  bool D.31475;
  struct ImGuiWindow * window.634;
  int D.31472;
  struct ImGuiWindow * window.633;
  struct ImVec2 * D.31468;
  struct ImGuiWindow * window.632;
  struct ImGuiWindow * window.631;
  bool D.31465;
  bool D.31463;
  struct ImVec2 D.17745;
  struct ImGuiWindow * window.630;
  float D.31454;
  struct ImGuiWindow * window.629;
  struct ImGuiWindow * window.628;
  bool D.31449;
  float D.31447;
  struct ImGuiWindow * window.627;
  struct ImGuiWindow * window.626;
  bool D.31442;
  int D.31439;
  struct ImGuiWindow * window.625;
  int D.31435;
  int D.31431;
  int D.31430;
  struct ImGuiWindow * window.624;
  int D.31426;
  struct ImGuiWindow * window.623;
  struct ImGuiWindow * window.622;
  struct ImGuiWindow * window.621;
  struct ImGuiWindow * window.620;
  struct ImGuiWindow * window.619;
  struct ImGuiWindow * window.618;
  struct ImGuiWindow * window.617;
  bool D.31417;
  bool D.31416;
  struct ImGuiWindow * window.616;
  struct ImGuiWindow * window.615;
  bool D.31411;
  bool D.31409;
  struct ImGuiWindow * window.614;
  struct ImGuiWindow * D.31406;
  bool D.31404;
  struct ImGuiWindow * window.613;
  bool iftmp.612;
  bool retval.611;
  struct ImGuiWindow * window.610;
  int D.31395;
  int D.31393;
  int D.31386;
  float iftmp.609;
  struct ImVec2 D.17741;
  struct ImGuiWindow * window.608;
  float D.31381;
  struct ImGuiWindow * window.607;
  int D.31377;
  int D.31374;
  struct ImGuiWindow * window.606;
  int D.31371;
  int D.31369;
  const float iftmp.605;
  int D.31362;
  const float iftmp.604;
  struct ImGuiWindow * window.603;
  int D.31358;
  int D.31356;
  const float iftmp.602;
  int D.31349;
  const float iftmp.601;
  struct ImGuiWindow * window.600;
  struct ImVector * D.31346;
  struct ImGuiWindow * window.599;
  struct ImGuiWindow * window.598;
  struct ImVec4 D.17739;
  struct ImRect D.17740;
  struct ImGuiWindow * window.597;
  struct ImGuiWindow * window.596;
  int D.31341;
  int D.31340;
  int D.31339;
  struct ImGuiWindow * window.595;
  struct ImGuiWindow * window.594;
  struct ImGuiWindow * window.593;
  struct ImGuiWindow * D.31335;
  struct ImGuiWindow * D.31334;
  struct ImGuiWindow * window.592;
  struct ImGuiWindow * window.591;
  int D.31330;
  int D.31329;
  struct ImGuiWindow * D.31328;
  struct ImGuiWindow * window.590;
  struct ImGuiWindow * D.31324;
  struct ImGuiWindow * D.31323;
  struct ImGuiWindow * window.589;
  struct ImGuiWindow * window.588;
  int D.31318;
  int D.31315;
  struct ImGuiWindow * D.31311;
  struct ImGuiWindow * window.587;
  bool D.31307;
  int D.31304;
  struct ImGuiWindow * D.31301;
  struct ImGuiWindow * D.31300;
  struct ImGuiWindow * D.31299;
  struct ImGuiWindow * window.586;
  struct ImGuiWindow * window.585;
  struct ImGuiWindow * window.584;
  struct ImGuiWindow * window.583;
  struct ImGuiWindow * window.582;
  struct ImGuiWindow * window.581;
  int D.31291;
  int D.31289;
  bool iftmp.580;
  struct ImGuiWindow * window.579;
  bool D.31279;
  struct ImGuiWindow * window.578;
  int D.31274;
  struct ImGuiWindow * window.577;
  int D.31271;
  bool D.31270;
  int D.31269;
  int D.31266;
  struct ImVec2 D.17737;
  struct ImGuiWindow * window.576;
  float D.31259;
  float D.31258;
  struct ImGuiWindow * window.575;
  struct ImGuiWindow * window.574;
  float D.31255;
  struct ImGuiWindow * window.573;
  float D.31253;
  struct ImGuiWindow * window.572;
  float D.17736;
  float D.31249;
  struct ImGuiWindow * window.571;
  struct ImGuiWindow * window.570;
  int D.31244;
  struct ImGuiWindow * window.569;
  struct ImVec2 * D.31241;
  int D.31240;
  float D.31238;
  int D.31236;
  int D.31235;
  int D.31234;
  struct ImGuiWindow * window.568;
  bool iftmp.567;
  float D.31228;
  int D.31226;
  int D.31225;
  int D.31224;
  struct ImGuiWindow * window.566;
  bool iftmp.565;
  int D.31217;
  struct ImGuiWindow * window.564;
  struct ImVec2 * D.31214;
  int D.31213;
  int D.31211;
  int D.31210;
  struct ImGuiWindow * window.563;
  struct ImGuiWindow * window.562;
  struct ImGuiWindow * window.561;
  struct ImGuiWindow * window.560;
  float D.31202;
  struct ImVec2 * D.31201;
  bool window_pos_set_by_api.559;
  bool iftmp.558;
  bool retval.557;
  bool window_pos_set_by_api.556;
  int D.31193;
  int D.31192;
  int D.31191;
  struct ImGuiWindow * window.555;
  int D.31187;
  struct ImGuiWindow * window.554;
  int D.31182;
  unsigned int D.31178;
  struct ImGuiWindow * window.553;
  struct ImVector * D.31176;
  struct ImGuiWindow * window.552;
  struct ImVector * D.31174;
  int D.31173;
  int D.31170;
  struct ImGuiWindow * window.551;
  struct ImGuiWindow * window.550;
  struct ImVector * D.31167;
  int D.31163;
  struct ImGuiWindow * window.549;
  int D.31155;
  struct ImGuiWindow * iftmp.548;
  struct ImGuiWindow * iftmp.547;
  struct ImGuiWindow * & D.31150;
  struct ImVector * D.31149;
  bool D.31145;
  struct ImVector * D.31144;
  struct ImGuiWindow * iftmp.546;
  struct ImGuiWindow * window.545;
  bool D.31138;
  struct ImGuiWindow * window.544;
  bool D.31136;
  struct ImGuiWindow * window.543;
  bool iftmp.542;
  struct ImGuiWindow * window.541;
  int D.31127;
  int D.31126;
  bool D.31125;
  struct ImGuiWindow * window.540;
  struct ImGuiWindow * D.31123;
  int D.31122;
  int D.31121;
  int D.31120;
  bool D.31119;
  unsigned int D.31118;
  unsigned int D.31117;
  struct ImGuiWindow * window.539;
  int D.31115;
  struct ImVector * D.31114;
  int D.31113;
  int D.31110;
  int D.31109;
  struct ImGuiWindow * window.538;
  int D.31107;
  int D.31106;
  struct ImGuiWindow * window.537;
  struct ImGuiWindow * window.536;
  struct ImGuiWindow * window.535;
  int D.31099;
  struct ImGuiWindow * window.534;
  int D.31093;
  int D.31090;
  int D.31086;
  struct ImGuiWindow * window.533;
  int D.31080;
  struct ImGuiWindow * window.532;
  struct ImGuiWindow * window.531;
  int D.31072;
  int D.31071;
  bool D.31067;
  bool iftmp.542_12;
  struct ImGuiWindow * iftmp.546_13;
  struct ImGuiWindow * iftmp.547_14;
  struct ImGuiWindow * iftmp.548_15;
  bool iftmp.558_16;
  bool iftmp.565_17;
  bool iftmp.567_18;
  bool iftmp.580_19;
  const float iftmp.601_20;
  const float iftmp.602_21;
  const float iftmp.604_22;
  const float iftmp.605_23;
  float iftmp.609_24;
  bool iftmp.612_25;
  float iftmp.641_26;
  float iftmp.646_27;
  float iftmp.659_28;
  float iftmp.662_29;
  bool iftmp.666_30;
  bool iftmp.669_31;
  float iftmp.671_32;
  bool iftmp.676_33;
  float iftmp.679_34;
  float iftmp.681_35;
  bool iftmp.693_36;
  int iftmp.740_37;
  int iftmp.747_38;
  int iftmp.760_39;
  int iftmp.766_40;
  int iftmp.767_41;
  bool iftmp.770_42;
  bool iftmp.779_43;
  ImGuiCol iftmp.784_44;
  int iftmp.785_45;
  ImGuiCol iftmp.791_46;
  ImGuiCol iftmp.793_47;
  float iftmp.797_48;
  float iftmp.839_49;
  float iftmp.847_50;
  int iftmp.888_51;
  ImGuiDir iftmp.924_52;
  float iftmp.934_53;
  float iftmp.935_54;
  float iftmp.938_55;
  const float iftmp.947_56;
  int iftmp.974_57;
  bool iftmp.981_58;
  bool iftmp.986_59;
  bool iftmp.995_60;
  bool _162;
  int _163;
  int _164;
  struct ImGuiWindow * _166;
  struct ImGuiWindow * window.531_167;
  struct ImGuiWindow * window.532_169;
  int _171;
  struct ImGuiWindow * _176;
  struct ImGuiWindow * window.533_177;
  int _181;
  int _183;
  int _184;
  struct ImGuiWindow * window.534_187;
  int _188;
  struct ImGuiWindow * window.535_190;
  struct ImGuiWindow * window.536_192;
  struct ImGuiWindow * window.537_194;
  int _195;
  int _196;
  struct ImGuiWindow * window.538_198;
  int _199;
  int _201;
  int _202;
  struct ImVector * _203;
  int _206;
  struct ImGuiWindow * window.539_207;
  unsigned int _208;
  unsigned int _209;
  bool _210;
  int _211;
  int _212;
  int _214;
  struct ImGuiWindow * _215;
  struct ImGuiWindow * window.540_216;
  bool _217;
  int _218;
  int _219;
  struct ImGuiWindow * window.541_221;
  bool iftmp.542_222;
  bool iftmp.542_223;
  struct ImGuiWindow * window.543_225;
  bool _227;
  struct ImGuiWindow * window.544_229;
  bool _230;
  struct ImGuiWindow * window.545_231;
  struct ImVector * _233;
  bool _235;
  struct ImGuiWindow * iftmp.546_236;
  struct ImVector * _237;
  struct ImGuiWindow * & _239;
  struct ImGuiWindow * iftmp.546_240;
  int _242;
  struct ImGuiWindow * iftmp.548_243;
  struct ImGuiWindow * iftmp.548_244;
  struct ImGuiWindow * iftmp.547_245;
  struct ImGuiWindow * window.549_246;
  struct ImGuiWindow * iftmp.547_247;
  int _249;
  struct ImVector * _251;
  struct ImGuiWindow * window.550_253;
  struct ImGuiWindow * window.551_255;
  int _257;
  int _258;
  struct ImVector * _259;
  struct ImGuiWindow * window.552_262;
  struct ImVector * _264;
  struct ImGuiWindow * window.553_266;
  unsigned int _267;
  int _269;
  struct ImGuiWindow * window.554_270;
  int _275;
  struct ImGuiWindow * window.555_276;
  int _277;
  int _278;
  int _279;
  bool window_pos_set_by_api.556_280;
  bool window_pos_set_by_api.559_282;
  struct ImVec2 * _283;
  float _285;
  bool iftmp.558_286;
  bool iftmp.558_287;
  bool retval.557_288;
  struct ImGuiWindow * window.560_289;
  struct ImGuiWindow * window.561_291;
  struct ImGuiWindow * window.562_293;
  struct ImGuiWindow * window.563_294;
  int _295;
  int _296;
  int _298;
  struct ImVec2 * _299;
  struct ImGuiWindow * window.564_300;
  int _303;
  struct ImGuiWindow * window.566_304;
  int _305;
  int _306;
  int _307;
  float _308;
  bool iftmp.565_309;
  bool iftmp.565_310;
  struct ImGuiWindow * window.568_312;
  int _313;
  int _314;
  int _315;
  float _316;
  bool iftmp.567_317;
  bool iftmp.567_318;
  int _320;
  struct ImVec2 * _321;
  struct ImGuiWindow * window.569_322;
  int _325;
  struct ImGuiWindow * window.570_326;
  struct ImGuiWindow * window.571_328;
  float _329;
  struct ImGuiWindow * window.572_330;
  float _332;
  struct ImGuiWindow * window.573_333;
  float _335;
  float _336;
  struct ImGuiWindow * window.574_337;
  struct ImGuiWindow * window.575_338;
  float _339;
  float _340;
  struct ImGuiWindow * window.576_343;
  int _347;
  int _348;
  bool _349;
  int _350;
  struct ImGuiWindow * window.577_351;
  int _354;
  struct ImGuiWindow * window.578_357;
  bool _358;
  struct ImGuiWindow * window.579_359;
  int _361;
  int _362;
  bool iftmp.580_363;
  bool iftmp.580_364;
  struct ImGuiWindow * window.581_366;
  struct ImGuiWindow * window.582_368;
  struct ImGuiWindow * window.583_369;
  struct ImGuiWindow * window.584_370;
  struct ImGuiWindow * window.585_371;
  struct ImGuiWindow * window.586_372;
  struct ImGuiWindow * _374;
  struct ImGuiWindow * _376;
  struct ImGuiWindow * _378;
  int _380;
  bool _381;
  struct ImGuiWindow * window.587_382;
  struct ImGuiWindow * _383;
  int _385;
  int _386;
  struct ImGuiWindow * window.588_387;
  struct ImGuiWindow * window.589_388;
  struct ImGuiWindow * _389;
  struct ImGuiWindow * _391;
  struct ImGuiWindow * window.590_393;
  struct ImGuiWindow * _394;
  int _395;
  int _396;
  struct ImGuiWindow * window.591_397;
  struct ImGuiWindow * window.592_398;
  struct ImGuiWindow * _399;
  struct ImGuiWindow * _400;
  struct ImGuiWindow * window.593_402;
  struct ImGuiWindow * window.594_404;
  struct ImGuiWindow * window.595_406;
  int _407;
  int _408;
  int _409;
  struct ImGuiWindow * window.596_412;
  struct ImGuiWindow * window.597_414;
  struct ImGuiWindow * window.598_420;
  struct ImGuiWindow * window.599_422;
  struct ImVector * _423;
  struct ImGuiWindow * window.600_425;
  int _426;
  const float iftmp.601_427;
  int _428;
  int _429;
  const float iftmp.602_430;
  const float iftmp.602_431;
  const float iftmp.601_432;
  struct ImGuiWindow * window.603_434;
  int _435;
  const float iftmp.604_436;
  int _437;
  int _438;
  const float iftmp.605_439;
  const float iftmp.605_440;
  const float iftmp.604_441;
  struct ImGuiWindow * window.606_443;
  int _445;
  int _446;
  struct ImGuiWindow * window.607_447;
  float _448;
  struct ImGuiWindow * window.608_449;
  int _450;
  float iftmp.609_451;
  float iftmp.609_452;
  int _456;
  int _457;
  struct ImGuiWindow * window.610_458;
  struct ImGuiWindow * window.613_460;
  bool _461;
  struct ImGuiWindow * _462;
  struct ImGuiWindow * window.614_463;
  bool _465;
  bool _466;
  bool iftmp.612_467;
  bool iftmp.612_468;
  bool retval.611_469;
  struct ImGuiWindow * window.615_470;
  struct ImGuiWindow * window.616_471;
  bool _472;
  bool _473;
  struct ImGuiWindow * window.617_475;
  struct ImGuiWindow * window.618_477;
  struct ImGuiWindow * window.619_481;
  struct ImGuiWindow * window.620_483;
  struct ImGuiWindow * window.621_485;
  struct ImGuiWindow * window.622_486;
  struct ImGuiWindow * window.623_488;
  int _489;
  struct ImGuiWindow * window.624_490;
  int _491;
  int _492;
  int _494;
  struct ImGuiWindow * window.625_495;
  int _497;
  bool _498;
  struct ImGuiWindow * window.626_499;
  struct ImGuiWindow * window.627_500;
  float _502;
  bool _504;
  struct ImGuiWindow * window.628_505;
  struct ImGuiWindow * window.629_506;
  float _508;
  struct ImGuiWindow * window.630_510;
  bool _514;
  bool _515;
  struct ImGuiWindow * window.631_516;
  struct ImGuiWindow * window.632_518;
  struct ImVec2 * _519;
  struct ImGuiWindow * window.633_520;
  int _523;
  struct ImGuiWindow * window.634_524;
  bool _525;
  bool _526;
  bool _527;
  struct ImGuiWindow * window.635_528;
  float _529;
  float _531;
  bool _533;
  struct ImGuiWindow * window.636_534;
  float _535;
  float _537;
  struct ImGuiWindow * window.637_539;
  int _540;
  struct ImGuiWindow * window.638_541;
  int _542;
  bool _543;
  struct ImGuiWindow * window.639_544;
  int _545;
  struct ImGuiWindow * window.640_546;
  struct ImGuiWindow * window.642_547;
  bool _548;
  float _549;
  struct ImGuiWindow * window.643_550;
  float _551;
  float iftmp.641_553;
  float iftmp.641_554;
  float _556;
  bool _558;
  struct ImGuiWindow * window.644_559;
  int _560;
  struct ImGuiWindow * window.645_561;
  struct ImGuiWindow * window.647_562;
  bool _563;
  float _564;
  struct ImGuiWindow * window.648_565;
  float _566;
  float iftmp.646_568;
  float iftmp.646_569;
  float _571;
  struct ImGuiWindow * window.649_573;
  bool _574;
  bool _575;
  struct ImGuiWindow * window.650_576;
  struct ImGuiWindow * window.651_578;
  struct ImGuiWindow * window.652_579;
  struct ImGuiWindow * window.653_580;
  struct ImGuiWindow * window.654_582;
  struct ImGuiWindow * window.655_583;
  bool _584;
  int _585;
  struct ImGuiWindow * window.656_586;
  struct ImGuiWindow * window.657_589;
  struct ImGuiWindow * window.658_592;
  bool _593;
  bool _594;
  float _595;
  struct ImGuiWindow * window.660_596;
  float iftmp.659_597;
  struct ImGuiWindow * window.661_598;
  float iftmp.659_599;
  float _601;
  struct ImGuiWindow * window.663_602;
  float iftmp.662_603;
  struct ImGuiWindow * window.664_604;
  float iftmp.662_605;
  struct ImGuiWindow * window.665_607;
  int _608;
  struct ImGuiWindow * window.667_609;
  float _610;
  int _611;
  bool iftmp.666_612;
  bool iftmp.666_613;
  struct ImGuiWindow * window.668_615;
  int _616;
  struct ImGuiWindow * window.670_617;
  float _618;
  struct ImGuiWindow * window.672_619;
  bool _620;
  float iftmp.671_621;
  float iftmp.671_622;
  float _623;
  int _624;
  int _625;
  bool iftmp.669_626;
  bool iftmp.669_627;
  struct ImGuiWindow * window.673_629;
  bool _630;
  struct ImGuiWindow * window.674_631;
  bool _632;
  bool _633;
  struct ImGuiWindow * window.675_634;
  struct ImGuiWindow * window.677_635;
  float _636;
  float _637;
  float _638;
  int _639;
  bool iftmp.676_640;
  bool iftmp.676_641;
  struct ImGuiWindow * window.678_643;
  struct ImGuiWindow * window.680_644;
  bool _645;
  float iftmp.679_646;
  float iftmp.679_647;
  struct ImGuiWindow * window.682_648;
  bool _649;
  float iftmp.681_650;
  float iftmp.681_651;
  struct ImGuiWindow * window.683_655;
  int _657;
  bool window_pos_set_by_api.684_658;
  bool _659;
  struct ImGuiWindow * window.685_660;
  struct ImGuiWindow * window.686_661;
  struct ImVector * _662;
  struct value_type & _664;
  struct ImGuiWindow * window.687_666;
  struct ImVec2 * _667;
  int _669;
  struct ImGuiWindow * window.688_670;
  int _671;
  struct ImVector * _673;
  int _675;
  bool window_pos_set_by_api.689_676;
  bool _677;
  bool _678;
  struct ImGuiWindow * window.690_679;
  struct ImGuiWindow * window.691_680;
  struct ImGuiWindow * window.692_682;
  struct ImVec2 * _683;
  struct ImGuiWindow * window.694_685;
  float _686;
  struct ImGuiWindow * window.695_687;
  int _688;
  bool iftmp.693_689;
  bool iftmp.693_690;
  struct ImGuiWindow * window.696_692;
  struct ImVec2 * _693;
  struct ImGuiWindow * window.697_694;
  struct ImVec2 * _695;
  struct ImGuiWindow * window.698_697;
  struct ImVec2 * _698;
  const struct ImVec2 * _700;
  struct ImGuiWindow * window.699_702;
  int _707;
  bool window_pos_set_by_api.700_708;
  bool _712;
  float _713;
  float _715;
  float _716;
  float _718;
  float _719;
  float _720;
  float _722;
  float _723;
  float _727;
  float _728;
  float _729;
  float _730;
  float _731;
  float _732;
  float _733;
  float _734;
  struct ImGuiWindow * window.703_738;
  struct ImGuiWindow * window.704_739;
  ImGuiDir * _740;
  struct ImGuiWindow * window.705_741;
  struct ImVec2 * _742;
  struct ImGuiWindow * window.706_743;
  struct ImVec2 * _744;
  int _748;
  bool window_pos_set_by_api.707_749;
  bool _750;
  struct ImGuiWindow * window.708_751;
  float _752;
  float _753;
  struct ImGuiWindow * window.709_754;
  float _755;
  float _756;
  struct ImGuiWindow * window.710_757;
  float _758;
  float _759;
  struct ImGuiWindow * window.711_760;
  float _761;
  float _762;
  struct ImGuiWindow * window.712_764;
  struct ImGuiWindow * window.713_765;
  ImGuiDir * _766;
  struct ImGuiWindow * window.714_767;
  struct ImVec2 * _768;
  struct ImGuiWindow * window.715_769;
  struct ImVec2 * _770;
  int _773;
  bool window_pos_set_by_api.716_774;
  bool _775;
  bool _776;
  bool _778;
  bool _779;
  bool _780;
  bool _786;
  bool _787;
  bool _788;
  int _789;
  int _790;
  float _791;
  float _792;
  float _793;
  float _794;
  float _795;
  float _796;
  float _797;
  float _798;
  float _802;
  float _803;
  float _804;
  float _805;
  float _806;
  float _807;
  float _808;
  float _809;
  float _810;
  float _811;
  struct ImGuiWindow * window.719_815;
  struct ImGuiWindow * window.720_816;
  ImGuiDir * _817;
  struct ImGuiWindow * window.721_818;
  struct ImVec2 * _819;
  struct ImGuiWindow * window.722_821;
  int _822;
  struct ImGuiWindow * window.723_823;
  int _829;
  int _830;
  bool window_pos_set_by_api.724_831;
  bool _832;
  struct ImGuiWindow * window.725_833;
  int _834;
  struct ImGuiWindow * window.726_835;
  int _836;
  float _837;
  float _838;
  const struct ImVec2 * _839;
  const struct ImVec2 * _840;
  struct ImGuiWindow * window.727_842;
  struct ImGuiWindow * window.728_843;
  struct ImVec2 * _844;
  struct ImGuiWindow * window.729_845;
  struct ImVec2 * _846;
  struct ImGuiWindow * window.730_847;
  struct ImVec2 * _848;
  struct ImGuiWindow * window.731_854;
  struct ImVec2 * _855;
  struct ImGuiWindow * window.732_857;
  struct ImVec2 * _858;
  struct ImGuiWindow * window.733_862;
  struct ImGuiWindow * window.734_863;
  struct ImVec2 * _864;
  struct ImGuiWindow * window.735_866;
  float _867;
  int _868;
  int _869;
  struct ImGuiWindow * window.736_870;
  struct ImGuiWindow * window.737_871;
  float _872;
  float _873;
  int _874;
  float _875;
  struct ImGuiWindow * window.738_877;
  float _878;
  float _879;
  int _880;
  float _881;
  struct ImGuiWindow * window.739_883;
  struct ImGuiWindow * window.741_884;
  int _885;
  struct ImGuiWindow * window.742_886;
  int _887;
  struct ImGuiWindow * window.743_888;
  int _889;
  struct ImGuiWindow * window.744_890;
  int _891;
  int _892;
  int _893;
  struct ImGuiWindow * window.745_894;
  int _895;
  int _896;
  int iftmp.740_897;
  int iftmp.740_898;
  struct ImGuiWindow * window.746_900;
  struct ImGuiWindow * window.748_901;
  int _902;
  struct ImGuiWindow * window.749_903;
  int _904;
  struct ImGuiWindow * window.750_905;
  int _906;
  struct ImGuiWindow * window.751_907;
  int _908;
  int _909;
  int _910;
  struct ImGuiWindow * window.752_911;
  int _912;
  int _913;
  int iftmp.747_914;
  int iftmp.747_915;
  struct ImGuiWindow * window.753_917;
  struct ImGuiWindow * window.754_918;
  int _920;
  struct ImGuiWindow * window.755_922;
  struct ImGuiWindow * window.756_923;
  int _925;
  struct ImGuiWindow * window.757_927;
  struct ImGuiWindow * window.758_928;
  struct ImGuiWindow * window.759_930;
  int _935;
  int _936;
  int _937;
  int _941;
  int iftmp.760_942;
  int iftmp.760_943;
  struct ImGuiWindow * window.761_945;
  float _946;
  float _947;
  float _948;
  float _949;
  float _950;
  float _951;
  float _952;
  float _954;
  int _955;
  struct ImGuiWindow * window.762_957;
  bool _958;
  bool _959;
  struct ImGuiWindow * window.763_960;
  struct ImGuiWindow * window.764_962;
  struct ImDrawList * _963;
  struct ImGuiWindow * window.765_965;
  struct ImDrawList * _966;
  bool _967;
  int iftmp.766_968;
  int iftmp.766_969;
  bool _970;
  int iftmp.767_971;
  int iftmp.767_972;
  int _973;
  struct ImFont * _975;
  struct ImFontAtlas * _976;
  void * _977;
  struct ImGuiWindow * window.768_978;
  struct ImDrawList * _979;
  int _982;
  int _983;
  bool _984;
  struct ImVec2 * _985;
  struct ImVec2 * _986;
  int _989;
  struct ImGuiWindow * _991;
  struct ImGuiWindow * window.771_992;
  bool iftmp.770_993;
  bool iftmp.770_994;
  bool retval.769_995;
  float _996;
  unsigned int _998;
  struct ImGuiWindow * window.772_999;
  struct ImDrawList * _1000;
  struct ImGuiWindow * _1002;
  struct ImGuiWindow * window.773_1003;
  struct ImGuiWindow * window.774_1004;
  float _1006;
  bool _1009;
  bool retval.775_1010;
  float _1011;
  float _1012;
  float _1013;
  unsigned int _1015;
  struct ImGuiWindow * window.776_1016;
  struct ImDrawList * _1017;
  struct ImGuiWindow * window.777_1021;
  struct ImGuiWindow * window.778_1023;
  struct ImGuiWindow * _1025;
  struct ImGuiWindow * window.780_1026;
  struct ImGuiWindow * _1027;
  struct ImGuiWindow * _1028;
  struct ImGuiWindow * _1029;
  bool iftmp.779_1030;
  bool iftmp.779_1031;
  struct ImGuiWindow * window.781_1033;
  struct ImGuiWindow * window.782_1035;
  bool _1036;
  struct ImGuiWindow * window.783_1038;
  float _1039;
  bool _1041;
  bool _1042;
  ImGuiCol iftmp.784_1043;
  ImGuiCol iftmp.784_1044;
  int _1050;
  int _1053;
  unsigned int _1054;
  float _1055;
  float _1057;
  float _1058;
  float _1059;
  int _1060;
  int _1061;
  unsigned int _1062;
  int _1065;
  int iftmp.785_1066;
  int iftmp.785_1067;
  struct ImGuiWindow * window.786_1068;
  struct ImVec2 * _1069;
  struct ImGuiWindow * window.787_1070;
  struct ImVec2 * _1071;
  struct ImGuiWindow * window.788_1073;
  float _1075;
  struct ImGuiWindow * window.789_1077;
  struct ImVec2 * _1078;
  struct ImGuiWindow * window.790_1080;
  struct ImDrawList * _1081;
  struct ImGuiWindow * window.792_1086;
  bool _1087;
  ImGuiCol iftmp.791_1088;
  ImGuiCol iftmp.793_1089;
  ImGuiCol iftmp.793_1090;
  ImGuiCol iftmp.791_1091;
  int _1094;
  struct ImGuiWindow * window.794_1095;
  struct ImDrawList * _1096;
  int _1098;
  struct ImGuiWindow * window.795_1099;
  struct ImGuiWindow * window.796_1101;
  int _1105;
  float iftmp.797_1106;
  float iftmp.797_1107;
  unsigned int _1109;
  struct ImGuiWindow * window.798_1110;
  struct ImDrawList * _1111;
  float _1113;
  float _1114;
  struct ImGuiWindow * window.799_1115;
  float _1116;
  struct ImGuiWindow * window.800_1117;
  float _1118;
  float _1119;
  float _1120;
  unsigned int _1122;
  struct ImGuiWindow * window.801_1125;
  struct ImDrawList * _1126;
  struct ImGuiWindow * window.802_1134;
  bool _1135;
  struct ImGuiWindow * window.803_1137;
  bool _1138;
  int _1140;
  const struct ImVec2 * _1143;
  struct ImGuiWindow * window.804_1144;
  struct ImVec2 * _1145;
  struct ImGuiWindow * window.805_1146;
  struct ImVec2 * _1147;
  struct ImGuiWindow * window.806_1149;
  struct ImVec2 * _1150;
  int _1153;
  const struct ImVec2 * _1156;
  struct ImGuiWindow * window.807_1159;
  struct ImDrawList * _1160;
  int _1165;
  const struct ImVec2 * _1168;
  struct ImGuiWindow * window.808_1171;
  struct ImDrawList * _1172;
  int _1177;
  int _1178;
  float _1179;
  float _1180;
  float _1181;
  float _1182;
  float _1183;
  float _1184;
  float _1185;
  float _1186;
  float _1187;
  float _1188;
  struct ImGuiWindow * window.809_1190;
  struct ImDrawList * _1191;
  unsigned int _1194;
  struct ImGuiWindow * window.810_1195;
  struct ImDrawList * _1196;
  unsigned int _1209;
  struct ImGuiWindow * window.811_1210;
  struct ImVec2 * _1211;
  struct ImGuiWindow * window.812_1212;
  struct ImVec2 * _1213;
  struct ImGuiWindow * window.813_1215;
  struct ImVec2 * _1216;
  struct ImGuiWindow * window.814_1217;
  struct ImDrawList * _1218;
  int border_held.815_1222;
  int border_held.816_1223;
  struct ImGuiWindow * window.817_1224;
  float _1227;
  unsigned int _1229;
  struct ImGuiWindow * window.818_1230;
  struct ImDrawList * _1231;
  float _1235;
  int _1236;
  float _1237;
  unsigned int _1239;
  float _1240;
  float _1241;
  float _1245;
  struct ImGuiWindow * window.819_1249;
  struct ImDrawList * _1250;
  struct ImGuiWindow * _1267;
  struct ImGuiWindow * window.820_1268;
  float _1269;
  struct ImGuiWindow * window.821_1270;
  float _1271;
  struct ImGuiWindow * window.822_1274;
  float _1276;
  bool retval.823_1279;
  float _1280;
  float _1281;
  float _1282;
  struct ImGuiWindow * window.824_1284;
  float _1286;
  unsigned int _1288;
  struct ImGuiWindow * window.825_1289;
  struct ImDrawList * _1290;
  struct ImGuiWindow * window.826_1294;
  struct ImGuiWindow * window.827_1295;
  struct ImGuiWindow * window.828_1297;
  struct ImGuiWindow * window.829_1298;
  float _1299;
  struct ImGuiWindow * window.830_1300;
  float _1301;
  float _1302;
  struct ImGuiWindow * window.831_1304;
  struct ImGuiWindow * window.832_1305;
  float _1306;
  struct ImGuiWindow * window.833_1307;
  float _1308;
  float _1309;
  struct ImGuiWindow * window.834_1310;
  float _1312;
  float _1313;
  struct ImGuiWindow * window.835_1314;
  float _1316;
  float _1317;
  struct ImGuiWindow * window.836_1319;
  struct ImGuiWindow * window.837_1320;
  float _1321;
  float _1322;
  struct ImGuiWindow * window.838_1323;
  float _1324;
  float _1325;
  struct ImGuiWindow * window.840_1326;
  float _1327;
  struct ImGuiWindow * window.841_1328;
  float iftmp.839_1329;
  struct ImGuiWindow * window.842_1330;
  float _1331;
  struct ImGuiWindow * window.843_1332;
  float _1333;
  float iftmp.839_1334;
  float _1335;
  struct ImGuiWindow * window.844_1337;
  struct ImGuiWindow * window.845_1338;
  float _1339;
  float _1340;
  struct ImGuiWindow * window.846_1341;
  float _1342;
  float _1343;
  struct ImGuiWindow * window.848_1344;
  float _1345;
  struct ImGuiWindow * window.849_1346;
  float iftmp.847_1347;
  struct ImGuiWindow * window.850_1348;
  float _1349;
  struct ImGuiWindow * window.851_1350;
  float _1351;
  float iftmp.847_1352;
  float _1353;
  struct ImGuiWindow * window.852_1355;
  struct ImGuiWindow * window.853_1356;
  float _1357;
  float _1358;
  struct ImGuiWindow * window.854_1359;
  float _1360;
  float _1361;
  struct ImGuiWindow * window.855_1363;
  struct ImGuiWindow * window.856_1365;
  struct ImGuiWindow * window.857_1367;
  struct ImGuiWindow * window.858_1368;
  float _1370;
  struct ImGuiWindow * window.859_1371;
  float _1373;
  float _1374;
  struct ImGuiWindow * window.860_1375;
  float _1376;
  float _1377;
  struct ImGuiWindow * window.861_1378;
  float _1379;
  float _1380;
  struct ImGuiWindow * window.862_1381;
  float _1382;
  struct ImGuiWindow * window.863_1383;
  float _1384;
  float _1385;
  struct ImGuiWindow * window.864_1387;
  struct ImVec2 * _1388;
  struct ImGuiWindow * window.865_1391;
  struct ImGuiWindow * window.866_1392;
  struct ImGuiWindow * window.867_1394;
  struct ImGuiWindow * window.868_1395;
  struct ImGuiWindow * window.869_1397;
  struct ImGuiWindow * window.870_1398;
  struct ImGuiWindow * window.871_1400;
  struct ImGuiWindow * window.872_1401;
  float _1403;
  struct ImGuiWindow * window.873_1405;
  struct ImGuiWindow * window.874_1406;
  float _1408;
  struct ImGuiWindow * window.875_1410;
  struct ImGuiWindow * window.876_1412;
  float _1414;
  bool _1415;
  struct ImGuiWindow * window.877_1417;
  struct ImGuiWindow * window.878_1418;
  int _1419;
  struct ImGuiWindow * window.879_1421;
  struct ImGuiWindow * window.880_1423;
  struct ImGuiWindow * window.881_1425;
  float _1426;
  struct ImGuiWindow * window.882_1427;
  float _1428;
  float _1430;
  struct ImGuiWindow * window.883_1432;
  struct ImGuiWindow * window.884_1433;
  float _1434;
  float _1435;
  struct ImGuiWindow * window.885_1437;
  struct ImVector * _1438;
  struct ImGuiWindow * window.886_1440;
  struct ImGuiWindow * window.887_1442;
  int iftmp.888_1443;
  int iftmp.888_1444;
  struct ImGuiWindow * window.889_1446;
  struct ImGuiWindow * window.890_1448;
  struct ImGuiWindow * window.891_1449;
  float _1450;
  struct ImGuiWindow * window.892_1452;
  struct ImGuiWindow * window.893_1454;
  struct ImVector * _1455;
  struct ImGuiWindow * window.894_1457;
  struct ImVector * _1458;
  struct ImGuiWindow * window.895_1460;
  struct ImVector * _1461;
  struct ImGuiWindow * window.896_1463;
  struct ImGuiWindow * window.897_1465;
  struct ImGuiWindow * window.898_1467;
  struct ImGuiWindow * window.899_1469;
  struct ImGuiWindow * window.900_1470;
  struct ImGuiStorage * _1471;
  struct ImGuiWindow * window.901_1473;
  struct ImVector * _1474;
  int _1476;
  float _1477;
  struct ImGuiWindow * window.902_1478;
  struct ImGuiMenuColumns * _1479;
  int _1481;
  struct ImGuiWindow * window.903_1482;
  int _1483;
  int _1484;
  struct ImGuiWindow * window.904_1485;
  int _1486;
  struct ImGuiWindow * window.905_1488;
  ImGuiItemFlags * _1489;
  struct ImGuiWindow * window.906_1490;
  struct ImVector * _1491;
  struct ImGuiWindow * window.907_1493;
  int _1494;
  struct ImGuiWindow * window.908_1495;
  int _1496;
  int _1497;
  struct ImGuiWindow * window.909_1499;
  int _1500;
  struct ImGuiWindow * window.910_1501;
  int _1502;
  int _1503;
  struct ImGuiWindow * window.911_1505;
  struct ImGuiWindow * window.912_1507;
  int _1509;
  struct ImGuiWindow * window.913_1510;
  struct ImGuiWindow * window.914_1512;
  struct ImGuiWindow * window.915_1513;
  int _1514;
  int _1515;
  struct ImGuiWindow * window.916_1517;
  int _1518;
  int _1519;
  struct ImGuiWindow * window.917_1521;
  struct ImGuiWindow * window.918_1522;
  int _1523;
  int _1524;
  int _1526;
  struct ImGuiWindow * window.919_1527;
  ImGuiID _1529;
  float _1532;
  float _1533;
  const struct ImVec2 * _1535;
  struct ImGuiWindow * window.920_1536;
  struct ImVec2 * _1537;
  const struct ImVec2 * _1542;
  struct ImGuiWindow * window.921_1543;
  struct ImVec2 * _1544;
  bool _1558;
  bool retval.922_1559;
  struct ImGuiWindow * window.923_1560;
  struct ImGuiWindow * window.925_1563;
  bool _1564;
  ImGuiDir iftmp.924_1565;
  ImGuiDir iftmp.924_1566;
  const struct ImVec2 * _1567;
  struct ImGuiWindow * window.926_1568;
  struct ImVec2 * _1569;
  float _1575;
  float _1577;
  float _1578;
  float _1579;
  float _1580;
  struct ImGuiWindow * window.928_1582;
  struct ImGuiWindow * window.929_1586;
  unsigned int _1588;
  unsigned int _1589;
  bool _1591;
  bool retval.927_1592;
  struct ImGuiWindow * window.930_1602;
  int _1603;
  int _1604;
  struct ImGuiWindow * window.931_1606;
  struct ImGuiWindow * window.932_1607;
  int _1608;
  int _1609;
  struct ImGuiWindow * window.933_1611;
  int _1615;
  float _1616;
  float _1617;
  float _1618;
  float _1619;
  float iftmp.934_1620;
  float iftmp.934_1621;
  float _1623;
  float _1624;
  float _1625;
  float _1626;
  float iftmp.935_1627;
  float iftmp.935_1628;
  float _1630;
  float _1631;
  float _1634;
  float _1635;
  float _1637;
  float _1638;
  struct ImGuiWindow * window.936_1641;
  float _1642;
  struct ImGuiWindow * window.937_1643;
  float _1644;
  float _1645;
  float _1647;
  float iftmp.938_1648;
  float iftmp.938_1649;
  float _1650;
  const struct ImVec2 * _1652;
  struct ImGuiWindow * window.939_1660;
  struct ImGuiWindow * window.940_1661;
  struct ImGuiWindow * window.941_1663;
  struct ImRect * _1664;
  struct ImGuiWindow * window.942_1665;
  struct ImRect * _1666;
  struct ImGuiWindow * window.943_1668;
  float _1669;
  struct ImGuiWindow * window.944_1670;
  float _1671;
  float _1672;
  struct ImGuiWindow * window.945_1674;
  float _1675;
  struct ImGuiWindow * window.946_1676;
  float _1678;
  float _1679;
  int _1680;
  int _1681;
  struct ImGuiWindow * window.948_1682;
  const float iftmp.947_1683;
  const float iftmp.947_1684;
  float _1685;
  struct ImGuiWindow * window.949_1687;
  struct ImGuiWindow * window.950_1688;
  float _1689;
  struct ImGuiWindow * window.951_1690;
  float _1691;
  float _1692;
  struct ImGuiWindow * window.952_1693;
  float _1694;
  float _1695;
  struct ImGuiWindow * window.953_1696;
  float _1697;
  float _1698;
  struct ImGuiWindow * window.954_1700;
  struct ImGuiWindow * window.955_1701;
  float _1702;
  struct ImGuiWindow * window.956_1703;
  float _1704;
  float _1705;
  struct ImGuiWindow * window.957_1706;
  float _1707;
  float _1708;
  struct ImGuiWindow * window.958_1709;
  float _1710;
  float _1711;
  struct ImGuiWindow * window.959_1713;
  struct ImGuiWindow * window.960_1714;
  float _1715;
  float _1716;
  struct ImGuiWindow * window.961_1717;
  float _1718;
  float _1719;
  struct ImGuiWindow * window.962_1720;
  float _1721;
  float _1722;
  float _1724;
  float _1726;
  float _1727;
  float _1729;
  struct ImGuiWindow * window.963_1731;
  struct ImGuiWindow * window.964_1732;
  float _1733;
  float _1734;
  float _1736;
  struct ImGuiWindow * window.965_1738;
  struct ImGuiWindow * window.966_1739;
  float _1740;
  float _1741;
  struct ImGuiWindow * window.967_1742;
  float _1743;
  float _1744;
  struct ImGuiWindow * window.968_1745;
  float _1746;
  float _1747;
  float _1749;
  float _1751;
  float _1752;
  float _1754;
  struct ImGuiWindow * window.969_1756;
  struct ImGuiWindow * window.970_1757;
  float _1758;
  float _1759;
  float _1761;
  struct ImGuiWindow * window.971_1763;
  struct ImGuiWindow * window.972_1764;
  unsigned int _1765;
  struct ImGuiWindow * window.973_1767;
  bool _1769;
  int iftmp.974_1770;
  int iftmp.974_1771;
  struct ImGuiWindow * window.975_1773;
  struct ImGuiWindow * window.976_1787;
  struct ImVec2 * _1788;
  struct ImGuiWindow * window.977_1789;
  struct ImVec2 * _1790;
  struct ImGuiWindow * window.978_1792;
  struct ImGuiWindow * window.979_1794;
  int _1795;
  int _1796;
  int _1799;
  int _1800;
  struct ImGuiWindow * window.980_1801;
  bool _1802;
  bool iftmp.981_1803;
  bool iftmp.981_1804;
  int _1806;
  struct ImGuiWindow * window.982_1807;
  int _1808;
  struct ImGuiWindow * window.983_1809;
  int _1810;
  struct ImGuiWindow * window.984_1811;
  struct ImGuiWindow * window.985_1812;
  bool _1813;
  struct ImGuiWindow * window.987_1814;
  float _1815;
  struct ImGuiWindow * window.988_1816;
  float _1817;
  struct ImGuiWindow * window.989_1818;
  float _1819;
  struct ImGuiWindow * window.990_1820;
  float _1821;
  bool iftmp.986_1822;
  bool iftmp.986_1823;
  bool _1824;
  struct ImGuiWindow * window.991_1826;
  bool _1827;
  struct ImGuiWindow * window.992_1828;
  float _1831;
  struct ImGuiWindow * window.993_1832;
  struct ImGuiWindow * window.994_1834;
  struct ImGuiWindow * window.996_1835;
  bool _1836;
  struct ImGuiWindow * window.997_1837;
  bool _1838;
  bool _1839;
  struct ImGuiWindow * window.998_1840;
  int _1841;
  struct ImGuiWindow * window.999_1842;
  int _1843;
  bool iftmp.995_1844;
  bool iftmp.995_1845;
  struct ImGuiWindow * window.1000_1847;
  bool _1848;
  bool _1849;

  <bb 2>:
  g_159 = GImGui;
  style_160 = &g_159->Style;
  if (name_161(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("name != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5619, &__PRETTY_FUNCTION__);

  <bb 4>:
  _162 = g_159->Initialized;
  if (_162 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("g.Initialized", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5620, &__PRETTY_FUNCTION__);

  <bb 6>:
  _163 = g_159->FrameCountEnded;
  _164 = g_159->FrameCount;
  if (_163 != _164)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("g.FrameCountEnded != g.FrameCount", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5621, &__PRETTY_FUNCTION__);

  <bb 8>:
  _166 = ImGui::FindWindowByName (name_161(D));
  window.531_167 = _166;
  window = window.531_167;
  window.532_169 = window;
  window_just_created_170 = window.532_169 == 0B;
  if (window_just_created_170 != 0)
    goto <bb 9>;
  else
    goto <bb 13>;

  <bb 9>:
  _171 = g_159->NextWindowData.SizeCond;
  if (_171 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  size_on_first_use = g_159->NextWindowData.SizeVal;
  goto <bb 12>;

  <bb 11>:
  ImVec2::ImVec2 (&size_on_first_use, 0.0, 0.0);

  <bb 12>:
  _176 = CreateNewWindow (name_161(D), size_on_first_use, flags_174(D));
  window.533_177 = _176;
  window = window.533_177;
  size_on_first_use ={v} {CLOBBER};

  <bb 13>:
  _181 = flags_174(D) & 512;
  if (_181 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  flags_182 = flags_174(D) | 6;

  <bb 15>:
  # flags_1 = PHI <flags_174(D)(13), flags_182(14)>
  _183 = flags_1 & 8388608;
  if (_183 != 0)
    goto <bb 16>;
  else
    goto <bb 18>;

  <bb 16>:
  _184 = flags_1 & 16777216;
  if (_184 != 0)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  __assert_fail ("flags & ImGuiWindowFlags_ChildWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5637, &__PRETTY_FUNCTION__);

  <bb 18>:
  current_frame_186 = g_159->FrameCount;
  window.534_187 = window;
  _188 = window.534_187->LastFrameActive;
  first_begin_of_the_frame_189 = _188 != current_frame_186;
  if (first_begin_of_the_frame_189 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  window.535_190 = window;
  window.535_190->Flags = flags_1;
  goto <bb 21>;

  <bb 20>:
  window.536_192 = window;
  flags_193 = window.536_192->Flags;

  <bb 21>:
  # flags_2 = PHI <flags_1(19), flags_193(20)>
  window.537_194 = window;
  _195 = window.537_194->LastFrameActive;
  _196 = current_frame_186 + -1;
  window_just_activated_by_user_197 = _195 < _196;
  window.538_198 = window;
  _199 = window.538_198->HiddenFrames;
  window_just_appearing_after_hidden_for_resize_200 = _199 > 0;
  _201 = flags_2 & 67108864;
  if (_201 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  _202 = g_159->CurrentPopupStack.Size;
  _203 = &g_159->OpenPopupStack;
  popup_ref_205 = ImVector<ImGuiPopupRef>::operator[] (_203, _202);
  _206 = (int) window_just_activated_by_user_197;
  window.539_207 = window;
  _208 = window.539_207->PopupId;
  _209 = popup_ref_205->PopupId;
  _210 = _208 != _209;
  _211 = (int) _210;
  _212 = _206 | _211;
  window_just_activated_by_user_213 = _212 != 0;
  _214 = (int) window_just_activated_by_user_213;
  _215 = popup_ref_205->Window;
  window.540_216 = window;
  _217 = _215 != window.540_216;
  _218 = (int) _217;
  _219 = _214 | _218;
  window_just_activated_by_user_220 = _219 != 0;

  <bb 23>:
  # window_just_activated_by_user_3 = PHI <window_just_activated_by_user_197(21), window_just_activated_by_user_220(22)>
  window.541_221 = window;
  if (window_just_activated_by_user_3 != 0)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  if (window_just_appearing_after_hidden_for_resize_200 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  iftmp.542_223 = 1;
  goto <bb 27>;

  <bb 26>:
  iftmp.542_222 = 0;

  <bb 27>:
  # iftmp.542_12 = PHI <iftmp.542_223(25), iftmp.542_222(26)>
  window.541_221->Appearing = iftmp.542_12;
  window.543_225 = window;
  _227 = p_open_226(D) != 0B;
  window.543_225->CloseButton = _227;
  window.544_229 = window;
  _230 = window.544_229->Appearing;
  if (_230 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  window.545_231 = window;
  SetWindowConditionAllowFlags (window.545_231, 8, 1);

  <bb 29>:
  _233 = &g_159->CurrentWindowStack;
  _235 = ImVector<ImGuiWindow*>::empty (_233);
  if (_235 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  iftmp.546_236 = 0B;
  goto <bb 32>;

  <bb 31>:
  _237 = &g_159->CurrentWindowStack;
  _239 = ImVector<ImGuiWindow*>::back (_237);
  iftmp.546_240 = *_239;

  <bb 32>:
  # iftmp.546_13 = PHI <iftmp.546_236(30), iftmp.546_240(31)>
  parent_window_in_stack_241 = iftmp.546_13;
  if (first_begin_of_the_frame_189 != 0)
    goto <bb 33>;
  else
    goto <bb 37>;

  <bb 33>:
  _242 = flags_2 & 83886080;
  if (_242 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  iftmp.548_243 = parent_window_in_stack_241;
  goto <bb 36>;

  <bb 35>:
  iftmp.548_244 = 0B;

  <bb 36>:
  # iftmp.548_15 = PHI <iftmp.548_243(34), iftmp.548_244(35)>
  iftmp.547_245 = iftmp.548_15;
  goto <bb 38>;

  <bb 37>:
  window.549_246 = window;
  iftmp.547_247 = window.549_246->ParentWindow;

  <bb 38>:
  # iftmp.547_14 = PHI <iftmp.547_245(36), iftmp.547_247(37)>
  parent_window_248 = iftmp.547_14;
  if (parent_window_248 != 0B)
    goto <bb 41>;
  else
    goto <bb 39>;

  <bb 39>:
  _249 = flags_2 & 16777216;
  if (_249 == 0)
    goto <bb 41>;
  else
    goto <bb 40>;

  <bb 40>:
  __assert_fail ("parent_window != __null || !(flags & ImGuiWindowFlags_ChildWindow)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5663, &__PRETTY_FUNCTION__);

  <bb 41>:
  _251 = &g_159->CurrentWindowStack;
  ImVector<ImGuiWindow*>::push_back (_251, &window);
  window.550_253 = window;
  SetCurrentWindow (window.550_253);
  window.551_255 = window;
  CheckStacksSize (window.551_255, 1);
  _257 = flags_2 & 67108864;
  if (_257 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  _258 = g_159->CurrentPopupStack.Size;
  _259 = &g_159->OpenPopupStack;
  popup_ref_261 = ImVector<ImGuiPopupRef>::operator[] (_259, _258);
  window.552_262 = window;
  popup_ref_261->Window = window.552_262;
  _264 = &g_159->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::push_back (_264, popup_ref_261);
  window.553_266 = window;
  _267 = popup_ref_261->PopupId;
  window.553_266->PopupId = _267;

  <bb 43>:
  if (window_just_appearing_after_hidden_for_resize_200 != 0)
    goto <bb 44>;
  else
    goto <bb 46>;

  <bb 44>:
  _269 = flags_2 & 16777216;
  if (_269 == 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  window.554_270 = window;
  window.554_270->NavLastIds[0] = 0;

  <bb 46>:
  window_pos_set_by_api = 0;
  window_size_x_set_by_api_273 = 0;
  window_size_y_set_by_api_274 = 0;
  _275 = g_159->NextWindowData.PosCond;
  if (_275 != 0)
    goto <bb 47>;
  else
    goto <bb 55>;

  <bb 47>:
  window.555_276 = window;
  _277 = window.555_276->SetWindowPosAllowFlags;
  _278 = g_159->NextWindowData.PosCond;
  _279 = _277 & _278;
  window_pos_set_by_api.556_280 = _279 != 0;
  window_pos_set_by_api = window_pos_set_by_api.556_280;
  window_pos_set_by_api.559_282 = window_pos_set_by_api;
  if (window_pos_set_by_api.559_282 != 0)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  _283 = &g_159->NextWindowData.PosPivotVal;
  _285 = ImLengthSqr (_283);
  if (_285 > 9.99999974737875163555145263671875e-6)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.558_286 = 1;
  goto <bb 51>;

  <bb 50>:
  iftmp.558_287 = 0;

  <bb 51>:
  # iftmp.558_16 = PHI <iftmp.558_286(49), iftmp.558_287(50)>
  retval.557_288 = iftmp.558_16;
  if (retval.557_288 != 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  window.560_289 = window;
  window.560_289->SetWindowPosVal = g_159->NextWindowData.PosVal;
  window.561_291 = window;
  window.561_291->SetWindowPosPivot = g_159->NextWindowData.PosPivotVal;
  window.562_293 = window;
  window.563_294 = window;
  _295 = window.563_294->SetWindowPosAllowFlags;
  _296 = _295 & -15;
  window.562_293->SetWindowPosAllowFlags = _296;
  goto <bb 54>;

  <bb 53>:
  _298 = g_159->NextWindowData.PosCond;
  _299 = &g_159->NextWindowData.PosVal;
  window.564_300 = window;
  SetWindowPos (window.564_300, _299, _298);

  <bb 54>:
  g_159->NextWindowData.PosCond = 0;

  <bb 55>:
  _303 = g_159->NextWindowData.SizeCond;
  if (_303 != 0)
    goto <bb 56>;
  else
    goto <bb 65>;

  <bb 56>:
  window.566_304 = window;
  _305 = window.566_304->SetWindowSizeAllowFlags;
  _306 = g_159->NextWindowData.SizeCond;
  _307 = _305 & _306;
  if (_307 != 0)
    goto <bb 57>;
  else
    goto <bb 59>;

  <bb 57>:
  _308 = g_159->NextWindowData.SizeVal.x;
  if (_308 > 0.0)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  iftmp.565_309 = 1;
  goto <bb 60>;

  <bb 59>:
  iftmp.565_310 = 0;

  <bb 60>:
  # iftmp.565_17 = PHI <iftmp.565_309(58), iftmp.565_310(59)>
  window_size_x_set_by_api_311 = iftmp.565_17;
  window.568_312 = window;
  _313 = window.568_312->SetWindowSizeAllowFlags;
  _314 = g_159->NextWindowData.SizeCond;
  _315 = _313 & _314;
  if (_315 != 0)
    goto <bb 61>;
  else
    goto <bb 63>;

  <bb 61>:
  _316 = g_159->NextWindowData.SizeVal.y;
  if (_316 > 0.0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  iftmp.567_317 = 1;
  goto <bb 64>;

  <bb 63>:
  iftmp.567_318 = 0;

  <bb 64>:
  # iftmp.567_18 = PHI <iftmp.567_317(62), iftmp.567_318(63)>
  window_size_y_set_by_api_319 = iftmp.567_18;
  _320 = g_159->NextWindowData.SizeCond;
  _321 = &g_159->NextWindowData.SizeVal;
  window.569_322 = window;
  SetWindowSize (window.569_322, _321, _320);
  g_159->NextWindowData.SizeCond = 0;

  <bb 65>:
  # window_size_x_set_by_api_4 = PHI <window_size_x_set_by_api_273(55), window_size_x_set_by_api_311(64)>
  # window_size_y_set_by_api_5 = PHI <window_size_y_set_by_api_274(55), window_size_y_set_by_api_319(64)>
  _325 = g_159->NextWindowData.ContentSizeCond;
  if (_325 != 0)
    goto <bb 66>;
  else
    goto <bb 69>;

  <bb 66>:
  window.570_326 = window;
  window.570_326->SizeContentsExplicit = g_159->NextWindowData.ContentSizeVal;
  window.571_328 = window;
  _329 = window.571_328->SizeContentsExplicit.y;
  if (_329 != 0.0)
    goto <bb 67>;
  else
    goto <bb 68>;

  <bb 67>:
  window.572_330 = window;
  _332 = ImGuiWindow::TitleBarHeight (window.572_330);
  window.573_333 = window;
  _335 = ImGuiWindow::MenuBarHeight (window.573_333);
  _336 = _332 + _335;
  window.574_337 = window;
  window.575_338 = window;
  _339 = window.575_338->SizeContentsExplicit.y;
  _340 = _339 + _336;
  window.574_337->SizeContentsExplicit.y = _340;

  <bb 68>:
  g_159->NextWindowData.ContentSizeCond = 0;
  goto <bb 71>;

  <bb 69>:
  if (first_begin_of_the_frame_189 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  window.576_343 = window;
  ImVec2::ImVec2 (&D.17737, 0.0, 0.0);
  window.576_343->SizeContentsExplicit = D.17737;
  D.17737 ={v} {CLOBBER};

  <bb 71>:
  _347 = g_159->NextWindowData.CollapsedCond;
  if (_347 != 0)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  _348 = g_159->NextWindowData.CollapsedCond;
  _349 = g_159->NextWindowData.CollapsedVal;
  _350 = (int) _349;
  window.577_351 = window;
  SetWindowCollapsed (window.577_351, _350, _348);
  g_159->NextWindowData.CollapsedCond = 0;

  <bb 73>:
  _354 = g_159->NextWindowData.FocusCond;
  if (_354 != 0)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  ImGui::SetWindowFocus ();
  g_159->NextWindowData.FocusCond = 0;

  <bb 75>:
  window.578_357 = window;
  _358 = window.578_357->Appearing;
  if (_358 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  window.579_359 = window;
  SetWindowConditionAllowFlags (window.579_359, 8, 0);

  <bb 77>:
  if (first_begin_of_the_frame_189 != 0)
    goto <bb 78>;
  else
    goto <bb 405>;

  <bb 78>:
  _361 = flags_2 & 16777216;
  if (_361 != 0)
    goto <bb 79>;
  else
    goto <bb 81>;

  <bb 79>:
  _362 = flags_2 & 33554432;
  if (_362 != 0)
    goto <bb 80>;
  else
    goto <bb 81>;

  <bb 80>:
  iftmp.580_363 = 1;
  goto <bb 82>;

  <bb 81>:
  iftmp.580_364 = 0;

  <bb 82>:
  # iftmp.580_19 = PHI <iftmp.580_363(80), iftmp.580_364(81)>
  window_is_child_tooltip_365 = iftmp.580_19;
  window.581_366 = window;
  window.581_366->ParentWindow = parent_window_248;
  window.582_368 = window;
  window.583_369 = window;
  window.584_370 = window;
  window.585_371 = window;
  window.586_372 = window;
  window.585_371->RootWindowForNav = window.586_372;
  _374 = window.585_371->RootWindowForNav;
  window.584_370->RootWindowForTabbing = _374;
  _376 = window.584_370->RootWindowForTabbing;
  window.583_369->RootWindowForTitleBarHighlight = _376;
  _378 = window.583_369->RootWindowForTitleBarHighlight;
  window.582_368->RootWindow = _378;
  if (parent_window_248 != 0B)
    goto <bb 83>;
  else
    goto <bb 86>;

  <bb 83>:
  _380 = flags_2 & 16777216;
  if (_380 != 0)
    goto <bb 84>;
  else
    goto <bb 86>;

  <bb 84>:
  _381 = ~window_is_child_tooltip_365;
  if (_381 != 0)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  window.587_382 = window;
  _383 = parent_window_248->RootWindow;
  window.587_382->RootWindow = _383;

  <bb 86>:
  if (parent_window_248 != 0B)
    goto <bb 87>;
  else
    goto <bb 90>;

  <bb 87>:
  _385 = flags_2 & 134217728;
  if (_385 == 0)
    goto <bb 88>;
  else
    goto <bb 90>;

  <bb 88>:
  _386 = flags_2 & 83886080;
  if (_386 != 0)
    goto <bb 89>;
  else
    goto <bb 90>;

  <bb 89>:
  window.588_387 = window;
  window.589_388 = window;
  _389 = parent_window_248->RootWindowForTitleBarHighlight;
  window.589_388->RootWindowForTabbing = _389;
  _391 = window.589_388->RootWindowForTabbing;
  window.588_387->RootWindowForTitleBarHighlight = _391;

  <bb 90>:
  window.590_393 = window;
  _394 = window.590_393->RootWindowForNav;
  _395 = _394->Flags;
  _396 = _395 & 8388608;
  if (_396 == 0)
    goto <bb 92>;
  else
    goto <bb 91>;

  <bb 91>:
  window.591_397 = window;
  window.592_398 = window;
  _399 = window.592_398->RootWindowForNav;
  _400 = _399->ParentWindow;
  window.591_397->RootWindowForNav = _400;
  goto <bb 90>;

  <bb 92>:
  window.593_402 = window;
  window.593_402->Active = 1;
  window.594_404 = window;
  window.594_404->BeginOrderWithinParent = 0;
  window.595_406 = window;
  _407 = g_159->WindowsActiveCount;
  _408 = _407;
  _409 = _408 + 1;
  g_159->WindowsActiveCount = _409;
  window.595_406->BeginOrderWithinContext = _408;
  window.596_412 = window;
  window.596_412->BeginCount = 0;
  window.597_414 = window;
  ImVec4::ImVec4 (&D.17739, -3.4028234663852885981170418348451692544e+38, -3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  ImRect::ImRect (&D.17740, &D.17739);
  window.597_414->ClipRect = D.17740;
  D.17740 ={v} {CLOBBER};
  D.17739 ={v} {CLOBBER};
  window.598_420 = window;
  window.598_420->LastFrameActive = current_frame_186;
  window.599_422 = window;
  _423 = &window.599_422->IDStack;
  ImVector<unsigned int>::resize (_423, 1);
  window.600_425 = window;
  _426 = flags_2 & 16777216;
  if (_426 != 0)
    goto <bb 93>;
  else
    goto <bb 94>;

  <bb 93>:
  iftmp.601_427 = style_160->ChildRounding;
  goto <bb 99>;

  <bb 94>:
  _428 = flags_2 & 67108864;
  if (_428 != 0)
    goto <bb 95>;
  else
    goto <bb 97>;

  <bb 95>:
  _429 = flags_2 & 134217728;
  if (_429 == 0)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  iftmp.602_430 = style_160->PopupRounding;
  goto <bb 98>;

  <bb 97>:
  iftmp.602_431 = style_160->WindowRounding;

  <bb 98>:
  # iftmp.602_21 = PHI <iftmp.602_430(96), iftmp.602_431(97)>
  iftmp.601_432 = iftmp.602_21;

  <bb 99>:
  # iftmp.601_20 = PHI <iftmp.601_427(93), iftmp.601_432(98)>
  window.600_425->WindowRounding = iftmp.601_20;
  window.603_434 = window;
  _435 = flags_2 & 16777216;
  if (_435 != 0)
    goto <bb 100>;
  else
    goto <bb 101>;

  <bb 100>:
  iftmp.604_436 = style_160->ChildBorderSize;
  goto <bb 106>;

  <bb 101>:
  _437 = flags_2 & 100663296;
  if (_437 != 0)
    goto <bb 102>;
  else
    goto <bb 104>;

  <bb 102>:
  _438 = flags_2 & 134217728;
  if (_438 == 0)
    goto <bb 103>;
  else
    goto <bb 104>;

  <bb 103>:
  iftmp.605_439 = style_160->PopupBorderSize;
  goto <bb 105>;

  <bb 104>:
  iftmp.605_440 = style_160->WindowBorderSize;

  <bb 105>:
  # iftmp.605_23 = PHI <iftmp.605_439(103), iftmp.605_440(104)>
  iftmp.604_441 = iftmp.605_23;

  <bb 106>:
  # iftmp.604_22 = PHI <iftmp.604_436(100), iftmp.604_441(105)>
  window.603_434->WindowBorderSize = iftmp.604_22;
  window.606_443 = window;
  window.606_443->WindowPadding = style_160->WindowPadding;
  _445 = flags_2 & 16777216;
  if (_445 != 0)
    goto <bb 107>;
  else
    goto <bb 113>;

  <bb 107>:
  _446 = flags_2 & 67174400;
  if (_446 == 0)
    goto <bb 108>;
  else
    goto <bb 113>;

  <bb 108>:
  window.607_447 = window;
  _448 = window.607_447->WindowBorderSize;
  if (_448 == 0.0)
    goto <bb 109>;
  else
    goto <bb 113>;

  <bb 109>:
  window.608_449 = window;
  _450 = flags_2 & 1024;
  if (_450 != 0)
    goto <bb 110>;
  else
    goto <bb 111>;

  <bb 110>:
  iftmp.609_451 = style_160->WindowPadding.y;
  goto <bb 112>;

  <bb 111>:
  iftmp.609_452 = 0.0;

  <bb 112>:
  # iftmp.609_24 = PHI <iftmp.609_451(110), iftmp.609_452(111)>
  ImVec2::ImVec2 (&D.17741, 0.0, iftmp.609_24);
  window.608_449->WindowPadding = D.17741;
  D.17741 ={v} {CLOBBER};

  <bb 113>:
  _456 = flags_2 & 1;
  if (_456 == 0)
    goto <bb 114>;
  else
    goto <bb 124>;

  <bb 114>:
  _457 = flags_2 & 32;
  if (_457 == 0)
    goto <bb 115>;
  else
    goto <bb 124>;

  <bb 115>:
  window.610_458 = window;
  title_bar_rect = ImGuiWindow::TitleBarRect (window.610_458);
  window.613_460 = window;
  _461 = window.613_460->CollapseToggleWanted;
  if (_461 != 0)
    goto <bb 119>;
  else
    goto <bb 116>;

  <bb 116>:
  _462 = g_159->HoveredWindow;
  window.614_463 = window;
  if (_462 == window.614_463)
    goto <bb 117>;
  else
    goto <bb 120>;

  <bb 117>:
  _465 = ImGui::IsMouseHoveringRect (&title_bar_rect.Min, &title_bar_rect.Max, 1);
  if (_465 != 0)
    goto <bb 118>;
  else
    goto <bb 120>;

  <bb 118>:
  _466 = g_159->IO.MouseDoubleClicked[0];
  if (_466 != 0)
    goto <bb 119>;
  else
    goto <bb 120>;

  <bb 119>:
  iftmp.612_468 = 1;
  goto <bb 121>;

  <bb 120>:
  iftmp.612_467 = 0;

  <bb 121>:
  # iftmp.612_25 = PHI <iftmp.612_468(119), iftmp.612_467(120)>
  retval.611_469 = iftmp.612_25;
  if (retval.611_469 != 0)
    goto <bb 122>;
  else
    goto <bb 123>;

  <bb 122>:
  window.615_470 = window;
  window.616_471 = window;
  _472 = window.616_471->Collapsed;
  _473 = ~_472;
  window.615_470->Collapsed = _473;
  window.617_475 = window;
  MarkIniSettingsDirty (window.617_475);
  window.618_477 = window;
  ImGui::FocusWindow (window.618_477);

  <bb 123>:
  title_bar_rect ={v} {CLOBBER};
  goto <bb 125>;

  <bb 124>:
  window.619_481 = window;
  window.619_481->Collapsed = 0;

  <bb 125>:
  window.620_483 = window;
  window.620_483->CollapseToggleWanted = 0;
  window.621_485 = window;
  window.622_486 = window;
  window.621_485->SizeContents = CalcSizeContents (window.622_486);
  window.623_488 = window;
  _489 = window.623_488->HiddenFrames;
  if (_489 > 0)
    goto <bb 126>;
  else
    goto <bb 127>;

  <bb 126>:
  window.624_490 = window;
  _491 = window.624_490->HiddenFrames;
  _492 = _491 + -1;
  window.624_490->HiddenFrames = _492;

  <bb 127>:
  if (window_just_activated_by_user_3 != 0)
    goto <bb 128>;
  else
    goto <bb 135>;

  <bb 128>:
  _494 = flags_2 & 100663296;
  if (_494 != 0)
    goto <bb 129>;
  else
    goto <bb 135>;

  <bb 129>:
  window.625_495 = window;
  window.625_495->HiddenFrames = 1;
  _497 = flags_2 & 64;
  if (_497 != 0)
    goto <bb 130>;
  else
    goto <bb 135>;

  <bb 130>:
  _498 = ~window_size_x_set_by_api_4;
  if (_498 != 0)
    goto <bb 131>;
  else
    goto <bb 132>;

  <bb 131>:
  window.626_499 = window;
  window.627_500 = window;
  window.627_500->SizeFull.x = 0.0;
  _502 = window.627_500->SizeFull.x;
  window.626_499->Size.x = _502;

  <bb 132>:
  _504 = ~window_size_y_set_by_api_5;
  if (_504 != 0)
    goto <bb 133>;
  else
    goto <bb 134>;

  <bb 133>:
  window.628_505 = window;
  window.629_506 = window;
  window.629_506->SizeFull.y = 0.0;
  _508 = window.629_506->SizeFull.y;
  window.628_505->Size.y = _508;

  <bb 134>:
  window.630_510 = window;
  ImVec2::ImVec2 (&D.17745, 0.0, 0.0);
  window.630_510->SizeContents = D.17745;
  D.17745 ={v} {CLOBBER};

  <bb 135>:
  if (window_just_created_170 != 0)
    goto <bb 136>;
  else
    goto <bb 139>;

  <bb 136>:
  _514 = ~window_size_x_set_by_api_4;
  if (_514 != 0)
    goto <bb 138>;
  else
    goto <bb 137>;

  <bb 137>:
  _515 = ~window_size_y_set_by_api_5;
  if (_515 != 0)
    goto <bb 138>;
  else
    goto <bb 139>;

  <bb 138>:
  window.631_516 = window;
  window.631_516->HiddenFrames = 1;

  <bb 139>:
  window.632_518 = window;
  _519 = &window.632_518->SizeContents;
  window.633_520 = window;
  size_auto_fit = CalcSizeAutoFit (window.633_520, _519);
  ImVec2::ImVec2 (&size_full_modified, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  _523 = flags_2 & 64;
  if (_523 != 0)
    goto <bb 140>;
  else
    goto <bb 146>;

  <bb 140>:
  window.634_524 = window;
  _525 = window.634_524->Collapsed;
  _526 = ~_525;
  if (_526 != 0)
    goto <bb 141>;
  else
    goto <bb 146>;

  <bb 141>:
  _527 = ~window_size_x_set_by_api_4;
  if (_527 != 0)
    goto <bb 142>;
  else
    goto <bb 143>;

  <bb 142>:
  window.635_528 = window;
  _529 = size_auto_fit.x;
  size_full_modified.x = _529;
  _531 = size_full_modified.x;
  window.635_528->SizeFull.x = _531;

  <bb 143>:
  _533 = ~window_size_y_set_by_api_5;
  if (_533 != 0)
    goto <bb 144>;
  else
    goto <bb 145>;

  <bb 144>:
  window.636_534 = window;
  _535 = size_auto_fit.y;
  size_full_modified.y = _535;
  _537 = size_full_modified.y;
  window.636_534->SizeFull.y = _537;

  <bb 145>:
  goto <bb 162>;

  <bb 146>:
  window.637_539 = window;
  _540 = window.637_539->AutoFitFramesX;
  if (_540 > 0)
    goto <bb 148>;
  else
    goto <bb 147>;

  <bb 147>:
  window.638_541 = window;
  _542 = window.638_541->AutoFitFramesY;
  if (_542 > 0)
    goto <bb 148>;
  else
    goto <bb 162>;

  <bb 148>:
  _543 = ~window_size_x_set_by_api_4;
  if (_543 != 0)
    goto <bb 149>;
  else
    goto <bb 154>;

  <bb 149>:
  window.639_544 = window;
  _545 = window.639_544->AutoFitFramesX;
  if (_545 > 0)
    goto <bb 150>;
  else
    goto <bb 154>;

  <bb 150>:
  window.640_546 = window;
  window.642_547 = window;
  _548 = window.642_547->AutoFitOnlyGrows;
  if (_548 != 0)
    goto <bb 151>;
  else
    goto <bb 152>;

  <bb 151>:
  _549 = size_auto_fit.x;
  window.643_550 = window;
  _551 = window.643_550->SizeFull.x;
  iftmp.641_553 = ImMax (_551, _549);
  goto <bb 153>;

  <bb 152>:
  iftmp.641_554 = size_auto_fit.x;

  <bb 153>:
  # iftmp.641_26 = PHI <iftmp.641_553(151), iftmp.641_554(152)>
  size_full_modified.x = iftmp.641_26;
  _556 = size_full_modified.x;
  window.640_546->SizeFull.x = _556;

  <bb 154>:
  _558 = ~window_size_y_set_by_api_5;
  if (_558 != 0)
    goto <bb 155>;
  else
    goto <bb 160>;

  <bb 155>:
  window.644_559 = window;
  _560 = window.644_559->AutoFitFramesY;
  if (_560 > 0)
    goto <bb 156>;
  else
    goto <bb 160>;

  <bb 156>:
  window.645_561 = window;
  window.647_562 = window;
  _563 = window.647_562->AutoFitOnlyGrows;
  if (_563 != 0)
    goto <bb 157>;
  else
    goto <bb 158>;

  <bb 157>:
  _564 = size_auto_fit.y;
  window.648_565 = window;
  _566 = window.648_565->SizeFull.y;
  iftmp.646_568 = ImMax (_566, _564);
  goto <bb 159>;

  <bb 158>:
  iftmp.646_569 = size_auto_fit.y;

  <bb 159>:
  # iftmp.646_27 = PHI <iftmp.646_568(157), iftmp.646_569(158)>
  size_full_modified.y = iftmp.646_27;
  _571 = size_full_modified.y;
  window.645_561->SizeFull.y = _571;

  <bb 160>:
  window.649_573 = window;
  _574 = window.649_573->Collapsed;
  _575 = ~_574;
  if (_575 != 0)
    goto <bb 161>;
  else
    goto <bb 162>;

  <bb 161>:
  window.650_576 = window;
  MarkIniSettingsDirty (window.650_576);

  <bb 162>:
  window.651_578 = window;
  window.652_579 = window;
  window.653_580 = window;
  window.651_578->SizeFull = CalcSizeAfterConstraint (window.653_580, window.652_579->SizeFull);
  window.654_582 = window;
  window.655_583 = window;
  _584 = window.655_583->Collapsed;
  if (_584 != 0)
    goto <bb 163>;
  else
    goto <bb 165>;

  <bb 163>:
  _585 = flags_2 & 16777216;
  if (_585 == 0)
    goto <bb 164>;
  else
    goto <bb 165>;

  <bb 164>:
  window.656_586 = window;
  D.17751 = ImGuiWindow::TitleBarRect (window.656_586);
  window.654_582->Size = ImRect::GetSize (&D.17751);
  goto <bb 166>;

  <bb 165>:
  window.657_589 = window;
  window.654_582->Size = window.657_589->SizeFull;

  <bb 166>:
  D.17751 ={v} {CLOBBER};
  window.658_592 = window;
  _593 = window.658_592->Collapsed;
  _594 = ~_593;
  if (_594 != 0)
    goto <bb 167>;
  else
    goto <bb 201>;

  <bb 167>:
  _595 = size_full_modified.x;
  if (_595 != 3.4028234663852885981170418348451692544e+38)
    goto <bb 168>;
  else
    goto <bb 169>;

  <bb 168>:
  window.660_596 = window;
  iftmp.659_597 = window.660_596->SizeFull.x;
  goto <bb 170>;

  <bb 169>:
  window.661_598 = window;
  iftmp.659_599 = window.661_598->SizeFullAtLastBegin.x;

  <bb 170>:
  # iftmp.659_28 = PHI <iftmp.659_597(168), iftmp.659_599(169)>
  size_x_for_scrollbars_600 = iftmp.659_28;
  _601 = size_full_modified.y;
  if (_601 != 3.4028234663852885981170418348451692544e+38)
    goto <bb 171>;
  else
    goto <bb 172>;

  <bb 171>:
  window.663_602 = window;
  iftmp.662_603 = window.663_602->SizeFull.y;
  goto <bb 173>;

  <bb 172>:
  window.664_604 = window;
  iftmp.662_605 = window.664_604->SizeFullAtLastBegin.y;

  <bb 173>:
  # iftmp.662_29 = PHI <iftmp.662_603(171), iftmp.662_605(172)>
  size_y_for_scrollbars_606 = iftmp.662_29;
  window.665_607 = window;
  _608 = flags_2 & 16384;
  if (_608 != 0)
    goto <bb 176>;
  else
    goto <bb 174>;

  <bb 174>:
  window.667_609 = window;
  _610 = window.667_609->SizeContents.y;
  if (_610 > size_y_for_scrollbars_606)
    goto <bb 175>;
  else
    goto <bb 177>;

  <bb 175>:
  _611 = flags_2 & 8;
  if (_611 == 0)
    goto <bb 176>;
  else
    goto <bb 177>;

  <bb 176>:
  iftmp.666_613 = 1;
  goto <bb 178>;

  <bb 177>:
  iftmp.666_612 = 0;

  <bb 178>:
  # iftmp.666_30 = PHI <iftmp.666_613(176), iftmp.666_612(177)>
  window.665_607->ScrollbarY = iftmp.666_30;
  window.668_615 = window;
  _616 = flags_2 & 32768;
  if (_616 != 0)
    goto <bb 185>;
  else
    goto <bb 179>;

  <bb 179>:
  window.670_617 = window;
  _618 = window.670_617->SizeContents.x;
  window.672_619 = window;
  _620 = window.672_619->ScrollbarY;
  if (_620 != 0)
    goto <bb 180>;
  else
    goto <bb 181>;

  <bb 180>:
  iftmp.671_621 = style_160->ScrollbarSize;
  goto <bb 182>;

  <bb 181>:
  iftmp.671_622 = 0.0;

  <bb 182>:
  # iftmp.671_32 = PHI <iftmp.671_621(180), iftmp.671_622(181)>
  _623 = size_x_for_scrollbars_600 - iftmp.671_32;
  if (_618 > _623)
    goto <bb 183>;
  else
    goto <bb 186>;

  <bb 183>:
  _624 = flags_2 & 8;
  if (_624 == 0)
    goto <bb 184>;
  else
    goto <bb 186>;

  <bb 184>:
  _625 = flags_2 & 2048;
  if (_625 != 0)
    goto <bb 185>;
  else
    goto <bb 186>;

  <bb 185>:
  iftmp.669_627 = 1;
  goto <bb 187>;

  <bb 186>:
  iftmp.669_626 = 0;

  <bb 187>:
  # iftmp.669_31 = PHI <iftmp.669_627(185), iftmp.669_626(186)>
  window.668_615->ScrollbarX = iftmp.669_31;
  window.673_629 = window;
  _630 = window.673_629->ScrollbarX;
  if (_630 != 0)
    goto <bb 188>;
  else
    goto <bb 194>;

  <bb 188>:
  window.674_631 = window;
  _632 = window.674_631->ScrollbarY;
  _633 = ~_632;
  if (_633 != 0)
    goto <bb 189>;
  else
    goto <bb 194>;

  <bb 189>:
  window.675_634 = window;
  window.677_635 = window;
  _636 = window.677_635->SizeContents.y;
  _637 = style_160->ScrollbarSize;
  _638 = size_y_for_scrollbars_606 - _637;
  if (_636 > _638)
    goto <bb 190>;
  else
    goto <bb 192>;

  <bb 190>:
  _639 = flags_2 & 8;
  if (_639 == 0)
    goto <bb 191>;
  else
    goto <bb 192>;

  <bb 191>:
  iftmp.676_640 = 1;
  goto <bb 193>;

  <bb 192>:
  iftmp.676_641 = 0;

  <bb 193>:
  # iftmp.676_33 = PHI <iftmp.676_640(191), iftmp.676_641(192)>
  window.675_634->ScrollbarY = iftmp.676_33;

  <bb 194>:
  window.678_643 = window;
  window.680_644 = window;
  _645 = window.680_644->ScrollbarX;
  if (_645 != 0)
    goto <bb 195>;
  else
    goto <bb 196>;

  <bb 195>:
  iftmp.679_646 = style_160->ScrollbarSize;
  goto <bb 197>;

  <bb 196>:
  iftmp.679_647 = 0.0;

  <bb 197>:
  # iftmp.679_34 = PHI <iftmp.679_646(195), iftmp.679_647(196)>
  window.682_648 = window;
  _649 = window.682_648->ScrollbarY;
  if (_649 != 0)
    goto <bb 198>;
  else
    goto <bb 199>;

  <bb 198>:
  iftmp.681_650 = style_160->ScrollbarSize;
  goto <bb 200>;

  <bb 199>:
  iftmp.681_651 = 0.0;

  <bb 200>:
  # iftmp.681_35 = PHI <iftmp.681_650(198), iftmp.681_651(199)>
  ImVec2::ImVec2 (&D.17757, iftmp.681_35, iftmp.679_34);
  window.678_643->ScrollbarSizes = D.17757;
  D.17757 ={v} {CLOBBER};

  <bb 201>:
  if (window_just_activated_by_user_3 != 0)
    goto <bb 202>;
  else
    goto <bb 205>;

  <bb 202>:
  window.683_655 = window;
  window.683_655->AutoPosLastDirection = -1;
  _657 = flags_2 & 67108864;
  if (_657 != 0)
    goto <bb 203>;
  else
    goto <bb 205>;

  <bb 203>:
  window_pos_set_by_api.684_658 = window_pos_set_by_api;
  _659 = ~window_pos_set_by_api.684_658;
  if (_659 != 0)
    goto <bb 204>;
  else
    goto <bb 205>;

  <bb 204>:
  window.685_660 = window;
  window.686_661 = window;
  _662 = &g_159->CurrentPopupStack;
  _664 = ImVector<ImGuiPopupRef>::back (_662);
  window.686_661->PosFloat = _664->OpenPopupPos;
  window.687_666 = window;
  _667 = &window.687_666->PosFloat;
  window.685_660->Pos = MEM[(const struct ImVec2 &)_667];

  <bb 205>:
  _669 = flags_2 & 16777216;
  if (_669 != 0)
    goto <bb 206>;
  else
    goto <bb 210>;

  <bb 206>:
  window.688_670 = window;
  _671 = parent_window_248->DC.ChildWindows.Size;
  window.688_670->BeginOrderWithinParent = _671;
  _673 = &parent_window_248->DC.ChildWindows;
  ImVector<ImGuiWindow*>::push_back (_673, &window);
  _675 = flags_2 & 67108864;
  if (_675 == 0)
    goto <bb 207>;
  else
    goto <bb 210>;

  <bb 207>:
  window_pos_set_by_api.689_676 = window_pos_set_by_api;
  _677 = ~window_pos_set_by_api.689_676;
  if (_677 != 0)
    goto <bb 208>;
  else
    goto <bb 210>;

  <bb 208>:
  _678 = ~window_is_child_tooltip_365;
  if (_678 != 0)
    goto <bb 209>;
  else
    goto <bb 210>;

  <bb 209>:
  window.690_679 = window;
  window.691_680 = window;
  window.691_680->PosFloat = parent_window_248->DC.CursorPos;
  window.692_682 = window;
  _683 = &window.692_682->PosFloat;
  window.690_679->Pos = MEM[(const struct ImVec2 &)_683];

  <bb 210>:
  window.694_685 = window;
  _686 = window.694_685->SetWindowPosVal.x;
  if (_686 != 3.4028234663852885981170418348451692544e+38)
    goto <bb 211>;
  else
    goto <bb 213>;

  <bb 211>:
  window.695_687 = window;
  _688 = window.695_687->HiddenFrames;
  if (_688 == 0)
    goto <bb 212>;
  else
    goto <bb 213>;

  <bb 212>:
  iftmp.693_689 = 1;
  goto <bb 214>;

  <bb 213>:
  iftmp.693_690 = 0;

  <bb 214>:
  # iftmp.693_36 = PHI <iftmp.693_689(212), iftmp.693_690(213)>
  window_pos_with_pivot_691 = iftmp.693_36;
  if (window_pos_with_pivot_691 != 0)
    goto <bb 215>;
  else
    goto <bb 216>;

  <bb 215>:
  window.696_692 = window;
  _693 = &window.696_692->SetWindowPosPivot;
  window.697_694 = window;
  _695 = &window.697_694->SizeFull;
  D.17759 = operator* (_695, _693);
  window.698_697 = window;
  _698 = &window.698_697->SetWindowPosVal;
  D.17760 = operator- (_698, &D.17759);
  _700 = &style_160->DisplaySafeAreaPadding;
  D.17761 = ImMax (_700, &D.17760);
  window.699_702 = window;
  SetWindowPos (window.699_702, &D.17761, 0);
  D.17761 ={v} {CLOBBER};
  D.17760 ={v} {CLOBBER};
  D.17759 ={v} {CLOBBER};
  goto <bb 227>;

  <bb 216>:
  _707 = flags_2 & 268435456;
  if (_707 != 0)
    goto <bb 217>;
  else
    goto <bb 223>;

  <bb 217>:
  window_pos_set_by_api.700_708 = window_pos_set_by_api;
  if (window_pos_set_by_api.700_708 != 0)
    goto <bb 219>;
  else
    goto <bb 218>;

  <bb 218>:
  __assert_fail ("window_pos_set_by_api", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 5876, &__PRETTY_FUNCTION__);

  <bb 219>:
  horizontal_overlap_709 = style_160->ItemSpacing.x;
  parent_menu_710 = parent_window_in_stack_241;
  ImRect::ImRect (&rect_to_avoid);
  _712 = parent_menu_710->DC.MenuBarAppending;
  if (_712 != 0)
    goto <bb 220>;
  else
    goto <bb 221>;

  <bb 220>:
  _713 = parent_menu_710->Pos.y;
  _715 = ImGuiWindow::TitleBarHeight (parent_menu_710);
  _716 = _713 + _715;
  _718 = ImGuiWindow::MenuBarHeight (parent_menu_710);
  _719 = _716 + _718;
  _720 = parent_menu_710->Pos.y;
  _722 = ImGuiWindow::TitleBarHeight (parent_menu_710);
  _723 = _720 + _722;
  ImRect::ImRect (&rect_to_avoid.701, -3.4028234663852885981170418348451692544e+38, _723, 3.4028234663852885981170418348451692544e+38, _719);
  rect_to_avoid = rect_to_avoid.701;
  rect_to_avoid.701 ={v} {CLOBBER};
  goto <bb 222>;

  <bb 221>:
  _727 = parent_menu_710->Pos.x;
  _728 = parent_menu_710->Size.x;
  _729 = _727 + _728;
  _730 = _729 - horizontal_overlap_709;
  _731 = parent_menu_710->ScrollbarSizes.x;
  _732 = _730 - _731;
  _733 = parent_menu_710->Pos.x;
  _734 = _733 + horizontal_overlap_709;
  ImRect::ImRect (&rect_to_avoid.702, _734, -3.4028234663852885981170418348451692544e+38, _732, 3.4028234663852885981170418348451692544e+38);
  rect_to_avoid = rect_to_avoid.702;
  rect_to_avoid.702 ={v} {CLOBBER};

  <bb 222>:
  window.703_738 = window;
  window.704_739 = window;
  _740 = &window.704_739->AutoPosLastDirection;
  window.705_741 = window;
  _742 = &window.705_741->Size;
  window.706_743 = window;
  _744 = &window.706_743->PosFloat;
  window.703_738->PosFloat = FindBestWindowPosForPopup (_744, _742, _740, &rect_to_avoid, 0);
  rect_to_avoid ={v} {CLOBBER};
  goto <bb 227>;

  <bb 223>:
  _748 = flags_2 & 67108864;
  if (_748 != 0)
    goto <bb 224>;
  else
    goto <bb 227>;

  <bb 224>:
  window_pos_set_by_api.707_749 = window_pos_set_by_api;
  _750 = ~window_pos_set_by_api.707_749;
  if (_750 != 0)
    goto <bb 225>;
  else
    goto <bb 227>;

  <bb 225>:
  if (window_just_appearing_after_hidden_for_resize_200 != 0)
    goto <bb 226>;
  else
    goto <bb 227>;

  <bb 226>:
  window.708_751 = window;
  _752 = window.708_751->PosFloat.y;
  _753 = _752 + 1.0e+0;
  window.709_754 = window;
  _755 = window.709_754->PosFloat.x;
  _756 = _755 + 1.0e+0;
  window.710_757 = window;
  _758 = window.710_757->PosFloat.y;
  _759 = _758 - 1.0e+0;
  window.711_760 = window;
  _761 = window.711_760->PosFloat.x;
  _762 = _761 - 1.0e+0;
  ImRect::ImRect (&rect_to_avoid, _762, _759, _756, _753);
  window.712_764 = window;
  window.713_765 = window;
  _766 = &window.713_765->AutoPosLastDirection;
  window.714_767 = window;
  _768 = &window.714_767->Size;
  window.715_769 = window;
  _770 = &window.715_769->PosFloat;
  window.712_764->PosFloat = FindBestWindowPosForPopup (_770, _768, _766, &rect_to_avoid, 0);
  rect_to_avoid ={v} {CLOBBER};

  <bb 227>:
  _773 = flags_2 & 33554432;
  if (_773 != 0)
    goto <bb 228>;
  else
    goto <bb 242>;

  <bb 228>:
  window_pos_set_by_api.716_774 = window_pos_set_by_api;
  _775 = ~window_pos_set_by_api.716_774;
  if (_775 != 0)
    goto <bb 229>;
  else
    goto <bb 242>;

  <bb 229>:
  _776 = ~window_is_child_tooltip_365;
  if (_776 != 0)
    goto <bb 230>;
  else
    goto <bb 242>;

  <bb 230>:
  sc_777 = g_159->Style.MouseCursorScale;
  _778 = g_159->NavDisableHighlight;
  _779 = ~_778;
  if (_779 != 0)
    goto <bb 231>;
  else
    goto <bb 233>;

  <bb 231>:
  _780 = g_159->NavDisableMouseHover;
  if (_780 != 0)
    goto <bb 232>;
  else
    goto <bb 233>;

  <bb 232>:
  ref_pos = NavCalcPreferredMousePos ();
  goto <bb 234>;

  <bb 233>:
  ref_pos = g_159->IO.MousePos;

  <bb 234>:
  ImRect::ImRect (&rect_to_avoid);
  _786 = g_159->NavDisableHighlight;
  _787 = ~_786;
  if (_787 != 0)
    goto <bb 235>;
  else
    goto <bb 238>;

  <bb 235>:
  _788 = g_159->NavDisableMouseHover;
  if (_788 != 0)
    goto <bb 236>;
  else
    goto <bb 238>;

  <bb 236>:
  _789 = g_159->IO.ConfigFlags;
  _790 = _789 & 4;
  if (_790 == 0)
    goto <bb 237>;
  else
    goto <bb 238>;

  <bb 237>:
  _791 = ref_pos.y;
  _792 = _791 + 8.0e+0;
  _793 = ref_pos.x;
  _794 = _793 + 1.6e+1;
  _795 = ref_pos.y;
  _796 = _795 - 8.0e+0;
  _797 = ref_pos.x;
  _798 = _797 - 1.6e+1;
  ImRect::ImRect (&rect_to_avoid.717, _798, _796, _794, _792);
  rect_to_avoid = rect_to_avoid.717;
  rect_to_avoid.717 ={v} {CLOBBER};
  goto <bb 239>;

  <bb 238>:
  _802 = ref_pos.y;
  _803 = sc_777 * 2.4e+1;
  _804 = _802 + _803;
  _805 = ref_pos.x;
  _806 = sc_777 * 2.4e+1;
  _807 = _805 + _806;
  _808 = ref_pos.y;
  _809 = _808 - 8.0e+0;
  _810 = ref_pos.x;
  _811 = _810 - 1.6e+1;
  ImRect::ImRect (&rect_to_avoid.718, _811, _809, _807, _804);
  rect_to_avoid = rect_to_avoid.718;
  rect_to_avoid.718 ={v} {CLOBBER};

  <bb 239>:
  window.719_815 = window;
  window.720_816 = window;
  _817 = &window.720_816->AutoPosLastDirection;
  window.721_818 = window;
  _819 = &window.721_818->Size;
  window.719_815->PosFloat = FindBestWindowPosForPopup (&ref_pos, _819, _817, &rect_to_avoid, 0);
  window.722_821 = window;
  _822 = window.722_821->AutoPosLastDirection;
  if (_822 == -1)
    goto <bb 240>;
  else
    goto <bb 241>;

  <bb 240>:
  window.723_823 = window;
  ImVec2::ImVec2 (&D.17779, 2.0e+0, 2.0e+0);
  window.723_823->PosFloat = operator+ (&ref_pos, &D.17779);
  D.17779 ={v} {CLOBBER};

  <bb 241>:
  ref_pos ={v} {CLOBBER};
  rect_to_avoid ={v} {CLOBBER};

  <bb 242>:
  _829 = flags_2 & 16777216;
  if (_829 == 0)
    goto <bb 243>;
  else
    goto <bb 251>;

  <bb 243>:
  _830 = flags_2 & 33554432;
  if (_830 == 0)
    goto <bb 244>;
  else
    goto <bb 251>;

  <bb 244>:
  window_pos_set_by_api.724_831 = window_pos_set_by_api;
  _832 = ~window_pos_set_by_api.724_831;
  if (_832 != 0)
    goto <bb 245>;
  else
    goto <bb 250>;

  <bb 245>:
  window.725_833 = window;
  _834 = window.725_833->AutoFitFramesX;
  if (_834 <= 0)
    goto <bb 246>;
  else
    goto <bb 250>;

  <bb 246>:
  window.726_835 = window;
  _836 = window.726_835->AutoFitFramesY;
  if (_836 <= 0)
    goto <bb 247>;
  else
    goto <bb 250>;

  <bb 247>:
  _837 = g_159->IO.DisplaySize.x;
  if (_837 > 0.0)
    goto <bb 248>;
  else
    goto <bb 250>;

  <bb 248>:
  _838 = g_159->IO.DisplaySize.y;
  if (_838 > 0.0)
    goto <bb 249>;
  else
    goto <bb 250>;

  <bb 249>:
  _839 = &style_160->DisplaySafeAreaPadding;
  _840 = &style_160->DisplayWindowPadding;
  padding = ImMax (_840, _839);
  window.727_842 = window;
  window.728_843 = window;
  _844 = &window.728_843->Size;
  window.729_845 = window;
  _846 = &window.729_845->Size;
  window.730_847 = window;
  _848 = &window.730_847->PosFloat;
  D.17783 = operator+ (_848, _846);
  D.17784 = ImMax (&D.17783, &padding);
  window.727_842->PosFloat = operator- (&D.17784, _844);
  D.17784 ={v} {CLOBBER};
  D.17783 ={v} {CLOBBER};
  window.731_854 = window;
  _855 = &g_159->IO.DisplaySize;
  D.17786 = operator- (_855, &padding);
  window.732_857 = window;
  _858 = &window.732_857->PosFloat;
  window.731_854->PosFloat = ImMin (_858, &D.17786);
  D.17786 ={v} {CLOBBER};
  padding ={v} {CLOBBER};

  <bb 250>:

  <bb 251>:
  window.733_862 = window;
  window.734_863 = window;
  _864 = &window.734_863->PosFloat;
  window.733_862->Pos = ImFloor (_864);
  window.735_866 = window;
  _867 = window.735_866->Size.x;
  if (_867 > 0.0)
    goto <bb 252>;
  else
    goto <bb 255>;

  <bb 252>:
  _868 = flags_2 & 33554432;
  if (_868 == 0)
    goto <bb 253>;
  else
    goto <bb 255>;

  <bb 253>:
  _869 = flags_2 & 64;
  if (_869 == 0)
    goto <bb 254>;
  else
    goto <bb 255>;

  <bb 254>:
  window.736_870 = window;
  window.737_871 = window;
  _872 = window.737_871->Size.x;
  _873 = _872 * 6.4999997615814208984375e-1;
  _874 = (int) _873;
  _875 = (float) _874;
  window.736_870->ItemWidthDefault = _875;
  goto <bb 256>;

  <bb 255>:
  window.738_877 = window;
  _878 = g_159->FontSize;
  _879 = _878 * 1.6e+1;
  _880 = (int) _879;
  _881 = (float) _880;
  window.738_877->ItemWidthDefault = _881;

  <bb 256>:
  window.739_883 = window;
  window.741_884 = window;
  _885 = window.741_884->FocusIdxAllRequestNext;
  if (_885 != 2147483647)
    goto <bb 257>;
  else
    goto <bb 259>;

  <bb 257>:
  window.742_886 = window;
  _887 = window.742_886->FocusIdxAllCounter;
  if (_887 != -1)
    goto <bb 258>;
  else
    goto <bb 259>;

  <bb 258>:
  window.743_888 = window;
  _889 = window.743_888->FocusIdxAllRequestNext;
  window.744_890 = window;
  _891 = window.744_890->FocusIdxAllCounter;
  _892 = _891 + 1;
  _893 = _889 + _892;
  window.745_894 = window;
  _895 = window.745_894->FocusIdxAllCounter;
  _896 = _895 + 1;
  iftmp.740_897 = _893 % _896;
  goto <bb 260>;

  <bb 259>:
  iftmp.740_898 = 2147483647;

  <bb 260>:
  # iftmp.740_37 = PHI <iftmp.740_897(258), iftmp.740_898(259)>
  window.739_883->FocusIdxAllRequestCurrent = iftmp.740_37;
  window.746_900 = window;
  window.748_901 = window;
  _902 = window.748_901->FocusIdxTabRequestNext;
  if (_902 != 2147483647)
    goto <bb 261>;
  else
    goto <bb 263>;

  <bb 261>:
  window.749_903 = window;
  _904 = window.749_903->FocusIdxTabCounter;
  if (_904 != -1)
    goto <bb 262>;
  else
    goto <bb 263>;

  <bb 262>:
  window.750_905 = window;
  _906 = window.750_905->FocusIdxTabRequestNext;
  window.751_907 = window;
  _908 = window.751_907->FocusIdxTabCounter;
  _909 = _908 + 1;
  _910 = _906 + _909;
  window.752_911 = window;
  _912 = window.752_911->FocusIdxTabCounter;
  _913 = _912 + 1;
  iftmp.747_914 = _910 % _913;
  goto <bb 264>;

  <bb 263>:
  iftmp.747_915 = 2147483647;

  <bb 264>:
  # iftmp.747_38 = PHI <iftmp.747_914(262), iftmp.747_915(263)>
  window.746_900->FocusIdxTabRequestCurrent = iftmp.747_38;
  window.753_917 = window;
  window.754_918 = window;
  window.754_918->FocusIdxTabCounter = -1;
  _920 = window.754_918->FocusIdxTabCounter;
  window.753_917->FocusIdxAllCounter = _920;
  window.755_922 = window;
  window.756_923 = window;
  window.756_923->FocusIdxTabRequestNext = 2147483647;
  _925 = window.756_923->FocusIdxTabRequestNext;
  window.755_922->FocusIdxAllRequestNext = _925;
  window.757_927 = window;
  window.758_928 = window;
  window.757_927->Scroll = CalcNextScrollFromScrollTargetAndClamp (window.758_928);
  window.759_930 = window;
  ImVec2::ImVec2 (&D.17790, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  window.759_930->ScrollTarget = D.17790;
  D.17790 ={v} {CLOBBER};
  want_focus_934 = 0;
  if (window_just_activated_by_user_3 != 0)
    goto <bb 265>;
  else
    goto <bb 270>;

  <bb 265>:
  _935 = flags_2 & 4096;
  if (_935 == 0)
    goto <bb 266>;
  else
    goto <bb 270>;

  <bb 266>:
  _936 = flags_2 & 50331648;
  if (_936 == 0)
    goto <bb 268>;
  else
    goto <bb 267>;

  <bb 267>:
  _937 = flags_2 & 67108864;
  if (_937 != 0)
    goto <bb 268>;
  else
    goto <bb 269>;

  <bb 268>:
  want_focus_938 = 1;

  <bb 269>:
  # want_focus_6 = PHI <want_focus_934(267), want_focus_938(268)>

  <bb 270>:
  # want_focus_7 = PHI <want_focus_934(264), want_focus_934(265), want_focus_6(269)>
  border_held = -1;
  resize_grip_col = {};
  _941 = flags_2 & 131072;
  if (_941 != 0)
    goto <bb 271>;
  else
    goto <bb 272>;

  <bb 271>:
  iftmp.760_942 = 2;
  goto <bb 273>;

  <bb 272>:
  iftmp.760_943 = 1;

  <bb 273>:
  # iftmp.760_39 = PHI <iftmp.760_942(271), iftmp.760_943(272)>
  resize_grip_count_944 = iftmp.760_39;
  window.761_945 = window;
  _946 = window.761_945->WindowRounding;
  _947 = _946 + 1.0e+0;
  _948 = g_159->FontSize;
  _949 = _948 * 2.0000000298023223876953125e-1;
  _950 = _947 + _949;
  _951 = g_159->FontSize;
  _952 = _951 * 1.35000002384185791015625e+0;
  _954 = ImMax (_952, _950);
  _955 = (int) _954;
  grip_draw_size_956 = (const float) _955;
  window.762_957 = window;
  _958 = window.762_957->Collapsed;
  _959 = ~_958;
  if (_959 != 0)
    goto <bb 274>;
  else
    goto <bb 275>;

  <bb 274>:
  window.763_960 = window;
  ImGui::UpdateManualResize (window.763_960, &size_auto_fit, &border_held, resize_grip_count_944, &resize_grip_col[0]);

  <bb 275>:
  window.764_962 = window;
  _963 = window.764_962->DrawList;
  ImDrawList::Clear (_963);
  window.765_965 = window;
  _966 = window.765_965->DrawList;
  _967 = g_159->Style.AntiAliasedLines;
  if (_967 != 0)
    goto <bb 276>;
  else
    goto <bb 277>;

  <bb 276>:
  iftmp.766_968 = 1;
  goto <bb 278>;

  <bb 277>:
  iftmp.766_969 = 0;

  <bb 278>:
  # iftmp.766_40 = PHI <iftmp.766_968(276), iftmp.766_969(277)>
  _970 = g_159->Style.AntiAliasedFill;
  if (_970 != 0)
    goto <bb 279>;
  else
    goto <bb 280>;

  <bb 279>:
  iftmp.767_971 = 2;
  goto <bb 281>;

  <bb 280>:
  iftmp.767_972 = 0;

  <bb 281>:
  # iftmp.767_41 = PHI <iftmp.767_971(279), iftmp.767_972(280)>
  _973 = iftmp.766_40 | iftmp.767_41;
  _966->Flags = _973;
  _975 = g_159->Font;
  _976 = _975->ContainerAtlas;
  _977 = _976->TexID;
  window.768_978 = window;
  _979 = window.768_978->DrawList;
  ImDrawList::PushTextureID (_979, _977);
  viewport_rect = GetViewportRect ();
  _982 = flags_2 & 16777216;
  if (_982 != 0)
    goto <bb 282>;
  else
    goto <bb 285>;

  <bb 282>:
  _983 = flags_2 & 67108864;
  if (_983 == 0)
    goto <bb 283>;
  else
    goto <bb 285>;

  <bb 283>:
  _984 = ~window_is_child_tooltip_365;
  if (_984 != 0)
    goto <bb 284>;
  else
    goto <bb 285>;

  <bb 284>:
  _985 = &parent_window_248->ClipRect.Max;
  _986 = &parent_window_248->ClipRect.Min;
  ImGui::PushClipRect (_986, _985, 1);
  goto <bb 286>;

  <bb 285>:
  ImGui::PushClipRect (&viewport_rect.Min, &viewport_rect.Max, 1);

  <bb 286>:
  _989 = flags_2 & 134217728;
  if (_989 != 0)
    goto <bb 287>;
  else
    goto <bb 289>;

  <bb 287>:
  _991 = GetFrontMostModalRootWindow ();
  window.771_992 = window;
  if (_991 == window.771_992)
    goto <bb 288>;
  else
    goto <bb 289>;

  <bb 288>:
  iftmp.770_993 = 1;
  goto <bb 290>;

  <bb 289>:
  iftmp.770_994 = 0;

  <bb 290>:
  # iftmp.770_42 = PHI <iftmp.770_993(288), iftmp.770_994(289)>
  retval.769_995 = iftmp.770_42;
  if (retval.769_995 != 0)
    goto <bb 291>;
  else
    goto <bb 292>;

  <bb 291>:
  _996 = g_159->ModalWindowDarkeningRatio;
  _998 = ImGui::GetColorU32 (38, _996);
  window.772_999 = window;
  _1000 = window.772_999->DrawList;
  ImDrawList::AddRectFilled (_1000, &viewport_rect.Min, &viewport_rect.Max, _998, 0.0, 15);

  <bb 292>:
  _1002 = g_159->NavWindowingTarget;
  window.773_1003 = window;
  if (_1002 == window.773_1003)
    goto <bb 293>;
  else
    goto <bb 296>;

  <bb 293>:
  window.774_1004 = window;
  bb = ImGuiWindow::Rect (window.774_1004);
  _1006 = g_159->FontSize;
  ImRect::Expand (&bb, _1006);
  _1009 = ImRect::Contains (&bb, &viewport_rect);
  retval.775_1010 = ~_1009;
  if (retval.775_1010 != 0)
    goto <bb 294>;
  else
    goto <bb 295>;

  <bb 294>:
  _1011 = g_159->Style.WindowRounding;
  _1012 = g_159->NavWindowingHighlightAlpha;
  _1013 = _1012 * 2.5e-1;
  _1015 = ImGui::GetColorU32 (41, _1013);
  window.776_1016 = window;
  _1017 = window.776_1016->DrawList;
  ImDrawList::AddRectFilled (_1017, &bb.Min, &bb.Max, _1015, _1011, 15);

  <bb 295>:
  bb ={v} {CLOBBER};

  <bb 296>:
  window.777_1021 = window;
  window_rounding_1022 = window.777_1021->WindowRounding;
  window.778_1023 = window;
  window_border_size_1024 = window.778_1023->WindowBorderSize;
  if (want_focus_7 != 0)
    goto <bb 299>;
  else
    goto <bb 297>;

  <bb 297>:
  _1025 = g_159->NavWindow;
  if (_1025 != 0B)
    goto <bb 298>;
  else
    goto <bb 300>;

  <bb 298>:
  window.780_1026 = window;
  _1027 = window.780_1026->RootWindowForTitleBarHighlight;
  _1028 = g_159->NavWindow;
  _1029 = _1028->RootWindowForTitleBarHighlight;
  if (_1027 == _1029)
    goto <bb 299>;
  else
    goto <bb 300>;

  <bb 299>:
  iftmp.779_1031 = 1;
  goto <bb 301>;

  <bb 300>:
  iftmp.779_1030 = 0;

  <bb 301>:
  # iftmp.779_43 = PHI <iftmp.779_1031(299), iftmp.779_1030(300)>
  title_bar_is_highlight_1032 = iftmp.779_43;
  window.781_1033 = window;
  title_bar_rect = ImGuiWindow::TitleBarRect (window.781_1033);
  window.782_1035 = window;
  _1036 = window.782_1035->Collapsed;
  if (_1036 != 0)
    goto <bb 302>;
  else
    goto <bb 307>;

  <bb 302>:
  backup_border_size_1037 = style_160->FrameBorderSize;
  window.783_1038 = window;
  _1039 = window.783_1038->WindowBorderSize;
  g_159->Style.FrameBorderSize = _1039;
  if (title_bar_is_highlight_1032 != 0)
    goto <bb 303>;
  else
    goto <bb 305>;

  <bb 303>:
  _1041 = g_159->NavDisableHighlight;
  _1042 = ~_1041;
  if (_1042 != 0)
    goto <bb 304>;
  else
    goto <bb 305>;

  <bb 304>:
  iftmp.784_1043 = 11;
  goto <bb 306>;

  <bb 305>:
  iftmp.784_1044 = 12;

  <bb 306>:
  # iftmp.784_44 = PHI <iftmp.784_1043(304), iftmp.784_1044(305)>
  title_bar_col_1046 = ImGui::GetColorU32 (iftmp.784_44, 1.0e+0);
  ImGui::RenderFrame (title_bar_rect.Min, title_bar_rect.Max, title_bar_col_1046, 1, window_rounding_1022);
  g_159->Style.FrameBorderSize = backup_border_size_1037;
  goto <bb 350>;

  <bb 307>:
  _1050 = GetWindowBgColorIdxFromFlags (flags_2);
  bg_col_1052 = ImGui::GetColorU32 (_1050, 1.0e+0);
  _1053 = g_159->NextWindowData.BgAlphaCond;
  if (_1053 != 0)
    goto <bb 308>;
  else
    goto <bb 309>;

  <bb 308>:
  _1054 = bg_col_1052 & 16777215;
  _1055 = g_159->NextWindowData.BgAlphaVal;
  _1057 = ImSaturate (_1055);
  _1058 = _1057 * 2.55e+2;
  _1059 = _1058 + 5.0e-1;
  _1060 = (int) _1059;
  _1061 = _1060 << 24;
  _1062 = (unsigned int) _1061;
  bg_col_1063 = _1054 | _1062;
  g_159->NextWindowData.BgAlphaCond = 0;

  <bb 309>:
  # bg_col_8 = PHI <bg_col_1052(307), bg_col_1063(308)>
  _1065 = flags_2 & 1;
  if (_1065 != 0)
    goto <bb 310>;
  else
    goto <bb 311>;

  <bb 310>:
  iftmp.785_1066 = 15;
  goto <bb 312>;

  <bb 311>:
  iftmp.785_1067 = 12;

  <bb 312>:
  # iftmp.785_45 = PHI <iftmp.785_1066(310), iftmp.785_1067(311)>
  window.786_1068 = window;
  _1069 = &window.786_1068->Size;
  window.787_1070 = window;
  _1071 = &window.787_1070->Pos;
  D.17812 = operator+ (_1071, _1069);
  window.788_1073 = window;
  _1075 = ImGuiWindow::TitleBarHeight (window.788_1073);
  ImVec2::ImVec2 (&D.17810, 0.0, _1075);
  window.789_1077 = window;
  _1078 = &window.789_1077->Pos;
  D.17811 = operator+ (_1078, &D.17810);
  window.790_1080 = window;
  _1081 = window.790_1080->DrawList;
  ImDrawList::AddRectFilled (_1081, &D.17811, &D.17812, bg_col_8, window_rounding_1022, iftmp.785_45);
  D.17811 ={v} {CLOBBER};
  D.17810 ={v} {CLOBBER};
  D.17812 ={v} {CLOBBER};
  window.792_1086 = window;
  _1087 = window.792_1086->Collapsed;
  if (_1087 != 0)
    goto <bb 313>;
  else
    goto <bb 314>;

  <bb 313>:
  iftmp.791_1088 = 12;
  goto <bb 318>;

  <bb 314>:
  if (title_bar_is_highlight_1032 != 0)
    goto <bb 315>;
  else
    goto <bb 316>;

  <bb 315>:
  iftmp.793_1089 = 11;
  goto <bb 317>;

  <bb 316>:
  iftmp.793_1090 = 10;

  <bb 317>:
  # iftmp.793_47 = PHI <iftmp.793_1089(315), iftmp.793_1090(316)>
  iftmp.791_1091 = iftmp.793_47;

  <bb 318>:
  # iftmp.791_46 = PHI <iftmp.791_1088(313), iftmp.791_1091(317)>
  title_bar_col_1093 = ImGui::GetColorU32 (iftmp.791_46, 1.0e+0);
  _1094 = flags_2 & 1;
  if (_1094 == 0)
    goto <bb 319>;
  else
    goto <bb 320>;

  <bb 319>:
  window.794_1095 = window;
  _1096 = window.794_1095->DrawList;
  ImDrawList::AddRectFilled (_1096, &title_bar_rect.Min, &title_bar_rect.Max, title_bar_col_1093, window_rounding_1022, 3);

  <bb 320>:
  _1098 = flags_2 & 1024;
  if (_1098 != 0)
    goto <bb 321>;
  else
    goto <bb 328>;

  <bb 321>:
  window.795_1099 = window;
  menu_bar_rect = ImGuiWindow::MenuBarRect (window.795_1099);
  window.796_1101 = window;
  D.17816 = ImGuiWindow::Rect (window.796_1101);
  ImRect::ClipWith (&menu_bar_rect, &D.17816);
  D.17816 ={v} {CLOBBER};
  _1105 = flags_2 & 1;
  if (_1105 != 0)
    goto <bb 322>;
  else
    goto <bb 323>;

  <bb 322>:
  iftmp.797_1106 = window_rounding_1022;
  goto <bb 324>;

  <bb 323>:
  iftmp.797_1107 = 0.0;

  <bb 324>:
  # iftmp.797_48 = PHI <iftmp.797_1106(322), iftmp.797_1107(323)>
  _1109 = ImGui::GetColorU32 (13, 1.0e+0);
  window.798_1110 = window;
  _1111 = window.798_1110->DrawList;
  ImDrawList::AddRectFilled (_1111, &menu_bar_rect.Min, &menu_bar_rect.Max, _1109, iftmp.797_48, 3);
  _1113 = style_160->FrameBorderSize;
  if (_1113 > 0.0)
    goto <bb 325>;
  else
    goto <bb 327>;

  <bb 325>:
  _1114 = menu_bar_rect.Max.y;
  window.799_1115 = window;
  _1116 = window.799_1115->Pos.y;
  window.800_1117 = window;
  _1118 = window.800_1117->Size.y;
  _1119 = _1116 + _1118;
  if (_1114 < _1119)
    goto <bb 326>;
  else
    goto <bb 327>;

  <bb 326>:
  _1120 = style_160->FrameBorderSize;
  _1122 = ImGui::GetColorU32 (5, 1.0e+0);
  D.17818 = ImRect::GetBR (&menu_bar_rect);
  D.17817 = ImRect::GetBL (&menu_bar_rect);
  window.801_1125 = window;
  _1126 = window.801_1125->DrawList;
  ImDrawList::AddLine (_1126, &D.17817, &D.17818, _1122, _1120);
  D.17817 ={v} {CLOBBER};
  D.17818 ={v} {CLOBBER};

  <bb 327>:
  menu_bar_rect ={v} {CLOBBER};

  <bb 328>:
  window.802_1134 = window;
  _1135 = window.802_1134->ScrollbarX;
  if (_1135 != 0)
    goto <bb 329>;
  else
    goto <bb 330>;

  <bb 329>:
  ImGui::Scrollbar (1);

  <bb 330>:
  window.803_1137 = window;
  _1138 = window.803_1137->ScrollbarY;
  if (_1138 != 0)
    goto <bb 331>;
  else
    goto <bb 332>;

  <bb 331>:
  ImGui::Scrollbar (0);

  <bb 332>:
  _1140 = flags_2 & 2;
  if (_1140 == 0)
    goto <bb 333>;
  else
    goto <bb 343>;

  <bb 333>:
  resize_grip_n_1141 = 0;

  <bb 334>:
  # resize_grip_n_9 = PHI <resize_grip_n_1141(333), resize_grip_n_1199(341)>
  if (resize_grip_n_9 >= resize_grip_count_944)
    goto <bb 342>;
  else
    goto <bb 335>;

  <bb 335>:
  grip_1142 = &resize_grip_def[resize_grip_n_9];
  _1143 = &grip_1142->CornerPos;
  window.804_1144 = window;
  _1145 = &window.804_1144->Size;
  window.805_1146 = window;
  _1147 = &window.805_1146->Pos;
  D.17822 = operator+ (_1147, _1145);
  window.806_1149 = window;
  _1150 = &window.806_1149->Pos;
  corner = ImLerp (_1150, &D.17822, _1143);
  D.17822 ={v} {CLOBBER};
  _1153 = resize_grip_n_9 & 1;
  if (_1153 != 0)
    goto <bb 336>;
  else
    goto <bb 337>;

  <bb 336>:
  ImVec2::ImVec2 (&D.17826, window_border_size_1024, grip_draw_size_956);
  goto <bb 338>;

  <bb 337>:
  ImVec2::ImVec2 (&D.17826, grip_draw_size_956, window_border_size_1024);

  <bb 338>:
  _1156 = &grip_1142->InnerDir;
  D.17827 = operator* (_1156, &D.17826);
  D.17828 = operator+ (&corner, &D.17827);
  window.807_1159 = window;
  _1160 = window.807_1159->DrawList;
  ImDrawList::PathLineTo (_1160, &D.17828);
  D.17828 ={v} {CLOBBER};
  D.17827 ={v} {CLOBBER};
  D.17826 ={v} {CLOBBER};
  _1165 = resize_grip_n_9 & 1;
  if (_1165 != 0)
    goto <bb 339>;
  else
    goto <bb 340>;

  <bb 339>:
  ImVec2::ImVec2 (&D.17831, grip_draw_size_956, window_border_size_1024);
  goto <bb 341>;

  <bb 340>:
  ImVec2::ImVec2 (&D.17831, window_border_size_1024, grip_draw_size_956);

  <bb 341>:
  _1168 = &grip_1142->InnerDir;
  D.17832 = operator* (_1168, &D.17831);
  D.17833 = operator+ (&corner, &D.17832);
  window.808_1171 = window;
  _1172 = window.808_1171->DrawList;
  ImDrawList::PathLineTo (_1172, &D.17833);
  D.17833 ={v} {CLOBBER};
  D.17832 ={v} {CLOBBER};
  D.17831 ={v} {CLOBBER};
  _1177 = grip_1142->AngleMax12;
  _1178 = grip_1142->AngleMin12;
  _1179 = corner.y;
  _1180 = grip_1142->InnerDir.y;
  _1181 = window_rounding_1022 + window_border_size_1024;
  _1182 = _1180 * _1181;
  _1183 = _1179 + _1182;
  _1184 = corner.x;
  _1185 = grip_1142->InnerDir.x;
  _1186 = window_rounding_1022 + window_border_size_1024;
  _1187 = _1185 * _1186;
  _1188 = _1184 + _1187;
  ImVec2::ImVec2 (&D.17834, _1188, _1183);
  window.809_1190 = window;
  _1191 = window.809_1190->DrawList;
  ImDrawList::PathArcToFast (_1191, &D.17834, window_rounding_1022, _1178, _1177);
  D.17834 ={v} {CLOBBER};
  _1194 = resize_grip_col[resize_grip_n_9];
  window.810_1195 = window;
  _1196 = window.810_1195->DrawList;
  ImDrawList::PathFillConvex (_1196, _1194);
  corner ={v} {CLOBBER};
  resize_grip_n_1199 = resize_grip_n_9 + 1;
  goto <bb 334>;

  <bb 342>:

  <bb 343>:
  if (window_border_size_1024 > 0.0)
    goto <bb 344>;
  else
    goto <bb 345>;

  <bb 344>:
  _1209 = ImGui::GetColorU32 (5, 1.0e+0);
  window.811_1210 = window;
  _1211 = &window.811_1210->Size;
  window.812_1212 = window;
  _1213 = &window.812_1212->Pos;
  D.17835 = operator+ (_1213, _1211);
  window.813_1215 = window;
  _1216 = &window.813_1215->Pos;
  window.814_1217 = window;
  _1218 = window.814_1217->DrawList;
  ImDrawList::AddRect (_1218, _1216, &D.17835, _1209, window_rounding_1022, 15, window_border_size_1024);
  D.17835 ={v} {CLOBBER};

  <bb 345>:
  border_held.815_1222 = border_held;
  if (border_held.815_1222 != -1)
    goto <bb 346>;
  else
    goto <bb 347>;

  <bb 346>:
  border_held.816_1223 = border_held;
  window.817_1224 = window;
  border = GetBorderRect (window.817_1224, border_held.816_1223, grip_draw_size_956, 0.0);
  _1227 = ImMax (1.0e+0, window_border_size_1024);
  _1229 = ImGui::GetColorU32 (29, 1.0e+0);
  window.818_1230 = window;
  _1231 = window.818_1230->DrawList;
  ImDrawList::AddLine (_1231, &border.Min, &border.Max, _1229, _1227);
  border ={v} {CLOBBER};

  <bb 347>:
  _1235 = style_160->FrameBorderSize;
  if (_1235 > 0.0)
    goto <bb 348>;
  else
    goto <bb 350>;

  <bb 348>:
  _1236 = flags_2 & 1;
  if (_1236 == 0)
    goto <bb 349>;
  else
    goto <bb 350>;

  <bb 349>:
  _1237 = style_160->FrameBorderSize;
  _1239 = ImGui::GetColorU32 (5, 1.0e+0);
  _1240 = style_160->WindowBorderSize;
  _1241 = -_1240;
  ImVec2::ImVec2 (&D.17842, _1241, -1.0e+0);
  D.17841 = ImRect::GetBR (&title_bar_rect);
  D.17843 = operator+ (&D.17841, &D.17842);
  _1245 = style_160->WindowBorderSize;
  ImVec2::ImVec2 (&D.17839, _1245, -1.0e+0);
  D.17838 = ImRect::GetBL (&title_bar_rect);
  D.17840 = operator+ (&D.17838, &D.17839);
  window.819_1249 = window;
  _1250 = window.819_1249->DrawList;
  ImDrawList::AddLine (_1250, &D.17840, &D.17843, _1239, _1237);
  D.17840 ={v} {CLOBBER};
  D.17838 ={v} {CLOBBER};
  D.17839 ={v} {CLOBBER};
  D.17843 ={v} {CLOBBER};
  D.17841 ={v} {CLOBBER};
  D.17842 ={v} {CLOBBER};

  <bb 350>:
  _1267 = g_159->NavWindowingTarget;
  window.820_1268 = window;
  if (_1267 == window.820_1268)
    goto <bb 351>;
  else
    goto <bb 354>;

  <bb 351>:
  _1269 = g_159->Style.WindowRounding;
  window.821_1270 = window;
  _1271 = window.821_1270->WindowRounding;
  rounding_1273 = ImMax (_1271, _1269);
  window.822_1274 = window;
  bb = ImGuiWindow::Rect (window.822_1274);
  _1276 = g_159->FontSize;
  ImRect::Expand (&bb, _1276);
  retval.823_1279 = ImRect::Contains (&bb, &viewport_rect);
  if (retval.823_1279 != 0)
    goto <bb 352>;
  else
    goto <bb 353>;

  <bb 352>:
  _1280 = g_159->FontSize;
  _1281 = -_1280;
  _1282 = _1281 - 1.0e+0;
  ImRect::Expand (&bb, _1282);
  window.824_1284 = window;
  rounding_1285 = window.824_1284->WindowRounding;

  <bb 353>:
  # rounding_10 = PHI <rounding_1273(351), rounding_1285(352)>
  _1286 = g_159->NavWindowingHighlightAlpha;
  _1288 = ImGui::GetColorU32 (41, _1286);
  window.825_1289 = window;
  _1290 = window.825_1289->DrawList;
  ImDrawList::AddRect (_1290, &bb.Min, &bb.Max, _1288, rounding_10, -1, 3.0e+0);
  bb ={v} {CLOBBER};

  <bb 354>:
  window.826_1294 = window;
  window.827_1295 = window;
  window.826_1294->SizeFullAtLastBegin = window.827_1295->SizeFull;
  window.828_1297 = window;
  window.829_1298 = window;
  _1299 = window.829_1298->WindowPadding.x;
  window.830_1300 = window;
  _1301 = window.830_1300->Scroll.x;
  _1302 = _1299 - _1301;
  window.828_1297->ContentsRegionRect.Min.x = _1302;
  window.831_1304 = window;
  window.832_1305 = window;
  _1306 = window.832_1305->WindowPadding.y;
  window.833_1307 = window;
  _1308 = window.833_1307->Scroll.y;
  _1309 = _1306 - _1308;
  window.834_1310 = window;
  _1312 = ImGuiWindow::TitleBarHeight (window.834_1310);
  _1313 = _1309 + _1312;
  window.835_1314 = window;
  _1316 = ImGuiWindow::MenuBarHeight (window.835_1314);
  _1317 = _1313 + _1316;
  window.831_1304->ContentsRegionRect.Min.y = _1317;
  window.836_1319 = window;
  window.837_1320 = window;
  _1321 = window.837_1320->Scroll.x;
  _1322 = -_1321;
  window.838_1323 = window;
  _1324 = window.838_1323->WindowPadding.x;
  _1325 = _1322 - _1324;
  window.840_1326 = window;
  _1327 = window.840_1326->SizeContentsExplicit.x;
  if (_1327 != 0.0)
    goto <bb 355>;
  else
    goto <bb 356>;

  <bb 355>:
  window.841_1328 = window;
  iftmp.839_1329 = window.841_1328->SizeContentsExplicit.x;
  goto <bb 357>;

  <bb 356>:
  window.842_1330 = window;
  _1331 = window.842_1330->Size.x;
  window.843_1332 = window;
  _1333 = window.843_1332->ScrollbarSizes.x;
  iftmp.839_1334 = _1331 - _1333;

  <bb 357>:
  # iftmp.839_49 = PHI <iftmp.839_1329(355), iftmp.839_1334(356)>
  _1335 = _1325 + iftmp.839_49;
  window.836_1319->ContentsRegionRect.Max.x = _1335;
  window.844_1337 = window;
  window.845_1338 = window;
  _1339 = window.845_1338->Scroll.y;
  _1340 = -_1339;
  window.846_1341 = window;
  _1342 = window.846_1341->WindowPadding.y;
  _1343 = _1340 - _1342;
  window.848_1344 = window;
  _1345 = window.848_1344->SizeContentsExplicit.y;
  if (_1345 != 0.0)
    goto <bb 358>;
  else
    goto <bb 359>;

  <bb 358>:
  window.849_1346 = window;
  iftmp.847_1347 = window.849_1346->SizeContentsExplicit.y;
  goto <bb 360>;

  <bb 359>:
  window.850_1348 = window;
  _1349 = window.850_1348->Size.y;
  window.851_1350 = window;
  _1351 = window.851_1350->ScrollbarSizes.y;
  iftmp.847_1352 = _1349 - _1351;

  <bb 360>:
  # iftmp.847_50 = PHI <iftmp.847_1347(358), iftmp.847_1352(359)>
  _1353 = _1343 + iftmp.847_50;
  window.844_1337->ContentsRegionRect.Max.y = _1353;
  window.852_1355 = window;
  window.853_1356 = window;
  _1357 = window.853_1356->WindowPadding.x;
  _1358 = _1357 + 0.0;
  window.854_1359 = window;
  _1360 = window.854_1359->Scroll.x;
  _1361 = _1358 - _1360;
  window.852_1355->DC.IndentX = _1361;
  window.855_1363 = window;
  window.855_1363->DC.GroupOffsetX = 0.0;
  window.856_1365 = window;
  window.856_1365->DC.ColumnsOffsetX = 0.0;
  window.857_1367 = window;
  window.858_1368 = window;
  _1370 = ImGuiWindow::TitleBarHeight (window.858_1368);
  window.859_1371 = window;
  _1373 = ImGuiWindow::MenuBarHeight (window.859_1371);
  _1374 = _1370 + _1373;
  window.860_1375 = window;
  _1376 = window.860_1375->WindowPadding.y;
  _1377 = _1374 + _1376;
  window.861_1378 = window;
  _1379 = window.861_1378->Scroll.y;
  _1380 = _1377 - _1379;
  window.862_1381 = window;
  _1382 = window.862_1381->DC.IndentX;
  window.863_1383 = window;
  _1384 = window.863_1383->DC.ColumnsOffsetX;
  _1385 = _1382 + _1384;
  ImVec2::ImVec2 (&D.17847, _1385, _1380);
  window.864_1387 = window;
  _1388 = &window.864_1387->Pos;
  window.857_1367->DC.CursorStartPos = operator+ (_1388, &D.17847);
  D.17847 ={v} {CLOBBER};
  window.865_1391 = window;
  window.866_1392 = window;
  window.865_1391->DC.CursorPos = window.866_1392->DC.CursorStartPos;
  window.867_1394 = window;
  window.868_1395 = window;
  window.867_1394->DC.CursorPosPrevLine = window.868_1395->DC.CursorPos;
  window.869_1397 = window;
  window.870_1398 = window;
  window.869_1397->DC.CursorMaxPos = window.870_1398->DC.CursorStartPos;
  window.871_1400 = window;
  window.872_1401 = window;
  window.872_1401->DC.PrevLineHeight = 0.0;
  _1403 = window.872_1401->DC.PrevLineHeight;
  window.871_1400->DC.CurrentLineHeight = _1403;
  window.873_1405 = window;
  window.874_1406 = window;
  window.874_1406->DC.PrevLineTextBaseOffset = 0.0;
  _1408 = window.874_1406->DC.PrevLineTextBaseOffset;
  window.873_1405->DC.CurrentLineTextBaseOffset = _1408;
  window.875_1410 = window;
  window.875_1410->DC.NavHideHighlightOneFrame = 0;
  window.876_1412 = window;
  _1414 = ImGui::GetScrollMaxY ();
  _1415 = _1414 > 0.0;
  window.876_1412->DC.NavHasScroll = _1415;
  window.877_1417 = window;
  window.878_1418 = window;
  _1419 = window.878_1418->DC.NavLayerActiveMaskNext;
  window.877_1417->DC.NavLayerActiveMask = _1419;
  window.879_1421 = window;
  window.879_1421->DC.NavLayerActiveMaskNext = 0;
  window.880_1423 = window;
  window.880_1423->DC.MenuBarAppending = 0;
  window.881_1425 = window;
  _1426 = style_160->ItemSpacing.x;
  window.882_1427 = window;
  _1428 = window.882_1427->WindowPadding.x;
  _1430 = ImMax (_1428, _1426);
  window.881_1425->DC.MenuBarOffsetX = _1430;
  window.883_1432 = window;
  window.884_1433 = window;
  _1434 = window.884_1433->DC.CursorPos.y;
  _1435 = _1434 - 9.999e+3;
  window.883_1432->DC.LogLinePosY = _1435;
  window.885_1437 = window;
  _1438 = &window.885_1437->DC.ChildWindows;
  ImVector<ImGuiWindow*>::resize (_1438, 0);
  window.886_1440 = window;
  window.886_1440->DC.LayoutType = 0;
  window.887_1442 = window;
  if (parent_window_248 != 0B)
    goto <bb 361>;
  else
    goto <bb 362>;

  <bb 361>:
  iftmp.888_1443 = parent_window_248->DC.LayoutType;
  goto <bb 363>;

  <bb 362>:
  iftmp.888_1444 = 0;

  <bb 363>:
  # iftmp.888_51 = PHI <iftmp.888_1443(361), iftmp.888_1444(362)>
  window.887_1442->DC.ParentLayoutType = iftmp.888_51;
  window.889_1446 = window;
  window.889_1446->DC.ItemFlags = 1;
  window.890_1448 = window;
  window.891_1449 = window;
  _1450 = window.891_1449->ItemWidthDefault;
  window.890_1448->DC.ItemWidth = _1450;
  window.892_1452 = window;
  window.892_1452->DC.TextWrapPos = -1.0e+0;
  window.893_1454 = window;
  _1455 = &window.893_1454->DC.ItemFlagsStack;
  ImVector<int>::resize (_1455, 0);
  window.894_1457 = window;
  _1458 = &window.894_1457->DC.ItemWidthStack;
  ImVector<float>::resize (_1458, 0);
  window.895_1460 = window;
  _1461 = &window.895_1460->DC.TextWrapPosStack;
  ImVector<float>::resize (_1461, 0);
  window.896_1463 = window;
  window.896_1463->DC.ColumnsSet = 0B;
  window.897_1465 = window;
  window.897_1465->DC.TreeDepth = 0;
  window.898_1467 = window;
  window.898_1467->DC.TreeDepthMayJumpToParentOnPop = 0;
  window.899_1469 = window;
  window.900_1470 = window;
  _1471 = &window.900_1470->StateStorage;
  window.899_1469->DC.StateStorage = _1471;
  window.901_1473 = window;
  _1474 = &window.901_1473->DC.GroupStack;
  ImVector<ImGuiGroupData>::resize (_1474, 0);
  _1476 = (int) window_just_activated_by_user_3;
  _1477 = style_160->ItemSpacing.x;
  window.902_1478 = window;
  _1479 = &window.902_1478->MenuColumns;
  ImGuiMenuColumns::Update (_1479, 3, _1477, _1476);
  _1481 = flags_2 & 16777216;
  if (_1481 != 0)
    goto <bb 364>;
  else
    goto <bb 366>;

  <bb 364>:
  window.903_1482 = window;
  _1483 = window.903_1482->DC.ItemFlags;
  _1484 = parent_window_248->DC.ItemFlags;
  if (_1483 != _1484)
    goto <bb 365>;
  else
    goto <bb 366>;

  <bb 365>:
  window.904_1485 = window;
  _1486 = parent_window_248->DC.ItemFlags;
  window.904_1485->DC.ItemFlags = _1486;
  window.905_1488 = window;
  _1489 = &window.905_1488->DC.ItemFlags;
  window.906_1490 = window;
  _1491 = &window.906_1490->DC.ItemFlagsStack;
  ImVector<int>::push_back (_1491, _1489);

  <bb 366>:
  window.907_1493 = window;
  _1494 = window.907_1493->AutoFitFramesX;
  if (_1494 > 0)
    goto <bb 367>;
  else
    goto <bb 368>;

  <bb 367>:
  window.908_1495 = window;
  _1496 = window.908_1495->AutoFitFramesX;
  _1497 = _1496 + -1;
  window.908_1495->AutoFitFramesX = _1497;

  <bb 368>:
  window.909_1499 = window;
  _1500 = window.909_1499->AutoFitFramesY;
  if (_1500 > 0)
    goto <bb 369>;
  else
    goto <bb 370>;

  <bb 369>:
  window.910_1501 = window;
  _1502 = window.910_1501->AutoFitFramesY;
  _1503 = _1502 + -1;
  window.910_1501->AutoFitFramesY = _1503;

  <bb 370>:
  if (want_focus_7 != 0)
    goto <bb 371>;
  else
    goto <bb 372>;

  <bb 371>:
  window.911_1505 = window;
  ImGui::FocusWindow (window.911_1505);
  window.912_1507 = window;
  ImGui::NavInitWindow (window.912_1507, 0);

  <bb 372>:
  _1509 = flags_2 & 1;
  if (_1509 == 0)
    goto <bb 373>;
  else
    goto <bb 397>;

  <bb 373>:
  window.913_1510 = window;
  item_flags_backup_1511 = window.913_1510->DC.ItemFlags;
  window.914_1512 = window;
  window.915_1513 = window;
  _1514 = window.915_1513->DC.ItemFlags;
  _1515 = _1514 | 16;
  window.914_1512->DC.ItemFlags = _1515;
  window.916_1517 = window;
  _1518 = window.916_1517->DC.NavLayerCurrent;
  _1519 = _1518 + 1;
  window.916_1517->DC.NavLayerCurrent = _1519;
  window.917_1521 = window;
  window.918_1522 = window;
  _1523 = window.918_1522->DC.NavLayerCurrentMask;
  _1524 = _1523 << 1;
  window.917_1521->DC.NavLayerCurrentMask = _1524;
  _1526 = flags_2 & 32;
  if (_1526 == 0)
    goto <bb 374>;
  else
    goto <bb 380>;

  <bb 374>:
  window.919_1527 = window;
  _1529 = ImGuiWindow::GetID (window.919_1527, "#COLLAPSE", 0B);
  id_1530 = _1529;
  ImVec2::ImVec2 (&D.17858, 1.0e+0, 1.0e+0);
  _1532 = g_159->FontSize;
  _1533 = g_159->FontSize;
  ImVec2::ImVec2 (&D.17856, _1533, _1532);
  _1535 = &style_160->FramePadding;
  window.920_1536 = window;
  _1537 = &window.920_1536->Pos;
  D.17855 = operator+ (_1537, _1535);
  D.17857 = operator+ (&D.17855, &D.17856);
  D.17859 = operator- (&D.17857, &D.17858);
  ImVec2::ImVec2 (&D.17853, 1.0e+0, 1.0e+0);
  _1542 = &style_160->FramePadding;
  window.921_1543 = window;
  _1544 = &window.921_1543->Pos;
  D.17852 = operator+ (_1544, _1542);
  D.17854 = operator+ (&D.17852, &D.17853);
  ImRect::ImRect (&bb, &D.17854, &D.17859);
  D.17854 ={v} {CLOBBER};
  D.17852 ={v} {CLOBBER};
  D.17853 ={v} {CLOBBER};
  D.17859 ={v} {CLOBBER};
  D.17857 ={v} {CLOBBER};
  D.17855 ={v} {CLOBBER};
  D.17856 ={v} {CLOBBER};
  D.17858 ={v} {CLOBBER};
  ImGui::ItemAdd (&bb, id_1530, 0B);
  _1558 = ImGui::ButtonBehavior (&bb, id_1530, 0B, 0B, 0);
  retval.922_1559 = _1558;
  if (retval.922_1559 != 0)
    goto <bb 375>;
  else
    goto <bb 376>;

  <bb 375>:
  window.923_1560 = window;
  window.923_1560->CollapseToggleWanted = 1;

  <bb 376>:
  ImGui::RenderNavHighlight (&bb, id_1530, 1);
  window.925_1563 = window;
  _1564 = window.925_1563->Collapsed;
  if (_1564 != 0)
    goto <bb 377>;
  else
    goto <bb 378>;

  <bb 377>:
  iftmp.924_1565 = 1;
  goto <bb 379>;

  <bb 378>:
  iftmp.924_1566 = 3;

  <bb 379>:
  # iftmp.924_52 = PHI <iftmp.924_1565(377), iftmp.924_1566(378)>
  _1567 = &style_160->FramePadding;
  window.926_1568 = window;
  _1569 = &window.926_1568->Pos;
  D.32467 = operator+ (_1569, _1567);
  ImGui::RenderArrow (D.32467, iftmp.924_52, 1.0e+0);
  bb ={v} {CLOBBER};

  <bb 380>:
  if (p_open_226(D) != 0B)
    goto <bb 381>;
  else
    goto <bb 385>;

  <bb 381>:
  pad_1574 = style_160->FramePadding.y;
  _1575 = g_159->FontSize;
  rad_1576 = _1575 * 5.0e-1;
  _1577 = rad_1576 + 1.0e+0;
  _1578 = pad_1574 + rad_1576;
  _1579 = -pad_1574;
  _1580 = _1579 - rad_1576;
  ImVec2::ImVec2 (&D.17865, _1580, _1578);
  window.928_1582 = window;
  D.17863 = ImGuiWindow::Rect (window.928_1582);
  D.17864 = ImRect::GetTR (&D.17863);
  D.17866 = operator+ (&D.17864, &D.17865);
  window.929_1586 = window;
  _1588 = ImGuiWindow::GetID (window.929_1586, "#CLOSE", 0B);
  _1589 = _1588;
  _1591 = ImGui::CloseButton (_1589, &D.17866, _1577);

  <bb 382>:
  retval.927_1592 = _1591;
  D.17866 ={v} {CLOBBER};
  D.17864 ={v} {CLOBBER};
  D.17863 ={v} {CLOBBER};
  D.17865 ={v} {CLOBBER};
  if (retval.927_1592 != 0)
    goto <bb 383>;
  else
    goto <bb 384>;

  <bb 383>:
  *p_open_226(D) = 0;

  <bb 384>:

  <bb 385>:
  window.930_1602 = window;
  _1603 = window.930_1602->DC.NavLayerCurrent;
  _1604 = _1603 + -1;
  window.930_1602->DC.NavLayerCurrent = _1604;
  window.931_1606 = window;
  window.932_1607 = window;
  _1608 = window.932_1607->DC.NavLayerCurrentMask;
  _1609 = _1608 >> 1;
  window.931_1606->DC.NavLayerCurrentMask = _1609;
  window.933_1611 = window;
  window.933_1611->DC.ItemFlags = item_flags_backup_1511;
  text_size = ImGui::CalcTextSize (name_161(D), 0B, 1, -1.0e+0);
  text_r = title_bar_rect;
  _1615 = flags_2 & 32;
  if (_1615 == 0)
    goto <bb 386>;
  else
    goto <bb 387>;

  <bb 386>:
  _1616 = style_160->FramePadding.x;
  _1617 = g_159->FontSize;
  _1618 = _1616 + _1617;
  _1619 = style_160->ItemInnerSpacing.x;
  iftmp.934_1620 = _1618 + _1619;
  goto <bb 388>;

  <bb 387>:
  iftmp.934_1621 = style_160->FramePadding.x;

  <bb 388>:
  # iftmp.934_53 = PHI <iftmp.934_1620(386), iftmp.934_1621(387)>
  pad_left_1622 = iftmp.934_53;
  if (p_open_226(D) != 0B)
    goto <bb 389>;
  else
    goto <bb 390>;

  <bb 389>:
  _1623 = style_160->FramePadding.x;
  _1624 = g_159->FontSize;
  _1625 = _1623 + _1624;
  _1626 = style_160->ItemInnerSpacing.x;
  iftmp.935_1627 = _1625 + _1626;
  goto <bb 391>;

  <bb 390>:
  iftmp.935_1628 = style_160->FramePadding.x;

  <bb 391>:
  # iftmp.935_54 = PHI <iftmp.935_1627(389), iftmp.935_1628(390)>
  pad_right_1629 = iftmp.935_54;
  _1630 = style_160->WindowTitleAlign.x;
  if (_1630 > 0.0)
    goto <bb 392>;
  else
    goto <bb 393>;

  <bb 392>:
  _1631 = style_160->WindowTitleAlign.x;
  pad_right_1633 = ImLerp (pad_right_1629, pad_left_1622, _1631);

  <bb 393>:
  # pad_right_11 = PHI <pad_right_1629(391), pad_right_1633(392)>
  _1634 = text_r.Min.x;
  _1635 = _1634 + pad_left_1622;
  text_r.Min.x = _1635;
  _1637 = text_r.Max.x;
  _1638 = _1637 - pad_right_11;
  text_r.Max.x = _1638;
  clip_rect = text_r;
  window.936_1641 = window;
  _1642 = window.936_1641->Pos.x;
  window.937_1643 = window;
  _1644 = window.937_1643->Size.x;
  _1645 = _1642 + _1644;
  if (p_open_226(D) != 0B)
    goto <bb 394>;
  else
    goto <bb 395>;

  <bb 394>:
  _1647 = ImRect::GetHeight (&title_bar_rect);
  iftmp.938_1648 = _1647 - 3.0e+0;
  goto <bb 396>;

  <bb 395>:
  iftmp.938_1649 = style_160->FramePadding.x;

  <bb 396>:
  # iftmp.938_55 = PHI <iftmp.938_1648(394), iftmp.938_1649(395)>
  _1650 = _1645 - iftmp.938_55;
  clip_rect.Max.x = _1650;
  _1652 = &style_160->WindowTitleAlign;
  ImGui::RenderTextClipped (&text_r.Min, &text_r.Max, name_161(D), 0B, &text_size, _1652, &clip_rect);
  text_size ={v} {CLOBBER};
  text_r ={v} {CLOBBER};
  clip_rect ={v} {CLOBBER};

  <bb 397>:
  window.939_1660 = window;
  window.940_1661 = window;
  window.939_1660->WindowRectClipped = ImGuiWindow::Rect (window.940_1661);
  window.941_1663 = window;
  _1664 = &window.941_1663->ClipRect;
  window.942_1665 = window;
  _1666 = &window.942_1665->WindowRectClipped;
  ImRect::ClipWith (_1666, _1664);
  window.943_1668 = window;
  _1669 = title_bar_rect.Min.x;
  window.944_1670 = window;
  _1671 = window.944_1670->WindowBorderSize;
  _1672 = _1669 + _1671;
  window.943_1668->InnerRect.Min.x = _1672;
  window.945_1674 = window;
  _1675 = title_bar_rect.Max.y;
  window.946_1676 = window;
  _1678 = ImGuiWindow::MenuBarHeight (window.946_1676);
  _1679 = _1675 + _1678;
  _1680 = flags_2 & 1024;
  if (_1680 != 0)
    goto <bb 399>;
  else
    goto <bb 398>;

  <bb 398>:
  _1681 = flags_2 & 1;
  if (_1681 == 0)
    goto <bb 399>;
  else
    goto <bb 400>;

  <bb 399>:
  iftmp.947_1684 = style_160->FrameBorderSize;
  goto <bb 401>;

  <bb 400>:
  window.948_1682 = window;
  iftmp.947_1683 = window.948_1682->WindowBorderSize;

  <bb 401>:
  # iftmp.947_56 = PHI <iftmp.947_1684(399), iftmp.947_1683(400)>
  _1685 = _1679 + iftmp.947_56;
  window.945_1674->InnerRect.Min.y = _1685;
  window.949_1687 = window;
  window.950_1688 = window;
  _1689 = window.950_1688->Pos.x;
  window.951_1690 = window;
  _1691 = window.951_1690->Size.x;
  _1692 = _1689 + _1691;
  window.952_1693 = window;
  _1694 = window.952_1693->ScrollbarSizes.x;
  _1695 = _1692 - _1694;
  window.953_1696 = window;
  _1697 = window.953_1696->WindowBorderSize;
  _1698 = _1695 - _1697;
  window.949_1687->InnerRect.Max.x = _1698;
  window.954_1700 = window;
  window.955_1701 = window;
  _1702 = window.955_1701->Pos.y;
  window.956_1703 = window;
  _1704 = window.956_1703->Size.y;
  _1705 = _1702 + _1704;
  window.957_1706 = window;
  _1707 = window.957_1706->ScrollbarSizes.y;
  _1708 = _1705 - _1707;
  window.958_1709 = window;
  _1710 = window.958_1709->WindowBorderSize;
  _1711 = _1708 - _1710;
  window.954_1700->InnerRect.Max.y = _1711;
  window.959_1713 = window;
  window.960_1714 = window;
  _1715 = window.960_1714->InnerRect.Min.x;
  _1716 = _1715 + 5.0e-1;
  window.961_1717 = window;
  _1718 = window.961_1717->WindowPadding.x;
  _1719 = _1718 * 5.0e-1;
  window.962_1720 = window;
  _1721 = window.962_1720->WindowBorderSize;
  _1722 = _1719 - _1721;
  _1724 = ImFloor (_1722);
  _1726 = ImMax (0.0, _1724);
  _1727 = _1716 + _1726;
  _1729 = ImFloor (_1727);
  window.959_1713->InnerClipRect.Min.x = _1729;
  window.963_1731 = window;
  window.964_1732 = window;
  _1733 = window.964_1732->InnerRect.Min.y;
  _1734 = _1733 + 5.0e-1;
  _1736 = ImFloor (_1734);
  window.963_1731->InnerClipRect.Min.y = _1736;
  window.965_1738 = window;
  window.966_1739 = window;
  _1740 = window.966_1739->InnerRect.Max.x;
  _1741 = _1740 + 5.0e-1;
  window.967_1742 = window;
  _1743 = window.967_1742->WindowPadding.x;
  _1744 = _1743 * 5.0e-1;
  window.968_1745 = window;
  _1746 = window.968_1745->WindowBorderSize;
  _1747 = _1744 - _1746;
  _1749 = ImFloor (_1747);
  _1751 = ImMax (0.0, _1749);
  _1752 = _1741 - _1751;
  _1754 = ImFloor (_1752);
  window.965_1738->InnerClipRect.Max.x = _1754;
  window.969_1756 = window;
  window.970_1757 = window;
  _1758 = window.970_1757->InnerRect.Max.y;
  _1759 = _1758 + 5.0e-1;
  _1761 = ImFloor (_1759);
  window.969_1756->InnerClipRect.Max.y = _1761;
  window.971_1763 = window;
  window.972_1764 = window;
  _1765 = window.972_1764->MoveId;
  window.971_1763->DC.LastItemId = _1765;
  window.973_1767 = window;
  _1769 = ImGui::IsMouseHoveringRect (&title_bar_rect.Min, &title_bar_rect.Max, 0);
  if (_1769 != 0)
    goto <bb 402>;
  else
    goto <bb 403>;

  <bb 402>:
  iftmp.974_1770 = 1;
  goto <bb 404>;

  <bb 403>:
  iftmp.974_1771 = 0;

  <bb 404>:
  # iftmp.974_57 = PHI <iftmp.974_1770(402), iftmp.974_1771(403)>
  window.973_1767->DC.LastItemStatusFlags = iftmp.974_57;
  window.975_1773 = window;
  window.975_1773->DC.LastItemRect = title_bar_rect;
  size_auto_fit ={v} {CLOBBER};
  size_full_modified ={v} {CLOBBER};
  border_held ={v} {CLOBBER};
  resize_grip_col ={v} {CLOBBER};
  viewport_rect ={v} {CLOBBER};
  title_bar_rect ={v} {CLOBBER};

  <bb 405>:
  window.976_1787 = window;
  _1788 = &window.976_1787->InnerClipRect.Max;
  window.977_1789 = window;
  _1790 = &window.977_1789->InnerClipRect.Min;
  ImGui::PushClipRect (_1790, _1788, 1);
  if (first_begin_of_the_frame_189 != 0)
    goto <bb 406>;
  else
    goto <bb 407>;

  <bb 406>:
  window.978_1792 = window;
  window.978_1792->WriteAccessed = 0;

  <bb 407>:
  window.979_1794 = window;
  _1795 = window.979_1794->BeginCount;
  _1796 = _1795 + 1;
  window.979_1794->BeginCount = _1796;
  g_159->NextWindowData.SizeConstraintCond = 0;
  _1799 = flags_2 & 16777216;
  if (_1799 != 0)
    goto <bb 408>;
  else
    goto <bb 424>;

  <bb 408>:
  _1800 = flags_2 & 1;
  if (_1800 != 0)
    goto <bb 410>;
  else
    goto <bb 409>;

  <bb 409>:
  __assert_fail ("(flags & ImGuiWindowFlags_NoTitleBar) != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6216, &__PRETTY_FUNCTION__);

  <bb 410>:
  window.980_1801 = window;
  if (parent_window_248 != 0B)
    goto <bb 411>;
  else
    goto <bb 413>;

  <bb 411>:
  _1802 = parent_window_248->Collapsed;
  if (_1802 != 0)
    goto <bb 412>;
  else
    goto <bb 413>;

  <bb 412>:
  iftmp.981_1803 = 1;
  goto <bb 414>;

  <bb 413>:
  iftmp.981_1804 = 0;

  <bb 414>:
  # iftmp.981_58 = PHI <iftmp.981_1803(412), iftmp.981_1804(413)>
  window.980_1801->Collapsed = iftmp.981_58;
  _1806 = flags_2 & 64;
  if (_1806 == 0)
    goto <bb 415>;
  else
    goto <bb 422>;

  <bb 415>:
  window.982_1807 = window;
  _1808 = window.982_1807->AutoFitFramesX;
  if (_1808 <= 0)
    goto <bb 416>;
  else
    goto <bb 422>;

  <bb 416>:
  window.983_1809 = window;
  _1810 = window.983_1809->AutoFitFramesY;
  if (_1810 <= 0)
    goto <bb 417>;
  else
    goto <bb 422>;

  <bb 417>:
  window.984_1811 = window;
  window.985_1812 = window;
  _1813 = window.985_1812->Collapsed;
  window.987_1814 = window;
  _1815 = window.987_1814->WindowRectClipped.Min.x;
  window.988_1816 = window;
  _1817 = window.988_1816->WindowRectClipped.Max.x;
  if (_1815 >= _1817)
    goto <bb 419>;
  else
    goto <bb 418>;

  <bb 418>:
  window.989_1818 = window;
  _1819 = window.989_1818->WindowRectClipped.Min.y;
  window.990_1820 = window;
  _1821 = window.990_1820->WindowRectClipped.Max.y;
  if (_1819 >= _1821)
    goto <bb 419>;
  else
    goto <bb 420>;

  <bb 419>:
  iftmp.986_1823 = 1;
  goto <bb 421>;

  <bb 420>:
  iftmp.986_1822 = 0;

  <bb 421>:
  # iftmp.986_59 = PHI <iftmp.986_1823(419), iftmp.986_1822(420)>
  _1824 = _1813 | iftmp.986_59;
  window.984_1811->Collapsed = _1824;

  <bb 422>:
  window.991_1826 = window;
  _1827 = window.991_1826->Collapsed;
  if (_1827 != 0)
    goto <bb 423>;
  else
    goto <bb 424>;

  <bb 423>:
  window.992_1828 = window;
  window.992_1828->Active = 0;

  <bb 424>:
  _1831 = style_160->Alpha;
  if (_1831 <= 0.0)
    goto <bb 425>;
  else
    goto <bb 426>;

  <bb 425>:
  window.993_1832 = window;
  window.993_1832->Active = 0;

  <bb 426>:
  window.994_1834 = window;
  window.996_1835 = window;
  _1836 = window.996_1835->Collapsed;
  if (_1836 != 0)
    goto <bb 428>;
  else
    goto <bb 427>;

  <bb 427>:
  window.997_1837 = window;
  _1838 = window.997_1837->Active;
  _1839 = ~_1838;
  if (_1839 != 0)
    goto <bb 428>;
  else
    goto <bb 431>;

  <bb 428>:
  window.998_1840 = window;
  _1841 = window.998_1840->AutoFitFramesX;
  if (_1841 <= 0)
    goto <bb 429>;
  else
    goto <bb 431>;

  <bb 429>:
  window.999_1842 = window;
  _1843 = window.999_1842->AutoFitFramesY;
  if (_1843 <= 0)
    goto <bb 430>;
  else
    goto <bb 431>;

  <bb 430>:
  iftmp.995_1844 = 1;
  goto <bb 432>;

  <bb 431>:
  iftmp.995_1845 = 0;

  <bb 432>:
  # iftmp.995_60 = PHI <iftmp.995_1844(430), iftmp.995_1845(431)>
  window.994_1834->SkipItems = iftmp.995_60;
  window.1000_1847 = window;
  _1848 = window.1000_1847->SkipItems;
  _1849 = ~_1848;
  window ={v} {CLOBBER};
  window_pos_set_by_api ={v} {CLOBBER};

<L552>:
  return _1849;

<L581>:
  _151 = __builtin_eh_pointer (95);
  __builtin_unwind_resume (_151);

}



;; Function bool ImGui::Begin(const char*, bool*, const ImVec2&, float, ImGuiWindowFlags) (_ZN5ImGui5BeginEPKcPbRK6ImVec2fi, funcdef_no=842, decl_uid=3961, cgraph_uid=741, symbol_order=748)

bool ImGui::Begin(const char*, bool*, const ImVec2&, float, ImGuiWindowFlags) (const char * name, bool * p_open, const struct ImVec2 & size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)
{
  bool D.32952;
  bool D.32950;
  float D.32946;
  float D.32944;
  float _5;
  float _6;
  bool _14;
  bool _15;

  <bb 2>:
  _5 = size_first_use_4(D)->x;
  if (_5 != 0.0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _6 = size_first_use_4(D)->y;
  if (_6 != 0.0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  ImGui::SetNextWindowSize (size_first_use_4(D), 4);

  <bb 5>:
  if (bg_alpha_override_8(D) >= 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  ImGui::SetNextWindowBgAlpha (bg_alpha_override_8(D));

  <bb 7>:
  _14 = ImGui::Begin (name_10(D), p_open_11(D), flags_12(D));
  _15 = _14;

<L6>:
  return _15;

}



;; Function void ImGui::End() (_ZN5ImGui3EndEv, funcdef_no=843, decl_uid=2455, cgraph_uid=742, symbol_order=749)

void ImGui::End() ()
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImGuiWindow * & D.32976;
  struct ImVector * D.32975;
  bool D.32971;
  struct ImVector * D.32970;
  struct ImGuiWindow * iftmp.1007;
  struct ImVector * D.32967;
  int D.32964;
  int D.32963;
  struct ImVector * D.32962;
  int D.32958;
  int D.32957;
  struct ImGuiColumnsSet * D.32953;
  struct ImGuiWindow * iftmp.1007_1;
  struct ImGuiColumnsSet * _9;
  int _12;
  int _13;
  struct ImVector * _15;
  int _17;
  int _18;
  struct ImVector * _19;
  struct ImVector * _22;
  bool _24;
  struct ImGuiWindow * iftmp.1007_25;
  struct ImVector * _26;
  struct ImGuiWindow * & _28;
  struct ImGuiWindow * iftmp.1007_29;

  <bb 2>:
  g_7 = GImGui;
  window_8 = g_7->CurrentWindow;
  _9 = window_8->DC.ColumnsSet;
  if (_9 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::EndColumns ();

  <bb 4>:
  ImGui::PopClipRect ();
  _12 = window_8->Flags;
  _13 = _12 & 16777216;
  if (_13 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::LogFinish ();

  <bb 6>:
  _15 = &g_7->CurrentWindowStack;
  ImVector<ImGuiWindow*>::pop_back (_15);
  _17 = window_8->Flags;
  _18 = _17 & 67108864;
  if (_18 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _19 = &g_7->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::pop_back (_19);

  <bb 8>:
  CheckStacksSize (window_8, 0);
  _22 = &g_7->CurrentWindowStack;
  _24 = ImVector<ImGuiWindow*>::empty (_22);
  if (_24 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1007_25 = 0B;
  goto <bb 11>;

  <bb 10>:
  _26 = &g_7->CurrentWindowStack;
  _28 = ImVector<ImGuiWindow*>::back (_26);
  iftmp.1007_29 = *_28;

  <bb 11>:
  # iftmp.1007_1 = PHI <iftmp.1007_25(9), iftmp.1007_29(10)>
  SetCurrentWindow (iftmp.1007_1);
  return;

}



;; Function void ImGui::Scrollbar(ImGuiLayoutType) (_ZN5ImGui9ScrollbarEi, funcdef_no=844, decl_uid=13846, cgraph_uid=743, symbol_order=750)

void ImGui::Scrollbar(ImGuiLayoutType) (ImGuiLayoutType direction)
{
  const ImGuiID D.33208;
  const float scroll_v_norm;
  bool seek_absolute;
  const float clicked_v_norm;
  float * click_delta_to_grab_center_v;
  float mouse_pos_v;
  float scrollbar_pos_v;
  struct ImRect grab_rect;
  const ImU32 grab_col;
  float grab_v_norm;
  float scroll_ratio;
  float scroll_max;
  const bool previously_held;
  bool hovered;
  bool held;
  const float grab_h_norm;
  const float grab_h_pixels;
  const float win_size_v;
  static const char __PRETTY_FUNCTION__[39] = "void ImGui::Scrollbar(ImGuiLayoutType)";
  float win_size_contents_v;
  float win_size_avail_v;
  float scroll_v;
  float scrollbar_size_v;
  int window_rounding_corners;
  struct ImRect bb;
  const float border_size;
  const struct ImRect window_rect;
  float other_scrollbar_size_w;
  bool other_scrollbar;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  const bool horizontal;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.33206;
  float D.33205;
  float D.33204;
  float D.33203;
  float D.33202;
  float D.33201;
  float D.33200;
  float D.33199;
  float D.33198;
  float D.33197;
  float D.33196;
  float D.33195;
  float D.33194;
  struct ImRect grab_rect.1030;
  float D.33192;
  float D.33191;
  float D.33190;
  float D.33189;
  float D.33188;
  float D.33187;
  float D.33186;
  float D.33185;
  float D.33184;
  float D.33183;
  float D.33182;
  struct ImRect grab_rect.1029;
  bool hovered.1028;
  ImGuiCol iftmp.1027;
  bool held.1026;
  ImGuiCol iftmp.1025;
  float D.33167;
  float D.33166;
  float D.33165;
  float D.33162;
  float D.33161;
  float D.33160;
  int D.33156;
  float D.33155;
  float D.33154;
  float D.33153;
  float D.33152;
  float D.33151;
  float D.33150;
  float D.33149;
  float D.33148;
  float D.33146;
  float D.33145;
  float D.33144;
  float D.33142;
  bool D.33136;
  float D.33135;
  float D.33134;
  float * iftmp.1024;
  float iftmp.1023;
  float iftmp.1022;
  bool held.1021;
  float D.33116;
  float D.33115;
  float D.33114;
  float D.33113;
  unsigned int D.33112;
  float D.33111;
  float D.33110;
  float D.33109;
  float D.33108;
  float D.33104;
  float iftmp.1020;
  float iftmp.1019;
  float iftmp.1018;
  float iftmp.1017;
  float D.33087;
  float D.33086;
  float D.33085;
  int D.33084;
  float D.33083;
  float D.33082;
  float D.33081;
  float D.33080;
  float D.33079;
  float D.33078;
  float D.33077;
  float D.33076;
  int D.33075;
  float D.33074;
  float D.33073;
  float D.33072;
  float D.33071;
  float D.33070;
  struct ImVec2 D.17910;
  struct ImDrawList * D.33069;
  unsigned int D.33068;
  float D.33067;
  int iftmp.1016;
  int D.33061;
  int D.33060;
  int D.33058;
  int D.33057;
  int iftmp.1015;
  int iftmp.1014;
  float D.33044;
  float D.33042;
  bool iftmp.1013;
  bool retval.1012;
  float D.33035;
  float D.33034;
  int D.33030;
  int D.33029;
  float iftmp.1011;
  float D.33027;
  float D.17908;
  bool D.33024;
  float D.33023;
  float D.33022;
  float D.33021;
  float D.33020;
  float D.33019;
  float D.33018;
  float D.33017;
  float D.33016;
  float D.33015;
  float D.33014;
  float D.33012;
  float D.33011;
  float D.33010;
  float D.33009;
  float D.33008;
  float D.33007;
  float D.33006;
  float D.33005;
  float D.33004;
  float D.33003;
  float iftmp.1010;
  bool iftmp.1009;
  const char[9] * iftmp.1008;
  const char[9] * iftmp.1008_5;
  bool iftmp.1009_6;
  float iftmp.1010_7;
  float iftmp.1011_8;
  bool iftmp.1013_9;
  int iftmp.1014_10;
  int iftmp.1015_11;
  int iftmp.1016_12;
  float iftmp.1017_13;
  float iftmp.1018_14;
  float iftmp.1019_15;
  float iftmp.1020_16;
  float iftmp.1022_17;
  float iftmp.1023_18;
  float * iftmp.1024_19;
  ImGuiCol iftmp.1025_20;
  ImGuiCol iftmp.1027_21;
  const char[9] * iftmp.1008_42;
  const char[9] * iftmp.1008_43;
  const ImGuiID _45;
  bool iftmp.1009_47;
  bool iftmp.1009_48;
  float iftmp.1010_50;
  float iftmp.1010_51;
  float _55;
  float _56;
  float _57;
  float _58;
  float _59;
  float _60;
  float _61;
  float _62;
  float _63;
  float _64;
  float _66;
  float _67;
  float _68;
  float _69;
  float _70;
  float _71;
  float _72;
  float _73;
  float _74;
  float _75;
  bool _77;
  float _79;
  int _80;
  int _81;
  float iftmp.1011_83;
  float iftmp.1011_84;
  float _85;
  float _86;
  float _87;
  float _90;
  float _92;
  bool iftmp.1013_93;
  bool iftmp.1013_94;
  bool retval.1012_95;
  int iftmp.1014_96;
  int iftmp.1014_97;
  int _99;
  int _100;
  int _101;
  int _102;
  int iftmp.1015_103;
  int iftmp.1015_104;
  int iftmp.1016_105;
  int iftmp.1016_106;
  float _108;
  unsigned int _110;
  struct ImDrawList * _111;
  float _113;
  float _114;
  float _115;
  float _116;
  float _117;
  int _118;
  float _119;
  float _121;
  float _122;
  float _123;
  float _124;
  float _125;
  float _126;
  float _127;
  int _128;
  float _129;
  float _131;
  float _132;
  float iftmp.1017_137;
  float iftmp.1017_139;
  float iftmp.1018_141;
  float iftmp.1018_142;
  float iftmp.1019_144;
  float iftmp.1019_145;
  float iftmp.1020_147;
  float iftmp.1020_148;
  float _151;
  float _153;
  float _156;
  float _157;
  float _158;
  unsigned int _164;
  float _167;
  float _170;
  float _173;
  float _174;
  bool held.1021_176;
  float iftmp.1022_177;
  float iftmp.1022_178;
  float iftmp.1023_180;
  float iftmp.1023_181;
  float * iftmp.1024_183;
  float * iftmp.1024_184;
  float _186;
  float _187;
  bool _192;
  float _193;
  float _194;
  float _195;
  float _196;
  float _200;
  float _201;
  float _202;
  float _203;
  float _204;
  float _205;
  float _208;
  float _209;
  int _210;
  float _214;
  float _217;
  float _218;
  float _220;
  float _221;
  float _222;
  bool held.1026_224;
  ImGuiCol iftmp.1025_225;
  bool hovered.1028_226;
  ImGuiCol iftmp.1027_227;
  ImGuiCol iftmp.1027_228;
  ImGuiCol iftmp.1025_229;
  float _233;
  float _234;
  float _235;
  float _236;
  float _238;
  float _239;
  float _241;
  float _242;
  float _243;
  float _244;
  float _246;
  float _250;
  float _251;
  float _252;
  float _254;
  float _255;
  float _257;
  float _258;
  float _259;
  float _260;
  float _262;
  float _263;
  float _267;
  struct ImDrawList * _268;

  <bb 2>:
  g_37 = GImGui;
  window_38 = g_37->CurrentWindow;
  horizontal_40 = direction_39(D) == 1;
  style_41 = &g_37->Style;
  if (horizontal_40 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1008_42 = "#SCROLLX";
  goto <bb 5>;

  <bb 4>:
  iftmp.1008_43 = "#SCROLLY";

  <bb 5>:
  # iftmp.1008_5 = PHI <iftmp.1008_42(3), iftmp.1008_43(4)>
  _45 = ImGuiWindow::GetID (window_38, iftmp.1008_5, 0B);
  id_46 = _45;
  if (horizontal_40 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1009_47 = window_38->ScrollbarY;
  goto <bb 8>;

  <bb 7>:
  iftmp.1009_48 = window_38->ScrollbarX;

  <bb 8>:
  # iftmp.1009_6 = PHI <iftmp.1009_47(6), iftmp.1009_48(7)>
  other_scrollbar_49 = iftmp.1009_6;
  if (other_scrollbar_49 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1010_50 = style_41->ScrollbarSize;
  goto <bb 11>;

  <bb 10>:
  iftmp.1010_51 = 0.0;

  <bb 11>:
  # iftmp.1010_7 = PHI <iftmp.1010_50(9), iftmp.1010_51(10)>
  other_scrollbar_size_w_52 = iftmp.1010_7;
  window_rect = ImGuiWindow::Rect (window_38);
  border_size_54 = window_38->WindowBorderSize;
  if (horizontal_40 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _55 = window_rect.Max.y;
  _56 = _55 - border_size_54;
  _57 = window_rect.Max.x;
  _58 = _57 - other_scrollbar_size_w_52;
  _59 = _58 - border_size_54;
  _60 = window_rect.Max.y;
  _61 = style_41->ScrollbarSize;
  _62 = _60 - _61;
  _63 = window_38->Pos.x;
  _64 = _63 + border_size_54;
  ImRect::ImRect (&bb, _64, _62, _59, _56);
  goto <bb 14>;

  <bb 13>:
  _66 = window_rect.Max.y;
  _67 = _66 - other_scrollbar_size_w_52;
  _68 = _67 - border_size_54;
  _69 = window_rect.Max.x;
  _70 = _69 - border_size_54;
  _71 = window_38->Pos.y;
  _72 = _71 + border_size_54;
  _73 = window_rect.Max.x;
  _74 = style_41->ScrollbarSize;
  _75 = _73 - _74;
  ImRect::ImRect (&bb, _75, _72, _70, _68);

  <bb 14>:
  _77 = ~horizontal_40;
  if (_77 != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

  <bb 15>:
  _79 = ImGuiWindow::TitleBarHeight (window_38);
  _80 = window_38->Flags;
  _81 = _80 & 1024;
  if (_81 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.1011_83 = ImGuiWindow::MenuBarHeight (window_38);
  goto <bb 18>;

  <bb 17>:
  iftmp.1011_84 = 0.0;

  <bb 18>:
  # iftmp.1011_8 = PHI <iftmp.1011_83(16), iftmp.1011_84(17)>
  _85 = _79 + iftmp.1011_8;
  _86 = bb.Min.y;
  _87 = _86 + _85;
  bb.Min.y = _87;

  <bb 19>:
  _90 = ImRect::GetWidth (&bb);
  if (_90 <= 0.0)
    goto <bb 21>;
  else
    goto <bb 20>;

  <bb 20>:
  _92 = ImRect::GetHeight (&bb);
  if (_92 <= 0.0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  iftmp.1013_94 = 1;
  goto <bb 23>;

  <bb 22>:
  iftmp.1013_93 = 0;

  <bb 23>:
  # iftmp.1013_9 = PHI <iftmp.1013_94(21), iftmp.1013_93(22)>
  retval.1012_95 = iftmp.1013_9;
  if (retval.1012_95 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  window_rect ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  held ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  grab_rect ={v} {CLOBBER};
  goto <bb 85> (<L90>);

  <bb 25>:
  if (horizontal_40 != 0)
    goto <bb 26>;
  else
    goto <bb 30>;

  <bb 26>:
  if (other_scrollbar_49 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  iftmp.1014_96 = 4;
  goto <bb 29>;

  <bb 28>:
  iftmp.1014_97 = 12;

  <bb 29>:
  # iftmp.1014_10 = PHI <iftmp.1014_96(27), iftmp.1014_97(28)>
  window_rounding_corners_98 = iftmp.1014_10;
  goto <bb 38>;

  <bb 30>:
  _99 = window_38->Flags;
  _100 = _99 & 1;
  if (_100 != 0)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  _101 = window_38->Flags;
  _102 = _101 & 1024;
  if (_102 == 0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  iftmp.1015_103 = 2;
  goto <bb 34>;

  <bb 33>:
  iftmp.1015_104 = 0;

  <bb 34>:
  # iftmp.1015_11 = PHI <iftmp.1015_103(32), iftmp.1015_104(33)>
  if (other_scrollbar_49 != 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  iftmp.1016_105 = 0;
  goto <bb 37>;

  <bb 36>:
  iftmp.1016_106 = 8;

  <bb 37>:
  # iftmp.1016_12 = PHI <iftmp.1016_105(35), iftmp.1016_106(36)>
  window_rounding_corners_107 = iftmp.1015_11 | iftmp.1016_12;

  <bb 38>:
  # window_rounding_corners_1 = PHI <window_rounding_corners_98(29), window_rounding_corners_107(37)>
  _108 = window_38->WindowRounding;
  _110 = ImGui::GetColorU32 (14, 1.0e+0);
  _111 = window_38->DrawList;
  ImDrawList::AddRectFilled (_111, &bb.Min, &bb.Max, _110, _108, window_rounding_corners_1);
  _113 = bb.Max.y;
  _114 = bb.Min.y;
  _115 = _113 - _114;
  _116 = _115 - 2.0e+0;
  _117 = _116 * 5.0e-1;
  _118 = (int) _117;
  _119 = (float) _118;
  _121 = ImClamp (_119, 0.0, 3.0e+0);
  _122 = -_121;
  _123 = bb.Max.x;
  _124 = bb.Min.x;
  _125 = _123 - _124;
  _126 = _125 - 2.0e+0;
  _127 = _126 * 5.0e-1;
  _128 = (int) _127;
  _129 = (float) _128;
  _131 = ImClamp (_129, 0.0, 3.0e+0);
  _132 = -_131;
  ImVec2::ImVec2 (&D.17910, _132, _122);
  ImRect::Expand (&bb, &D.17910);
  D.17910 ={v} {CLOBBER};
  if (horizontal_40 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  iftmp.1017_137 = ImRect::GetWidth (&bb);
  goto <bb 41>;

  <bb 40>:
  iftmp.1017_139 = ImRect::GetHeight (&bb);

  <bb 41>:
  # iftmp.1017_13 = PHI <iftmp.1017_137(39), iftmp.1017_139(40)>
  scrollbar_size_v_140 = iftmp.1017_13;
  if (horizontal_40 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  iftmp.1018_141 = window_38->Scroll.x;
  goto <bb 44>;

  <bb 43>:
  iftmp.1018_142 = window_38->Scroll.y;

  <bb 44>:
  # iftmp.1018_14 = PHI <iftmp.1018_141(42), iftmp.1018_142(43)>
  scroll_v_143 = iftmp.1018_14;
  if (horizontal_40 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  iftmp.1019_144 = window_38->SizeFull.x;
  goto <bb 47>;

  <bb 46>:
  iftmp.1019_145 = window_38->SizeFull.y;

  <bb 47>:
  # iftmp.1019_15 = PHI <iftmp.1019_144(45), iftmp.1019_145(46)>
  win_size_avail_v_146 = iftmp.1019_15 - other_scrollbar_size_w_52;
  if (horizontal_40 != 0)
    goto <bb 48>;
  else
    goto <bb 49>;

  <bb 48>:
  iftmp.1020_147 = window_38->SizeContents.x;
  goto <bb 50>;

  <bb 49>:
  iftmp.1020_148 = window_38->SizeContents.y;

  <bb 50>:
  # iftmp.1020_16 = PHI <iftmp.1020_147(48), iftmp.1020_148(49)>
  win_size_contents_v_149 = iftmp.1020_16;
  _151 = ImMax (win_size_contents_v_149, win_size_avail_v_146);
  if (_151 > 0.0)
    goto <bb 52>;
  else
    goto <bb 51>;

  <bb 51>:
  __assert_fail ("ImMax(win_size_contents_v, win_size_avail_v) > 0.0f", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6315, &__PRETTY_FUNCTION__);

  <bb 52>:
  _153 = ImMax (win_size_contents_v_149, win_size_avail_v_146);
  win_size_v_155 = ImMax (_153, 1.0e+0);
  _156 = style_41->GrabMinSize;
  _157 = win_size_avail_v_146 / win_size_v_155;
  _158 = _157 * scrollbar_size_v_140;
  grab_h_pixels_160 = ImClamp (_158, _156, scrollbar_size_v_140);
  grab_h_norm_161 = grab_h_pixels_160 / scrollbar_size_v_140;
  held = 0;
  hovered = 0;
  _164 = g_37->ActiveId;
  previously_held_165 = _164 == id_46;
  ImGui::ButtonBehavior (&bb, id_46, &hovered, &held, 8192);
  _167 = win_size_contents_v_149 - win_size_avail_v_146;
  scroll_max_169 = ImMax (1.0e+0, _167);
  _170 = scroll_v_143 / scroll_max_169;
  scroll_ratio_172 = ImSaturate (_170);
  _173 = scrollbar_size_v_140 - grab_h_pixels_160;
  _174 = _173 * scroll_ratio_172;
  grab_v_norm_175 = _174 / scrollbar_size_v_140;
  held.1021_176 = held;
  if (held.1021_176 != 0)
    goto <bb 53>;
  else
    goto <bb 75>;

  <bb 53>:
  if (grab_h_norm_161 < 1.0e+0)
    goto <bb 54>;
  else
    goto <bb 75>;

  <bb 54>:
  if (horizontal_40 != 0)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  iftmp.1022_177 = bb.Min.x;
  goto <bb 57>;

  <bb 56>:
  iftmp.1022_178 = bb.Min.y;

  <bb 57>:
  # iftmp.1022_17 = PHI <iftmp.1022_177(55), iftmp.1022_178(56)>
  scrollbar_pos_v_179 = iftmp.1022_17;
  if (horizontal_40 != 0)
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  iftmp.1023_180 = g_37->IO.MousePos.x;
  goto <bb 60>;

  <bb 59>:
  iftmp.1023_181 = g_37->IO.MousePos.y;

  <bb 60>:
  # iftmp.1023_18 = PHI <iftmp.1023_180(58), iftmp.1023_181(59)>
  mouse_pos_v_182 = iftmp.1023_18;
  if (horizontal_40 != 0)
    goto <bb 61>;
  else
    goto <bb 62>;

  <bb 61>:
  iftmp.1024_183 = &g_37->ScrollbarClickDeltaToGrabCenter.x;
  goto <bb 63>;

  <bb 62>:
  iftmp.1024_184 = &g_37->ScrollbarClickDeltaToGrabCenter.y;

  <bb 63>:
  # iftmp.1024_19 = PHI <iftmp.1024_183(61), iftmp.1024_184(62)>
  click_delta_to_grab_center_v_185 = iftmp.1024_19;
  _186 = mouse_pos_v_182 - scrollbar_pos_v_179;
  _187 = _186 / scrollbar_size_v_140;
  clicked_v_norm_189 = ImSaturate (_187);
  ImGui::SetHoveredID (id_46);
  seek_absolute_191 = 0;
  _192 = ~previously_held_165;
  if (_192 != 0)
    goto <bb 64>;
  else
    goto <bb 69>;

  <bb 64>:
  if (clicked_v_norm_189 >= grab_v_norm_175)
    goto <bb 65>;
  else
    goto <bb 67>;

  <bb 65>:
  _193 = grab_v_norm_175 + grab_h_norm_161;
  if (_193 >= clicked_v_norm_189)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  _194 = clicked_v_norm_189 - grab_v_norm_175;
  _195 = grab_h_norm_161 * 5.0e-1;
  _196 = _194 - _195;
  *click_delta_to_grab_center_v_185 = _196;
  goto <bb 68>;

  <bb 67>:
  seek_absolute_198 = 1;
  *click_delta_to_grab_center_v_185 = 0.0;

  <bb 68>:
  # seek_absolute_3 = PHI <seek_absolute_191(66), seek_absolute_198(67)>

  <bb 69>:
  # seek_absolute_4 = PHI <seek_absolute_191(63), seek_absolute_3(68)>
  _200 = *click_delta_to_grab_center_v_185;
  _201 = clicked_v_norm_189 - _200;
  _202 = grab_h_norm_161 * 5.0e-1;
  _203 = _201 - _202;
  _204 = 1.0e+0 - grab_h_norm_161;
  _205 = _203 / _204;
  scroll_v_norm_207 = ImSaturate (_205);
  _208 = scroll_v_norm_207 * scroll_max_169;
  _209 = _208 + 5.0e-1;
  _210 = (int) _209;
  scroll_v_211 = (float) _210;
  if (horizontal_40 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  window_38->Scroll.x = scroll_v_211;
  goto <bb 72>;

  <bb 71>:
  window_38->Scroll.y = scroll_v_211;

  <bb 72>:
  _214 = scroll_v_211 / scroll_max_169;
  scroll_ratio_216 = ImSaturate (_214);
  _217 = scrollbar_size_v_140 - grab_h_pixels_160;
  _218 = _217 * scroll_ratio_216;
  grab_v_norm_219 = _218 / scrollbar_size_v_140;
  if (seek_absolute_4 != 0)
    goto <bb 73>;
  else
    goto <bb 74>;

  <bb 73>:
  _220 = clicked_v_norm_189 - grab_v_norm_219;
  _221 = grab_h_norm_161 * 5.0e-1;
  _222 = _220 - _221;
  *click_delta_to_grab_center_v_185 = _222;

  <bb 74>:

  <bb 75>:
  # grab_v_norm_2 = PHI <grab_v_norm_175(52), grab_v_norm_175(53), grab_v_norm_219(74)>
  held.1026_224 = held;
  if (held.1026_224 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  iftmp.1025_225 = 17;
  goto <bb 81>;

  <bb 77>:
  hovered.1028_226 = hovered;
  if (hovered.1028_226 != 0)
    goto <bb 78>;
  else
    goto <bb 79>;

  <bb 78>:
  iftmp.1027_227 = 16;
  goto <bb 80>;

  <bb 79>:
  iftmp.1027_228 = 15;

  <bb 80>:
  # iftmp.1027_21 = PHI <iftmp.1027_227(78), iftmp.1027_228(79)>
  iftmp.1025_229 = iftmp.1027_21;

  <bb 81>:
  # iftmp.1025_20 = PHI <iftmp.1025_225(76), iftmp.1025_229(80)>
  grab_col_231 = ImGui::GetColorU32 (iftmp.1025_20, 1.0e+0);
  ImRect::ImRect (&grab_rect);
  if (horizontal_40 != 0)
    goto <bb 82>;
  else
    goto <bb 83>;

  <bb 82>:
  _233 = bb.Max.y;
  _234 = window_rect.Max.x;
  _235 = bb.Max.x;
  _236 = bb.Min.x;
  _238 = ImLerp (_236, _235, grab_v_norm_2);
  _239 = _238 + grab_h_pixels_160;
  _241 = ImMin (_239, _234);
  _242 = bb.Min.y;
  _243 = bb.Max.x;
  _244 = bb.Min.x;
  _246 = ImLerp (_244, _243, grab_v_norm_2);
  ImRect::ImRect (&grab_rect.1029, _246, _242, _241, _233);
  grab_rect = grab_rect.1029;
  grab_rect.1029 ={v} {CLOBBER};
  goto <bb 84>;

  <bb 83>:
  _250 = window_rect.Max.y;
  _251 = bb.Max.y;
  _252 = bb.Min.y;
  _254 = ImLerp (_252, _251, grab_v_norm_2);
  _255 = _254 + grab_h_pixels_160;
  _257 = ImMin (_255, _250);
  _258 = bb.Max.x;
  _259 = bb.Max.y;
  _260 = bb.Min.y;
  _262 = ImLerp (_260, _259, grab_v_norm_2);
  _263 = bb.Min.x;
  ImRect::ImRect (&grab_rect.1030, _263, _262, _258, _257);
  grab_rect = grab_rect.1030;
  grab_rect.1030 ={v} {CLOBBER};

  <bb 84>:
  _267 = style_41->ScrollbarRounding;
  _268 = window_38->DrawList;
  ImDrawList::AddRectFilled (_268, &grab_rect.Min, &grab_rect.Max, grab_col_231, _267, 15);
  window_rect ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  held ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  grab_rect ={v} {CLOBBER};

<L90>:
  return;

}



;; Function void ImGui::BringWindowToFront(ImGuiWindow*) (_ZN5ImGui18BringWindowToFrontEP11ImGuiWindow, funcdef_no=845, decl_uid=13742, cgraph_uid=744, symbol_order=751)

void ImGui::BringWindowToFront(ImGuiWindow*) (struct ImGuiWindow * window)
{
  int i;
  struct ImGuiWindow * current_front_window;
  struct ImGuiContext & g;
  struct ImVector * D.33235;
  struct ImVector * D.33234;
  struct ImGuiWindow * * D.33233;
  long unsigned int D.33232;
  long unsigned int D.33231;
  struct ImGuiWindow * * D.33230;
  struct ImGuiWindow * window.1034;
  struct ImGuiWindow * D.33226;
  struct ImGuiWindow * & D.33225;
  struct ImVector * D.33224;
  bool retval.1033;
  int D.33220;
  struct ImGuiWindow * window.1032;
  struct ImGuiWindow * D.33218;
  struct ImGuiWindow * window.1031;
  struct ImGuiWindow * & D.33213;
  struct ImVector * D.33212;
  struct ImVector * _6;
  struct ImGuiWindow * & _8;
  struct ImGuiWindow * window.1031_10;
  struct ImGuiWindow * _11;
  struct ImGuiWindow * window.1032_12;
  int _13;
  struct ImVector * _15;
  struct ImGuiWindow * & _17;
  struct ImGuiWindow * _18;
  struct ImGuiWindow * window.1034_19;
  bool retval.1033_20;
  struct ImGuiWindow * * _22;
  long unsigned int _23;
  long unsigned int _24;
  struct ImGuiWindow * * _25;
  struct ImVector * _26;
  struct ImVector * _28;

  <bb 2>:
  g_5 = GImGui;
  _6 = &g_5->Windows;
  _8 = ImVector<ImGuiWindow*>::back (_6);
  current_front_window_9 = *_8;
  window.1031_10 = window;
  if (current_front_window_9 == window.1031_10)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _11 = current_front_window_9->RootWindow;
  window.1032_12 = window;
  if (_11 == window.1032_12)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 10> (<L8>);

  <bb 5>:
  _13 = g_5->Windows.Size;
  i_14 = _13 + -2;

  <bb 6>:
  # i_1 = PHI <i_14(5), i_21(9)>
  if (i_1 < 0)
    goto <bb 10> (<L8>);
  else
    goto <bb 7>;

  <bb 7>:
  _15 = &g_5->Windows;
  _17 = ImVector<ImGuiWindow*>::operator[] (_15, i_1);
  _18 = *_17;
  window.1034_19 = window;
  retval.1033_20 = _18 == window.1034_19;
  if (retval.1033_20 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _22 = g_5->Windows.Data;
  _23 = (long unsigned int) i_1;
  _24 = _23 * 8;
  _25 = _22 + _24;
  _26 = &g_5->Windows;
  ImVector<ImGuiWindow*>::erase (_26, _25);
  _28 = &g_5->Windows;
  ImVector<ImGuiWindow*>::push_back (_28, &window);
  goto <bb 10> (<L8>);

  <bb 9>:
  i_21 = i_1 + -1;
  goto <bb 6>;

<L8>:
  return;

}



;; Function void ImGui::BringWindowToBack(ImGuiWindow*) (_ZN5ImGui17BringWindowToBackEP11ImGuiWindow, funcdef_no=846, decl_uid=13744, cgraph_uid=745, symbol_order=752)

void ImGui::BringWindowToBack(ImGuiWindow*) (struct ImGuiWindow * window)
{
  int i;
  struct ImGuiContext & g;
  struct ImGuiWindow * & D.33295;
  struct ImVector * D.33294;
  struct ImGuiWindow * & D.33293;
  struct ImVector * D.33292;
  struct ImGuiWindow * & D.33291;
  struct ImVector * D.33290;
  long unsigned int D.33289;
  long unsigned int D.33288;
  struct ImGuiWindow * D.33285;
  struct ImGuiWindow * & D.33284;
  struct ImVector * D.33283;
  bool retval.1041;
  int D.33280;
  struct ImGuiWindow * D.33276;
  struct ImGuiWindow * & D.33275;
  struct ImVector * D.33274;
  bool retval.1040;
  struct ImVector * _6;
  struct ImGuiWindow * & _8;
  struct ImGuiWindow * _9;
  bool retval.1040_11;
  int _13;
  struct ImVector * _14;
  struct ImGuiWindow * & _16;
  struct ImGuiWindow * _17;
  bool retval.1041_18;
  long unsigned int _20;
  long unsigned int _21;
  struct ImVector * _22;
  struct ImGuiWindow * & _24;
  struct ImVector * _25;
  struct ImGuiWindow * & _27;
  struct ImVector * _29;
  struct ImGuiWindow * & _31;

  <bb 2>:
  g_5 = GImGui;
  _6 = &g_5->Windows;
  _8 = ImVector<ImGuiWindow*>::operator[] (_6, 0);
  _9 = *_8;
  retval.1040_11 = _9 == window_10(D);
  if (retval.1040_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 9> (<L7>);

  <bb 4>:
  i_12 = 0;

  <bb 5>:
  # i_1 = PHI <i_12(4), i_19(8)>
  _13 = g_5->Windows.Size;
  if (_13 <= i_1)
    goto <bb 9> (<L7>);
  else
    goto <bb 6>;

  <bb 6>:
  _14 = &g_5->Windows;
  _16 = ImVector<ImGuiWindow*>::operator[] (_14, i_1);
  _17 = *_16;
  retval.1041_18 = _17 == window_10(D);
  if (retval.1041_18 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _20 = (long unsigned int) i_1;
  _21 = _20 * 8;
  _22 = &g_5->Windows;
  _24 = ImVector<ImGuiWindow*>::operator[] (_22, 0);
  _25 = &g_5->Windows;
  _27 = ImVector<ImGuiWindow*>::operator[] (_25, 1);
  memmove (_27, _24, _21);
  _29 = &g_5->Windows;
  _31 = ImVector<ImGuiWindow*>::operator[] (_29, 0);
  *_31 = window_10(D);
  goto <bb 9> (<L7>);

  <bb 8>:
  i_19 = i_1 + 1;
  goto <bb 5>;

<L7>:
  return;

}



;; Function void ImGui::FocusWindow(ImGuiWindow*) (_ZN5ImGui11FocusWindowEP11ImGuiWindow, funcdef_no=847, decl_uid=13740, cgraph_uid=746, symbol_order=753)

void ImGui::FocusWindow(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  int D.33334;
  int D.33333;
  struct ImGuiWindow * D.33328;
  struct ImGuiWindow * D.33327;
  struct ImGuiWindow * D.33324;
  unsigned int D.33321;
  int D.33318;
  int D.33317;
  struct ImGuiWindow * D.33313;
  unsigned int iftmp.1042;
  bool D.33302;
  struct ImGuiWindow * D.33297;
  unsigned int iftmp.1042_2;
  struct ImGuiWindow * _9;
  bool _12;
  unsigned int iftmp.1042_15;
  unsigned int iftmp.1042_16;
  struct ImGuiWindow * _20;
  int _22;
  int _23;
  unsigned int _24;
  struct ImGuiWindow * _25;
  struct ImGuiWindow * _26;
  struct ImGuiWindow * _27;
  int _29;
  int _30;

  <bb 2>:
  g_8 = GImGui;
  _9 = g_8->NavWindow;
  if (_9 != window_10(D))
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 3>:
  g_8->NavWindow = window_10(D);
  if (window_10(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _12 = g_8->NavDisableMouseHover;
  if (_12 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  g_8->NavMousePosDirty = 1;

  <bb 6>:
  g_8->NavInitRequest = 0;
  if (window_10(D) != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1042_15 = window_10(D)->NavLastIds[0];
  goto <bb 9>;

  <bb 8>:
  iftmp.1042_16 = 0;

  <bb 9>:
  # iftmp.1042_2 = PHI <iftmp.1042_15(7), iftmp.1042_16(8)>
  g_8->NavId = iftmp.1042_2;
  g_8->NavIdIsAlive = 0;
  g_8->NavLayer = 0;

  <bb 10>:
  if (window_10(D) == 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  goto <bb 21> (<L29>);

  <bb 12>:
  _20 = window_10(D)->RootWindow;
  if (_20 != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  window_21 = window_10(D)->RootWindow;

  <bb 14>:
  # window_1 = PHI <window_10(D)(12), window_21(13)>
  _22 = window_1->Flags;
  _23 = _22 & 67108864;
  if (_23 != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

  <bb 15>:
  _24 = g_8->ActiveId;
  if (_24 != 0)
    goto <bb 16>;
  else
    goto <bb 19>;

  <bb 16>:
  _25 = g_8->ActiveIdWindow;
  if (_25 != 0B)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  _26 = g_8->ActiveIdWindow;
  _27 = _26->RootWindow;
  if (_27 != window_1)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  ImGui::ClearActiveID ();

  <bb 19>:
  _29 = window_1->Flags;
  _30 = _29 & 8192;
  if (_30 == 0)
    goto <bb 20>;
  else
    goto <bb 21> (<L29>);

  <bb 20>:
  ImGui::BringWindowToFront (window_1);

<L29>:
  return;

}



;; Function void ImGui::FocusFrontMostActiveWindow(ImGuiWindow*) (_ZN5ImGuiL26FocusFrontMostActiveWindowEP11ImGuiWindow, funcdef_no=848, decl_uid=15127, cgraph_uid=747, symbol_order=754)

void ImGui::FocusFrontMostActiveWindow(ImGuiWindow*) (struct ImGuiWindow * ignore_window)
{
  struct ImGuiWindow * focus_window;
  int i;
  struct ImGuiContext & g;
  struct ImGuiWindow * D.33365;
  struct ImGuiWindow * & D.33364;
  struct ImVector * D.33363;
  int D.33359;
  int D.33358;
  struct ImGuiWindow * D.33357;
  struct ImGuiWindow * & D.33356;
  struct ImVector * D.33355;
  bool D.33353;
  struct ImGuiWindow * D.33352;
  struct ImGuiWindow * & D.33351;
  struct ImVector * D.33350;
  struct ImGuiWindow * D.33348;
  struct ImGuiWindow * & D.33347;
  struct ImVector * D.33346;
  bool iftmp.1044;
  bool retval.1043;
  int D.33339;
  bool iftmp.1044_2;
  int _9;
  struct ImVector * _11;
  struct ImGuiWindow * & _13;
  struct ImGuiWindow * _14;
  struct ImVector * _16;
  struct ImGuiWindow * & _18;
  struct ImGuiWindow * _19;
  bool _20;
  struct ImVector * _21;
  struct ImGuiWindow * & _23;
  struct ImGuiWindow * _24;
  int _25;
  int _26;
  bool iftmp.1044_27;
  bool iftmp.1044_28;
  bool retval.1043_29;
  struct ImVector * _31;
  struct ImGuiWindow * & _33;
  struct ImGuiWindow * _34;

  <bb 2>:
  g_8 = GImGui;
  _9 = g_8->Windows.Size;
  i_10 = _9 + -1;

  <bb 3>:
  # i_1 = PHI <i_10(2), i_30(11)>
  if (i_1 < 0)
    goto <bb 12> (<L10>);
  else
    goto <bb 4>;

  <bb 4>:
  _11 = &g_8->Windows;
  _13 = ImVector<ImGuiWindow*>::operator[] (_11, i_1);
  _14 = *_13;
  if (_14 != ignore_window_15(D))
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _16 = &g_8->Windows;
  _18 = ImVector<ImGuiWindow*>::operator[] (_16, i_1);
  _19 = *_18;
  _20 = _19->WasActive;
  if (_20 != 0)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _21 = &g_8->Windows;
  _23 = ImVector<ImGuiWindow*>::operator[] (_21, i_1);
  _24 = *_23;
  _25 = _24->Flags;
  _26 = _25 & 16777216;
  if (_26 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1044_27 = 1;
  goto <bb 9>;

  <bb 8>:
  iftmp.1044_28 = 0;

  <bb 9>:
  # iftmp.1044_2 = PHI <iftmp.1044_27(7), iftmp.1044_28(8)>
  retval.1043_29 = iftmp.1044_2;
  if (retval.1043_29 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _31 = &g_8->Windows;
  _33 = ImVector<ImGuiWindow*>::operator[] (_31, i_1);
  _34 = *_33;
  focus_window_36 = NavRestoreLastChildNavWindow (_34);
  ImGui::FocusWindow (focus_window_36);
  goto <bb 12> (<L10>);

  <bb 11>:
  i_30 = i_1 + -1;
  goto <bb 3>;

<L10>:
  return;

}



;; Function void ImGui::PushItemWidth(float) (_ZN5ImGui13PushItemWidthEf, funcdef_no=849, decl_uid=2605, cgraph_uid=748, symbol_order=755)

void ImGui::PushItemWidth(float) (float item_width)
{
  struct ImGuiWindow * window;
  struct ImVector * D.33372;
  float * D.33371;
  float iftmp.1045;
  float iftmp.1045_1;
  float iftmp.1045_6;
  float iftmp.1045_7;
  float * _9;
  struct ImVector * _10;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  if (item_width_5(D) == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1045_6 = window_4->ItemWidthDefault;
  goto <bb 5>;

  <bb 4>:
  iftmp.1045_7 = item_width_5(D);

  <bb 5>:
  # iftmp.1045_1 = PHI <iftmp.1045_6(3), iftmp.1045_7(4)>
  window_4->DC.ItemWidth = iftmp.1045_1;
  _9 = &window_4->DC.ItemWidth;
  _10 = &window_4->DC.ItemWidthStack;
  ImVector<float>::push_back (_10, _9);
  return;

}



;; Function void ImGui::PushMultiItemsWidths(int, float) (_ZN5ImGui20PushMultiItemsWidthsEif, funcdef_no=850, decl_uid=13805, cgraph_uid=749, symbol_order=756)

void ImGui::PushMultiItemsWidths(int, float) (int components, float w_full)
{
  float D.33421;
  int i;
  const float w_item_last;
  const float w_item_one;
  const struct ImGuiStyle & style;
  struct ImGuiWindow * window;
  float D.33420;
  value_type & D.33419;
  struct ImVector * D.33418;
  struct ImVector * D.33417;
  int D.33415;
  struct ImVector * D.33413;
  float w_item_last.1049;
  float D.33411;
  int D.33410;
  float D.33409;
  float D.33408;
  float D.33407;
  int D.33406;
  float D.33405;
  float w_item_one.1048;
  float D.33403;
  float w_item_one.1047;
  float D.33401;
  int D.33400;
  float D.33399;
  float D.33398;
  float D.33397;
  float D.33396;
  float D.33395;
  int D.33394;
  float D.33393;
  struct ImGuiContext * GImGui.1046;
  struct ImGuiContext * GImGui.1046_9;
  float _13;
  float _15;
  int _17;
  float _18;
  float _19;
  float _20;
  float _21;
  float _22;
  int _23;
  float _24;
  float w_item_one.1047_26;
  float _28;
  float w_item_one.1048_29;
  float _30;
  int _31;
  float _32;
  float _33;
  float _34;
  int _35;
  float _36;
  float w_item_last.1049_38;
  struct ImVector * _40;
  int _43;
  struct ImVector * _44;
  struct ImVector * _47;
  value_type & _49;
  float _50;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  GImGui.1046_9 = GImGui;
  style_10 = &GImGui.1046_9->Style;
  if (w_full_11(D) <= 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = ImGui::CalcItemWidth ();
  w_full_14 = _13;

  <bb 4>:
  # w_full_1 = PHI <w_full_11(D)(2), w_full_14(3)>
  _15 = style_10->ItemInnerSpacing.x;
  _17 = components_16(D) + -1;
  _18 = (float) _17;
  _19 = _15 * _18;
  _20 = w_full_1 - _19;
  _21 = (float) components_16(D);
  _22 = _20 / _21;
  _23 = (int) _22;
  _24 = (float) _23;
  w_item_one.1047_26 = ImMax (1.0e+0, _24);
  w_item_one = w_item_one.1047_26;
  _28 = style_10->ItemInnerSpacing.x;
  w_item_one.1048_29 = w_item_one;
  _30 = _28 + w_item_one.1048_29;
  _31 = components_16(D) + -1;
  _32 = (float) _31;
  _33 = _30 * _32;
  _34 = w_full_1 - _33;
  _35 = (int) _34;
  _36 = (float) _35;
  w_item_last.1049_38 = ImMax (1.0e+0, _36);
  w_item_last = w_item_last.1049_38;
  _40 = &window_8->DC.ItemWidthStack;
  ImVector<float>::push_back (_40, &w_item_last);
  i_42 = 0;

  <bb 5>:
  # i_2 = PHI <i_42(4), i_46(6)>
  _43 = components_16(D) + -1;
  if (_43 <= i_2)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _44 = &window_8->DC.ItemWidthStack;
  ImVector<float>::push_back (_44, &w_item_one);
  i_46 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  _47 = &window_8->DC.ItemWidthStack;
  _49 = ImVector<float>::back (_47);
  _50 = *_49;
  window_8->DC.ItemWidth = _50;
  w_item_one ={v} {CLOBBER};
  w_item_last ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PopItemWidth() (_ZN5ImGui12PopItemWidthEv, funcdef_no=851, decl_uid=2606, cgraph_uid=750, symbol_order=757)

void ImGui::PopItemWidth() ()
{
  struct ImGuiWindow * window;
  value_type & D.33442;
  struct ImVector * D.33441;
  bool D.33437;
  struct ImVector * D.33436;
  float iftmp.1050;
  struct ImVector * D.33434;
  float iftmp.1050_1;
  struct ImVector * _6;
  struct ImVector * _8;
  bool _10;
  float iftmp.1050_11;
  struct ImVector * _12;
  value_type & _14;
  float iftmp.1050_15;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = &window_5->DC.ItemWidthStack;
  ImVector<float>::pop_back (_6);
  _8 = &window_5->DC.ItemWidthStack;
  _10 = ImVector<float>::empty (_8);
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1050_11 = window_5->ItemWidthDefault;
  goto <bb 5>;

  <bb 4>:
  _12 = &window_5->DC.ItemWidthStack;
  _14 = ImVector<float>::back (_12);
  iftmp.1050_15 = *_14;

  <bb 5>:
  # iftmp.1050_1 = PHI <iftmp.1050_11(3), iftmp.1050_15(4)>
  window_5->DC.ItemWidth = iftmp.1050_1;
  return;

}



;; Function float ImGui::CalcItemWidth() (_ZN5ImGui13CalcItemWidthEv, funcdef_no=852, decl_uid=2607, cgraph_uid=751, symbol_order=758)

float ImGui::CalcItemWidth() ()
{
  float width_to_right_edge;
  float w;
  struct ImGuiWindow * window;
  float D.33457;
  int D.33456;
  float D.33454;
  struct ImVec2 D.17985;
  float _9;
  int _12;
  float _14;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindowRead ();
  w_6 = window_5->DC.ItemWidth;
  if (w_6 < 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  D.17985 = ImGui::GetContentRegionAvail ();
  width_to_right_edge_8 = D.17985.x;
  _9 = width_to_right_edge_8 + w_6;
  w_11 = ImMax (1.0e+0, _9);

  <bb 4>:
  # w_1 = PHI <w_6(2), w_11(3)>
  _12 = (int) w_1;
  w_13 = (float) _12;
  _14 = w_13;

<L3>:
  return _14;

}



;; Function ImFont* GetDefaultFont() (_ZL14GetDefaultFontv, funcdef_no=853, decl_uid=15018, cgraph_uid=752, symbol_order=759)

ImFont* GetDefaultFont() ()
{
  struct ImGuiContext & g;
  struct ImFont * & D.33467;
  struct ImVector * D.33466;
  struct ImFontAtlas * D.33465;
  struct ImFont * D.33461;
  struct ImFont * iftmp.1051;
  struct ImFont * D.33459;
  struct ImFont * iftmp.1051_1;
  struct ImFont * _5;
  struct ImFont * iftmp.1051_6;
  struct ImFontAtlas * _7;
  struct ImVector * _8;
  struct ImFont * & _10;
  struct ImFont * iftmp.1051_11;
  struct ImFont * _12;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->IO.FontDefault;
  if (_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1051_6 = g_4->IO.FontDefault;
  goto <bb 5>;

  <bb 4>:
  _7 = g_4->IO.Fonts;
  _8 = &_7->Fonts;
  _10 = ImVector<ImFont*>::operator[] (_8, 0);
  iftmp.1051_11 = *_10;

  <bb 5>:
  # iftmp.1051_1 = PHI <iftmp.1051_6(3), iftmp.1051_11(4)>
  _12 = iftmp.1051_1;

<L3>:
  return _12;

}



;; Function void ImGui::SetCurrentFont(ImFont*) (_ZN5ImGui14SetCurrentFontEP6ImFont, funcdef_no=854, decl_uid=13811, cgraph_uid=753, symbol_order=760)

void ImGui::SetCurrentFont(ImFont*) (struct ImFont * font)
{
  struct ImFontAtlas * atlas;
  static const char __PRETTY_FUNCTION__[36] = "void ImGui::SetCurrentFont(ImFont*)";
  struct ImGuiContext & g;
  float D.33493;
  struct ImFont * D.33492;
  struct ImFont * D.33491;
  struct ImGuiWindow * D.33489;
  struct ImGuiWindow * D.33486;
  float iftmp.1052;
  float D.33484;
  float D.33483;
  struct ImFont * D.33482;
  float D.33481;
  float D.33480;
  struct ImFont * D.33479;
  float D.33478;
  float D.33474;
  bool D.33472;
  float iftmp.1052_1;
  bool _8;
  float _9;
  float _11;
  struct ImFont * _12;
  float _13;
  float _14;
  struct ImFont * _15;
  float _16;
  float _17;
  struct ImGuiWindow * _19;
  struct ImGuiWindow * _20;
  float iftmp.1052_22;
  float iftmp.1052_23;
  struct ImFont * _25;
  struct ImFont * _28;
  float _30;

  <bb 2>:
  g_5 = GImGui;
  if (font_6(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _8 = ImFont::IsLoaded (font_6(D));
  if (_8 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("font && font->IsLoaded()", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6509, &__PRETTY_FUNCTION__);

  <bb 6>:
  _9 = font_6(D)->Scale;
  if (_9 > 0.0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("font->Scale > 0.0f", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6510, &__PRETTY_FUNCTION__);

  <bb 8>:
  g_5->Font = font_6(D);
  _11 = g_5->IO.FontGlobalScale;
  _12 = g_5->Font;
  _13 = _12->FontSize;
  _14 = _11 * _13;
  _15 = g_5->Font;
  _16 = _15->Scale;
  _17 = _14 * _16;
  g_5->FontBaseSize = _17;
  _19 = g_5->CurrentWindow;
  if (_19 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _20 = g_5->CurrentWindow;
  iftmp.1052_22 = ImGuiWindow::CalcFontSize (_20);
  goto <bb 11>;

  <bb 10>:
  iftmp.1052_23 = 0.0;

  <bb 11>:
  # iftmp.1052_1 = PHI <iftmp.1052_22(9), iftmp.1052_23(10)>
  g_5->FontSize = iftmp.1052_1;
  _25 = g_5->Font;
  atlas_26 = _25->ContainerAtlas;
  g_5->DrawListSharedData.TexUvWhitePixel = atlas_26->TexUvWhitePixel;
  _28 = g_5->Font;
  g_5->DrawListSharedData.Font = _28;
  _30 = g_5->FontSize;
  g_5->DrawListSharedData.FontSize = _30;
  return;

}



;; Function void ImGui::PushFont(ImFont*) (_ZN5ImGui8PushFontEP6ImFont, funcdef_no=855, decl_uid=2574, cgraph_uid=754, symbol_order=761)

void ImGui::PushFont(ImFont*) (struct ImFont * font)
{
  struct ImFont * D.33506;
  struct ImGuiContext & g;
  struct ImDrawList * D.33505;
  struct ImGuiWindow * D.33504;
  void * D.33503;
  struct ImFontAtlas * D.33502;
  struct ImFont * font.1056;
  struct ImVector * D.33500;
  struct ImFont * font.1055;
  struct ImFont * font.1054;
  struct ImFont * font.1053;
  struct ImFont * font.1053_4;
  struct ImFont * _6;
  struct ImFont * font.1054_7;
  struct ImFont * font.1055_9;
  struct ImVector * _11;
  struct ImFont * font.1056_13;
  struct ImFontAtlas * _14;
  void * _15;
  struct ImGuiWindow * _16;
  struct ImDrawList * _17;

  <bb 2>:
  g_3 = GImGui;
  font.1053_4 = font;
  if (font.1053_4 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = GetDefaultFont ();
  font.1054_7 = _6;
  font = font.1054_7;

  <bb 4>:
  font.1055_9 = font;
  ImGui::SetCurrentFont (font.1055_9);
  _11 = &g_3->FontStack;
  ImVector<ImFont*>::push_back (_11, &font);
  font.1056_13 = font;
  _14 = font.1056_13->ContainerAtlas;
  _15 = _14->TexID;
  _16 = g_3->CurrentWindow;
  _17 = _16->DrawList;
  ImDrawList::PushTextureID (_17, _15);
  return;

}



;; Function void ImGui::PopFont() (_ZN5ImGui7PopFontEv, funcdef_no=856, decl_uid=2575, cgraph_uid=755, symbol_order=762)

void ImGui::PopFont() ()
{
  struct ImFont * D.33564;
  struct ImGuiContext & g;
  struct ImFont * & D.33563;
  struct ImVector * D.33562;
  bool D.33558;
  struct ImVector * D.33557;
  struct ImFont * iftmp.1059;
  struct ImVector * D.33555;
  struct ImDrawList * D.33554;
  struct ImGuiWindow * D.33553;
  struct ImFont * iftmp.1059_1;
  struct ImGuiWindow * _5;
  struct ImDrawList * _6;
  struct ImVector * _8;
  struct ImVector * _10;
  bool _12;
  struct ImFont * _14;
  struct ImFont * iftmp.1059_15;
  struct ImVector * _16;
  struct ImFont * & _18;
  struct ImFont * iftmp.1059_19;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->CurrentWindow;
  _6 = _5->DrawList;
  ImDrawList::PopTextureID (_6);
  _8 = &g_4->FontStack;
  ImVector<ImFont*>::pop_back (_8);
  _10 = &g_4->FontStack;
  _12 = ImVector<ImFont*>::empty (_10);
  if (_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _14 = GetDefaultFont ();
  iftmp.1059_15 = _14;
  goto <bb 5>;

  <bb 4>:
  _16 = &g_4->FontStack;
  _18 = ImVector<ImFont*>::back (_16);
  iftmp.1059_19 = *_18;

  <bb 5>:
  # iftmp.1059_1 = PHI <iftmp.1059_15(3), iftmp.1059_19(4)>
  ImGui::SetCurrentFont (iftmp.1059_1);
  return;

}



;; Function void ImGui::PushItemFlag(ImGuiItemFlags, bool) (_ZN5ImGui12PushItemFlagEib, funcdef_no=857, decl_uid=13808, cgraph_uid=756, symbol_order=763)

void ImGui::PushItemFlag(ImGuiItemFlags, bool) (ImGuiItemFlags option, bool enabled)
{
  struct ImGuiWindow * window;
  struct ImVector * D.33594;
  ImGuiItemFlags * D.33593;
  int D.33592;
  int D.33591;
  int D.33590;
  int D.33588;
  int D.33587;
  int _6;
  int _8;
  int _10;
  int _11;
  int _12;
  ImGuiItemFlags * _14;
  struct ImVector * _15;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  if (enabled_5(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = window_4->DC.ItemFlags;
  _8 = _6 | option_7(D);
  window_4->DC.ItemFlags = _8;
  goto <bb 5>;

  <bb 4>:
  _10 = window_4->DC.ItemFlags;
  _11 = ~option_7(D);
  _12 = _10 & _11;
  window_4->DC.ItemFlags = _12;

  <bb 5>:
  _14 = &window_4->DC.ItemFlags;
  _15 = &window_4->DC.ItemFlagsStack;
  ImVector<int>::push_back (_15, _14);
  return;

}



;; Function void ImGui::PopItemFlag() (_ZN5ImGui11PopItemFlagEv, funcdef_no=858, decl_uid=13809, cgraph_uid=757, symbol_order=764)

void ImGui::PopItemFlag() ()
{
  struct ImGuiWindow * window;
  value_type & D.33603;
  struct ImVector * D.33602;
  bool D.33598;
  struct ImVector * D.33597;
  int iftmp.1060;
  struct ImVector * D.33595;
  int iftmp.1060_1;
  struct ImVector * _6;
  struct ImVector * _8;
  bool _10;
  int iftmp.1060_11;
  struct ImVector * _12;
  value_type & _14;
  int iftmp.1060_15;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = &window_5->DC.ItemFlagsStack;
  ImVector<int>::pop_back (_6);
  _8 = &window_5->DC.ItemFlagsStack;
  _10 = ImVector<int>::empty (_8);
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1060_11 = 1;
  goto <bb 5>;

  <bb 4>:
  _12 = &window_5->DC.ItemFlagsStack;
  _14 = ImVector<int>::back (_12);
  iftmp.1060_15 = *_14;

  <bb 5>:
  # iftmp.1060_1 = PHI <iftmp.1060_11(3), iftmp.1060_15(4)>
  window_5->DC.ItemFlags = iftmp.1060_1;
  return;

}



;; Function void ImGui::PushAllowKeyboardFocus(bool) (_ZN5ImGui22PushAllowKeyboardFocusEb, funcdef_no=859, decl_uid=2612, cgraph_uid=758, symbol_order=765)

void ImGui::PushAllowKeyboardFocus(bool) (bool allow_keyboard_focus)
{
  int D.33624;
  int _2;

  <bb 2>:
  _2 = (int) allow_keyboard_focus_1(D);
  ImGui::PushItemFlag (1, _2);
  return;

}



;; Function void ImGui::PopAllowKeyboardFocus() (_ZN5ImGui21PopAllowKeyboardFocusEv, funcdef_no=860, decl_uid=2613, cgraph_uid=759, symbol_order=766)

void ImGui::PopAllowKeyboardFocus() ()
{
  <bb 2>:
  ImGui::PopItemFlag ();
  return;

}



;; Function void ImGui::PushButtonRepeat(bool) (_ZN5ImGui16PushButtonRepeatEb, funcdef_no=861, decl_uid=2615, cgraph_uid=760, symbol_order=767)

void ImGui::PushButtonRepeat(bool) (bool repeat)
{
  int D.33625;
  int _2;

  <bb 2>:
  _2 = (int) repeat_1(D);
  ImGui::PushItemFlag (2, _2);
  return;

}



;; Function void ImGui::PopButtonRepeat() (_ZN5ImGui15PopButtonRepeatEv, funcdef_no=862, decl_uid=2616, cgraph_uid=761, symbol_order=768)

void ImGui::PopButtonRepeat() ()
{
  <bb 2>:
  ImGui::PopItemFlag ();
  return;

}



;; Function void ImGui::PushTextWrapPos(float) (_ZN5ImGui15PushTextWrapPosEf, funcdef_no=863, decl_uid=2609, cgraph_uid=762, symbol_order=769)

void ImGui::PushTextWrapPos(float) (float wrap_pos_x)
{
  struct ImGuiWindow * window;
  struct ImVector * D.33627;
  float wrap_pos_x.1061;
  float wrap_pos_x.1061_4;
  struct ImVector * _6;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  wrap_pos_x.1061_4 = wrap_pos_x;
  window_3->DC.TextWrapPos = wrap_pos_x.1061_4;
  _6 = &window_3->DC.TextWrapPosStack;
  ImVector<float>::push_back (_6, &wrap_pos_x);
  return;

}



;; Function void ImGui::PopTextWrapPos() (_ZN5ImGui14PopTextWrapPosEv, funcdef_no=864, decl_uid=2610, cgraph_uid=763, symbol_order=770)

void ImGui::PopTextWrapPos() ()
{
  struct ImGuiWindow * window;
  value_type & D.33636;
  struct ImVector * D.33635;
  bool D.33631;
  struct ImVector * D.33630;
  float iftmp.1062;
  struct ImVector * D.33628;
  float iftmp.1062_1;
  struct ImVector * _6;
  struct ImVector * _8;
  bool _10;
  float iftmp.1062_11;
  struct ImVector * _12;
  value_type & _14;
  float iftmp.1062_15;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = &window_5->DC.TextWrapPosStack;
  ImVector<float>::pop_back (_6);
  _8 = &window_5->DC.TextWrapPosStack;
  _10 = ImVector<float>::empty (_8);
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1062_11 = -1.0e+0;
  goto <bb 5>;

  <bb 4>:
  _12 = &window_5->DC.TextWrapPosStack;
  _14 = ImVector<float>::back (_12);
  iftmp.1062_15 = *_14;

  <bb 5>:
  # iftmp.1062_1 = PHI <iftmp.1062_11(3), iftmp.1062_15(4)>
  window_5->DC.TextWrapPos = iftmp.1062_1;
  return;

}



;; Function ImGuiColMod::ImGuiColMod() (_ZN11ImGuiColModC2Ev, funcdef_no=867, decl_uid=18037, cgraph_uid=765, symbol_order=772)

ImGuiColMod::ImGuiColMod() (struct ImGuiColMod * const this)
{
  struct ImVec4 * D.33639;
  struct ImVec4 * _2;

  <bb 2>:
  _2 = &this_1(D)->BackupValue;
  ImVec4::ImVec4 (_2);
  return;

}



;; Function void ImGui::PushStyleColor(ImGuiCol, ImU32) (_ZN5ImGui14PushStyleColorEij, funcdef_no=865, decl_uid=2578, cgraph_uid=767, symbol_order=774)

void ImGui::PushStyleColor(ImGuiCol, ImU32) (ImGuiCol idx, ImU32 col)
{
  struct ImGuiColMod backup;
  struct ImGuiContext & g;
  struct ImVector * D.33637;
  struct ImVector * _7;

  <bb 2>:
  g_2 = GImGui;
  ImGuiColMod::ImGuiColMod (&backup);
  backup.Col = idx_4(D);
  backup.BackupValue = g_2->Style.Colors[idx_4(D)];
  _7 = &g_2->ColorModifiers;
  ImVector<ImGuiColMod>::push_back (_7, &backup);
  g_2->Style.Colors[idx_4(D)] = ImGui::ColorConvertU32ToFloat4 (col_9(D));
  backup ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PushStyleColor(ImGuiCol, const ImVec4&) (_ZN5ImGui14PushStyleColorEiRK6ImVec4, funcdef_no=869, decl_uid=2581, cgraph_uid=768, symbol_order=775)

void ImGui::PushStyleColor(ImGuiCol, const ImVec4&) (ImGuiCol idx, const struct ImVec4 & col)
{
  struct ImGuiColMod backup;
  struct ImGuiContext & g;
  struct ImVector * D.33685;
  struct ImVector * _7;

  <bb 2>:
  g_2 = GImGui;
  ImGuiColMod::ImGuiColMod (&backup);
  backup.Col = idx_4(D);
  backup.BackupValue = g_2->Style.Colors[idx_4(D)];
  _7 = &g_2->ColorModifiers;
  ImVector<ImGuiColMod>::push_back (_7, &backup);
  g_2->Style.Colors[idx_4(D)] = *col_9(D);
  backup ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PopStyleColor(int) (_ZN5ImGui13PopStyleColorEi, funcdef_no=870, decl_uid=2583, cgraph_uid=769, symbol_order=776)

void ImGui::PopStyleColor(int) (int count)
{
  struct ImGuiColMod & backup;
  struct ImGuiContext & g;
  struct ImVector * D.33691;
  int D.33690;
  struct ImVector * D.33689;
  struct ImVector * _6;
  int _9;
  struct ImVector * _11;

  <bb 2>:
  g_4 = GImGui;

  <bb 3>:
  # count_1 = PHI <count_5(D)(2), count_13(4)>
  if (count_1 <= 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _6 = &g_4->ColorModifiers;
  backup_8 = ImVector<ImGuiColMod>::back (_6);
  _9 = backup_8->Col;
  g_4->Style.Colors[_9] = backup_8->BackupValue;
  _11 = &g_4->ColorModifiers;
  ImVector<ImGuiColMod>::pop_back (_11);
  count_13 = count_1 + -1;
  goto <bb 3>;

  <bb 5>:
  return;

}



;; Function void* ImGuiStyleVarInfo::GetVarPtr(ImGuiStyle*) const (_ZNK17ImGuiStyleVarInfo9GetVarPtrEP10ImGuiStyle, funcdef_no=871, decl_uid=18089, cgraph_uid=770, symbol_order=777)

void* ImGuiStyleVarInfo::GetVarPtr(ImGuiStyle*) const (const struct ImGuiStyleVarInfo * const this, struct ImGuiStyle * style)
{
  sizetype D.33734;
  unsigned int D.33733;
  void * D.33732;
  unsigned int _3;
  sizetype _4;
  void * _6;

  <bb 2>:
  _3 = this_2(D)->Offset;
  _4 = (sizetype) _3;
  _6 = style_5(D) + _4;

<L0>:
  return _6;

}



;; Function const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar) (_ZL15GetStyleVarInfoi, funcdef_no=872, decl_uid=18127, cgraph_uid=771, symbol_order=779)

const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar) (ImGuiStyleVar idx)
{
  static const char __PRETTY_FUNCTION__[56] = "const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar)";
  const struct ImGuiStyleVarInfo * D.33716;
  const struct ImGuiStyleVarInfo * _2;

  <bb 2>:
  if (idx_1(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (idx_1(D) <= 20)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("idx >= 0 && idx < ImGuiStyleVar_COUNT", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6658, &__PRETTY_FUNCTION__);

  <bb 6>:

  <bb 7>:
  _2 = &GStyleVarInfo[idx_1(D)];

<L7>:
  return _2;

}



;; Function void ImGui::PushStyleVar(ImGuiStyleVar, float) (_ZN5ImGui12PushStyleVarEif, funcdef_no=873, decl_uid=2586, cgraph_uid=772, symbol_order=780)

void ImGui::PushStyleVar(ImGuiStyleVar, float) (ImGuiStyleVar idx, float val)
{
  float * pvar;
  struct ImGuiContext & g;
  static const char __PRETTY_FUNCTION__[47] = "void ImGui::PushStyleVar(ImGuiStyleVar, float)";
  const struct ImGuiStyleVarInfo * var_info;
  struct ImVector * D.33726;
  float D.33725;
  struct ImGuiStyleMod D.18155;
  struct ImGuiStyle * D.33724;
  unsigned int D.33721;
  ImGuiDataType D.33718;
  ImGuiDataType _5;
  unsigned int _6;
  struct ImGuiStyle * _8;
  float _11;
  struct ImVector * _13;

  <bb 2>:
  var_info_4 = GetStyleVarInfo (idx_2(D));
  _5 = var_info_4->Type;
  if (_5 == 1)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _6 = var_info_4->Count;
  if (_6 == 1)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  g_7 = GImGui;
  _8 = &g_7->Style;
  pvar_10 = ImGuiStyleVarInfo::GetVarPtr (var_info_4, _8);
  _11 = *pvar_10;
  ImGuiStyleMod::ImGuiStyleMod (&D.18155, idx_2(D), _11);
  _13 = &g_7->StyleModifiers;
  ImVector<ImGuiStyleMod>::push_back (_13, &D.18155);
  D.18155 ={v} {CLOBBER};
  *pvar_10 = val_16(D);
  goto <bb 7> (<L7>);

  <bb 5>:

  <bb 6>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6674, &__PRETTY_FUNCTION__);

<L7>:
  return;

}



;; Function void ImGui::PushStyleVar(ImGuiStyleVar, const ImVec2&) (_ZN5ImGui12PushStyleVarEiRK6ImVec2, funcdef_no=874, decl_uid=2589, cgraph_uid=773, symbol_order=781)

void ImGui::PushStyleVar(ImGuiStyleVar, const ImVec2&) (ImGuiStyleVar idx, const struct ImVec2 & val)
{
  struct ImVec2 * pvar;
  struct ImGuiContext & g;
  static const char __PRETTY_FUNCTION__[55] = "void ImGui::PushStyleVar(ImGuiStyleVar, const ImVec2&)";
  const struct ImGuiStyleVarInfo * var_info;
  struct ImVector * D.33788;
  struct ImGuiStyleMod D.18174;
  struct ImGuiStyle * D.33787;
  unsigned int D.33784;
  ImGuiDataType D.33781;
  ImGuiDataType _5;
  unsigned int _6;
  struct ImGuiStyle * _8;
  struct ImVector * _12;

  <bb 2>:
  var_info_4 = GetStyleVarInfo (idx_2(D));
  _5 = var_info_4->Type;
  if (_5 == 1)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _6 = var_info_4->Count;
  if (_6 == 2)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  g_7 = GImGui;
  _8 = &g_7->Style;
  pvar_10 = ImGuiStyleVarInfo::GetVarPtr (var_info_4, _8);
  ImGuiStyleMod::ImGuiStyleMod (&D.18174, idx_2(D), MEM[(const struct ImVec2 &)pvar_10]);
  _12 = &g_7->StyleModifiers;
  ImVector<ImGuiStyleMod>::push_back (_12, &D.18174);
  D.18174 ={v} {CLOBBER};
  *pvar_10 = *val_15(D);
  goto <bb 7> (<L7>);

  <bb 5>:

  <bb 6>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6688, &__PRETTY_FUNCTION__);

<L7>:
  return;

}



;; Function void ImGui::PopStyleVar(int) (_ZN5ImGui11PopStyleVarEi, funcdef_no=875, decl_uid=2591, cgraph_uid=774, symbol_order=782)

void ImGui::PopStyleVar(int) (int count)
{
  void * data;
  const struct ImGuiStyleVarInfo * info;
  struct ImGuiStyleMod & backup;
  struct ImGuiContext & g;
  struct ImVector * D.33818;
  float D.33816;
  float * D.33815;
  float D.33814;
  unsigned int D.33811;
  ImGuiDataType D.33808;
  float D.33807;
  unsigned int D.33805;
  ImGuiDataType D.33803;
  struct ImGuiStyle * D.33800;
  int D.33799;
  struct ImVector * D.33798;
  struct ImVector * _7;
  int _10;
  struct ImGuiStyle * _13;
  ImGuiDataType _16;
  unsigned int _17;
  float _18;
  ImGuiDataType _20;
  unsigned int _21;
  float _22;
  float * _24;
  float _25;
  struct ImVector * _27;

  <bb 2>:
  g_5 = GImGui;

  <bb 3>:
  # count_1 = PHI <count_6(D)(2), count_29(10)>
  if (count_1 <= 0)
    goto <bb 11>;
  else
    goto <bb 4>;

  <bb 4>:
  _7 = &g_5->StyleModifiers;
  backup_9 = ImVector<ImGuiStyleMod>::back (_7);
  _10 = backup_9->VarIdx;
  info_12 = GetStyleVarInfo (_10);
  _13 = &g_5->Style;
  data_15 = ImGuiStyleVarInfo::GetVarPtr (info_12, _13);
  _16 = info_12->Type;
  if (_16 == 1)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _17 = info_12->Count;
  if (_17 == 1)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _18 = backup_9->D.11007.BackupFloat[0];
  MEM[(float *)data_15] = _18;
  goto <bb 10>;

  <bb 7>:
  _20 = info_12->Type;
  if (_20 == 1)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _21 = info_12->Count;
  if (_21 == 2)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _22 = backup_9->D.11007.BackupFloat[0];
  MEM[(float *)data_15] = _22;
  _24 = data_15 + 4;
  _25 = backup_9->D.11007.BackupFloat[1];
  *_24 = _25;

  <bb 10>:
  _27 = &g_5->StyleModifiers;
  ImVector<ImGuiStyleMod>::pop_back (_27);
  count_29 = count_1 + -1;
  goto <bb 3>;

  <bb 11>:
  return;

}



;; Function const char* ImGui::GetStyleColorName(ImGuiCol) (_ZN5ImGui17GetStyleColorNameEi, funcdef_no=876, decl_uid=3326, cgraph_uid=775, symbol_order=783)

const char* ImGui::GetStyleColorName(ImGuiCol) (ImGuiCol idx)
{
  static const char __PRETTY_FUNCTION__[47] = "const char* ImGui::GetStyleColorName(ImGuiCol)";
  const char * D.33836;
  const char * _1;
  const char * _3;
  const char * _4;
  const char * _5;
  const char * _6;
  const char * _7;
  const char * _8;
  const char * _9;
  const char * _10;
  const char * _11;
  const char * _12;
  const char * _13;
  const char * _14;
  const char * _15;
  const char * _16;
  const char * _17;
  const char * _18;
  const char * _19;
  const char * _20;
  const char * _21;
  const char * _22;
  const char * _23;
  const char * _24;
  const char * _25;
  const char * _26;
  const char * _27;
  const char * _28;
  const char * _29;
  const char * _30;
  const char * _31;
  const char * _32;
  const char * _33;
  const char * _34;
  const char * _35;
  const char * _36;
  const char * _37;
  const char * _38;
  const char * _39;
  const char * _40;
  const char * _41;
  const char * _42;
  const char * _43;
  const char * _44;

  <bb 2>:
  switch (idx_2(D)) <default: <L42>, case 0: <L0>, case 1: <L1>, case 2: <L2>, case 3: <L3>, case 4: <L4>, case 5: <L5>, case 6: <L6>, case 7: <L7>, case 8: <L8>, case 9: <L9>, case 10: <L10>, case 11: <L11>, case 12: <L12>, case 13: <L13>, case 14: <L14>, case 15: <L15>, case 16: <L16>, case 17: <L17>, case 18: <L18>, case 19: <L19>, case 20: <L20>, case 21: <L21>, case 22: <L22>, case 23: <L23>, case 24: <L24>, case 25: <L25>, case 26: <L26>, case 27: <L27>, case 28: <L28>, case 29: <L29>, case 30: <L30>, case 31: <L31>, case 32: <L32>, case 33: <L33>, case 34: <L34>, case 35: <L35>, case 36: <L36>, case 37: <L37>, case 38: <L38>, case 39: <L39>, case 40: <L40>, case 41: <L41>>

<L0>:
  _3 = "Text";
  goto <bb 46> (<L46>);

<L1>:
  _4 = "TextDisabled";
  goto <bb 46> (<L46>);

<L2>:
  _5 = "WindowBg";
  goto <bb 46> (<L46>);

<L3>:
  _6 = "ChildBg";
  goto <bb 46> (<L46>);

<L4>:
  _7 = "PopupBg";
  goto <bb 46> (<L46>);

<L5>:
  _8 = "Border";
  goto <bb 46> (<L46>);

<L6>:
  _9 = "BorderShadow";
  goto <bb 46> (<L46>);

<L7>:
  _10 = "FrameBg";
  goto <bb 46> (<L46>);

<L8>:
  _11 = "FrameBgHovered";
  goto <bb 46> (<L46>);

<L9>:
  _12 = "FrameBgActive";
  goto <bb 46> (<L46>);

<L10>:
  _13 = "TitleBg";
  goto <bb 46> (<L46>);

<L11>:
  _14 = "TitleBgActive";
  goto <bb 46> (<L46>);

<L12>:
  _15 = "TitleBgCollapsed";
  goto <bb 46> (<L46>);

<L13>:
  _16 = "MenuBarBg";
  goto <bb 46> (<L46>);

<L14>:
  _17 = "ScrollbarBg";
  goto <bb 46> (<L46>);

<L15>:
  _18 = "ScrollbarGrab";
  goto <bb 46> (<L46>);

<L16>:
  _19 = "ScrollbarGrabHovered";
  goto <bb 46> (<L46>);

<L17>:
  _20 = "ScrollbarGrabActive";
  goto <bb 46> (<L46>);

<L18>:
  _21 = "CheckMark";
  goto <bb 46> (<L46>);

<L19>:
  _22 = "SliderGrab";
  goto <bb 46> (<L46>);

<L20>:
  _23 = "SliderGrabActive";
  goto <bb 46> (<L46>);

<L21>:
  _24 = "Button";
  goto <bb 46> (<L46>);

<L22>:
  _25 = "ButtonHovered";
  goto <bb 46> (<L46>);

<L23>:
  _26 = "ButtonActive";
  goto <bb 46> (<L46>);

<L24>:
  _27 = "Header";
  goto <bb 46> (<L46>);

<L25>:
  _28 = "HeaderHovered";
  goto <bb 46> (<L46>);

<L26>:
  _29 = "HeaderActive";
  goto <bb 46> (<L46>);

<L27>:
  _30 = "Separator";
  goto <bb 46> (<L46>);

<L28>:
  _31 = "SeparatorHovered";
  goto <bb 46> (<L46>);

<L29>:
  _32 = "SeparatorActive";
  goto <bb 46> (<L46>);

<L30>:
  _33 = "ResizeGrip";
  goto <bb 46> (<L46>);

<L31>:
  _34 = "ResizeGripHovered";
  goto <bb 46> (<L46>);

<L32>:
  _35 = "ResizeGripActive";
  goto <bb 46> (<L46>);

<L33>:
  _36 = "PlotLines";
  goto <bb 46> (<L46>);

<L34>:
  _37 = "PlotLinesHovered";
  goto <bb 46> (<L46>);

<L35>:
  _38 = "PlotHistogram";
  goto <bb 46> (<L46>);

<L36>:
  _39 = "PlotHistogramHovered";
  goto <bb 46> (<L46>);

<L37>:
  _40 = "TextSelectedBg";
  goto <bb 46> (<L46>);

<L38>:
  _41 = "ModalWindowDarkening";
  goto <bb 46> (<L46>);

<L39>:
  _42 = "DragDropTarget";
  goto <bb 46> (<L46>);

<L40>:
  _43 = "NavHighlight";
  goto <bb 46> (<L46>);

<L41>:
  _44 = "NavWindowingHighlight";
  goto <bb 46> (<L46>);

<L42>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6755, &__PRETTY_FUNCTION__);

  # _1 = PHI <_3(3), _4(4), _5(5), _6(6), _7(7), _8(8), _9(9), _10(10), _11(11), _12(12), _13(13), _14(14), _15(15), _16(16), _17(17), _18(18), _19(19), _20(20), _21(21), _22(22), _23(23), _24(24), _25(25), _26(26), _27(27), _28(28), _29(29), _30(30), _31(31), _32(32), _33(33), _34(34), _35(35), _36(36), _37(37), _38(38), _39(39), _40(40), _41(41), _42(42), _43(43), _44(44)>
<L46>:
  return _1;

}



;; Function bool ImGui::IsWindowChildOf(ImGuiWindow*, ImGuiWindow*) (_ZN5ImGui15IsWindowChildOfEP11ImGuiWindowS1_, funcdef_no=877, decl_uid=13747, cgraph_uid=776, symbol_order=784)

bool ImGui::IsWindowChildOf(ImGuiWindow*, ImGuiWindow*) (struct ImGuiWindow * window, struct ImGuiWindow * potential_parent)
{
  bool D.33845;
  struct ImGuiWindow * D.33842;
  bool _2;
  struct ImGuiWindow * _5;
  bool _7;
  bool _9;
  bool _10;

  <bb 2>:
  _5 = window_4(D)->RootWindow;
  if (_5 == potential_parent_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 1;
  goto <bb 9> (<L7>);

  <bb 4>:
  # window_1 = PHI <window_4(D)(2), window_8(7)>
  if (window_1 == 0B)
    goto <bb 8>;
  else
    goto <bb 5>;

  <bb 5>:
  if (window_1 == potential_parent_6(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _9 = 1;
  goto <bb 9> (<L7>);

  <bb 7>:
  window_8 = window_1->ParentWindow;
  goto <bb 4>;

  <bb 8>:
  _10 = 0;

  # _2 = PHI <_7(3), _9(6), _10(8)>
<L7>:
  return _2;

}



;; Function bool ImGui::IsWindowHovered(ImGuiHoveredFlags) (_ZN5ImGui15IsWindowHoveredEi, funcdef_no=878, decl_uid=2501, cgraph_uid=777, symbol_order=785)

bool ImGui::IsWindowHovered(ImGuiHoveredFlags) (ImGuiHoveredFlags flags)
{
  struct ImGuiContext & g;
  static const char __PRETTY_FUNCTION__[47] = "bool ImGui::IsWindowHovered(ImGuiHoveredFlags)";
  unsigned int D.33908;
  struct ImGuiWindow * D.33907;
  unsigned int D.33906;
  bool D.33903;
  bool D.33902;
  unsigned int D.33899;
  int D.33896;
  bool D.33893;
  struct ImGuiWindow * D.33892;
  bool retval.1069;
  struct ImGuiWindow * D.33888;
  struct ImGuiWindow * D.33887;
  bool D.33884;
  bool D.33883;
  struct ImGuiWindow * D.33882;
  struct ImGuiWindow * D.33881;
  struct ImGuiWindow * D.33879;
  bool iftmp.1068;
  bool retval.1067;
  struct ImGuiWindow * D.33871;
  struct ImGuiWindow * D.33870;
  struct ImGuiWindow * D.33869;
  struct ImGuiWindow * D.33866;
  struct ImGuiWindow * D.33865;
  struct ImGuiWindow * D.33864;
  int D.33863;
  bool D.33861;
  struct ImGuiWindow * D.33858;
  int D.33855;
  int D.33851;
  bool _1;
  bool iftmp.1068_2;
  int _8;
  int _11;
  struct ImGuiWindow * _12;
  bool _13;
  int _14;
  struct ImGuiWindow * _15;
  struct ImGuiWindow * _16;
  struct ImGuiWindow * _17;
  bool _18;
  struct ImGuiWindow * _19;
  struct ImGuiWindow * _20;
  struct ImGuiWindow * _21;
  bool _22;
  struct ImGuiWindow * _23;
  struct ImGuiWindow * _24;
  struct ImGuiWindow * _25;
  bool _27;
  bool _28;
  bool iftmp.1068_29;
  bool iftmp.1068_30;
  bool retval.1067_31;
  bool _32;
  struct ImGuiWindow * _33;
  struct ImGuiWindow * _34;
  bool _35;
  struct ImGuiWindow * _36;
  bool _38;
  bool retval.1069_39;
  bool _40;
  int _41;
  unsigned int _42;
  bool _43;
  bool _44;
  unsigned int _45;
  struct ImGuiWindow * _46;
  unsigned int _47;
  bool _48;
  bool _49;

  <bb 2>:
  _8 = flags_7(D) & 64;
  if (_8 == 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("(flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6774, &__PRETTY_FUNCTION__);

  <bb 4>:
  g_10 = GImGui;
  _11 = flags_7(D) & 4;
  if (_11 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _12 = g_10->HoveredWindow;
  if (_12 == 0B)
    goto <bb 6>;
  else
    goto <bb 24>;

  <bb 6>:
  _13 = 0;
  goto <bb 32> (<L36>);

  <bb 7>:
  _14 = flags_7(D) & 3;
  switch (_14) <default: <L20>, case 1: <L13>, case 2: <L10>, case 3: <L7>>

<L7>:
  _15 = g_10->HoveredRootWindow;
  _16 = g_10->CurrentWindow;
  _17 = _16->RootWindow;
  if (_15 != _17)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _18 = 0;
  goto <bb 32> (<L36>);

  <bb 10>:
  goto <bb 24>;

<L10>:
  _19 = g_10->HoveredWindow;
  _20 = g_10->CurrentWindow;
  _21 = _20->RootWindow;
  if (_19 != _21)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _22 = 0;
  goto <bb 32> (<L36>);

  <bb 13>:
  goto <bb 24>;

<L13>:
  _23 = g_10->HoveredWindow;
  if (_23 == 0B)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  _24 = g_10->CurrentWindow;
  _25 = g_10->HoveredWindow;
  _27 = ImGui::IsWindowChildOf (_25, _24);
  _28 = ~_27;
  if (_28 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.1068_30 = 1;
  goto <bb 18>;

  <bb 17>:
  iftmp.1068_29 = 0;

  <bb 18>:
  # iftmp.1068_2 = PHI <iftmp.1068_30(16), iftmp.1068_29(17)>
  retval.1067_31 = iftmp.1068_2;
  if (retval.1067_31 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _32 = 0;
  goto <bb 32> (<L36>);

  <bb 20>:
  goto <bb 24>;

<L20>:
  _33 = g_10->HoveredWindow;
  _34 = g_10->CurrentWindow;
  if (_33 != _34)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  _35 = 0;
  goto <bb 32> (<L36>);

  <bb 23>:

  <bb 24>:
  _36 = g_10->HoveredRootWindow;
  _38 = IsWindowContentHoverable (_36, flags_7(D));
  retval.1069_39 = ~_38;
  if (retval.1069_39 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _40 = 0;
  goto <bb 32> (<L36>);

  <bb 26>:
  _41 = flags_7(D) & 32;
  if (_41 == 0)
    goto <bb 27>;
  else
    goto <bb 31>;

  <bb 27>:
  _42 = g_10->ActiveId;
  if (_42 != 0)
    goto <bb 28>;
  else
    goto <bb 31>;

  <bb 28>:
  _43 = g_10->ActiveIdAllowOverlap;
  _44 = ~_43;
  if (_44 != 0)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 29>:
  _45 = g_10->ActiveId;
  _46 = g_10->HoveredWindow;
  _47 = _46->MoveId;
  if (_45 != _47)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _48 = 0;
  goto <bb 32> (<L36>);

  <bb 31>:
  _49 = 1;

  # _1 = PHI <_13(6), _18(9), _22(12), _32(19), _35(22), _40(25), _48(30), _49(31)>
<L36>:
  return _1;

}



;; Function bool ImGui::IsWindowFocused(ImGuiFocusedFlags) (_ZN5ImGui15IsWindowFocusedEi, funcdef_no=879, decl_uid=2499, cgraph_uid=778, symbol_order=786)

bool ImGui::IsWindowFocused(ImGuiFocusedFlags) (ImGuiFocusedFlags flags)
{
  static const char __PRETTY_FUNCTION__[47] = "bool ImGui::IsWindowFocused(ImGuiFocusedFlags)";
  struct ImGuiContext & g;
  struct ImGuiWindow * D.33946;
  struct ImGuiWindow * D.33945;
  bool D.33943;
  struct ImGuiWindow * D.33942;
  struct ImGuiWindow * D.33941;
  struct ImGuiWindow * D.33939;
  bool iftmp.1071;
  struct ImGuiWindow * D.33935;
  struct ImGuiWindow * D.33934;
  struct ImGuiWindow * D.33933;
  struct ImGuiWindow * D.33931;
  struct ImGuiWindow * D.33930;
  struct ImGuiWindow * D.33929;
  struct ImGuiWindow * D.33928;
  struct ImGuiWindow * D.33926;
  bool iftmp.1070;
  int D.33922;
  struct ImGuiWindow * D.33921;
  bool D.33920;
  int D.33917;
  struct ImGuiWindow * D.33913;
  bool _1;
  bool iftmp.1070_2;
  bool iftmp.1071_3;
  struct ImGuiWindow * _9;
  int _11;
  struct ImGuiWindow * _12;
  bool _13;
  int _14;
  struct ImGuiWindow * _15;
  struct ImGuiWindow * _16;
  struct ImGuiWindow * _17;
  struct ImGuiWindow * _18;
  struct ImGuiWindow * _19;
  bool iftmp.1070_20;
  bool iftmp.1070_21;
  bool _22;
  struct ImGuiWindow * _23;
  struct ImGuiWindow * _24;
  struct ImGuiWindow * _25;
  bool _26;
  struct ImGuiWindow * _27;
  struct ImGuiWindow * _28;
  struct ImGuiWindow * _29;
  bool _31;
  bool iftmp.1071_32;
  bool iftmp.1071_33;
  bool _34;
  struct ImGuiWindow * _35;
  struct ImGuiWindow * _36;
  bool _37;

  <bb 2>:
  g_8 = GImGui;
  _9 = g_8->CurrentWindow;
  if (_9 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.CurrentWindow", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6816, &__PRETTY_FUNCTION__);

  <bb 4>:
  _11 = flags_10(D) & 4;
  if (_11 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _12 = g_8->NavWindow;
  _13 = _12 != 0B;
  goto <bb 19> (<L17>);

  <bb 6>:
  _14 = flags_10(D) & 3;
  switch (_14) <default: <L16>, case 1: <L11>, case 2: <L10>, case 3: <L5>>

<L5>:
  _15 = g_8->NavWindow;
  if (_15 != 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _16 = g_8->NavWindow;
  _17 = _16->RootWindow;
  _18 = g_8->CurrentWindow;
  _19 = _18->RootWindow;
  if (_17 == _19)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1070_20 = 1;
  goto <bb 11>;

  <bb 10>:
  iftmp.1070_21 = 0;

  <bb 11>:
  # iftmp.1070_2 = PHI <iftmp.1070_20(9), iftmp.1070_21(10)>
  _22 = iftmp.1070_2;
  goto <bb 19> (<L17>);

<L10>:
  _23 = g_8->NavWindow;
  _24 = g_8->CurrentWindow;
  _25 = _24->RootWindow;
  _26 = _23 == _25;
  goto <bb 19> (<L17>);

<L11>:
  _27 = g_8->NavWindow;
  if (_27 != 0B)
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  _28 = g_8->CurrentWindow;
  _29 = g_8->NavWindow;
  _31 = ImGui::IsWindowChildOf (_29, _28);
  if (_31 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.1071_32 = 1;
  goto <bb 17>;

  <bb 16>:
  iftmp.1071_33 = 0;

  <bb 17>:
  # iftmp.1071_3 = PHI <iftmp.1071_32(15), iftmp.1071_33(16)>
  _34 = iftmp.1071_3;
  goto <bb 19> (<L17>);

<L16>:
  _35 = g_8->NavWindow;
  _36 = g_8->CurrentWindow;
  _37 = _35 == _36;

  # _1 = PHI <_13(5), _22(11), _26(12), _34(17), _37(18)>
<L17>:
  return _1;

}



;; Function bool ImGui::IsWindowNavFocusable(ImGuiWindow*) (_ZN5ImGui20IsWindowNavFocusableEP11ImGuiWindow, funcdef_no=880, decl_uid=13749, cgraph_uid=779, symbol_order=787)

bool ImGui::IsWindowNavFocusable(ImGuiWindow*) (struct ImGuiWindow * window)
{
  struct ImGuiContext & g;
  struct ImGuiWindow * D.33960;
  int D.33958;
  int D.33957;
  struct ImGuiWindow * D.33955;
  bool D.33953;
  bool iftmp.1072;
  bool D.33948;
  bool iftmp.1072_1;
  bool _5;
  struct ImGuiWindow * _6;
  int _7;
  int _8;
  struct ImGuiWindow * _9;
  bool iftmp.1072_10;
  bool iftmp.1072_11;
  bool _12;

  <bb 2>:
  g_3 = GImGui;
  _5 = window_4(D)->Active;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _6 = window_4(D)->RootWindowForTabbing;
  if (_6 == window_4(D))
    goto <bb 4>;
  else
    goto <bb 7>;

  <bb 4>:
  _7 = window_4(D)->Flags;
  _8 = _7 & 524288;
  if (_8 == 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _9 = g_3->NavWindow;
  if (_9 == window_4(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1072_10 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.1072_11 = 0;

  <bb 8>:
  # iftmp.1072_1 = PHI <iftmp.1072_10(6), iftmp.1072_11(7)>
  _12 = iftmp.1072_1;

<L6>:
  return _12;

}



;; Function float ImGui::GetWindowWidth() (_ZN5ImGui14GetWindowWidthEv, funcdef_no=881, decl_uid=2505, cgraph_uid=780, symbol_order=788)

float ImGui::GetWindowWidth() ()
{
  struct ImGuiWindow * window;
  float D.33963;
  struct ImGuiContext * GImGui.1073;
  struct ImGuiContext * GImGui.1073_2;
  float _4;

  <bb 2>:
  GImGui.1073_2 = GImGui;
  window_3 = GImGui.1073_2->CurrentWindow;
  _4 = window_3->Size.x;

<L0>:
  return _4;

}



;; Function float ImGui::GetWindowHeight() (_ZN5ImGui15GetWindowHeightEv, funcdef_no=882, decl_uid=2506, cgraph_uid=781, symbol_order=789)

float ImGui::GetWindowHeight() ()
{
  struct ImGuiWindow * window;
  float D.33966;
  struct ImGuiContext * GImGui.1074;
  struct ImGuiContext * GImGui.1074_2;
  float _4;

  <bb 2>:
  GImGui.1074_2 = GImGui;
  window_3 = GImGui.1074_2->CurrentWindow;
  _4 = window_3->Size.y;

<L0>:
  return _4;

}



;; Function ImVec2 ImGui::GetWindowPos() (_ZN5ImGui12GetWindowPosEv, funcdef_no=883, decl_uid=2503, cgraph_uid=782, symbol_order=790)

ImVec2 ImGui::GetWindowPos() ()
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImVec2 D.33968;

  <bb 2>:
  g_2 = GImGui;
  window_3 = g_2->CurrentWindow;
  D.33968 = window_3->Pos;

<L0>:
  return D.33968;

}



;; Function void SetWindowScrollX(ImGuiWindow*, float) (_ZL16SetWindowScrollXP11ImGuiWindowf, funcdef_no=884, decl_uid=15023, cgraph_uid=783, symbol_order=791)

void SetWindowScrollX(ImGuiWindow*, float) (struct ImGuiWindow * window, float new_scroll_x)
{
  float D.33975;
  float D.33974;
  float D.33973;
  float D.33972;
  float D.33971;
  float D.33970;
  float _3;
  float _4;
  float _5;
  float _9;
  float _10;
  float _11;

  <bb 2>:
  _3 = window_2(D)->DC.CursorMaxPos.x;
  _4 = window_2(D)->Scroll.x;
  _5 = _3 + _4;
  window_2(D)->DC.CursorMaxPos.x = _5;
  window_2(D)->Scroll.x = new_scroll_x_7(D);
  _9 = window_2(D)->DC.CursorMaxPos.x;
  _10 = window_2(D)->Scroll.x;
  _11 = _9 - _10;
  window_2(D)->DC.CursorMaxPos.x = _11;
  return;

}



;; Function void SetWindowScrollY(ImGuiWindow*, float) (_ZL16SetWindowScrollYP11ImGuiWindowf, funcdef_no=885, decl_uid=15026, cgraph_uid=784, symbol_order=792)

void SetWindowScrollY(ImGuiWindow*, float) (struct ImGuiWindow * window, float new_scroll_y)
{
  float D.33981;
  float D.33980;
  float D.33979;
  float D.33978;
  float D.33977;
  float D.33976;
  float _3;
  float _4;
  float _5;
  float _9;
  float _10;
  float _11;

  <bb 2>:
  _3 = window_2(D)->DC.CursorMaxPos.y;
  _4 = window_2(D)->Scroll.y;
  _5 = _3 + _4;
  window_2(D)->DC.CursorMaxPos.y = _5;
  window_2(D)->Scroll.y = new_scroll_y_7(D);
  _9 = window_2(D)->DC.CursorMaxPos.y;
  _10 = window_2(D)->Scroll.y;
  _11 = _9 - _10;
  window_2(D)->DC.CursorMaxPos.y = _11;
  return;

}



;; Function void SetWindowPos(ImGuiWindow*, const ImVec2&, ImGuiCond) (_ZL12SetWindowPosP11ImGuiWindowRK6ImVec2i, funcdef_no=886, decl_uid=15030, cgraph_uid=785, symbol_order=793)

void SetWindowPos(ImGuiWindow*, const ImVec2&, ImGuiCond) (struct ImGuiWindow * window, const struct ImVec2 & pos, ImGuiCond cond)
{
  const struct ImVec2 old_pos;
  static const char __PRETTY_FUNCTION__[58] = "void SetWindowPos(ImGuiWindow*, const ImVec2&, ImGuiCond)";
  struct ImVec2 * D.33999;
  struct ImVec2 * D.33998;
  struct ImVec2 D.18292;
  struct ImVec2 * D.33997;
  struct ImVec2 * D.33996;
  struct ImVec2 D.18291;
  struct ImVec2 D.18287;
  int D.33995;
  int D.33994;
  bool D.33990;
  int D.33985;
  int D.33984;
  int _6;
  int _7;
  bool _10;
  int _12;
  int _13;
  struct ImVec2 * _22;
  struct ImVec2 * _24;
  struct ImVec2 * _27;
  struct ImVec2 * _29;

  <bb 2>:
  if (cond_3(D) != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _6 = window_5(D)->SetWindowPosAllowFlags;
  _7 = _6 & cond_3(D);
  if (_7 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  old_pos ={v} {CLOBBER};
  goto <bb 9> (<L11>);

  <bb 5>:
  if (cond_3(D) == 0)
    goto <bb 8>;
  else
    goto <bb 6>;

  <bb 6>:
  _10 = ImIsPowerOfTwo (cond_3(D));
  if (_10 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("cond == 0 || ImIsPowerOfTwo(cond)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6880, &__PRETTY_FUNCTION__);

  <bb 8>:
  _12 = window_5(D)->SetWindowPosAllowFlags;
  _13 = _12 & -15;
  window_5(D)->SetWindowPosAllowFlags = _13;
  ImVec2::ImVec2 (&D.18287, 3.4028234663852885981170418348451692544e+38, 3.4028234663852885981170418348451692544e+38);
  window_5(D)->SetWindowPosVal = D.18287;
  D.18287 ={v} {CLOBBER};
  old_pos = window_5(D)->Pos;
  window_5(D)->PosFloat = *pos_19(D);
  window_5(D)->Pos = ImFloor (pos_19(D));
  _22 = &window_5(D)->Pos;
  D.18291 = operator- (_22, &old_pos);
  _24 = &window_5(D)->DC.CursorPos;
  operator+= (_24, &D.18291);
  D.18291 ={v} {CLOBBER};
  _27 = &window_5(D)->Pos;
  D.18292 = operator- (_27, &old_pos);
  _29 = &window_5(D)->DC.CursorMaxPos;
  operator+= (_29, &D.18292);
  D.18292 ={v} {CLOBBER};
  old_pos ={v} {CLOBBER};

<L11>:
  return;

}



;; Function void ImGui::SetWindowPos(const ImVec2&, ImGuiCond) (_ZN5ImGui12SetWindowPosERK6ImVec2i, funcdef_no=887, decl_uid=2536, cgraph_uid=786, symbol_order=794)

void ImGui::SetWindowPos(const ImVec2&, ImGuiCond) (const struct ImVec2 & pos, ImGuiCond cond)
{
  struct ImGuiWindow * window;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  SetWindowPos (window_3, pos_4(D), cond_5(D));
  return;

}



;; Function void ImGui::SetWindowPos(const char*, const ImVec2&, ImGuiCond) (_ZN5ImGui12SetWindowPosEPKcRK6ImVec2i, funcdef_no=888, decl_uid=2549, cgraph_uid=787, symbol_order=795)

void ImGui::SetWindowPos(const char*, const ImVec2&, ImGuiCond) (const char * name, const struct ImVec2 & pos, ImGuiCond cond)
{
  struct ImGuiWindow * D.34015;
  struct ImGuiWindow * window;
  struct ImGuiWindow * _5;

  <bb 2>:
  _5 = ImGui::FindWindowByName (name_3(D));
  window_6 = _5;
  if (window_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  SetWindowPos (window_6, pos_7(D), cond_8(D));

  <bb 4>:
  return;

}



;; Function ImVec2 ImGui::GetWindowSize() (_ZN5ImGui13GetWindowSizeEv, funcdef_no=889, decl_uid=2504, cgraph_uid=788, symbol_order=796)

ImVec2 ImGui::GetWindowSize() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.34016;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  D.34016 = window_3->Size;

<L0>:
  return D.34016;

}



;; Function void SetWindowSize(ImGuiWindow*, const ImVec2&, ImGuiCond) (_ZL13SetWindowSizeP11ImGuiWindowRK6ImVec2i, funcdef_no=890, decl_uid=15034, cgraph_uid=789, symbol_order=797)

void SetWindowSize(ImGuiWindow*, const ImVec2&, ImGuiCond) (struct ImGuiWindow * window, const struct ImVec2 & size, ImGuiCond cond)
{
  static const char __PRETTY_FUNCTION__[59] = "void SetWindowSize(ImGuiWindow*, const ImVec2&, ImGuiCond)";
  float D.34040;
  float D.34037;
  float D.34035;
  float D.34032;
  int D.34031;
  int D.34030;
  bool D.34026;
  int D.34021;
  int D.34020;
  int _7;
  int _8;
  bool _10;
  int _12;
  int _13;
  float _16;
  float _18;
  float _22;
  float _24;

  <bb 2>:
  if (cond_4(D) != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = window_6(D)->SetWindowSizeAllowFlags;
  _8 = _7 & cond_4(D);
  if (_8 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 14> (<L15>);

  <bb 5>:
  if (cond_4(D) == 0)
    goto <bb 8>;
  else
    goto <bb 6>;

  <bb 6>:
  _10 = ImIsPowerOfTwo (cond_4(D));
  if (_10 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("cond == 0 || ImIsPowerOfTwo(cond)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 6916, &__PRETTY_FUNCTION__);

  <bb 8>:
  _12 = window_6(D)->SetWindowSizeAllowFlags;
  _13 = _12 & -15;
  window_6(D)->SetWindowSizeAllowFlags = _13;
  _16 = size_15(D)->x;
  if (_16 > 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  window_6(D)->AutoFitFramesX = 0;
  _18 = size_15(D)->x;
  window_6(D)->SizeFull.x = _18;
  goto <bb 11>;

  <bb 10>:
  window_6(D)->AutoFitFramesX = 2;
  window_6(D)->AutoFitOnlyGrows = 0;

  <bb 11>:
  _22 = size_15(D)->y;
  if (_22 > 0.0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  window_6(D)->AutoFitFramesY = 0;
  _24 = size_15(D)->y;
  window_6(D)->SizeFull.y = _24;
  goto <bb 14> (<L15>);

  <bb 13>:
  window_6(D)->AutoFitFramesY = 2;
  window_6(D)->AutoFitOnlyGrows = 0;

<L15>:
  return;

}



;; Function void ImGui::SetWindowSize(const ImVec2&, ImGuiCond) (_ZN5ImGui13SetWindowSizeERK6ImVec2i, funcdef_no=891, decl_uid=2539, cgraph_uid=790, symbol_order=798)

void ImGui::SetWindowSize(const ImVec2&, ImGuiCond) (const struct ImVec2 & size, ImGuiCond cond)
{
  struct ImGuiWindow * D.34044;
  struct ImGuiContext * GImGui.1076;
  struct ImGuiContext * GImGui.1076_2;
  struct ImGuiWindow * _3;

  <bb 2>:
  GImGui.1076_2 = GImGui;
  _3 = GImGui.1076_2->CurrentWindow;
  SetWindowSize (_3, size_4(D), cond_5(D));
  return;

}



;; Function void ImGui::SetWindowSize(const char*, const ImVec2&, ImGuiCond) (_ZN5ImGui13SetWindowSizeEPKcRK6ImVec2i, funcdef_no=892, decl_uid=2553, cgraph_uid=791, symbol_order=799)

void ImGui::SetWindowSize(const char*, const ImVec2&, ImGuiCond) (const char * name, const struct ImVec2 & size, ImGuiCond cond)
{
  struct ImGuiWindow * D.34048;
  struct ImGuiWindow * window;
  struct ImGuiWindow * _5;

  <bb 2>:
  _5 = ImGui::FindWindowByName (name_3(D));
  window_6 = _5;
  if (window_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  SetWindowSize (window_6, size_7(D), cond_8(D));

  <bb 4>:
  return;

}



;; Function void SetWindowCollapsed(ImGuiWindow*, bool, ImGuiCond) (_ZL18SetWindowCollapsedP11ImGuiWindowbi, funcdef_no=893, decl_uid=15038, cgraph_uid=792, symbol_order=800)

void SetWindowCollapsed(ImGuiWindow*, bool, ImGuiCond) (struct ImGuiWindow * window, bool collapsed, ImGuiCond cond)
{
  int D.34056;
  int D.34055;
  int D.34052;
  int D.34051;
  int _5;
  int _6;
  int _7;
  int _8;

  <bb 2>:
  if (cond_2(D) != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _5 = window_4(D)->SetWindowCollapsedAllowFlags;
  _6 = _5 & cond_2(D);
  if (_6 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6> (<L4>);

  <bb 5>:
  _7 = window_4(D)->SetWindowCollapsedAllowFlags;
  _8 = _7 & -15;
  window_4(D)->SetWindowCollapsedAllowFlags = _8;
  window_4(D)->Collapsed = collapsed_10(D);

<L4>:
  return;

}



;; Function void ImGui::SetWindowCollapsed(bool, ImGuiCond) (_ZN5ImGui18SetWindowCollapsedEbi, funcdef_no=894, decl_uid=2542, cgraph_uid=793, symbol_order=801)

void ImGui::SetWindowCollapsed(bool, ImGuiCond) (bool collapsed, ImGuiCond cond)
{
  struct ImGuiWindow * D.34060;
  struct ImGuiContext * GImGui.1077;
  int D.34058;
  int _2;
  struct ImGuiContext * GImGui.1077_4;
  struct ImGuiWindow * _5;

  <bb 2>:
  _2 = (int) collapsed_1(D);
  GImGui.1077_4 = GImGui;
  _5 = GImGui.1077_4->CurrentWindow;
  SetWindowCollapsed (_5, _2, cond_6(D));
  return;

}



;; Function bool ImGui::IsWindowCollapsed() (_ZN5ImGui17IsWindowCollapsedEv, funcdef_no=895, decl_uid=2497, cgraph_uid=794, symbol_order=802)

bool ImGui::IsWindowCollapsed() ()
{
  struct ImGuiWindow * window;
  bool D.34061;
  bool _4;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = window_3->Collapsed;

<L0>:
  return _4;

}



;; Function bool ImGui::IsWindowAppearing() (_ZN5ImGui17IsWindowAppearingEv, funcdef_no=896, decl_uid=2496, cgraph_uid=795, symbol_order=803)

bool ImGui::IsWindowAppearing() ()
{
  struct ImGuiWindow * window;
  bool D.34063;
  bool _4;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = window_3->Appearing;

<L0>:
  return _4;

}



;; Function void ImGui::SetWindowCollapsed(const char*, bool, ImGuiCond) (_ZN5ImGui18SetWindowCollapsedEPKcbi, funcdef_no=897, decl_uid=2557, cgraph_uid=796, symbol_order=804)

void ImGui::SetWindowCollapsed(const char*, bool, ImGuiCond) (const char * name, bool collapsed, ImGuiCond cond)
{
  struct ImGuiWindow * D.34069;
  struct ImGuiWindow * window;
  int D.34067;
  struct ImGuiWindow * _5;
  int _8;

  <bb 2>:
  _5 = ImGui::FindWindowByName (name_3(D));
  window_6 = _5;
  if (window_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = (int) collapsed_7(D);
  SetWindowCollapsed (window_6, _8, cond_9(D));

  <bb 4>:
  return;

}



;; Function void ImGui::SetWindowFocus() (_ZN5ImGui14SetWindowFocusEv, funcdef_no=898, decl_uid=2543, cgraph_uid=797, symbol_order=805)

void ImGui::SetWindowFocus() ()
{
  struct ImGuiWindow * D.34071;
  struct ImGuiContext * GImGui.1078;
  struct ImGuiContext * GImGui.1078_2;
  struct ImGuiWindow * _3;

  <bb 2>:
  GImGui.1078_2 = GImGui;
  _3 = GImGui.1078_2->CurrentWindow;
  ImGui::FocusWindow (_3);
  return;

}



;; Function void ImGui::SetWindowFocus(const char*) (_ZN5ImGui14SetWindowFocusEPKc, funcdef_no=899, decl_uid=2559, cgraph_uid=798, symbol_order=806)

void ImGui::SetWindowFocus(const char*) (const char * name)
{
  struct ImGuiWindow * D.34078;
  struct ImGuiWindow * window;
  struct ImGuiWindow * _6;

  <bb 2>:
  if (name_3(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _6 = ImGui::FindWindowByName (name_3(D));
  window_7 = _6;
  if (window_7 != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  ImGui::FocusWindow (window_7);

  <bb 5>:
  goto <bb 7>;

  <bb 6>:
  ImGui::FocusWindow (0B);

  <bb 7>:
  return;

}



;; Function void ImGui::SetNextWindowPos(const ImVec2&, ImGuiCond, const ImVec2&) (_ZN5ImGui16SetNextWindowPosERK6ImVec2iS2_, funcdef_no=900, decl_uid=2517, cgraph_uid=799, symbol_order=807)

void ImGui::SetNextWindowPos(const ImVec2&, ImGuiCond, const ImVec2&) (const struct ImVec2 & pos, ImGuiCond cond, const struct ImVec2 & pivot)
{
  static const char __PRETTY_FUNCTION__[70] = "void ImGui::SetNextWindowPos(const ImVec2&, ImGuiCond, const ImVec2&)";
  struct ImGuiContext & g;
  int iftmp.1079;
  bool D.34081;
  int iftmp.1079_1;
  bool _7;
  int iftmp.1079_13;
  int iftmp.1079_14;

  <bb 2>:
  g_4 = GImGui;
  if (cond_5(D) == 0)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _7 = ImIsPowerOfTwo (cond_5(D));
  if (_7 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __assert_fail ("cond == 0 || ImIsPowerOfTwo(cond)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7008, &__PRETTY_FUNCTION__);

  <bb 5>:
  g_4->NextWindowData.PosVal = *pos_9(D);
  g_4->NextWindowData.PosPivotVal = *pivot_11(D);
  if (cond_5(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1079_13 = cond_5(D);
  goto <bb 8>;

  <bb 7>:
  iftmp.1079_14 = 1;

  <bb 8>:
  # iftmp.1079_1 = PHI <iftmp.1079_13(6), iftmp.1079_14(7)>
  g_4->NextWindowData.PosCond = iftmp.1079_1;
  return;

}



;; Function void ImGui::SetNextWindowSize(const ImVec2&, ImGuiCond) (_ZN5ImGui17SetNextWindowSizeERK6ImVec2i, funcdef_no=901, decl_uid=2520, cgraph_uid=800, symbol_order=808)

void ImGui::SetNextWindowSize(const ImVec2&, ImGuiCond) (const struct ImVec2 & size, ImGuiCond cond)
{
  static const char __PRETTY_FUNCTION__[56] = "void ImGui::SetNextWindowSize(const ImVec2&, ImGuiCond)";
  struct ImGuiContext & g;
  int iftmp.1080;
  bool D.34091;
  int iftmp.1080_1;
  bool _7;
  int iftmp.1080_11;
  int iftmp.1080_12;

  <bb 2>:
  g_4 = GImGui;
  if (cond_5(D) == 0)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _7 = ImIsPowerOfTwo (cond_5(D));
  if (_7 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __assert_fail ("cond == 0 || ImIsPowerOfTwo(cond)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7017, &__PRETTY_FUNCTION__);

  <bb 5>:
  g_4->NextWindowData.SizeVal = *size_9(D);
  if (cond_5(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1080_11 = cond_5(D);
  goto <bb 8>;

  <bb 7>:
  iftmp.1080_12 = 1;

  <bb 8>:
  # iftmp.1080_1 = PHI <iftmp.1080_11(6), iftmp.1080_12(7)>
  g_4->NextWindowData.SizeCond = iftmp.1080_1;
  return;

}



;; Function void ImGui::SetNextWindowSizeConstraints(const ImVec2&, const ImVec2&, ImGuiSizeCallback, void*) (_ZN5ImGui28SetNextWindowSizeConstraintsERK6ImVec2S2_PFvP21ImGuiSizeCallbackDataEPv, funcdef_no=902, decl_uid=2525, cgraph_uid=801, symbol_order=809)

void ImGui::SetNextWindowSizeConstraints(const ImVec2&, const ImVec2&, ImGuiSizeCallback, void*) (const struct ImVec2 & size_min, const struct ImVec2 & size_max, void (*ImGuiSizeCallback) (struct ImGuiSizeCallbackData *) custom_callback, void * custom_callback_user_data)
{
  struct ImGuiContext & g;
  struct ImRect D.18371;

  <bb 2>:
  g_2 = GImGui;
  g_2->NextWindowData.SizeConstraintCond = 1;
  ImRect::ImRect (&D.18371, size_min_4(D), size_max_5(D));
  g_2->NextWindowData.SizeConstraintRect = D.18371;
  D.18371 ={v} {CLOBBER};
  g_2->NextWindowData.SizeCallback = custom_callback_9(D);
  g_2->NextWindowData.SizeCallbackUserData = custom_callback_user_data_11(D);
  return;

}



;; Function void ImGui::SetNextWindowContentSize(const ImVec2&) (_ZN5ImGui24SetNextWindowContentSizeERK6ImVec2, funcdef_no=903, decl_uid=2527, cgraph_uid=802, symbol_order=810)

void ImGui::SetNextWindowContentSize(const ImVec2&) (const struct ImVec2 & size)
{
  struct ImGuiContext & g;

  <bb 2>:
  g_2 = GImGui;
  g_2->NextWindowData.ContentSizeVal = *size_3(D);
  g_2->NextWindowData.ContentSizeCond = 1;
  return;

}



;; Function void ImGui::SetNextWindowCollapsed(bool, ImGuiCond) (_ZN5ImGui22SetNextWindowCollapsedEbi, funcdef_no=904, decl_uid=2530, cgraph_uid=803, symbol_order=811)

void ImGui::SetNextWindowCollapsed(bool, ImGuiCond) (bool collapsed, ImGuiCond cond)
{
  static const char __PRETTY_FUNCTION__[52] = "void ImGui::SetNextWindowCollapsed(bool, ImGuiCond)";
  struct ImGuiContext & g;
  int iftmp.1081;
  bool D.34101;
  int iftmp.1081_1;
  bool _7;
  int iftmp.1081_11;
  int iftmp.1081_12;

  <bb 2>:
  g_4 = GImGui;
  if (cond_5(D) == 0)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  _7 = ImIsPowerOfTwo (cond_5(D));
  if (_7 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __assert_fail ("cond == 0 || ImIsPowerOfTwo(cond)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7041, &__PRETTY_FUNCTION__);

  <bb 5>:
  g_4->NextWindowData.CollapsedVal = collapsed_9(D);
  if (cond_5(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1081_11 = cond_5(D);
  goto <bb 8>;

  <bb 7>:
  iftmp.1081_12 = 1;

  <bb 8>:
  # iftmp.1081_1 = PHI <iftmp.1081_11(6), iftmp.1081_12(7)>
  g_4->NextWindowData.CollapsedCond = iftmp.1081_1;
  return;

}



;; Function void ImGui::SetNextWindowFocus() (_ZN5ImGui18SetNextWindowFocusEv, funcdef_no=905, decl_uid=2531, cgraph_uid=804, symbol_order=812)

void ImGui::SetNextWindowFocus() ()
{
  struct ImGuiContext & g;

  <bb 2>:
  g_2 = GImGui;
  g_2->NextWindowData.FocusCond = 1;
  return;

}



;; Function void ImGui::SetNextWindowBgAlpha(float) (_ZN5ImGui20SetNextWindowBgAlphaEf, funcdef_no=906, decl_uid=2533, cgraph_uid=805, symbol_order=813)

void ImGui::SetNextWindowBgAlpha(float) (float alpha)
{
  struct ImGuiContext & g;

  <bb 2>:
  g_2 = GImGui;
  g_2->NextWindowData.BgAlphaVal = alpha_3(D);
  g_2->NextWindowData.BgAlphaCond = 1;
  return;

}



;; Function ImVec2 ImGui::GetContentRegionMax() (_ZN5ImGui19GetContentRegionMaxEv, funcdef_no=907, decl_uid=2507, cgraph_uid=806, symbol_order=814)

ImVec2 ImGui::GetContentRegionMax() ()
{
  float D.34121;
  struct ImVec2 mx;
  struct ImGuiWindow * window;
  struct ImVec2 D.34119;
  float D.34117;
  float D.34116;
  float D.34115;
  int D.34114;
  int D.34113;
  struct ImGuiColumnsSet * D.34112;
  struct ImGuiColumnsSet * D.34109;
  struct ImGuiColumnsSet * _6;
  struct ImGuiColumnsSet * _7;
  int _8;
  int _9;
  float _11;
  float _12;
  float _13;
  float _14;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  mx = window_4->ContentsRegionRect.Max;
  _6 = window_4->DC.ColumnsSet;
  if (_6 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = window_4->DC.ColumnsSet;
  _8 = _7->Current;
  _9 = _8 + 1;
  _11 = ImGui::GetColumnOffset (_9);
  _12 = _11;
  _13 = window_4->WindowPadding.x;
  _14 = _12 - _13;
  mx.x = _14;

  <bb 4>:
  D.34119 = mx;
  mx ={v} {CLOBBER};

<L4>:
  return D.34119;

}



;; Function ImVec2 ImGui::GetContentRegionAvail() (_ZN5ImGui21GetContentRegionAvailEv, funcdef_no=908, decl_uid=2508, cgraph_uid=807, symbol_order=815)

ImVec2 ImGui::GetContentRegionAvail() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.18398;
  struct ImVec2 * D.34126;
  struct ImVec2 * D.34125;
  struct ImVec2 D.18399;
  struct ImVec2 D.34124;
  struct ImVec2 * _4;
  struct ImVec2 * _5;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->Pos;
  _5 = &window_3->DC.CursorPos;
  D.18399 = operator- (_5, _4);
  D.18398 = ImGui::GetContentRegionMax ();
  D.34124 = operator- (&D.18398, &D.18399);
  D.18398 ={v} {CLOBBER};
  D.18399 ={v} {CLOBBER};

<L2>:
  return D.34124;

}



;; Function float ImGui::GetContentRegionAvailWidth() (_ZN5ImGui26GetContentRegionAvailWidthEv, funcdef_no=909, decl_uid=2509, cgraph_uid=808, symbol_order=816)

float ImGui::GetContentRegionAvailWidth() ()
{
  struct ImVec2 D.18403;
  float D.34131;
  float _3;

  <bb 2>:
  D.18403 = ImGui::GetContentRegionAvail ();
  _3 = D.18403.x;

<L0>:
  return _3;

}



;; Function ImVec2 ImGui::GetWindowContentRegionMin() (_ZN5ImGui25GetWindowContentRegionMinEv, funcdef_no=910, decl_uid=2510, cgraph_uid=809, symbol_order=817)

ImVec2 ImGui::GetWindowContentRegionMin() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.34133;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  D.34133 = window_3->ContentsRegionRect.Min;

<L0>:
  return D.34133;

}



;; Function ImVec2 ImGui::GetWindowContentRegionMax() (_ZN5ImGui25GetWindowContentRegionMaxEv, funcdef_no=911, decl_uid=2511, cgraph_uid=810, symbol_order=818)

ImVec2 ImGui::GetWindowContentRegionMax() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.34135;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  D.34135 = window_3->ContentsRegionRect.Max;

<L0>:
  return D.34135;

}



;; Function float ImGui::GetWindowContentRegionWidth() (_ZN5ImGui27GetWindowContentRegionWidthEv, funcdef_no=912, decl_uid=2512, cgraph_uid=811, symbol_order=819)

float ImGui::GetWindowContentRegionWidth() ()
{
  struct ImGuiWindow * window;
  float D.34139;
  float D.34138;
  float D.34137;
  float _4;
  float _5;
  float _6;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = window_3->ContentsRegionRect.Max.x;
  _5 = window_3->ContentsRegionRect.Min.x;
  _6 = _4 - _5;

<L0>:
  return _6;

}



;; Function float ImGui::GetTextLineHeight() (_ZN5ImGui17GetTextLineHeightEv, funcdef_no=913, decl_uid=2645, cgraph_uid=812, symbol_order=820)

float ImGui::GetTextLineHeight() ()
{
  struct ImGuiContext & g;
  float D.34141;
  float _3;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->FontSize;

<L0>:
  return _3;

}



;; Function float ImGui::GetTextLineHeightWithSpacing() (_ZN5ImGui28GetTextLineHeightWithSpacingEv, funcdef_no=914, decl_uid=2646, cgraph_uid=813, symbol_order=821)

float ImGui::GetTextLineHeightWithSpacing() ()
{
  struct ImGuiContext & g;
  float D.34145;
  float D.34144;
  float D.34143;
  float _3;
  float _4;
  float _5;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->FontSize;
  _4 = g_2->Style.ItemSpacing.y;
  _5 = _3 + _4;

<L0>:
  return _5;

}



;; Function float ImGui::GetFrameHeight() (_ZN5ImGui14GetFrameHeightEv, funcdef_no=915, decl_uid=2647, cgraph_uid=814, symbol_order=822)

float ImGui::GetFrameHeight() ()
{
  struct ImGuiContext & g;
  float D.34150;
  float D.34149;
  float D.34148;
  float D.34147;
  float _3;
  float _4;
  float _5;
  float _6;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->FontSize;
  _4 = g_2->Style.FramePadding.y;
  _5 = _4 * 2.0e+0;
  _6 = _3 + _5;

<L0>:
  return _6;

}



;; Function float ImGui::GetFrameHeightWithSpacing() (_ZN5ImGui25GetFrameHeightWithSpacingEv, funcdef_no=916, decl_uid=2648, cgraph_uid=815, symbol_order=823)

float ImGui::GetFrameHeightWithSpacing() ()
{
  struct ImGuiContext & g;
  float D.34157;
  float D.34156;
  float D.34155;
  float D.34154;
  float D.34153;
  float D.34152;
  float _3;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->FontSize;
  _4 = g_2->Style.FramePadding.y;
  _5 = _4 * 2.0e+0;
  _6 = _3 + _5;
  _7 = g_2->Style.ItemSpacing.y;
  _8 = _6 + _7;

<L0>:
  return _8;

}



;; Function ImDrawList* ImGui::GetWindowDrawList() (_ZN5ImGui17GetWindowDrawListEv, funcdef_no=917, decl_uid=2502, cgraph_uid=816, symbol_order=824)

ImDrawList* ImGui::GetWindowDrawList() ()
{
  struct ImGuiWindow * window;
  struct ImDrawList * D.34159;
  struct ImDrawList * _4;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = window_3->DrawList;

<L0>:
  return _4;

}



;; Function ImFont* ImGui::GetFont() (_ZN5ImGui7GetFontEv, funcdef_no=918, decl_uid=2594, cgraph_uid=817, symbol_order=825)

ImFont* ImGui::GetFont() ()
{
  struct ImGuiContext * GImGui.1082;
  struct ImFont * D.34161;
  struct ImGuiContext * GImGui.1082_2;
  struct ImFont * _3;

  <bb 2>:
  GImGui.1082_2 = GImGui;
  _3 = GImGui.1082_2->Font;

<L0>:
  return _3;

}



;; Function float ImGui::GetFontSize() (_ZN5ImGui11GetFontSizeEv, funcdef_no=919, decl_uid=2595, cgraph_uid=818, symbol_order=826)

float ImGui::GetFontSize() ()
{
  struct ImGuiContext * GImGui.1083;
  float D.34164;
  struct ImGuiContext * GImGui.1083_2;
  float _3;

  <bb 2>:
  GImGui.1083_2 = GImGui;
  _3 = GImGui.1083_2->FontSize;

<L0>:
  return _3;

}



;; Function ImVec2 ImGui::GetFontTexUvWhitePixel() (_ZN5ImGui22GetFontTexUvWhitePixelEv, funcdef_no=920, decl_uid=2596, cgraph_uid=819, symbol_order=827)

ImVec2 ImGui::GetFontTexUvWhitePixel() ()
{
  struct ImGuiContext * GImGui.1084;
  struct ImVec2 D.34167;
  struct ImGuiContext * GImGui.1084_2;

  <bb 2>:
  GImGui.1084_2 = GImGui;
  D.34167 = GImGui.1084_2->DrawListSharedData.TexUvWhitePixel;

<L0>:
  return D.34167;

}



;; Function void ImGui::SetWindowFontScale(float) (_ZN5ImGui18SetWindowFontScaleEf, funcdef_no=921, decl_uid=2545, cgraph_uid=820, symbol_order=828)

void ImGui::SetWindowFontScale(float) (float scale)
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  float D.34171;
  float D.34170;
  float _8;
  float _10;

  <bb 2>:
  g_2 = GImGui;
  window_4 = ImGui::GetCurrentWindow ();
  window_4->FontWindowScale = scale_5(D);
  _8 = ImGuiWindow::CalcFontSize (window_4);
  g_2->DrawListSharedData.FontSize = _8;
  _10 = g_2->DrawListSharedData.FontSize;
  g_2->FontSize = _10;
  return;

}



;; Function ImVec2 ImGui::GetCursorPos() (_ZN5ImGui12GetCursorPosEv, funcdef_no=922, decl_uid=2631, cgraph_uid=821, symbol_order=829)

ImVec2 ImGui::GetCursorPos() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 * D.34175;
  struct ImVec2 * D.34174;
  struct ImVec2 D.18445;
  struct ImVec2 * D.34173;
  struct ImVec2 D.34172;
  struct ImVec2 * _4;
  struct ImVec2 * _5;
  struct ImVec2 * _6;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->Scroll;
  _5 = &window_3->Pos;
  _6 = &window_3->DC.CursorPos;
  D.18445 = operator- (_6, _5);
  D.34172 = operator+ (&D.18445, _4);
  D.18445 ={v} {CLOBBER};

<L1>:
  return D.34172;

}



;; Function float ImGui::GetCursorPosX() (_ZN5ImGui13GetCursorPosXEv, funcdef_no=923, decl_uid=2632, cgraph_uid=822, symbol_order=830)

float ImGui::GetCursorPosX() ()
{
  struct ImGuiWindow * window;
  float D.34182;
  float D.34181;
  float D.34180;
  float D.34179;
  float D.34178;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = window_3->DC.CursorPos.x;
  _5 = window_3->Pos.x;
  _6 = _4 - _5;
  _7 = window_3->Scroll.x;
  _8 = _6 + _7;

<L0>:
  return _8;

}



;; Function float ImGui::GetCursorPosY() (_ZN5ImGui13GetCursorPosYEv, funcdef_no=924, decl_uid=2633, cgraph_uid=823, symbol_order=831)

float ImGui::GetCursorPosY() ()
{
  struct ImGuiWindow * window;
  float D.34188;
  float D.34187;
  float D.34186;
  float D.34185;
  float D.34184;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = window_3->DC.CursorPos.y;
  _5 = window_3->Pos.y;
  _6 = _4 - _5;
  _7 = window_3->Scroll.y;
  _8 = _6 + _7;

<L0>:
  return _8;

}



;; Function void ImGui::SetCursorPos(const ImVec2&) (_ZN5ImGui12SetCursorPosERK6ImVec2, funcdef_no=925, decl_uid=2635, cgraph_uid=824, symbol_order=832)

void ImGui::SetCursorPos(const ImVec2&) (const struct ImVec2 & local_pos)
{
  struct ImGuiWindow * window;
  struct ImVec2 * D.34193;
  struct ImVec2 * D.34192;
  struct ImVec2 * D.34191;
  struct ImVec2 * D.34190;
  struct ImVec2 D.18457;
  struct ImVec2 * _4;
  struct ImVec2 * _5;
  struct ImVec2 * _10;
  struct ImVec2 * _11;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = &window_3->Scroll;
  _5 = &window_3->Pos;
  D.18457 = operator- (_5, _4);
  window_3->DC.CursorPos = operator+ (&D.18457, local_pos_7(D));
  D.18457 ={v} {CLOBBER};
  _10 = &window_3->DC.CursorPos;
  _11 = &window_3->DC.CursorMaxPos;
  window_3->DC.CursorMaxPos = ImMax (_11, _10);
  return;

}



;; Function void ImGui::SetCursorPosX(float) (_ZN5ImGui13SetCursorPosXEf, funcdef_no=926, decl_uid=2637, cgraph_uid=825, symbol_order=833)

void ImGui::SetCursorPosX(float) (float x)
{
  struct ImGuiWindow * window;
  float D.34200;
  float D.34199;
  float D.34198;
  float D.34197;
  float D.34196;
  float D.34195;
  float D.34194;
  float _4;
  float _5;
  float _6;
  float _8;
  float _10;
  float _11;
  float _13;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = window_3->Pos.x;
  _5 = window_3->Scroll.x;
  _6 = _4 - _5;
  _8 = _6 + x_7(D);
  window_3->DC.CursorPos.x = _8;
  _10 = window_3->DC.CursorPos.x;
  _11 = window_3->DC.CursorMaxPos.x;
  _13 = ImMax (_11, _10);
  window_3->DC.CursorMaxPos.x = _13;
  return;

}



;; Function void ImGui::SetCursorPosY(float) (_ZN5ImGui13SetCursorPosYEf, funcdef_no=927, decl_uid=2639, cgraph_uid=826, symbol_order=834)

void ImGui::SetCursorPosY(float) (float y)
{
  struct ImGuiWindow * window;
  float D.34207;
  float D.34206;
  float D.34205;
  float D.34204;
  float D.34203;
  float D.34202;
  float D.34201;
  float _4;
  float _5;
  float _6;
  float _8;
  float _10;
  float _11;
  float _13;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = window_3->Pos.y;
  _5 = window_3->Scroll.y;
  _6 = _4 - _5;
  _8 = _6 + y_7(D);
  window_3->DC.CursorPos.y = _8;
  _10 = window_3->DC.CursorPos.y;
  _11 = window_3->DC.CursorMaxPos.y;
  _13 = ImMax (_11, _10);
  window_3->DC.CursorMaxPos.y = _13;
  return;

}



;; Function ImVec2 ImGui::GetCursorStartPos() (_ZN5ImGui17GetCursorStartPosEv, funcdef_no=928, decl_uid=2640, cgraph_uid=827, symbol_order=835)

ImVec2 ImGui::GetCursorStartPos() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 * D.34210;
  struct ImVec2 * D.34209;
  struct ImVec2 D.34208;
  struct ImVec2 * _4;
  struct ImVec2 * _5;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->Pos;
  _5 = &window_3->DC.CursorStartPos;
  D.34208 = operator- (_5, _4);

<L0>:
  return D.34208;

}



;; Function ImVec2 ImGui::GetCursorScreenPos() (_ZN5ImGui18GetCursorScreenPosEv, funcdef_no=929, decl_uid=2641, cgraph_uid=828, symbol_order=836)

ImVec2 ImGui::GetCursorScreenPos() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.34212;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  D.34212 = window_3->DC.CursorPos;

<L0>:
  return D.34212;

}



;; Function void ImGui::SetCursorScreenPos(const ImVec2&) (_ZN5ImGui18SetCursorScreenPosERK6ImVec2, funcdef_no=930, decl_uid=2643, cgraph_uid=829, symbol_order=837)

void ImGui::SetCursorScreenPos(const ImVec2&) (const struct ImVec2 & screen_pos)
{
  struct ImGuiWindow * window;
  struct ImVec2 * D.34215;
  struct ImVec2 * D.34214;
  struct ImVec2 * _6;
  struct ImVec2 * _7;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  window_3->DC.CursorPos = *screen_pos_4(D);
  _6 = &window_3->DC.CursorPos;
  _7 = &window_3->DC.CursorMaxPos;
  window_3->DC.CursorMaxPos = ImMax (_7, _6);
  return;

}



;; Function float ImGui::GetScrollX() (_ZN5ImGui10GetScrollXEv, funcdef_no=931, decl_uid=2560, cgraph_uid=830, symbol_order=838)

float ImGui::GetScrollX() ()
{
  struct ImGuiWindow * D.34218;
  struct ImGuiContext * GImGui.1085;
  float D.34216;
  struct ImGuiContext * GImGui.1085_2;
  struct ImGuiWindow * _3;
  float _4;

  <bb 2>:
  GImGui.1085_2 = GImGui;
  _3 = GImGui.1085_2->CurrentWindow;
  _4 = _3->Scroll.x;

<L0>:
  return _4;

}



;; Function float ImGui::GetScrollY() (_ZN5ImGui10GetScrollYEv, funcdef_no=932, decl_uid=2561, cgraph_uid=831, symbol_order=839)

float ImGui::GetScrollY() ()
{
  struct ImGuiWindow * D.34222;
  struct ImGuiContext * GImGui.1086;
  float D.34220;
  struct ImGuiContext * GImGui.1086_2;
  struct ImGuiWindow * _3;
  float _4;

  <bb 2>:
  GImGui.1086_2 = GImGui;
  _3 = GImGui.1086_2->CurrentWindow;
  _4 = _3->Scroll.y;

<L0>:
  return _4;

}



;; Function float ImGui::GetScrollMaxX() (_ZN5ImGui13GetScrollMaxXEv, funcdef_no=933, decl_uid=2562, cgraph_uid=832, symbol_order=840)

float ImGui::GetScrollMaxX() ()
{
  struct ImGuiWindow * D.34226;
  struct ImGuiContext * GImGui.1087;
  float D.34224;
  struct ImGuiContext * GImGui.1087_2;
  struct ImGuiWindow * _3;
  float _5;

  <bb 2>:
  GImGui.1087_2 = GImGui;
  _3 = GImGui.1087_2->CurrentWindow;
  _5 = GetScrollMaxX (_3);

<L0>:
  return _5;

}



;; Function float ImGui::GetScrollMaxY() (_ZN5ImGui13GetScrollMaxYEv, funcdef_no=934, decl_uid=2563, cgraph_uid=833, symbol_order=841)

float ImGui::GetScrollMaxY() ()
{
  struct ImGuiWindow * D.34230;
  struct ImGuiContext * GImGui.1088;
  float D.34228;
  struct ImGuiContext * GImGui.1088_2;
  struct ImGuiWindow * _3;
  float _5;

  <bb 2>:
  GImGui.1088_2 = GImGui;
  _3 = GImGui.1088_2->CurrentWindow;
  _5 = GetScrollMaxY (_3);

<L0>:
  return _5;

}



;; Function void ImGui::SetScrollX(float) (_ZN5ImGui10SetScrollXEf, funcdef_no=935, decl_uid=2565, cgraph_uid=834, symbol_order=842)

void ImGui::SetScrollX(float) (float scroll_x)
{
  struct ImGuiWindow * window;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  window_3->ScrollTarget.x = scroll_x_4(D);
  window_3->ScrollTargetCenterRatio.x = 0.0;
  return;

}



;; Function void ImGui::SetScrollY(float) (_ZN5ImGui10SetScrollYEf, funcdef_no=936, decl_uid=2567, cgraph_uid=835, symbol_order=843)

void ImGui::SetScrollY(float) (float scroll_y)
{
  struct ImGuiWindow * window;
  float D.34235;
  float D.34234;
  float D.34233;
  float D.34232;
  float _5;
  float _7;
  float _9;
  float _10;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _5 = ImGuiWindow::TitleBarHeight (window_3);
  _7 = _5 + scroll_y_6(D);
  _9 = ImGuiWindow::MenuBarHeight (window_3);
  _10 = _7 + _9;
  window_3->ScrollTarget.y = _10;
  window_3->ScrollTargetCenterRatio.y = 0.0;
  return;

}



;; Function void ImGui::SetScrollFromPosY(float, float) (_ZN5ImGui17SetScrollFromPosYEff, funcdef_no=937, decl_uid=2572, cgraph_uid=836, symbol_order=844)

void ImGui::SetScrollFromPosY(float, float) (float pos_y, float center_y_ratio)
{
  static const char __PRETTY_FUNCTION__[44] = "void ImGui::SetScrollFromPosY(float, float)";
  struct ImGuiWindow * window;
  float D.34261;
  float D.34258;
  float D.34257;
  struct ImGuiContext * GImGui.1089;
  float D.34255;
  float D.34254;
  float D.34253;
  float D.34252;
  float D.34248;
  float D.34247;
  float D.34243;
  int D.34242;
  float D.34241;
  float D.34240;
  float _6;
  float _8;
  int _9;
  float _10;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;
  float _19;
  struct ImGuiContext * GImGui.1089_20;
  float _21;
  float _22;
  float _23;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  if (center_y_ratio_5(D) >= 0.0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (center_y_ratio_5(D) <= 1.0e+0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("center_y_ratio >= 0.0f && center_y_ratio <= 1.0f", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7250, &__PRETTY_FUNCTION__);

  <bb 6>:
  _6 = window_4->Scroll.y;
  _8 = _6 + pos_y_7(D);
  _9 = (int) _8;
  _10 = (float) _9;
  window_4->ScrollTarget.y = _10;
  window_4->ScrollTargetCenterRatio.y = center_y_ratio_5(D);
  if (center_y_ratio_5(D) <= 0.0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _13 = window_4->ScrollTarget.y;
  _14 = window_4->WindowPadding.y;
  if (_13 <= _14)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  window_4->ScrollTarget.y = 0.0;
  goto <bb 12>;

  <bb 9>:
  if (center_y_ratio_5(D) >= 1.0e+0)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _16 = window_4->ScrollTarget.y;
  _17 = window_4->SizeContents.y;
  _18 = window_4->WindowPadding.y;
  _19 = _17 - _18;
  GImGui.1089_20 = GImGui;
  _21 = GImGui.1089_20->Style.ItemSpacing.y;
  _22 = _19 + _21;
  if (_16 >= _22)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _23 = window_4->SizeContents.y;
  window_4->ScrollTarget.y = _23;

  <bb 12>:
  return;

}



;; Function void ImGui::SetScrollHere(float) (_ZN5ImGui13SetScrollHereEf, funcdef_no=938, decl_uid=2569, cgraph_uid=837, symbol_order=845)

void ImGui::SetScrollHere(float) (float center_y_ratio)
{
  float target_y;
  struct ImGuiWindow * window;
  float D.34272;
  float D.34271;
  float D.34270;
  float D.34269;
  float D.34268;
  struct ImGuiContext * GImGui.1090;
  float D.34266;
  float D.34265;
  float D.34264;
  float D.34263;
  float _4;
  float _5;
  float _7;
  float _9;
  struct ImGuiContext * GImGui.1090_10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = window_3->DC.CursorPosPrevLine.y;
  _5 = window_3->Pos.y;
  target_y_6 = _4 - _5;
  _7 = window_3->DC.PrevLineHeight;
  _9 = _7 * center_y_ratio_8(D);
  GImGui.1090_10 = GImGui;
  _11 = GImGui.1090_10->Style.ItemSpacing.y;
  _12 = center_y_ratio_8(D) - 5.0e-1;
  _13 = _11 * _12;
  _14 = _13 * 2.0e+0;
  _15 = _9 + _14;
  target_y_16 = _15 + target_y_6;
  ImGui::SetScrollFromPosY (target_y_16, center_y_ratio_8(D));
  return;

}



;; Function void ImGui::ActivateItem(ImGuiID) (_ZN5ImGui12ActivateItemEj, funcdef_no=939, decl_uid=13831, cgraph_uid=838, symbol_order=846)

void ImGui::ActivateItem(ImGuiID) (ImGuiID id)
{
  struct ImGuiContext & g;

  <bb 2>:
  g_2 = GImGui;
  g_2->NavNextActivateId = id_3(D);
  return;

}



;; Function void ImGui::SetKeyboardFocusHere(int) (_ZN5ImGui20SetKeyboardFocusHereEi, funcdef_no=940, decl_uid=3301, cgraph_uid=839, symbol_order=847)

void ImGui::SetKeyboardFocusHere(int) (int offset)
{
  struct ImGuiWindow * window;
  static const char __PRETTY_FUNCTION__[38] = "void ImGui::SetKeyboardFocusHere(int)";
  int D.34278;
  int D.34277;
  int D.34276;
  int _5;
  int _6;
  int _7;

  <bb 2>:
  if (offset_1(D) >= -1)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("offset >= -1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7278, &__PRETTY_FUNCTION__);

  <bb 4>:
  window_4 = ImGui::GetCurrentWindow ();
  _5 = window_4->FocusIdxAllCounter;
  _6 = _5 + 1;
  _7 = _6 + offset_1(D);
  window_4->FocusIdxAllRequestNext = _7;
  window_4->FocusIdxTabRequestNext = 2147483647;
  return;

}



;; Function void ImGui::SetItemDefaultFocus() (_ZN5ImGui19SetItemDefaultFocusEv, funcdef_no=941, decl_uid=3299, cgraph_uid=840, symbol_order=848)

void ImGui::SetItemDefaultFocus() ()
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.34308;
  bool retval.1091;
  struct ImVec2 * D.34306;
  struct ImGuiWindow * D.34305;
  struct ImVec2 * D.34304;
  struct ImGuiWindow * D.34303;
  struct ImVec2 D.18521;
  struct ImVec2 * D.34302;
  struct ImGuiWindow * D.34301;
  struct ImVec2 * D.34300;
  struct ImGuiWindow * D.34299;
  struct ImVec2 D.18522;
  struct ImRect D.18523;
  unsigned int D.34298;
  struct ImGuiWindow * D.34297;
  int D.34294;
  struct ImGuiWindow * D.34293;
  int D.34292;
  unsigned int D.34291;
  bool D.34289;
  struct ImGuiWindow * D.34286;
  struct ImGuiWindow * D.34285;
  bool D.34280;
  bool D.34279;
  bool _5;
  bool _6;
  struct ImGuiWindow * _7;
  struct ImGuiWindow * _8;
  bool _9;
  unsigned int _10;
  int _11;
  struct ImGuiWindow * _12;
  int _13;
  struct ImGuiWindow * _15;
  unsigned int _16;
  struct ImGuiWindow * _18;
  struct ImVec2 * _19;
  struct ImGuiWindow * _20;
  struct ImVec2 * _21;
  struct ImGuiWindow * _23;
  struct ImVec2 * _24;
  struct ImGuiWindow * _25;
  struct ImVec2 * _26;
  bool _35;
  bool retval.1091_36;

  <bb 2>:
  g_3 = GImGui;
  window_4 = g_3->CurrentWindow;
  _5 = window_4->Appearing;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 10> (<L13>);

  <bb 4>:
  _7 = g_3->NavWindow;
  _8 = window_4->RootWindowForNav;
  if (_7 == _8)
    goto <bb 5>;
  else
    goto <bb 10> (<L13>);

  <bb 5>:
  _9 = g_3->NavInitRequest;
  if (_9 != 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _10 = g_3->NavInitResultId;
  if (_10 != 0)
    goto <bb 7>;
  else
    goto <bb 10> (<L13>);

  <bb 7>:
  _11 = g_3->NavLayer;
  _12 = g_3->NavWindow;
  _13 = _12->DC.NavLayerCurrent;
  if (_11 == _13)
    goto <bb 8>;
  else
    goto <bb 10> (<L13>);

  <bb 8>:
  g_3->NavInitRequest = 0;
  _15 = g_3->NavWindow;
  _16 = _15->DC.LastItemId;
  g_3->NavInitResultId = _16;
  _18 = g_3->NavWindow;
  _19 = &_18->Pos;
  _20 = g_3->NavWindow;
  _21 = &_20->DC.LastItemRect.Max;
  D.18522 = operator- (_21, _19);
  _23 = g_3->NavWindow;
  _24 = &_23->Pos;
  _25 = g_3->NavWindow;
  _26 = &_25->DC.LastItemRect.Min;
  D.18521 = operator- (_26, _24);
  ImRect::ImRect (&D.18523, &D.18521, &D.18522);
  g_3->NavInitResultRectRel = D.18523;
  D.18523 ={v} {CLOBBER};
  D.18521 ={v} {CLOBBER};
  D.18522 ={v} {CLOBBER};
  NavUpdateAnyRequestFlag ();
  _35 = ImGui::IsItemVisible ();
  retval.1091_36 = ~_35;
  if (retval.1091_36 != 0)
    goto <bb 9>;
  else
    goto <bb 10> (<L13>);

  <bb 9>:
  ImGui::SetScrollHere (5.0e-1);

<L13>:
  return;

}



;; Function void ImGui::SetStateStorage(ImGuiStorage*) (_ZN5ImGui15SetStateStorageEP12ImGuiStorage, funcdef_no=942, decl_uid=3328, cgraph_uid=841, symbol_order=849)

void ImGui::SetStateStorage(ImGuiStorage*) (struct ImGuiStorage * tree)
{
  struct ImGuiWindow * window;
  struct ImGuiStorage * iftmp.1092;
  struct ImGuiStorage * iftmp.1092_1;
  struct ImGuiStorage * iftmp.1092_6;
  struct ImGuiStorage * iftmp.1092_7;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  if (tree_5(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1092_6 = &window_4->StateStorage;
  goto <bb 5>;

  <bb 4>:
  iftmp.1092_7 = tree_5(D);

  <bb 5>:
  # iftmp.1092_1 = PHI <iftmp.1092_6(3), iftmp.1092_7(4)>
  window_4->DC.StateStorage = iftmp.1092_1;
  return;

}



;; Function ImGuiStorage* ImGui::GetStateStorage() (_ZN5ImGui15GetStateStorageEv, funcdef_no=943, decl_uid=3329, cgraph_uid=842, symbol_order=850)

ImGuiStorage* ImGui::GetStateStorage() ()
{
  struct ImGuiWindow * window;
  struct ImGuiStorage * D.34318;
  struct ImGuiStorage * _4;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = window_3->DC.StateStorage;

<L0>:
  return _4;

}



;; Function void ImGui::TextV(const char*, __va_list_tag*) (_ZN5ImGui5TextVEPKcP13__va_list_tag, funcdef_no=944, decl_uid=2673, cgraph_uid=843, symbol_order=851)

void ImGui::TextV(const char*, __va_list_tag*) (const char * fmt, struct  * args)
{
  const char * text_end;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  char[3073] * D.34327;
  sizetype D.34326;
  int D.34325;
  char[3073] * D.34324;
  char[3073] * D.34323;
  bool D.34320;
  bool _5;
  char[3073] * _7;
  char[3073] * _8;
  int _12;
  sizetype _13;
  char[3073] * _15;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  _5 = window_4->SkipItems;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 5> (<L2>);

  <bb 4>:
  g_6 = GImGui;
  _7 = &g_6->TempBuffer;
  _8 = &g_6->TempBuffer;
  _12 = ImFormatStringV (_8, 3073, fmt_9(D), args_10(D));
  _13 = (sizetype) _12;
  text_end_14 = _7 + _13;
  _15 = &g_6->TempBuffer;
  ImGui::TextUnformatted (_15, text_end_14);

<L2>:
  return;

}



;; Function void ImGui::Text(const char*, ...) (_ZN5ImGui4TextEPKcz, funcdef_no=945, decl_uid=2670, cgraph_uid=844, symbol_order=852)

void ImGui::Text(const char*, ...) (const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::TextV (fmt_3(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function void ImGui::TextColoredV(const ImVec4&, const char*, __va_list_tag*) (_ZN5ImGui12TextColoredVERK6ImVec4PKcP13__va_list_tag, funcdef_no=946, decl_uid=2680, cgraph_uid=845, symbol_order=853)

void ImGui::TextColoredV(const ImVec4&, const char*, __va_list_tag*) (const struct ImVec4 & col, const char * fmt, struct  * args)
{
  <bb 2>:
  ImGui::PushStyleColor (0, col_2(D));
  ImGui::TextV (fmt_4(D), args_5(D));
  ImGui::PopStyleColor (1);
  return;

}



;; Function void ImGui::TextColored(const ImVec4&, const char*, ...) (_ZN5ImGui11TextColoredERK6ImVec4PKcz, funcdef_no=947, decl_uid=2676, cgraph_uid=846, symbol_order=854)

void ImGui::TextColored(const ImVec4&, const char*, ...) (const struct ImVec4 & col, const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::TextColoredV (col_3(D), fmt_4(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function void ImGui::TextDisabledV(const char*, __va_list_tag*) (_ZN5ImGui13TextDisabledVEPKcP13__va_list_tag, funcdef_no=948, decl_uid=2685, cgraph_uid=847, symbol_order=855)

void ImGui::TextDisabledV(const char*, __va_list_tag*) (const char * fmt, struct  * args)
{
  struct ImVec4 * D.34332;
  struct ImGuiContext * GImGui.1093;
  struct ImGuiContext * GImGui.1093_2;
  struct ImVec4 * _3;

  <bb 2>:
  GImGui.1093_2 = GImGui;
  _3 = &GImGui.1093_2->Style.Colors[1];
  ImGui::PushStyleColor (0, _3);
  ImGui::TextV (fmt_5(D), args_6(D));
  ImGui::PopStyleColor (1);
  return;

}



;; Function void ImGui::TextDisabled(const char*, ...) (_ZN5ImGui12TextDisabledEPKcz, funcdef_no=949, decl_uid=2682, cgraph_uid=848, symbol_order=856)

void ImGui::TextDisabled(const char*, ...) (const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::TextDisabledV (fmt_3(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function void ImGui::TextWrappedV(const char*, __va_list_tag*) (_ZN5ImGui12TextWrappedVEPKcP13__va_list_tag, funcdef_no=950, decl_uid=2690, cgraph_uid=849, symbol_order=857)

void ImGui::TextWrappedV(const char*, __va_list_tag*) (const char * fmt, struct  * args)
{
  bool need_wrap;
  float D.34336;
  struct ImGuiWindow * D.34335;
  struct ImGuiContext * GImGui.1094;
  struct ImGuiContext * GImGui.1094_4;
  struct ImGuiWindow * _5;
  float _6;

  <bb 2>:
  GImGui.1094_4 = GImGui;
  _5 = GImGui.1094_4->CurrentWindow;
  _6 = _5->DC.TextWrapPos;
  need_wrap_7 = _6 < 0.0;
  if (need_wrap_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGui::PushTextWrapPos (0.0);

  <bb 4>:
  ImGui::TextV (fmt_9(D), args_10(D));
  if (need_wrap_7 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::PopTextWrapPos ();

  <bb 6>:
  return;

}



;; Function void ImGui::TextWrapped(const char*, ...) (_ZN5ImGui11TextWrappedEPKcz, funcdef_no=951, decl_uid=2687, cgraph_uid=850, symbol_order=858)

void ImGui::TextWrapped(const char*, ...) (const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::TextWrappedV (fmt_3(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function void ImGui::TextUnformatted(const char*, const char*) (_ZN5ImGui15TextUnformattedEPKcS1_, funcdef_no=952, decl_uid=2668, cgraph_uid=851, symbol_order=859)

void ImGui::TextUnformatted(const char*, const char*) (const char * text, const char * text_end)
{
  void * D.46530;
  bool D.34441;
  float D.34440;
  struct ImRect bb;
  const struct ImVec2 text_size;
  const float wrap_width;
  const char * line_end;
  const struct ImVec2 line_size;
  const char * line_end;
  int lines_skipped;
  struct ImRect line_rect;
  const char * line_end;
  int lines_skipped;
  int lines_skippable;
  struct ImVec2 pos;
  struct ImRect bb;
  struct ImVec2 text_size;
  const struct ImRect clip_rect;
  const float line_height;
  const char * line;
  const bool wrap_enabled;
  const float wrap_pos_x;
  const struct ImVec2 text_pos;
  const char * text_begin;
  static const char __PRETTY_FUNCTION__[54] = "void ImGui::TextUnformatted(const char*, const char*)";
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  bool D.34430;
  bool retval.1099;
  struct ImVec2 D.18607;
  struct ImVec2 * D.34427;
  float iftmp.1098;
  struct ImVec2 D.18602;
  float D.34422;
  float D.34421;
  struct ImVec2 D.18599;
  float D.18600;
  float D.34419;
  float D.34418;
  float D.34417;
  float D.34416;
  float D.34410;
  float D.34409;
  float D.34408;
  float D.34407;
  float D.34406;
  float D.34405;
  float D.34401;
  float D.34400;
  float D.34399;
  bool retval.1097;
  struct ImVec2 D.18591;
  struct ImVec2 D.18592;
  float D.34389;
  float D.34388;
  float D.34387;
  float D.34386;
  float D.34377;
  float D.34376;
  float D.34375;
  float D.34374;
  bool D.34371;
  bool D.34370;
  float D.34367;
  float D.34366;
  bool D.34364;
  long int D.34362;
  long int text.1096;
  long int text_end.1095;
  float D.34357;
  float D.34356;
  float D.34355;
  float D.34354;
  long unsigned int D.34352;
  bool D.34344;
  float iftmp.1098_12;
  bool _30;
  long unsigned int _35;
  float _37;
  float _38;
  float _39;
  float _40;
  long int text_end.1095_44;
  long int text.1096_45;
  long int _46;
  bool _47;
  float _53;
  float _54;
  bool _56;
  bool _57;
  float _58;
  float _59;
  float _60;
  float _61;
  float _68;
  float _69;
  float _70;
  float _71;
  bool retval.1097_80;
  float _82;
  float _83;
  float _85;
  float _90;
  float _91;
  float _93;
  float _94;
  float _96;
  float _97;
  float _109;
  float _110;
  float _111;
  float _112;
  float _116;
  float _117;
  float _118;
  struct ImVec2 * _132;
  float _134;
  float iftmp.1098_135;
  float iftmp.1098_136;
  bool _144;
  bool _145;
  bool retval.1099_146;

  <bb 2>:
  window_29 = ImGui::GetCurrentWindow ();
  _30 = window_29->SkipItems;
  if (_30 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 46>;

  <bb 4>:
  g_31 = GImGui;
  if (text_32(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("text != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7385, &__PRETTY_FUNCTION__);

  <bb 6>:
  text_begin_33 = text_32(D);
  if (text_end_34(D) == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _35 = strlen (text_32(D));
  text_end_36 = text_32(D) + _35;

  <bb 8>:
  # text_end_1 = PHI <text_end_34(D)(6), text_end_36(7)>
  _37 = window_29->DC.CursorPos.y;
  _38 = window_29->DC.CurrentLineTextBaseOffset;
  _39 = _37 + _38;
  _40 = window_29->DC.CursorPos.x;
  ImVec2::ImVec2 (&text_pos, _40, _39);
  wrap_pos_x_42 = window_29->DC.TextWrapPos;
  wrap_enabled_43 = wrap_pos_x_42 >= 0.0;
  text_end.1095_44 = (long int) text_end_1;
  text.1096_45 = (long int) text_32(D);
  _46 = text_end.1095_44 - text.1096_45;
  if (_46 > 2000)
    goto <bb 9>;
  else
    goto <bb 39>;

  <bb 9>:
  _47 = ~wrap_enabled_43;
  if (_47 != 0)
    goto <bb 10>;
  else
    goto <bb 39>;

  <bb 10>:
  line_48 = text_32(D);
  line_height_50 = ImGui::GetTextLineHeight ();
  clip_rect = window_29->ClipRect;
  ImVec2::ImVec2 (&text_size, 0.0, 0.0);
  _53 = text_pos.y;
  _54 = clip_rect.Max.y;
  if (_53 <= _54)
    goto <bb 11>;
  else
    goto <bb 38>;

  <bb 11>:
  pos = text_pos;
  _56 = g_31->LogEnabled;
  _57 = ~_56;
  if (_57 != 0)
    goto <bb 12>;
  else
    goto <bb 21>;

  <bb 12>:
  _58 = clip_rect.Min.y;
  _59 = text_pos.y;
  _60 = _58 - _59;
  _61 = _60 / line_height_50;
  lines_skippable_62 = (int) _61;
  if (lines_skippable_62 > 0)
    goto <bb 13>;
  else
    goto <bb 20>;

  <bb 13>:
  lines_skipped_63 = 0;

  <bb 14>:
  # line_2 = PHI <line_48(13), line_66(18)>
  # lines_skipped_7 = PHI <lines_skipped_63(13), lines_skipped_67(18)>
  if (line_2 >= text_end_1)
    goto <bb 19>;
  else
    goto <bb 15>;

  <bb 15>:
  if (lines_skipped_7 >= lines_skippable_62)
    goto <bb 19>;
  else
    goto <bb 16>;

  <bb 16>:
  line_end_64 = strchr (line_2, 10);
  if (line_end_64 == 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  line_end_65 = text_end_1;

  <bb 18>:
  # line_end_8 = PHI <line_end_64(16), line_end_65(17)>
  line_66 = line_end_8 + 1;
  lines_skipped_67 = lines_skipped_7 + 1;
  goto <bb 14>;

  <bb 19>:
  _68 = pos.y;
  _69 = (float) lines_skipped_7;
  _70 = _69 * line_height_50;
  _71 = _68 + _70;
  pos.y = _71;

  <bb 20>:
  # line_3 = PHI <line_48(12), line_2(19)>

  <bb 21>:
  # line_4 = PHI <line_48(11), line_3(20)>
  if (line_4 < text_end_1)
    goto <bb 22>;
  else
    goto <bb 37>;

  <bb 22>:
  ImVec2::ImVec2 (&D.18591, 3.4028234663852885981170418348451692544e+38, line_height_50);
  D.18592 = operator+ (&pos, &D.18591);
  ImRect::ImRect (&line_rect, &pos, &D.18592);
  D.18592 ={v} {CLOBBER};
  D.18591 ={v} {CLOBBER};

  <bb 23>:
  # line_5 = PHI <line_4(22), line_89(30)>
  if (line_5 >= text_end_1)
    goto <bb 31>;
  else
    goto <bb 24>;

  <bb 24>:
  line_end_78 = strchr (line_5, 10);
  retval.1097_80 = ImGui::IsClippedEx (&line_rect, 0, 0);
  if (retval.1097_80 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  line_size ={v} {CLOBBER};
  goto <bb 31>;

  <bb 26>:
  line_size = ImGui::CalcTextSize (line_5, line_end_78, 0, -1.0e+0);

  <bb 27>:
  _82 = line_size.x;
  _83 = text_size.x;
  _85 = ImMax (_83, _82);
  text_size.x = _85;
  ImGui::RenderText (pos, line_5, line_end_78, 0);

  <bb 28>:
  if (line_end_78 == 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  line_end_88 = text_end_1;

  <bb 30>:
  # line_end_9 = PHI <line_end_78(28), line_end_88(29)>
  line_89 = line_end_9 + 1;
  _90 = line_rect.Min.y;
  _91 = _90 + line_height_50;
  line_rect.Min.y = _91;
  _93 = line_rect.Max.y;
  _94 = _93 + line_height_50;
  line_rect.Max.y = _94;
  _96 = pos.y;
  _97 = _96 + line_height_50;
  pos.y = _97;
  line_size ={v} {CLOBBER};
  goto <bb 23>;

  <bb 31>:
  lines_skipped_104 = 0;

  <bb 32>:
  # line_6 = PHI <line_5(31), line_107(35)>
  # lines_skipped_10 = PHI <lines_skipped_104(31), lines_skipped_108(35)>
  if (line_6 >= text_end_1)
    goto <bb 36>;
  else
    goto <bb 33>;

  <bb 33>:
  line_end_105 = strchr (line_6, 10);
  if (line_end_105 == 0B)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  line_end_106 = text_end_1;

  <bb 35>:
  # line_end_11 = PHI <line_end_105(33), line_end_106(34)>
  line_107 = line_end_11 + 1;
  lines_skipped_108 = lines_skipped_10 + 1;
  goto <bb 32>;

  <bb 36>:
  _109 = pos.y;
  _110 = (float) lines_skipped_10;
  _111 = _110 * line_height_50;
  _112 = _109 + _111;
  pos.y = _112;
  line_rect ={v} {CLOBBER};

  <bb 37>:
  D.18599 = operator- (&pos, &text_pos);
  _116 = D.18599.y;
  _117 = text_size.y;
  _118 = _117 + _116;
  text_size.y = _118;
  pos ={v} {CLOBBER};

  <bb 38>:
  D.18602 = operator+ (&text_pos, &text_size);
  ImRect::ImRect (&bb, &text_pos, &D.18602);
  D.18602 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  ImGui::ItemAdd (&bb, 0, 0B);
  clip_rect ={v} {CLOBBER};
  text_size ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  goto <bb 45>;

  <bb 39>:
  if (wrap_enabled_43 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  _132 = &window_29->DC.CursorPos;
  _134 = ImGui::CalcWrapWidthForPos (_132, wrap_pos_x_42);
  iftmp.1098_135 = _134;
  goto <bb 42>;

  <bb 41>:
  iftmp.1098_136 = 0.0;

  <bb 42>:
  # iftmp.1098_12 = PHI <iftmp.1098_135(40), iftmp.1098_136(41)>
  wrap_width_137 = iftmp.1098_12;
  text_size = ImGui::CalcTextSize (text_begin_33, text_end_1, 0, wrap_width_137);
  D.18607 = operator+ (&text_pos, &text_size);
  ImRect::ImRect (&bb, &text_pos, &D.18607);
  D.18607 ={v} {CLOBBER};
  ImGui::ItemSize (&text_size, 0.0);
  _144 = ImGui::ItemAdd (&bb, 0, 0B);
  _145 = _144;
  retval.1099_146 = ~_145;
  if (retval.1099_146 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  text_size ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  goto <bb 46>;

  <bb 44>:
  ImGui::RenderTextWrapped (bb.Min, text_begin_33, text_end_1, wrap_width_137);
  text_size ={v} {CLOBBER};
  bb ={v} {CLOBBER};

  <bb 45>:
  text_pos ={v} {CLOBBER};
  goto <bb 47> (<L56>);

  <bb 46>:
  text_pos ={v} {CLOBBER};

<L56>:
  return;

<L57>:
  _24 = __builtin_eh_pointer (4);
  __builtin_unwind_resume (_24);

}



;; Function void ImGui::AlignTextToFramePadding() (_ZN5ImGui23AlignTextToFramePaddingEv, funcdef_no=953, decl_uid=2644, cgraph_uid=852, symbol_order=860)

void ImGui::AlignTextToFramePadding() ()
{
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.34459;
  float D.34458;
  float D.34457;
  float D.34456;
  float D.34455;
  float D.34454;
  float D.34453;
  float D.34452;
  float D.34451;
  bool D.34448;
  bool _5;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _13;
  float _15;
  float _16;
  float _18;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  _5 = window_4->SkipItems;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 5> (<L2>);

  <bb 4>:
  g_6 = GImGui;
  _7 = g_6->FontSize;
  _8 = g_6->Style.FramePadding.y;
  _9 = _8 * 2.0e+0;
  _10 = _7 + _9;
  _11 = window_4->DC.CurrentLineHeight;
  _13 = ImMax (_11, _10);
  window_4->DC.CurrentLineHeight = _13;
  _15 = g_6->Style.FramePadding.y;
  _16 = window_4->DC.CurrentLineTextBaseOffset;
  _18 = ImMax (_16, _15);
  window_4->DC.CurrentLineTextBaseOffset = _18;

<L2>:
  return;

}



;; Function void ImGui::LabelTextV(const char*, const char*, __va_list_tag*) (_ZN5ImGui10LabelTextVEPKcS1_P13__va_list_tag, funcdef_no=954, decl_uid=2697, cgraph_uid=853, symbol_order=861)

void ImGui::LabelTextV(const char*, const char*, __va_list_tag*) (const char * label, const char * fmt, struct  * args)
{
  bool D.34500;
  const float D.34499;
  const char * value_text_end;
  const char * value_text_begin;
  const struct ImRect total_bb;
  const struct ImRect value_bb;
  const struct ImVec2 label_size;
  const float w;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.34496;
  float D.34495;
  float D.34494;
  float D.34493;
  float D.34492;
  float D.34491;
  struct ImVec2 D.18640;
  float D.34488;
  struct ImVec2 D.18639;
  sizetype D.34487;
  int D.34486;
  char[3073] * D.34485;
  bool D.34482;
  bool retval.1101;
  float D.34480;
  struct ImVec2 * D.34479;
  struct ImVec2 * D.34478;
  float D.34477;
  float D.34473;
  float iftmp.1100;
  float D.34471;
  float D.34470;
  struct ImVec2 D.18634;
  struct ImVec2 D.18635;
  struct ImVec2 D.18636;
  struct ImVec2 * D.34469;
  struct ImVec2 * D.34468;
  float D.34467;
  float D.34466;
  float D.34465;
  float D.34464;
  struct ImVec2 D.18631;
  struct ImVec2 D.18632;
  bool D.34461;
  float iftmp.1100_1;
  bool _9;
  const float _13;
  float _17;
  float _18;
  float _19;
  float _20;
  struct ImVec2 * _22;
  struct ImVec2 * _24;
  float _28;
  float _29;
  float _30;
  float iftmp.1100_31;
  float iftmp.1100_32;
  float _33;
  struct ImVec2 * _35;
  struct ImVec2 * _38;
  float _43;
  bool _46;
  bool _47;
  bool retval.1101_48;
  char[3073] * _50;
  int _54;
  sizetype _55;
  float _60;
  float _61;
  float _62;
  float _63;
  float _64;
  float _65;
  float _66;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 12>;

  <bb 4>:
  g_10 = GImGui;
  style_11 = &g_10->Style;
  _13 = ImGui::CalcItemWidth ();
  w_14 = _13;
  label_size = ImGui::CalcTextSize (label_15(D), 0B, 1, -1.0e+0);
  _17 = label_size.y;
  _18 = style_11->FramePadding.y;
  _19 = _18 * 2.0e+0;
  _20 = _17 + _19;
  ImVec2::ImVec2 (&D.18631, w_14, _20);
  _22 = &window_8->DC.CursorPos;
  D.18632 = operator+ (_22, &D.18631);
  _24 = &window_8->DC.CursorPos;
  ImRect::ImRect (&value_bb, _24, &D.18632);
  D.18632 ={v} {CLOBBER};
  D.18631 ={v} {CLOBBER};
  _28 = style_11->FramePadding.y;
  _29 = _28 * 2.0e+0;
  _30 = label_size.x;
  if (_30 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1100_31 = style_11->ItemInnerSpacing.x;
  goto <bb 7>;

  <bb 6>:
  iftmp.1100_32 = 0.0;

  <bb 7>:
  # iftmp.1100_1 = PHI <iftmp.1100_31(5), iftmp.1100_32(6)>
  _33 = iftmp.1100_1 + w_14;
  ImVec2::ImVec2 (&D.18634, _33, _29);
  _35 = &window_8->DC.CursorPos;
  D.18635 = operator+ (_35, &D.18634);
  D.18636 = operator+ (&D.18635, &label_size);
  _38 = &window_8->DC.CursorPos;
  ImRect::ImRect (&total_bb, _38, &D.18636);
  D.18636 ={v} {CLOBBER};
  D.18635 ={v} {CLOBBER};
  D.18634 ={v} {CLOBBER};
  _43 = style_11->FramePadding.y;
  ImGui::ItemSize (&total_bb, _43);
  _46 = ImGui::ItemAdd (&total_bb, 0, 0B);
  _47 = _46;
  retval.1101_48 = ~_47;
  if (retval.1101_48 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 12>;

  <bb 9>:
  value_text_begin_49 = &g_10->TempBuffer[0];
  _50 = &g_10->TempBuffer;
  _54 = ImFormatStringV (_50, 3073, fmt_51(D), args_52(D));
  _55 = (sizetype) _54;
  value_text_end_56 = value_text_begin_49 + _55;
  ImVec2::ImVec2 (&D.18639, 0.0, 5.0e-1);
  ImGui::RenderTextClipped (&value_bb.Min, &value_bb.Max, value_text_begin_49, value_text_end_56, 0B, &D.18639, 0B);
  D.18639 ={v} {CLOBBER};
  _60 = label_size.x;
  if (_60 > 0.0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _61 = value_bb.Min.y;
  _62 = style_11->FramePadding.y;
  _63 = _61 + _62;
  _64 = value_bb.Max.x;
  _65 = style_11->ItemInnerSpacing.x;
  _66 = _64 + _65;
  ImVec2::ImVec2 (&D.18640, _66, _63);
  ImGui::RenderText (D.18640, label_15(D), 0B, 1);
  D.18640 ={v} {CLOBBER};

  <bb 11>:
  label_size ={v} {CLOBBER};
  value_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  goto <bb 13> (<L12>);

  <bb 12>:
  label_size ={v} {CLOBBER};
  value_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};

<L12>:
  return;

}



;; Function void ImGui::LabelText(const char*, const char*, ...) (_ZN5ImGui9LabelTextEPKcS1_z, funcdef_no=955, decl_uid=2693, cgraph_uid=854, symbol_order=862)

void ImGui::LabelText(const char*, const char*, ...) (const char * label, const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::LabelTextV (label_3(D), fmt_4(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function bool ImGui::ButtonBehavior(const ImRect&, ImGuiID, bool*, bool*, ImGuiButtonFlags) (_ZN5ImGui14ButtonBehaviorERK6ImRectjPbS3_i, funcdef_no=956, decl_uid=13935, cgraph_uid=855, symbol_order=863)

bool ImGui::ButtonBehavior(const ImRect&, ImGuiID, bool*, bool*, ImGuiButtonFlags) (const struct ImRect & bb, ImGuiID id, bool * out_hovered, bool * out_held, ImGuiButtonFlags flags)
{
  bool D.34747;
  bool D.34746;
  bool D.34745;
  bool nav_activated_by_inputs;
  bool nav_activated_by_code;
  bool held;
  bool hovered;
  bool pressed;
  struct ImGuiWindow * backup_hovered_window;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  unsigned int D.34732;
  ImGuiInputSource D.34729;
  int D.34724;
  bool D.34719;
  bool D.34718;
  bool D.34717;
  bool D.34716;
  float D.34715;
  float D.34714;
  int D.34712;
  int D.34707;
  bool D.34701;
  struct ImVec2 * D.34699;
  const struct ImVec2 * D.34698;
  bool D.34695;
  ImGuiInputSource D.34692;
  unsigned int D.34689;
  int D.34684;
  unsigned int D.34683;
  int D.34672;
  ImGuiInputReadMode iftmp.1106;
  unsigned int D.34670;
  unsigned int D.34667;
  unsigned int D.34666;
  unsigned int D.34665;
  unsigned int D.34663;
  unsigned int D.34661;
  bool D.34658;
  bool D.34655;
  bool D.34654;
  unsigned int D.34651;
  bool D.34640;
  float D.34638;
  unsigned int D.34636;
  int D.34634;
  bool iftmp.1105;
  bool retval.1104;
  bool D.34628;
  bool D.34627;
  float D.34626;
  float D.34625;
  int D.34623;
  bool D.34618;
  int D.34615;
  int D.34611;
  bool D.34610;
  int D.34608;
  bool D.34607;
  int D.34605;
  int D.34597;
  bool D.34594;
  int D.34591;
  bool D.34590;
  bool D.34589;
  bool D.34587;
  bool D.34586;
  bool D.34584;
  bool D.34583;
  int D.34581;
  unsigned int D.34573;
  unsigned int D.34570;
  int D.34567;
  struct ImGuiWindow * D.34561;
  int D.34558;
  int D.34552;
  float D.34551;
  float D.34550;
  float D.34549;
  float D.34548;
  float D.34547;
  float D.34546;
  bool retval.1103;
  bool retval.1102;
  int D.34539;
  int D.34538;
  bool D.34535;
  int D.34532;
  struct ImGuiWindow * D.34528;
  int D.34525;
  int D.34521;
  bool D.34520;
  unsigned int D.34516;
  int D.34507;
  bool _18;
  bool iftmp.1105_19;
  ImGuiInputReadMode iftmp.1106_20;
  int _50;
  unsigned int _55;
  bool _58;
  int _59;
  int _62;
  struct ImGuiWindow * _63;
  bool _68;
  int _70;
  bool _71;
  int _72;
  int _73;
  bool _75;
  bool retval.1102_76;
  float _79;
  float _80;
  float _81;
  float _82;
  float _83;
  float _84;
  int _86;
  bool retval.1103_87;
  int _90;
  struct ImGuiWindow * _91;
  int _93;
  unsigned int _94;
  unsigned int _95;
  int _97;
  bool _98;
  bool _99;
  bool _100;
  bool _101;
  bool _102;
  bool _103;
  int _104;
  bool _105;
  int _107;
  int _110;
  bool _111;
  int _112;
  bool _113;
  int _115;
  int _119;
  bool _120;
  int _121;
  float _122;
  float _123;
  bool _124;
  bool _125;
  int _128;
  unsigned int _129;
  float _130;
  bool _132;
  bool iftmp.1105_133;
  bool iftmp.1105_134;
  bool retval.1104_135;
  unsigned int _138;
  bool _139;
  bool _140;
  bool _141;
  unsigned int _142;
  unsigned int _143;
  unsigned int _144;
  unsigned int _145;
  unsigned int _147;
  unsigned int _148;
  int _150;
  ImGuiInputReadMode iftmp.1106_151;
  ImGuiInputReadMode iftmp.1106_152;
  bool _154;
  unsigned int _157;
  int _160;
  unsigned int _164;
  ImGuiInputSource _165;
  ImGuiInputSource _166;
  unsigned int _167;
  bool _169;
  const struct ImVec2 * _170;
  struct ImVec2 * _171;
  bool _173;
  int _175;
  int _176;
  float _177;
  float _178;
  bool _179;
  bool _180;
  bool _181;
  bool _182;
  int _185;
  bool _189;

  <bb 2>:
  g_46 = GImGui;
  window_48 = ImGui::GetCurrentWindow ();
  _50 = flags_49(D) & 256;
  if (_50 != 0)
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 3>:
  if (out_hovered_51(D) != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  *out_hovered_51(D) = 0;

  <bb 5>:
  if (out_held_53(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  *out_held_53(D) = 0;

  <bb 7>:
  _55 = g_46->ActiveId;
  if (_55 == id_56(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  ImGui::ClearActiveID ();

  <bb 9>:
  _58 = 0;
  goto <bb 107> (<L154>);

  <bb 10>:
  _59 = flags_49(D) & 30;
  if (_59 == 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  flags_60 = flags_49(D) | 2;

  <bb 12>:
  # flags_1 = PHI <flags_49(D)(10), flags_60(11)>
  backup_hovered_window_61 = g_46->HoveredWindow;
  _62 = flags_1 & 32;
  if (_62 != 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  _63 = g_46->HoveredRootWindow;
  if (_63 == window_48)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  g_46->HoveredWindow = window_48;

  <bb 15>:
  pressed_65 = 0;
  _68 = ImGui::ItemHoverable (bb_66(D), id_56(D));
  hovered_69 = _68;
  _70 = flags_1 & 4096;
  if (_70 != 0)
    goto <bb 16>;
  else
    goto <bb 21>;

  <bb 16>:
  _71 = g_46->DragDropActive;
  if (_71 != 0)
    goto <bb 17>;
  else
    goto <bb 21>;

  <bb 17>:
  _72 = g_46->DragDropSourceFlags;
  _73 = _72 & 4;
  if (_73 == 0)
    goto <bb 18>;
  else
    goto <bb 21>;

  <bb 18>:
  _75 = ImGui::IsItemHovered (32);
  retval.1102_76 = _75;
  if (retval.1102_76 != 0)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  hovered_77 = 1;
  ImGui::SetHoveredID (id_56(D));
  _79 = g_46->HoveredIdTimer;
  _80 = _79 + 9.99999974737875163555145263671875e-5;
  _81 = g_46->IO.DeltaTime;
  _82 = _80 - _81;
  _83 = g_46->HoveredIdTimer;
  _84 = _83 + 9.99999974737875163555145263671875e-5;
  _86 = ImGui::CalcTypematicPressedRepeatAmount (_84, _82, 9.99999977648258209228515625e-3, 6.99999988079071044921875e-1);
  retval.1103_87 = _86 != 0;
  if (retval.1103_87 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  pressed_88 = 1;
  ImGui::FocusWindow (window_48);

  <bb 21>:
  # pressed_2 = PHI <pressed_65(15), pressed_65(16), pressed_65(17), pressed_88(20), pressed_65(18), pressed_65(19)>
  # hovered_13 = PHI <hovered_69(15), hovered_69(16), hovered_69(17), hovered_77(20), hovered_69(18), hovered_77(19)>
  _90 = flags_1 & 32;
  if (_90 != 0)
    goto <bb 22>;
  else
    goto <bb 24>;

  <bb 22>:
  _91 = g_46->HoveredRootWindow;
  if (_91 == window_48)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  g_46->HoveredWindow = backup_hovered_window_61;

  <bb 24>:
  if (hovered_13 != 0)
    goto <bb 25>;
  else
    goto <bb 29>;

  <bb 25>:
  _93 = flags_1 & 64;
  if (_93 != 0)
    goto <bb 26>;
  else
    goto <bb 29>;

  <bb 26>:
  _94 = g_46->HoveredIdPreviousFrame;
  if (_94 != id_56(D))
    goto <bb 27>;
  else
    goto <bb 29>;

  <bb 27>:
  _95 = g_46->HoveredIdPreviousFrame;
  if (_95 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  hovered_96 = 0;

  <bb 29>:
  # hovered_14 = PHI <hovered_13(24), hovered_13(25), hovered_13(26), hovered_13(27), hovered_96(28)>
  if (hovered_14 != 0)
    goto <bb 30>;
  else
    goto <bb 63>;

  <bb 30>:
  _97 = flags_1 & 1024;
  if (_97 == 0)
    goto <bb 34>;
  else
    goto <bb 31>;

  <bb 31>:
  _98 = g_46->IO.KeyCtrl;
  _99 = ~_98;
  if (_99 != 0)
    goto <bb 32>;
  else
    goto <bb 61>;

  <bb 32>:
  _100 = g_46->IO.KeyShift;
  _101 = ~_100;
  if (_101 != 0)
    goto <bb 33>;
  else
    goto <bb 61>;

  <bb 33>:
  _102 = g_46->IO.KeyAlt;
  _103 = ~_102;
  if (_103 != 0)
    goto <bb 34>;
  else
    goto <bb 61>;

  <bb 34>:
  _104 = flags_1 & 2;
  if (_104 != 0)
    goto <bb 35>;
  else
    goto <bb 39>;

  <bb 35>:
  _105 = g_46->IO.MouseClicked[0];
  if (_105 != 0)
    goto <bb 36>;
  else
    goto <bb 39>;

  <bb 36>:
  ImGui::SetActiveID (id_56(D), window_48);
  _107 = flags_1 & 8192;
  if (_107 == 0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  ImGui::SetFocusID (id_56(D), window_48);

  <bb 38>:
  ImGui::FocusWindow (window_48);

  <bb 39>:
  _110 = flags_1 & 4;
  if (_110 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  _111 = g_46->IO.MouseClicked[0];
  if (_111 != 0)
    goto <bb 43>;
  else
    goto <bb 41>;

  <bb 41>:
  _112 = flags_1 & 16;
  if (_112 != 0)
    goto <bb 42>;
  else
    goto <bb 47>;

  <bb 42>:
  _113 = g_46->IO.MouseDoubleClicked[0];
  if (_113 != 0)
    goto <bb 43>;
  else
    goto <bb 47>;

  <bb 43>:
  pressed_114 = 1;
  _115 = flags_1 & 2048;
  if (_115 != 0)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  ImGui::ClearActiveID ();
  goto <bb 46>;

  <bb 45>:
  ImGui::SetActiveID (id_56(D), window_48);

  <bb 46>:
  ImGui::FocusWindow (window_48);

  <bb 47>:
  # pressed_3 = PHI <pressed_2(41), pressed_2(42), pressed_114(46)>
  _119 = flags_1 & 8;
  if (_119 != 0)
    goto <bb 48>;
  else
    goto <bb 53>;

  <bb 48>:
  _120 = g_46->IO.MouseReleased[0];
  if (_120 != 0)
    goto <bb 49>;
  else
    goto <bb 53>;

  <bb 49>:
  _121 = flags_1 & 1;
  if (_121 == 0)
    goto <bb 51>;
  else
    goto <bb 50>;

  <bb 50>:
  _122 = g_46->IO.MouseDownDurationPrev[0];
  _123 = g_46->IO.KeyRepeatDelay;
  _124 = _122 >= _123;
  _125 = ~_124;
  if (_125 != 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  pressed_126 = 1;

  <bb 52>:
  # pressed_4 = PHI <pressed_3(50), pressed_126(51)>
  ImGui::ClearActiveID ();

  <bb 53>:
  # pressed_5 = PHI <pressed_3(47), pressed_3(48), pressed_4(52)>
  _128 = flags_1 & 1;
  if (_128 != 0)
    goto <bb 54>;
  else
    goto <bb 58>;

  <bb 54>:
  _129 = g_46->ActiveId;
  if (_129 == id_56(D))
    goto <bb 55>;
  else
    goto <bb 58>;

  <bb 55>:
  _130 = g_46->IO.MouseDownDuration[0];
  if (_130 > 0.0)
    goto <bb 56>;
  else
    goto <bb 58>;

  <bb 56>:
  _132 = ImGui::IsMouseClicked (0, 1);
  if (_132 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  iftmp.1105_133 = 1;
  goto <bb 59>;

  <bb 58>:
  iftmp.1105_134 = 0;

  <bb 59>:
  # iftmp.1105_19 = PHI <iftmp.1105_133(57), iftmp.1105_134(58)>
  retval.1104_135 = iftmp.1105_19;
  if (retval.1104_135 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  pressed_136 = 1;

  <bb 61>:
  # pressed_6 = PHI <pressed_2(31), pressed_2(32), pressed_2(33), pressed_5(59), pressed_136(60)>
  if (pressed_6 != 0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  g_46->NavDisableHighlight = 1;

  <bb 63>:
  # pressed_7 = PHI <pressed_2(29), pressed_6(62), pressed_6(61)>
  _138 = g_46->NavId;
  if (_138 == id_56(D))
    goto <bb 64>;
  else
    goto <bb 70>;

  <bb 64>:
  _139 = g_46->NavDisableHighlight;
  _140 = ~_139;
  if (_140 != 0)
    goto <bb 65>;
  else
    goto <bb 70>;

  <bb 65>:
  _141 = g_46->NavDisableMouseHover;
  if (_141 != 0)
    goto <bb 66>;
  else
    goto <bb 70>;

  <bb 66>:
  _142 = g_46->ActiveId;
  if (_142 == 0)
    goto <bb 69>;
  else
    goto <bb 67>;

  <bb 67>:
  _143 = g_46->ActiveId;
  if (_143 == id_56(D))
    goto <bb 69>;
  else
    goto <bb 68>;

  <bb 68>:
  _144 = g_46->ActiveId;
  _145 = window_48->MoveId;
  if (_144 == _145)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  hovered_146 = 1;

  <bb 70>:
  # hovered_15 = PHI <hovered_14(63), hovered_14(64), hovered_14(65), hovered_14(68), hovered_146(69)>
  _147 = g_46->NavActivateDownId;
  if (_147 == id_56(D))
    goto <bb 71>;
  else
    goto <bb 84>;

  <bb 71>:
  _148 = g_46->NavActivateId;
  nav_activated_by_code_149 = _148 == id_56(D);
  _150 = flags_1 & 1;
  if (_150 != 0)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  iftmp.1106_151 = 3;
  goto <bb 74>;

  <bb 73>:
  iftmp.1106_152 = 1;

  <bb 74>:
  # iftmp.1106_20 = PHI <iftmp.1106_151(72), iftmp.1106_152(73)>
  _154 = IsNavInputPressed (0, iftmp.1106_20);
  nav_activated_by_inputs_155 = _154;
  if (nav_activated_by_code_149 != 0)
    goto <bb 76>;
  else
    goto <bb 75>;

  <bb 75>:
  if (nav_activated_by_inputs_155 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  pressed_156 = 1;

  <bb 77>:
  # pressed_8 = PHI <pressed_7(75), pressed_156(76)>
  if (nav_activated_by_code_149 != 0)
    goto <bb 80>;
  else
    goto <bb 78>;

  <bb 78>:
  if (nav_activated_by_inputs_155 != 0)
    goto <bb 80>;
  else
    goto <bb 79>;

  <bb 79>:
  _157 = g_46->ActiveId;
  if (_157 == id_56(D))
    goto <bb 80>;
  else
    goto <bb 83>;

  <bb 80>:
  g_46->NavActivateId = id_56(D);
  ImGui::SetActiveID (id_56(D), window_48);
  _160 = flags_1 & 8192;
  if (_160 == 0)
    goto <bb 81>;
  else
    goto <bb 82>;

  <bb 81>:
  ImGui::SetFocusID (id_56(D), window_48);

  <bb 82>:
  g_46->ActiveIdAllowNavDirFlags = 15;

  <bb 83>:

  <bb 84>:
  # pressed_9 = PHI <pressed_7(70), pressed_8(83)>
  held_163 = 0;
  _164 = g_46->ActiveId;
  if (_164 == id_56(D))
    goto <bb 85>;
  else
    goto <bb 102>;

  <bb 85>:
  _165 = g_46->ActiveIdSource;
  if (_165 == 1)
    goto <bb 86>;
  else
    goto <bb 99>;

  <bb 86>:
  _169 = g_46->ActiveIdIsJustActivated;
  if (_169 != 0)
    goto <bb 87>;
  else
    goto <bb 88>;

  <bb 87>:
  _170 = &bb_66(D)->Min;
  _171 = &g_46->IO.MousePos;
  g_46->ActiveIdClickOffset = operator- (_171, _170);

  <bb 88>:
  _173 = g_46->IO.MouseDown[0];
  if (_173 != 0)
    goto <bb 89>;
  else
    goto <bb 90>;

  <bb 89>:
  held_174 = 1;
  goto <bb 97>;

  <bb 90>:
  if (hovered_15 != 0)
    goto <bb 91>;
  else
    goto <bb 96>;

  <bb 91>:
  _175 = flags_1 & 2;
  if (_175 != 0)
    goto <bb 92>;
  else
    goto <bb 96>;

  <bb 92>:
  _176 = flags_1 & 1;
  if (_176 == 0)
    goto <bb 94>;
  else
    goto <bb 93>;

  <bb 93>:
  _177 = g_46->IO.MouseDownDurationPrev[0];
  _178 = g_46->IO.KeyRepeatDelay;
  _179 = _177 >= _178;
  _180 = ~_179;
  if (_180 != 0)
    goto <bb 94>;
  else
    goto <bb 96>;

  <bb 94>:
  _181 = g_46->DragDropActive;
  _182 = ~_181;
  if (_182 != 0)
    goto <bb 95>;
  else
    goto <bb 96>;

  <bb 95>:
  pressed_183 = 1;

  <bb 96>:
  # pressed_10 = PHI <pressed_9(90), pressed_9(91), pressed_9(94), pressed_9(93), pressed_183(95)>
  ImGui::ClearActiveID ();

  <bb 97>:
  # pressed_11 = PHI <pressed_9(89), pressed_10(96)>
  # held_16 = PHI <held_174(89), held_163(96)>
  _185 = flags_1 & 8192;
  if (_185 == 0)
    goto <bb 98>;
  else
    goto <bb 102>;

  <bb 98>:
  g_46->NavDisableHighlight = 1;
  goto <bb 102>;

  <bb 99>:
  _166 = g_46->ActiveIdSource;
  if (_166 == 2)
    goto <bb 100>;
  else
    goto <bb 102>;

  <bb 100>:
  _167 = g_46->NavActivateDownId;
  if (_167 != id_56(D))
    goto <bb 101>;
  else
    goto <bb 102>;

  <bb 101>:
  ImGui::ClearActiveID ();

  <bb 102>:
  # pressed_12 = PHI <pressed_9(84), pressed_9(99), pressed_11(98), pressed_9(100), pressed_11(97), pressed_9(101)>
  # held_17 = PHI <held_163(84), held_163(99), held_16(98), held_163(100), held_16(97), held_163(101)>
  if (out_hovered_51(D) != 0B)
    goto <bb 103>;
  else
    goto <bb 104>;

  <bb 103>:
  *out_hovered_51(D) = hovered_15;

  <bb 104>:
  if (out_held_53(D) != 0B)
    goto <bb 105>;
  else
    goto <bb 106>;

  <bb 105>:
  *out_held_53(D) = held_17;

  <bb 106>:
  _189 = pressed_12;

  # _18 = PHI <_58(9), _189(106)>
<L154>:
  return _18;

}



;; Function bool ImGui::ButtonEx(const char*, const ImVec2&, ImGuiButtonFlags) (_ZN5ImGui8ButtonExEPKcRK6ImVec2i, funcdef_no=957, decl_uid=13940, cgraph_uid=856, symbol_order=864)

bool ImGui::ButtonEx(const char*, const ImVec2&, ImGuiButtonFlags) (const char * label, const struct ImVec2 & size_arg, ImGuiButtonFlags flags)
{
  bool D.34804;
  bool D.34803;
  const ImGuiID D.34802;
  const ImU32 col;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect bb;
  struct ImVec2 size;
  struct ImVec2 pos;
  const struct ImVec2 label_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const struct ImVec2 * D.34800;
  struct ImVec2 D.18686;
  const struct ImVec2 * D.34799;
  struct ImVec2 D.18687;
  const struct ImVec2 * D.34798;
  float D.34797;
  bool hovered.1112;
  ImGuiCol iftmp.1111;
  bool D.34791;
  bool held.1110;
  bool D.34788;
  bool hovered.1109;
  ImGuiCol iftmp.1108;
  int D.34779;
  int D.34778;
  bool D.34775;
  bool retval.1107;
  float D.34773;
  struct ImVec2 D.18679;
  float D.34772;
  float D.34771;
  float D.34770;
  float D.34769;
  float D.34768;
  float D.34767;
  float D.34766;
  float D.34765;
  float D.34763;
  float D.34762;
  float D.34761;
  float D.34760;
  float D.34759;
  float D.34756;
  float D.34755;
  int D.34752;
  bool D.34751;
  bool D.34748;
  bool _2;
  ImGuiCol iftmp.1108_3;
  ImGuiCol iftmp.1111_4;
  bool _11;
  bool _12;
  const ImGuiID _17;
  int _22;
  float _23;
  float _24;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _31;
  float _32;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _38;
  float _44;
  bool _47;
  bool _48;
  bool retval.1107_49;
  bool _50;
  int _51;
  int _52;
  bool _55;
  bool hovered.1109_57;
  bool _58;
  bool held.1110_59;
  bool _60;
  ImGuiCol iftmp.1108_61;
  bool hovered.1112_62;
  ImGuiCol iftmp.1111_63;
  ImGuiCol iftmp.1111_64;
  ImGuiCol iftmp.1108_65;
  float _69;
  const struct ImVec2 * _71;
  const struct ImVec2 * _72;
  const struct ImVec2 * _74;
  bool _79;

  <bb 2>:
  window_10 = ImGui::GetCurrentWindow ();
  _11 = window_10->SkipItems;
  if (_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = 0;
  goto <bb 19>;

  <bb 4>:
  g_13 = GImGui;
  style_14 = &g_13->Style;
  _17 = ImGuiWindow::GetID (window_10, label_15(D), 0B);
  id_18 = _17;
  label_size = ImGui::CalcTextSize (label_15(D), 0B, 1, -1.0e+0);
  pos = window_10->DC.CursorPos;
  _22 = flags_21(D) & 512;
  if (_22 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _23 = style_14->FramePadding.y;
  _24 = window_10->DC.CurrentLineTextBaseOffset;
  if (_23 < _24)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _25 = pos.y;
  _26 = window_10->DC.CurrentLineTextBaseOffset;
  _27 = style_14->FramePadding.y;
  _28 = _26 - _27;
  _29 = _25 + _28;
  pos.y = _29;

  <bb 7>:
  _31 = label_size.y;
  _32 = style_14->FramePadding.y;
  _33 = _32 * 2.0e+0;
  _34 = _31 + _33;
  _35 = label_size.x;
  _36 = style_14->FramePadding.x;
  _37 = _36 * 2.0e+0;
  _38 = _35 + _37;
  size = ImGui::CalcItemSize (*size_arg_39(D), _38, _34);
  D.18679 = operator+ (&pos, &size);
  ImRect::ImRect (&bb, &pos, &D.18679);
  D.18679 ={v} {CLOBBER};
  _44 = style_14->FramePadding.y;
  ImGui::ItemSize (&bb, _44);
  _47 = ImGui::ItemAdd (&bb, id_18, 0B);
  _48 = _47;
  retval.1107_49 = ~_48;
  if (retval.1107_49 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _50 = 0;
  goto <bb 19>;

  <bb 9>:
  _51 = window_10->DC.ItemFlags;
  _52 = _51 & 2;
  if (_52 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  flags_53 = flags_21(D) | 1;

  <bb 11>:
  # flags_1 = PHI <flags_21(D)(9), flags_53(10)>
  _55 = ImGui::ButtonBehavior (&bb, id_18, &hovered, &held, flags_1);
  pressed_56 = _55;
  hovered.1109_57 = hovered;
  _58 = ~hovered.1109_57;
  if (_58 != 0)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  held.1110_59 = held;
  _60 = ~held.1110_59;
  if (_60 != 0)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:
  hovered.1112_62 = hovered;
  if (hovered.1112_62 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  iftmp.1111_63 = 22;
  goto <bb 16>;

  <bb 15>:
  iftmp.1111_64 = 21;

  <bb 16>:
  # iftmp.1111_4 = PHI <iftmp.1111_63(14), iftmp.1111_64(15)>
  iftmp.1108_65 = iftmp.1111_4;
  goto <bb 18>;

  <bb 17>:
  iftmp.1108_61 = 23;

  <bb 18>:
  # iftmp.1108_3 = PHI <iftmp.1108_65(16), iftmp.1108_61(17)>
  col_67 = ImGui::GetColorU32 (iftmp.1108_3, 1.0e+0);
  ImGui::RenderNavHighlight (&bb, id_18, 1);
  _69 = style_14->FrameRounding;
  ImGui::RenderFrame (bb.Min, bb.Max, col_67, 1, _69);
  _71 = &style_14->ButtonTextAlign;
  _72 = &style_14->FramePadding;
  D.18687 = operator- (&bb.Max, _72);
  _74 = &style_14->FramePadding;
  D.18686 = operator+ (&bb.Min, _74);
  ImGui::RenderTextClipped (&D.18686, &D.18687, label_15(D), 0B, &label_size, _71, &bb);
  D.18686 ={v} {CLOBBER};
  D.18687 ={v} {CLOBBER};
  _79 = pressed_56;

  <bb 19>:
  # _2 = PHI <_12(3), _50(8), _79(18)>
  label_size ={v} {CLOBBER};
  pos ={v} {CLOBBER};
  size ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L20>:
  return _2;

}



;; Function bool ImGui::Button(const char*, const ImVec2&) (_ZN5ImGui6ButtonEPKcRK6ImVec2, funcdef_no=958, decl_uid=2706, cgraph_uid=857, symbol_order=865)

bool ImGui::Button(const char*, const ImVec2&) (const char * label, const struct ImVec2 & size_arg)
{
  bool D.34811;
  bool D.34809;
  bool _5;
  bool _6;

  <bb 2>:
  _5 = ImGui::ButtonEx (label_2(D), size_arg_3(D), 0);
  _6 = _5;

<L0>:
  return _6;

}



;; Function bool ImGui::SmallButton(const char*) (_ZN5ImGui11SmallButtonEPKc, funcdef_no=959, decl_uid=2708, cgraph_uid=858, symbol_order=866)

bool ImGui::SmallButton(const char*) (const char * label)
{
  bool D.34814;
  bool pressed;
  float backup_padding_y;
  struct ImGuiContext & g;
  bool D.34812;
  struct ImVec2 D.18698;
  bool _8;
  bool _12;

  <bb 2>:
  g_2 = GImGui;
  backup_padding_y_3 = g_2->Style.FramePadding.y;
  g_2->Style.FramePadding.y = 0.0;
  ImVec2::ImVec2 (&D.18698, 0.0, 0.0);
  _8 = ImGui::ButtonEx (label_6(D), &D.18698, 512);
  pressed_9 = _8;
  D.18698 ={v} {CLOBBER};
  g_2->Style.FramePadding.y = backup_padding_y_3;
  _12 = pressed_9;

<L0>:
  return _12;

}



;; Function bool ImGui::ArrowButton(const char*, ImGuiDir) (_ZN5ImGui11ArrowButtonEPKci, funcdef_no=960, decl_uid=2711, cgraph_uid=859, symbol_order=867)

bool ImGui::ArrowButton(const char*, ImGuiDir) (const char * str_id, ImGuiDir dir)
{
  bool D.34846;
  bool D.34845;
  const ImGuiID D.34844;
  const ImU32 col;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect bb;
  float sz;
  const ImGuiID id;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  struct ImVec2 D.34842;
  struct ImVec2 * D.34841;
  float D.34840;
  bool hovered.1118;
  ImGuiCol iftmp.1117;
  bool D.34834;
  bool held.1116;
  bool D.34831;
  bool hovered.1115;
  ImGuiCol iftmp.1114;
  bool D.34823;
  bool retval.1113;
  struct ImVec2 * D.34821;
  struct ImVec2 * D.34820;
  struct ImVec2 D.18708;
  struct ImVec2 D.18709;
  bool D.34819;
  bool D.34816;
  bool _1;
  ImGuiCol iftmp.1114_2;
  ImGuiCol iftmp.1117_3;
  bool _9;
  bool _10;
  const ImGuiID _14;
  struct ImVec2 * _19;
  struct ImVec2 * _21;
  bool _27;
  bool _28;
  bool retval.1113_29;
  bool _30;
  bool _32;
  bool hovered.1115_34;
  bool _35;
  bool held.1116_36;
  bool _37;
  ImGuiCol iftmp.1114_38;
  bool hovered.1118_39;
  ImGuiCol iftmp.1117_40;
  ImGuiCol iftmp.1117_41;
  ImGuiCol iftmp.1114_42;
  float _46;
  struct ImVec2 * _48;
  bool _52;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 14>;

  <bb 4>:
  g_11 = GImGui;
  _14 = ImGuiWindow::GetID (window_8, str_id_12(D), 0B);
  id_15 = _14;
  sz_17 = ImGui::GetFrameHeight ();
  ImVec2::ImVec2 (&D.18708, sz_17, sz_17);
  _19 = &window_8->DC.CursorPos;
  D.18709 = operator+ (_19, &D.18708);
  _21 = &window_8->DC.CursorPos;
  ImRect::ImRect (&bb, _21, &D.18709);
  D.18709 ={v} {CLOBBER};
  D.18708 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  _27 = ImGui::ItemAdd (&bb, id_15, 0B);
  _28 = _27;
  retval.1113_29 = ~_28;
  if (retval.1113_29 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _30 = 0;
  goto <bb 14>;

  <bb 6>:
  _32 = ImGui::ButtonBehavior (&bb, id_15, &hovered, &held, 0);
  pressed_33 = _32;
  hovered.1115_34 = hovered;
  _35 = ~hovered.1115_34;
  if (_35 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  held.1116_36 = held;
  _37 = ~held.1116_36;
  if (_37 != 0)
    goto <bb 8>;
  else
    goto <bb 12>;

  <bb 8>:
  hovered.1118_39 = hovered;
  if (hovered.1118_39 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1117_40 = 22;
  goto <bb 11>;

  <bb 10>:
  iftmp.1117_41 = 21;

  <bb 11>:
  # iftmp.1117_3 = PHI <iftmp.1117_40(9), iftmp.1117_41(10)>
  iftmp.1114_42 = iftmp.1117_3;
  goto <bb 13>;

  <bb 12>:
  iftmp.1114_38 = 23;

  <bb 13>:
  # iftmp.1114_2 = PHI <iftmp.1114_42(11), iftmp.1114_38(12)>
  col_44 = ImGui::GetColorU32 (iftmp.1114_2, 1.0e+0);
  ImGui::RenderNavHighlight (&bb, id_15, 1);
  _46 = g_11->Style.FrameRounding;
  ImGui::RenderFrame (bb.Min, bb.Max, col_44, 1, _46);
  _48 = &g_11->Style.FramePadding;
  D.34842 = operator+ (&bb.Min, _48);
  ImGui::RenderArrow (D.34842, dir_50(D), 1.0e+0);
  _52 = pressed_33;

  <bb 14>:
  # _1 = PHI <_10(3), _30(5), _52(13)>
  bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L12>:
  return _1;

}



;; Function bool ImGui::InvisibleButton(const char*, const ImVec2&) (_ZN5ImGui15InvisibleButtonEPKcRK6ImVec2, funcdef_no=961, decl_uid=2714, cgraph_uid=860, symbol_order=868)

bool ImGui::InvisibleButton(const char*, const ImVec2&) (const char * str_id, const struct ImVec2 & size_arg)
{
  bool D.34862;
  bool D.34861;
  const ImGuiID D.34860;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect bb;
  struct ImVec2 size;
  const ImGuiID id;
  struct ImGuiWindow * window;
  bool D.34856;
  bool retval.1119;
  struct ImVec2 * D.34854;
  struct ImVec2 * D.34853;
  struct ImVec2 D.18727;
  bool D.34852;
  bool D.34849;
  bool _1;
  bool _7;
  bool _8;
  const ImGuiID _11;
  struct ImVec2 * _15;
  struct ImVec2 * _17;
  bool _22;
  bool _23;
  bool retval.1119_24;
  bool _25;
  bool _27;
  bool _29;

  <bb 2>:
  window_6 = ImGui::GetCurrentWindow ();
  _7 = window_6->SkipItems;
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = 0;
  goto <bb 7>;

  <bb 4>:
  _11 = ImGuiWindow::GetID (window_6, str_id_9(D), 0B);
  id_12 = _11;
  size = ImGui::CalcItemSize (*size_arg_13(D), 0.0, 0.0);
  _15 = &window_6->DC.CursorPos;
  D.18727 = operator+ (_15, &size);
  _17 = &window_6->DC.CursorPos;
  ImRect::ImRect (&bb, _17, &D.18727);
  D.18727 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  _22 = ImGui::ItemAdd (&bb, id_12, 0B);
  _23 = _22;
  retval.1119_24 = ~_23;
  if (retval.1119_24 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _25 = 0;
  goto <bb 7>;

  <bb 6>:
  _27 = ImGui::ButtonBehavior (&bb, id_12, &hovered, &held, 0);
  pressed_28 = _27;
  _29 = pressed_28;

  <bb 7>:
  # _1 = PHI <_8(3), _25(5), _29(6)>
  size ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L5>:
  return _1;

}



;; Function bool ImGui::CloseButton(ImGuiID, const ImVec2&, float) (_ZN5ImGui11CloseButtonEjRK6ImVec2f, funcdef_no=962, decl_uid=13944, cgraph_uid=861, symbol_order=869)

bool ImGui::CloseButton(ImGuiID, const ImVec2&, float) (ImGuiID id, const struct ImVec2 & pos, float radius)
{
  bool D.34892;
  bool D.34891;
  ImU32 cross_col;
  float cross_extent;
  struct ImVec2 center;
  bool pressed;
  bool held;
  bool hovered;
  bool is_clipped;
  const struct ImRect bb;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.34889;
  float D.34888;
  struct ImVec2 D.18756;
  struct ImVec2 D.18757;
  float D.34887;
  struct ImVec2 D.18758;
  struct ImVec2 D.18759;
  struct ImDrawList * D.34886;
  struct ImVec2 D.18752;
  struct ImVec2 D.18753;
  float D.34885;
  float D.34884;
  struct ImVec2 D.18754;
  struct ImVec2 D.18755;
  struct ImVec2 D.18751;
  float D.34883;
  struct ImDrawList * D.34881;
  float D.34880;
  unsigned int D.34879;
  bool hovered.1123;
  bool held.1122;
  ImGuiCol iftmp.1121;
  bool hovered.1120;
  bool D.34868;
  bool D.34865;
  struct ImVec2 D.18739;
  struct ImVec2 D.18740;
  struct ImVec2 D.18741;
  struct ImVec2 D.18742;
  bool _1;
  ImGuiCol iftmp.1121_2;
  bool _22;
  bool _23;
  bool _26;
  bool _28;
  bool hovered.1120_30;
  bool held.1122_31;
  bool hovered.1123_32;
  ImGuiCol iftmp.1121_33;
  ImGuiCol iftmp.1121_34;
  unsigned int _36;
  float _38;
  struct ImDrawList * _39;
  float _41;
  float _48;
  float _49;
  struct ImDrawList * _54;
  float _60;
  float _63;
  struct ImDrawList * _66;
  bool _72;

  <bb 2>:
  g_7 = GImGui;
  window_8 = g_7->CurrentWindow;
  ImVec2::ImVec2 (&D.18741, radius_9(D), radius_9(D));
  D.18742 = operator+ (pos_11(D), &D.18741);
  ImVec2::ImVec2 (&D.18739, radius_9(D), radius_9(D));
  D.18740 = operator- (pos_11(D), &D.18739);
  ImRect::ImRect (&bb, &D.18740, &D.18742);
  D.18740 ={v} {CLOBBER};
  D.18739 ={v} {CLOBBER};
  D.18742 ={v} {CLOBBER};
  D.18741 ={v} {CLOBBER};
  _22 = ImGui::ItemAdd (&bb, id_20(D), 0B);
  _23 = _22;
  is_clipped_24 = ~_23;
  _26 = ImGui::ButtonBehavior (&bb, id_20(D), &hovered, &held, 0);
  pressed_27 = _26;
  if (is_clipped_24 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _28 = pressed_27;
  goto <bb 11>;

  <bb 4>:
  center = ImRect::GetCenter (&bb);
  hovered.1120_30 = hovered;
  if (hovered.1120_30 != 0)
    goto <bb 5>;
  else
    goto <bb 10>;

  <bb 5>:
  held.1122_31 = held;
  if (held.1122_31 != 0)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  hovered.1123_32 = hovered;
  if (hovered.1123_32 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1121_33 = 23;
  goto <bb 9>;

  <bb 8>:
  iftmp.1121_34 = 22;

  <bb 9>:
  # iftmp.1121_2 = PHI <iftmp.1121_33(7), iftmp.1121_34(8)>
  _36 = ImGui::GetColorU32 (iftmp.1121_2, 1.0e+0);
  _38 = ImMax (2.0e+0, radius_9(D));
  _39 = window_8->DrawList;
  ImDrawList::AddCircleFilled (_39, &center, _38, _36, 9);

  <bb 10>:
  _41 = radius_9(D) * 7.07099974155426025390625e-1;
  cross_extent_42 = _41 - 1.0e+0;
  cross_col_44 = ImGui::GetColorU32 (0, 1.0e+0);
  ImVec2::ImVec2 (&D.18751, 5.0e-1, 5.0e-1);
  operator-= (&center, &D.18751);
  D.18751 ={v} {CLOBBER};
  _48 = -cross_extent_42;
  _49 = -cross_extent_42;
  ImVec2::ImVec2 (&D.18754, _49, _48);
  D.18755 = operator+ (&center, &D.18754);
  ImVec2::ImVec2 (&D.18752, cross_extent_42, cross_extent_42);
  D.18753 = operator+ (&center, &D.18752);
  _54 = window_8->DrawList;
  ImDrawList::AddLine (_54, &D.18753, &D.18755, cross_col_44, 1.0e+0);
  D.18753 ={v} {CLOBBER};
  D.18752 ={v} {CLOBBER};
  D.18755 ={v} {CLOBBER};
  D.18754 ={v} {CLOBBER};
  _60 = -cross_extent_42;
  ImVec2::ImVec2 (&D.18758, _60, cross_extent_42);
  D.18759 = operator+ (&center, &D.18758);
  _63 = -cross_extent_42;
  ImVec2::ImVec2 (&D.18756, cross_extent_42, _63);
  D.18757 = operator+ (&center, &D.18756);
  _66 = window_8->DrawList;
  ImDrawList::AddLine (_66, &D.18757, &D.18759, cross_col_44, 1.0e+0);
  D.18757 ={v} {CLOBBER};
  D.18756 ={v} {CLOBBER};
  D.18759 ={v} {CLOBBER};
  D.18758 ={v} {CLOBBER};
  _72 = pressed_27;

  <bb 11>:
  # _1 = PHI <_28(3), _72(10)>
  bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  center ={v} {CLOBBER};

<L10>:
  return _1;

}



;; Function void ImGui::Image(ImTextureID, const ImVec2&, const ImVec2&, const ImVec2&, const ImVec4&, const ImVec4&) (_ZN5ImGui5ImageEPvRK6ImVec2S3_S3_RK6ImVec4S6_, funcdef_no=963, decl_uid=2752, cgraph_uid=862, symbol_order=870)

void ImGui::Image(ImTextureID, const ImVec2&, const ImVec2&, const ImVec2&, const ImVec4&, const ImVec4&) (void * user_texture_id, const struct ImVec2 & size, const struct ImVec2 & uv0, const struct ImVec2 & uv1, const struct ImVec4 & tint_col, const struct ImVec4 & border_col)
{
  bool D.34938;
  struct ImRect bb;
  struct ImGuiWindow * window;
  struct ImDrawList * D.34936;
  unsigned int D.34935;
  struct ImDrawList * D.34933;
  struct ImVec2 D.18772;
  struct ImVec2 D.18773;
  struct ImVec2 D.18774;
  struct ImVec2 D.18775;
  unsigned int D.34932;
  struct ImDrawList * D.34931;
  unsigned int D.34930;
  float D.34927;
  bool D.34924;
  bool retval.1124;
  struct ImVec2 D.18771;
  float D.34919;
  struct ImVec2 * D.34918;
  struct ImVec2 * D.34917;
  struct ImVec2 D.18770;
  bool D.34914;
  bool _9;
  struct ImVec2 * _10;
  struct ImVec2 * _13;
  float _17;
  bool _23;
  bool _24;
  bool retval.1124_25;
  float _26;
  unsigned int _28;
  struct ImDrawList * _29;
  unsigned int _33;
  struct ImDrawList * _38;
  unsigned int _52;
  struct ImDrawList * _53;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 12>;

  <bb 4>:
  _10 = &window_8->DC.CursorPos;
  D.18770 = operator+ (_10, size_11(D));
  _13 = &window_8->DC.CursorPos;
  ImRect::ImRect (&bb, _13, &D.18770);
  D.18770 ={v} {CLOBBER};
  _17 = border_col_16(D)->w;
  if (_17 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImVec2::ImVec2 (&D.18771, 2.0e+0, 2.0e+0);
  operator+= (&bb.Max, &D.18771);
  D.18771 ={v} {CLOBBER};

  <bb 6>:
  ImGui::ItemSize (&bb, 0.0);
  _23 = ImGui::ItemAdd (&bb, 0, 0B);
  _24 = _23;
  retval.1124_25 = ~_24;
  if (retval.1124_25 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 12>;

  <bb 8>:
  _26 = border_col_16(D)->w;
  if (_26 > 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _28 = ImGui::GetColorU32 (border_col_16(D));
  _29 = window_8->DrawList;
  ImDrawList::AddRect (_29, &bb.Min, &bb.Max, _28, 0.0, 15, 1.0e+0);
  _33 = ImGui::GetColorU32 (tint_col_31(D));
  ImVec2::ImVec2 (&D.18774, 1.0e+0, 1.0e+0);
  D.18775 = operator- (&bb.Max, &D.18774);
  ImVec2::ImVec2 (&D.18772, 1.0e+0, 1.0e+0);
  D.18773 = operator+ (&bb.Min, &D.18772);
  _38 = window_8->DrawList;
  ImDrawList::AddImage (_38, user_texture_id_39(D), &D.18773, &D.18775, uv0_40(D), uv1_41(D), _33);
  D.18773 ={v} {CLOBBER};
  D.18772 ={v} {CLOBBER};
  D.18775 ={v} {CLOBBER};
  D.18774 ={v} {CLOBBER};
  goto <bb 11>;

  <bb 10>:
  _52 = ImGui::GetColorU32 (tint_col_31(D));
  _53 = window_8->DrawList;
  ImDrawList::AddImage (_53, user_texture_id_39(D), &bb.Min, &bb.Max, uv0_40(D), uv1_41(D), _52);

  <bb 11>:
  bb ={v} {CLOBBER};
  goto <bb 13> (<L12>);

  <bb 12>:
  bb ={v} {CLOBBER};

<L12>:
  return;

}



;; Function bool ImGui::ImageButton(ImTextureID, const ImVec2&, const ImVec2&, const ImVec2&, int, const ImVec4&, const ImVec4&) (_ZN5ImGui11ImageButtonEPvRK6ImVec2S3_S3_iRK6ImVec4S6_, funcdef_no=964, decl_uid=2764, cgraph_uid=863, symbol_order=871)

bool ImGui::ImageButton(ImTextureID, const ImVec2&, const ImVec2&, const ImVec2&, int, const ImVec4&, const ImVec4&) (void * user_texture_id, const struct ImVec2 & size, const struct ImVec2 & uv0, const struct ImVec2 & uv1, int frame_padding, const struct ImVec4 & bg_col, const struct ImVec4 & tint_col)
{
  bool D.34993;
  bool D.34992;
  const ImGuiID D.34991;
  const ImU32 col;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect image_bb;
  const struct ImRect bb;
  const struct ImVec2 padding;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  struct ImDrawList * D.34989;
  unsigned int D.34988;
  struct ImDrawList * D.34986;
  unsigned int D.34985;
  float D.34982;
  float D.34981;
  float D.34980;
  float D.34979;
  float D.34978;
  float D.34977;
  bool hovered.1130;
  ImGuiCol iftmp.1129;
  bool D.34971;
  bool held.1128;
  bool D.34968;
  bool hovered.1127;
  ImGuiCol iftmp.1126;
  bool D.34960;
  bool retval.1125;
  struct ImVec2 * D.34958;
  struct ImVec2 D.18798;
  struct ImVec2 * D.34957;
  struct ImVec2 D.18799;
  struct ImVec2 D.18800;
  struct ImVec2 * D.34956;
  struct ImVec2 * D.34955;
  struct ImVec2 D.18794;
  struct ImVec2 D.18795;
  struct ImVec2 D.18796;
  float D.34953;
  float D.34952;
  bool D.34949;
  bool D.34946;
  bool _1;
  ImGuiCol iftmp.1126_2;
  ImGuiCol iftmp.1129_3;
  bool _11;
  bool _12;
  const ImGuiID _18;
  float _22;
  float _23;
  struct ImVec2 * _27;
  struct ImVec2 * _31;
  struct ImVec2 * _36;
  struct ImVec2 * _39;
  bool _47;
  bool _48;
  bool retval.1125_49;
  bool _50;
  bool _52;
  bool hovered.1127_54;
  bool _55;
  bool held.1128_56;
  bool _57;
  ImGuiCol iftmp.1126_58;
  bool hovered.1130_59;
  ImGuiCol iftmp.1129_60;
  ImGuiCol iftmp.1129_61;
  ImGuiCol iftmp.1126_62;
  float _66;
  float _67;
  float _68;
  float _70;
  float _72;
  float _75;
  unsigned int _77;
  struct ImDrawList * _78;
  unsigned int _82;
  struct ImDrawList * _83;
  bool _87;

  <bb 2>:
  window_10 = ImGui::GetCurrentWindow ();
  _11 = window_10->SkipItems;
  if (_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = 0;
  goto <bb 19>;

  <bb 4>:
  g_13 = GImGui;
  style_14 = &g_13->Style;
  ImGui::PushID (user_texture_id_15(D));
  _18 = ImGuiWindow::GetID (window_10, "#image", 0B);
  id_19 = _18;
  ImGui::PopID ();
  if (frame_padding_21(D) >= 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _22 = (float) frame_padding_21(D);
  _23 = (float) frame_padding_21(D);
  ImVec2::ImVec2 (&padding, _23, _22);
  goto <bb 7>;

  <bb 6>:
  padding = style_14->FramePadding;

  <bb 7>:
  D.18795 = operator* (&padding, 2.0e+0);
  _27 = &window_10->DC.CursorPos;
  D.18794 = operator+ (_27, size_28(D));
  D.18796 = operator+ (&D.18794, &D.18795);
  _31 = &window_10->DC.CursorPos;
  ImRect::ImRect (&bb, _31, &D.18796);
  D.18796 ={v} {CLOBBER};
  D.18794 ={v} {CLOBBER};
  D.18795 ={v} {CLOBBER};
  _36 = &window_10->DC.CursorPos;
  D.18799 = operator+ (_36, &padding);
  D.18800 = operator+ (&D.18799, size_28(D));
  _39 = &window_10->DC.CursorPos;
  D.18798 = operator+ (_39, &padding);
  ImRect::ImRect (&image_bb, &D.18798, &D.18800);
  D.18798 ={v} {CLOBBER};
  D.18800 ={v} {CLOBBER};
  D.18799 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  _47 = ImGui::ItemAdd (&bb, id_19, 0B);
  _48 = _47;
  retval.1125_49 = ~_48;
  if (retval.1125_49 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _50 = 0;
  goto <bb 19>;

  <bb 9>:
  _52 = ImGui::ButtonBehavior (&bb, id_19, &hovered, &held, 0);
  pressed_53 = _52;
  hovered.1127_54 = hovered;
  _55 = ~hovered.1127_54;
  if (_55 != 0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  held.1128_56 = held;
  _57 = ~held.1128_56;
  if (_57 != 0)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  hovered.1130_59 = hovered;
  if (hovered.1130_59 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.1129_60 = 22;
  goto <bb 14>;

  <bb 13>:
  iftmp.1129_61 = 21;

  <bb 14>:
  # iftmp.1129_3 = PHI <iftmp.1129_60(12), iftmp.1129_61(13)>
  iftmp.1126_62 = iftmp.1129_3;
  goto <bb 16>;

  <bb 15>:
  iftmp.1126_58 = 23;

  <bb 16>:
  # iftmp.1126_2 = PHI <iftmp.1126_62(14), iftmp.1126_58(15)>
  col_64 = ImGui::GetColorU32 (iftmp.1126_2, 1.0e+0);
  ImGui::RenderNavHighlight (&bb, id_19, 1);
  _66 = style_14->FrameRounding;
  _67 = padding.y;
  _68 = padding.x;
  _70 = ImMin (_68, _67);
  _72 = ImClamp (_70, 0.0, _66);
  ImGui::RenderFrame (bb.Min, bb.Max, col_64, 1, _72);
  _75 = bg_col_74(D)->w;
  if (_75 > 0.0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _77 = ImGui::GetColorU32 (bg_col_74(D));
  _78 = window_10->DrawList;
  ImDrawList::AddRectFilled (_78, &image_bb.Min, &image_bb.Max, _77, 0.0, 15);

  <bb 18>:
  _82 = ImGui::GetColorU32 (tint_col_80(D));
  _83 = window_10->DrawList;
  ImDrawList::AddImage (_83, user_texture_id_15(D), &image_bb.Min, &image_bb.Max, uv0_84(D), uv1_85(D), _82);
  _87 = pressed_53;

  <bb 19>:
  # _1 = PHI <_12(3), _50(8), _87(18)>
  padding ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  image_bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L18>:
  return _1;

}



;; Function void ImGui::LogToTTY(int) (_ZN5ImGui8LogToTTYEi, funcdef_no=965, decl_uid=3271, cgraph_uid=864, symbol_order=872)

void ImGui::LogToTTY(int) (int max_depth)
{
  static const char __PRETTY_FUNCTION__[26] = "void ImGui::LogToTTY(int)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.35004;
  struct _IO_FILE * stdout.1131;
  struct FILE * D.34999;
  bool D.34996;
  bool _4;
  struct FILE * _6;
  struct _IO_FILE * stdout.1131_7;
  int _10;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->LogEnabled;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 8> (<L8>);

  <bb 4>:
  window_5 = g_3->CurrentWindow;
  _6 = g_3->LogFile;
  if (_6 == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("g.LogFile == __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7878, &__PRETTY_FUNCTION__);

  <bb 6>:
  stdout.1131_7 = stdout;
  g_3->LogFile = stdout.1131_7;
  g_3->LogEnabled = 1;
  _10 = window_5->DC.TreeDepth;
  g_3->LogStartDepth = _10;
  if (max_depth_12(D) >= 0)
    goto <bb 7>;
  else
    goto <bb 8> (<L8>);

  <bb 7>:
  g_3->LogAutoExpandMaxDepth = max_depth_12(D);

<L8>:
  return;

}



;; Function void ImGui::LogToFile(int, const char*) (_ZN5ImGui9LogToFileEiPKc, funcdef_no=966, decl_uid=3274, cgraph_uid=865, symbol_order=873)

void ImGui::LogToFile(int, const char*) (int max_depth, const char * filename)
{
  struct FILE * D.35034;
  static const char __PRETTY_FUNCTION__[40] = "void ImGui::LogToFile(int, const char*)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.35029;
  struct FILE * D.35025;
  struct FILE * D.35022;
  struct FILE * D.35021;
  struct FILE * D.35017;
  bool D.35009;
  bool _5;
  struct FILE * _9;
  struct FILE * _11;
  struct FILE * _12;
  struct FILE * _14;
  struct FILE * _15;
  int _18;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->LogEnabled;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 15> (<L18>);

  <bb 4>:
  window_6 = g_4->CurrentWindow;
  if (filename_7(D) == 0B)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  filename_8 = g_4->IO.LogFilename;
  if (filename_8 == 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 15> (<L18>);

  <bb 7>:
  # filename_1 = PHI <filename_7(D)(4), filename_8(5)>
  _9 = g_4->LogFile;
  if (_9 == 0B)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  __assert_fail ("g.LogFile == __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7901, &__PRETTY_FUNCTION__);

  <bb 9>:
  _11 = ImFileOpen (filename_1, "ab");
  _12 = _11;
  g_4->LogFile = _12;
  _14 = g_4->LogFile;
  if (_14 == 0B)
    goto <bb 10>;
  else
    goto <bb 13>;

  <bb 10>:
  _15 = g_4->LogFile;
  if (_15 != 0B)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  __assert_fail ("g.LogFile != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7905, &__PRETTY_FUNCTION__);

  <bb 12>:
  goto <bb 15> (<L18>);

  <bb 13>:
  g_4->LogEnabled = 1;
  _18 = window_6->DC.TreeDepth;
  g_4->LogStartDepth = _18;
  if (max_depth_20(D) >= 0)
    goto <bb 14>;
  else
    goto <bb 15> (<L18>);

  <bb 14>:
  g_4->LogAutoExpandMaxDepth = max_depth_20(D);

<L18>:
  return;

}



;; Function void ImGui::LogToClipboard(int) (_ZN5ImGui14LogToClipboardEi, funcdef_no=967, decl_uid=3276, cgraph_uid=866, symbol_order=874)

void ImGui::LogToClipboard(int) (int max_depth)
{
  static const char __PRETTY_FUNCTION__[32] = "void ImGui::LogToClipboard(int)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.35042;
  struct FILE * D.35038;
  bool D.35035;
  bool _4;
  struct FILE * _6;
  int _9;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->LogEnabled;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 8> (<L8>);

  <bb 4>:
  window_5 = g_3->CurrentWindow;
  _6 = g_3->LogFile;
  if (_6 == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("g.LogFile == __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 7922, &__PRETTY_FUNCTION__);

  <bb 6>:
  g_3->LogFile = 0B;
  g_3->LogEnabled = 1;
  _9 = window_5->DC.TreeDepth;
  g_3->LogStartDepth = _9;
  if (max_depth_11(D) >= 0)
    goto <bb 7>;
  else
    goto <bb 8> (<L8>);

  <bb 7>:
  g_3->LogAutoExpandMaxDepth = max_depth_11(D);

<L8>:
  return;

}



;; Function void ImGui::LogFinish() (_ZN5ImGui9LogFinishEv, funcdef_no=968, decl_uid=3277, cgraph_uid=867, symbol_order=875)

void ImGui::LogFinish() ()
{
  const char * D.35072;
  struct ImGuiContext & g;
  struct ImGuiTextBuffer * D.35069;
  const char * D.35068;
  struct ImGuiTextBuffer * D.35067;
  int D.35064;
  struct ImGuiTextBuffer * D.35063;
  bool retval.1133;
  struct FILE * D.35060;
  struct FILE * D.35058;
  struct _IO_FILE * stdout.1132;
  struct FILE * D.35054;
  struct FILE * D.35051;
  bool D.35048;
  bool D.35047;
  bool _7;
  bool _8;
  struct FILE * _10;
  struct FILE * _11;
  struct _IO_FILE * stdout.1132_12;
  struct FILE * _13;
  struct FILE * _15;
  struct ImGuiTextBuffer * _18;
  int _20;
  bool retval.1133_21;
  struct ImGuiTextBuffer * _22;
  const char * _24;
  const char * _25;
  struct ImGuiTextBuffer * _27;

  <bb 2>:
  g_6 = GImGui;
  _7 = g_6->LogEnabled;
  _8 = ~_7;
  if (_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 12> (<L11>);

  <bb 4>:
  ImGui::LogText ("\n");
  _10 = g_6->LogFile;
  if (_10 != 0B)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:
  _11 = g_6->LogFile;
  stdout.1132_12 = stdout;
  if (_11 == stdout.1132_12)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _13 = g_6->LogFile;
  fflush (_13);
  goto <bb 8>;

  <bb 7>:
  _15 = g_6->LogFile;
  fclose (_15);

  <bb 8>:
  g_6->LogFile = 0B;

  <bb 9>:
  _18 = g_6->LogClipboard;
  _20 = ImGuiTextBuffer::size (_18);
  retval.1133_21 = _20 > 1;
  if (retval.1133_21 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _22 = g_6->LogClipboard;
  _24 = ImGuiTextBuffer::begin (_22);
  _25 = _24;
  ImGui::SetClipboardText (_25);
  _27 = g_6->LogClipboard;
  ImGuiTextBuffer::clear (_27);

  <bb 11>:
  g_6->LogEnabled = 0;

<L11>:
  return;

}



;; Function void ImGui::LogButtons() (_ZN5ImGui10LogButtonsEv, funcdef_no=969, decl_uid=3278, cgraph_uid=868, symbol_order=876)

void ImGui::LogButtons() ()
{
  const bool D.35103;
  const bool D.35101;
  const bool D.35099;
  const bool log_to_clipboard;
  const bool log_to_file;
  const bool log_to_tty;
  struct ImGuiContext & g;
  int D.35097;
  int D.35093;
  const char * D.35092;
  int D.35088;
  int * D.35085;
  struct ImVec2 D.18837;
  struct ImVec2 D.18835;
  struct ImVec2 D.18833;
  const bool _9;
  const bool _15;
  const bool _21;
  int * _27;
  int _32;
  const char * _34;
  int _35;
  int _37;

  <bb 2>:
  g_5 = GImGui;
  ImGui::PushID ("LogButtons");
  ImVec2::ImVec2 (&D.18833, 0.0, 0.0);
  _9 = ImGui::Button ("Log To TTY", &D.18833);
  log_to_tty_10 = _9;
  D.18833 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.18835, 0.0, 0.0);
  _15 = ImGui::Button ("Log To File", &D.18835);
  log_to_file_16 = _15;
  D.18835 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImVec2::ImVec2 (&D.18837, 0.0, 0.0);
  _21 = ImGui::Button ("Log To Clipboard", &D.18837);
  log_to_clipboard_22 = _21;
  D.18837 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::PushItemWidth (8.0e+1);
  ImGui::PushAllowKeyboardFocus (0);
  _27 = &g_5->LogAutoExpandMaxDepth;
  ImGui::SliderInt ("Depth", _27, 0, 9, 0B);
  ImGui::PopAllowKeyboardFocus ();
  ImGui::PopItemWidth ();
  ImGui::PopID ();
  if (log_to_tty_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _32 = g_5->LogAutoExpandMaxDepth;
  ImGui::LogToTTY (_32);

  <bb 4>:
  if (log_to_file_16 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _34 = g_5->IO.LogFilename;
  _35 = g_5->LogAutoExpandMaxDepth;
  ImGui::LogToFile (_35, _34);

  <bb 6>:
  if (log_to_clipboard_22 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _37 = g_5->LogAutoExpandMaxDepth;
  ImGui::LogToClipboard (_37);

  <bb 8>:
  return;

}



;; Function bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID, ImGuiTreeNodeFlags) (_ZN5ImGui22TreeNodeBehaviorIsOpenEji, funcdef_no=970, decl_uid=14043, cgraph_uid=869, symbol_order=877)

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID, ImGuiTreeNodeFlags) (ImGuiID id, ImGuiTreeNodeFlags flags)
{
  int D.35142;
  const int D.35141;
  const int stored_value;
  bool is_open;
  struct ImGuiStorage * storage;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.35136;
  int D.35135;
  int D.35132;
  bool D.35129;
  int D.35128;
  int D.35124;
  int iftmp.1134;
  int D.35120;
  int D.35116;
  int D.35113;
  int D.35112;
  int D.35109;
  bool D.35108;
  int D.35105;
  bool _4;
  int iftmp.1134_5;
  int _10;
  bool _11;
  int _16;
  int _17;
  int _18;
  int _20;
  const int _24;
  int _27;
  int _31;
  int iftmp.1134_32;
  int iftmp.1134_33;
  int _35;
  int _36;
  bool _38;
  int _39;
  int _40;
  int _41;
  bool _43;

  <bb 2>:
  _10 = flags_9(D) & 256;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _11 = 1;
  goto <bb 20> (<L21>);

  <bb 4>:
  g_13 = GImGui;
  window_14 = g_13->CurrentWindow;
  storage_15 = window_14->DC.StateStorage;
  _16 = g_13->NextTreeNodeOpenCond;
  if (_16 != 0)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  _17 = g_13->NextTreeNodeOpenCond;
  _18 = _17 & 1;
  if (_18 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  is_open_19 = g_13->NextTreeNodeOpenVal;
  _20 = (int) is_open_19;
  ImGuiStorage::SetInt (storage_15, id_21(D), _20);
  goto <bb 10>;

  <bb 7>:
  _24 = ImGuiStorage::GetInt (storage_15, id_21(D), -1);
  stored_value_25 = _24;
  if (stored_value_25 == -1)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  is_open_26 = g_13->NextTreeNodeOpenVal;
  _27 = (int) is_open_26;
  ImGuiStorage::SetInt (storage_15, id_21(D), _27);
  goto <bb 10>;

  <bb 9>:
  is_open_29 = stored_value_25 != 0;

  <bb 10>:
  # is_open_1 = PHI <is_open_19(6), is_open_26(8), is_open_29(9)>
  g_13->NextTreeNodeOpenCond = 0;
  goto <bb 15>;

  <bb 11>:
  _31 = flags_9(D) & 32;
  if (_31 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.1134_32 = 1;
  goto <bb 14>;

  <bb 13>:
  iftmp.1134_33 = 0;

  <bb 14>:
  # iftmp.1134_5 = PHI <iftmp.1134_32(12), iftmp.1134_33(13)>
  _35 = ImGuiStorage::GetInt (storage_15, id_21(D), iftmp.1134_5);
  _36 = _35;
  is_open_37 = _36 != 0;

  <bb 15>:
  # is_open_2 = PHI <is_open_1(10), is_open_37(14)>
  _38 = g_13->LogEnabled;
  if (_38 != 0)
    goto <bb 16>;
  else
    goto <bb 19>;

  <bb 16>:
  _39 = flags_9(D) & 16;
  if (_39 == 0)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  _40 = window_14->DC.TreeDepth;
  _41 = g_13->LogAutoExpandMaxDepth;
  if (_40 < _41)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  is_open_42 = 1;

  <bb 19>:
  # is_open_3 = PHI <is_open_2(15), is_open_2(16), is_open_2(17), is_open_42(18)>
  _43 = is_open_3;

  # _4 = PHI <_11(3), _43(19)>
<L21>:
  return _4;

}



;; Function bool ImGui::TreeNodeBehavior(ImGuiID, ImGuiTreeNodeFlags, const char*, const char*) (_ZN5ImGui16TreeNodeBehaviorEjiPKcS1_, funcdef_no=971, decl_uid=14040, cgraph_uid=870, symbol_order=878)

bool ImGui::TreeNodeBehavior(ImGuiID, ImGuiTreeNodeFlags, const char*, const char*) (ImGuiID id, ImGuiTreeNodeFlags flags, const char * label, const char * label_end)
{
  bool D.35412;
  bool D.35411;
  bool D.35410;
  const char log_suffix[3];
  const char log_prefix[4];
  bool toggled;
  const struct ImVec2 text_pos;
  const ImU32 col;
  bool pressed;
  bool held;
  bool hovered;
  ImGuiButtonFlags button_flags;
  bool item_add;
  bool is_open;
  const struct ImRect interact_bb;
  const float text_width;
  const float text_offset_x;
  struct ImRect frame_bb;
  const float frame_height;
  const float text_base_offset_y;
  const struct ImVec2 label_size;
  const struct ImVec2 padding;
  const bool display_frame;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  int D.35404;
  bool D.35398;
  struct ImVec2 D.35396;
  float D.35395;
  float D.35394;
  float D.35393;
  float D.35392;
  struct ImVec2 D.18901;
  ImGuiDir iftmp.1148;
  int D.35385;
  struct ImVec2 D.35383;
  float D.35382;
  float D.35381;
  float D.35380;
  float D.35379;
  struct ImVec2 D.18899;
  int D.35376;
  int D.35375;
  bool hovered.1147;
  struct ImVec2 D.18896;
  const char * D.35368;
  const char * D.35367;
  struct ImVec2 D.18895;
  const char * D.35366;
  bool D.35363;
  struct ImVec2 D.35362;
  float D.35361;
  struct ImVec2 D.18891;
  ImGuiDir iftmp.1146;
  float D.35356;
  struct ImVec2 D.18887;
  bool hovered.1145;
  ImGuiCol iftmp.1144;
  bool D.35348;
  bool hovered.1143;
  bool D.35345;
  bool held.1142;
  ImGuiCol iftmp.1141;
  int D.35336;
  struct ImGuiStorage * D.35333;
  int D.35332;
  bool D.35326;
  int D.35323;
  bool D.35320;
  unsigned int D.35317;
  int D.35311;
  bool D.35308;
  unsigned int D.35305;
  bool D.35298;
  bool D.35296;
  int D.35293;
  bool D.35290;
  bool D.35289;
  bool D.35287;
  float D.35286;
  float D.35285;
  float D.35284;
  struct ImVec2 D.18883;
  bool iftmp.1140;
  bool D.18884;
  int D.35278;
  unsigned int D.35277;
  int D.35275;
  bool iftmp.1139;
  int D.35266;
  int D.35261;
  int iftmp.1138;
  int D.35257;
  int D.35253;
  int D.35249;
  int iftmp.1137;
  int D.35244;
  bool D.35239;
  int D.35238;
  int D.35237;
  unsigned int D.35235;
  unsigned int D.35234;
  int D.35233;
  int D.35232;
  unsigned int D.35231;
  int D.35228;
  int D.35225;
  bool D.35222;
  bool D.35221;
  float D.35218;
  float D.35217;
  float D.35216;
  float D.35215;
  float D.35214;
  float D.35213;
  float D.35212;
  float D.35211;
  struct ImVec2 D.18871;
  float D.35206;
  float D.35205;
  float D.35204;
  float D.35201;
  float iftmp.1136;
  float D.35199;
  float D.35198;
  float D.35196;
  float iftmp.1135;
  float D.35192;
  float D.35190;
  float D.35189;
  float D.35188;
  int D.35187;
  float D.35186;
  float D.35185;
  float D.35184;
  float D.35183;
  float D.35182;
  float D.35181;
  int D.35180;
  float D.35179;
  float D.35178;
  float D.35177;
  struct ImVec2 * D.35174;
  float D.35173;
  float D.35172;
  struct ImVec2 D.18866;
  float D.35171;
  float D.35170;
  float D.35169;
  struct ImVec2 D.18867;
  float D.35168;
  float D.35167;
  float D.35166;
  float D.35165;
  float D.35164;
  float D.35163;
  float D.35162;
  float D.35161;
  float D.35160;
  float D.35159;
  float D.35158;
  float D.35157;
  float D.35153;
  int D.35152;
  int D.35147;
  bool D.35146;
  bool D.35143;
  bool _11;
  float iftmp.1135_12;
  float iftmp.1136_13;
  int iftmp.1137_14;
  int iftmp.1138_15;
  bool iftmp.1139_16;
  bool iftmp.1140_17;
  ImGuiCol iftmp.1141_18;
  ImGuiCol iftmp.1144_19;
  ImGuiDir iftmp.1146_20;
  ImGuiDir iftmp.1148_21;
  bool _47;
  bool _48;
  int _52;
  int _54;
  float _55;
  float _63;
  float _64;
  float _67;
  float _68;
  float _69;
  float _70;
  float _71;
  float _72;
  float _73;
  float _74;
  float _75;
  float _77;
  float _80;
  float _81;
  float _82;
  float _84;
  float _85;
  struct ImVec2 * _87;
  float _90;
  float _91;
  float _92;
  int _93;
  float _94;
  float _95;
  float _96;
  float _98;
  float _99;
  float _100;
  int _101;
  float _102;
  float _103;
  float _104;
  float _106;
  float _107;
  float iftmp.1135_108;
  float _109;
  float iftmp.1135_110;
  float _112;
  float _113;
  float _114;
  float _115;
  float _116;
  float iftmp.1136_117;
  float iftmp.1136_118;
  float _124;
  float _125;
  float _126;
  float _127;
  float _128;
  float _129;
  float _130;
  float _131;
  bool _135;
  bool _137;
  bool _138;
  int _139;
  int _140;
  unsigned int _141;
  int _142;
  int _143;
  unsigned int _144;
  unsigned int _145;
  bool _148;
  int _150;
  int _151;
  bool _154;
  int _155;
  bool _157;
  int _158;
  int iftmp.1137_159;
  int iftmp.1137_160;
  int _162;
  int _164;
  int _165;
  int iftmp.1138_166;
  int iftmp.1138_167;
  bool _170;
  int _172;
  int _174;
  unsigned int _175;
  bool iftmp.1139_176;
  bool iftmp.1139_177;
  int _179;
  float _180;
  float _181;
  float _182;
  bool _185;
  bool _186;
  bool _187;
  bool iftmp.1140_188;
  bool iftmp.1140_189;
  bool _190;
  int _193;
  bool _194;
  bool _196;
  unsigned int _198;
  bool _199;
  int _200;
  unsigned int _203;
  bool _204;
  int _205;
  bool _206;
  int _210;
  struct ImGuiStorage * _211;
  int _213;
  bool held.1142_215;
  bool _216;
  bool hovered.1143_217;
  bool _218;
  ImGuiCol iftmp.1141_219;
  bool hovered.1145_220;
  ImGuiCol iftmp.1144_221;
  ImGuiCol iftmp.1144_222;
  ImGuiCol iftmp.1141_223;
  float _229;
  ImGuiDir iftmp.1146_232;
  ImGuiDir iftmp.1146_233;
  float _234;
  bool _239;
  const char * _242;
  const char * _247;
  const char * _248;
  bool hovered.1147_260;
  int _261;
  int _264;
  float _265;
  float _266;
  float _267;
  float _268;
  int _274;
  ImGuiDir iftmp.1148_275;
  ImGuiDir iftmp.1148_276;
  float _277;
  float _278;
  float _279;
  float _280;
  bool _286;
  int _289;
  bool _291;

  <bb 2>:
  window_46 = ImGui::GetCurrentWindow ();
  _47 = window_46->SkipItems;
  if (_47 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _48 = 0;
  goto <bb 105>;

  <bb 4>:
  g_49 = GImGui;
  style_50 = &g_49->Style;
  _52 = flags_51(D) & 2;
  display_frame_53 = _52 != 0;
  if (display_frame_53 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _54 = flags_51(D) & 1024;
  if (_54 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  padding = style_50->FramePadding;
  goto <bb 8>;

  <bb 7>:
  _55 = style_50->FramePadding.x;
  ImVec2::ImVec2 (&padding, _55, 0.0);

  <bb 8>:
  if (label_end_58(D) == 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  label_end_61 = ImGui::FindRenderedTextEnd (label_59(D), 0B);

  <bb 10>:
  # label_end_1 = PHI <label_end_58(D)(8), label_end_61(9)>
  label_size = ImGui::CalcTextSize (label_59(D), label_end_1, 0, -1.0e+0);
  _63 = window_46->DC.CurrentLineTextBaseOffset;
  _64 = padding.y;
  text_base_offset_y_66 = ImMax (_64, _63);
  _67 = label_size.y;
  _68 = padding.y;
  _69 = _68 * 2.0e+0;
  _70 = _67 + _69;
  _71 = g_49->FontSize;
  _72 = style_50->FramePadding.y;
  _73 = _72 * 2.0e+0;
  _74 = _71 + _73;
  _75 = window_46->DC.CurrentLineHeight;
  _77 = ImMin (_75, _74);
  frame_height_79 = ImMax (_77, _70);
  _80 = window_46->DC.CursorPos.y;
  _81 = _80 + frame_height_79;
  _82 = window_46->Pos.x;
  D.18866 = ImGui::GetContentRegionMax ();
  _84 = D.18866.x;
  _85 = _82 + _84;
  ImVec2::ImVec2 (&D.18867, _85, _81);
  _87 = &window_46->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _87, &D.18867);
  D.18867 ={v} {CLOBBER};
  if (display_frame_53 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _90 = frame_bb.Min.x;
  _91 = window_46->WindowPadding.x;
  _92 = _91 * 5.0e-1;
  _93 = (int) _92;
  _94 = (float) _93;
  _95 = _94 - 1.0e+0;
  _96 = _90 - _95;
  frame_bb.Min.x = _96;
  _98 = frame_bb.Max.x;
  _99 = window_46->WindowPadding.x;
  _100 = _99 * 5.0e-1;
  _101 = (int) _100;
  _102 = (float) _101;
  _103 = _102 - 1.0e+0;
  _104 = _98 + _103;
  frame_bb.Max.x = _104;

  <bb 12>:
  _106 = g_49->FontSize;
  if (display_frame_53 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _107 = padding.x;
  iftmp.1135_108 = _107 * 3.0e+0;
  goto <bb 15>;

  <bb 14>:
  _109 = padding.x;
  iftmp.1135_110 = _109 * 2.0e+0;

  <bb 15>:
  # iftmp.1135_12 = PHI <iftmp.1135_108(13), iftmp.1135_110(14)>
  text_offset_x_111 = _106 + iftmp.1135_12;
  _112 = g_49->FontSize;
  _113 = label_size.x;
  if (_113 > 0.0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _114 = label_size.x;
  _115 = padding.x;
  _116 = _115 * 2.0e+0;
  iftmp.1136_117 = _114 + _116;
  goto <bb 18>;

  <bb 17>:
  iftmp.1136_118 = 0.0;

  <bb 18>:
  # iftmp.1136_13 = PHI <iftmp.1136_117(16), iftmp.1136_118(17)>
  text_width_119 = _112 + iftmp.1136_13;
  ImVec2::ImVec2 (&D.18871, text_width_119, frame_height_79);
  ImGui::ItemSize (&D.18871, text_base_offset_y_66);
  D.18871 ={v} {CLOBBER};
  if (display_frame_53 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  interact_bb = frame_bb;
  goto <bb 21>;

  <bb 20>:
  _124 = frame_bb.Max.y;
  _125 = frame_bb.Min.x;
  _126 = _125 + text_width_119;
  _127 = style_50->ItemSpacing.x;
  _128 = _127 * 2.0e+0;
  _129 = _126 + _128;
  _130 = frame_bb.Min.y;
  _131 = frame_bb.Min.x;
  ImRect::ImRect (&interact_bb, _131, _130, _129, _124);

  <bb 21>:
  _135 = ImGui::TreeNodeBehaviorIsOpen (id_133(D), flags_51(D));
  is_open_136 = _135;
  if (is_open_136 != 0)
    goto <bb 22>;
  else
    goto <bb 26>;

  <bb 22>:
  _137 = g_49->NavIdIsAlive;
  _138 = ~_137;
  if (_138 != 0)
    goto <bb 23>;
  else
    goto <bb 26>;

  <bb 23>:
  _139 = flags_51(D) & 8192;
  if (_139 != 0)
    goto <bb 24>;
  else
    goto <bb 26>;

  <bb 24>:
  _140 = flags_51(D) & 8;
  if (_140 == 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _141 = window_46->DC.TreeDepthMayJumpToParentOnPop;
  _142 = window_46->DC.TreeDepth;
  _143 = 1 << _142;
  _144 = (unsigned int) _143;
  _145 = _141 | _144;
  window_46->DC.TreeDepthMayJumpToParentOnPop = _145;

  <bb 26>:
  _148 = ImGui::ItemAdd (&interact_bb, id_133(D), 0B);
  item_add_149 = _148;
  _150 = window_46->DC.LastItemStatusFlags;
  _151 = _150 | 2;
  window_46->DC.LastItemStatusFlags = _151;
  window_46->DC.LastItemDisplayRect = frame_bb;
  _154 = ~item_add_149;
  if (_154 != 0)
    goto <bb 27>;
  else
    goto <bb 31>;

  <bb 27>:
  if (is_open_136 != 0)
    goto <bb 28>;
  else
    goto <bb 30>;

  <bb 28>:
  _155 = flags_51(D) & 8;
  if (_155 == 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  ImGui::TreePushRawID (id_133(D));

  <bb 30>:
  _157 = is_open_136;
  goto <bb 105>;

  <bb 31>:
  _158 = flags_51(D) & 4;
  if (_158 != 0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  iftmp.1137_159 = 1088;
  goto <bb 34>;

  <bb 33>:
  iftmp.1137_160 = 1024;

  <bb 34>:
  # iftmp.1137_14 = PHI <iftmp.1137_159(32), iftmp.1137_160(33)>
  button_flags_161 = iftmp.1137_14;
  _162 = flags_51(D) & 256;
  if (_162 == 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  button_flags_163 = button_flags_161 | 4096;

  <bb 36>:
  # button_flags_4 = PHI <button_flags_161(34), button_flags_163(35)>
  _164 = flags_51(D) & 64;
  if (_164 != 0)
    goto <bb 37>;
  else
    goto <bb 41>;

  <bb 37>:
  _165 = flags_51(D) & 128;
  if (_165 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  iftmp.1138_166 = 18;
  goto <bb 40>;

  <bb 39>:
  iftmp.1138_167 = 16;

  <bb 40>:
  # iftmp.1138_15 = PHI <iftmp.1138_166(38), iftmp.1138_167(39)>
  button_flags_168 = iftmp.1138_15 | button_flags_4;

  <bb 41>:
  # button_flags_5 = PHI <button_flags_4(36), button_flags_168(40)>
  _170 = ImGui::ButtonBehavior (&interact_bb, id_133(D), &hovered, &held, button_flags_5);
  pressed_171 = _170;
  _172 = flags_51(D) & 256;
  if (_172 == 0)
    goto <bb 42>;
  else
    goto <bb 71>;

  <bb 42>:
  toggled_173 = 0;
  if (pressed_171 != 0)
    goto <bb 43>;
  else
    goto <bb 58>;

  <bb 43>:
  _174 = flags_51(D) & 192;
  if (_174 == 0)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  _175 = g_49->NavActivateId;
  if (_175 == id_133(D))
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  iftmp.1139_177 = 1;
  goto <bb 47>;

  <bb 46>:
  iftmp.1139_176 = 0;

  <bb 47>:
  # iftmp.1139_16 = PHI <iftmp.1139_177(45), iftmp.1139_176(46)>
  toggled_178 = iftmp.1139_16;
  _179 = flags_51(D) & 128;
  if (_179 != 0)
    goto <bb 48>;
  else
    goto <bb 53>;

  <bb 48>:
  _180 = interact_bb.Max.y;
  _181 = interact_bb.Min.x;
  _182 = _181 + text_offset_x_111;
  ImVec2::ImVec2 (&D.18883, _182, _180);
  _185 = ImGui::IsMouseHoveringRect (&interact_bb.Min, &D.18883, 1);
  if (_185 != 0)
    goto <bb 49>;
  else
    goto <bb 51>;

  <bb 49>:
  _186 = g_49->NavDisableMouseHover;
  _187 = ~_186;
  if (_187 != 0)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  iftmp.1140_188 = 1;
  goto <bb 52>;

  <bb 51>:
  iftmp.1140_189 = 0;

  <bb 52>:
  # iftmp.1140_17 = PHI <iftmp.1140_188(50), iftmp.1140_189(51)>
  _190 = iftmp.1140_17;
  toggled_191 = toggled_178 | _190;
  D.18883 ={v} {CLOBBER};

  <bb 53>:
  # toggled_6 = PHI <toggled_178(47), toggled_191(52)>
  _193 = flags_51(D) & 64;
  if (_193 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  _194 = g_49->IO.MouseDoubleClicked[0];
  toggled_195 = _194 | toggled_6;

  <bb 55>:
  # toggled_7 = PHI <toggled_6(53), toggled_195(54)>
  _196 = g_49->DragDropActive;
  if (_196 != 0)
    goto <bb 56>;
  else
    goto <bb 58>;

  <bb 56>:
  if (is_open_136 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  toggled_197 = 0;

  <bb 58>:
  # toggled_8 = PHI <toggled_173(42), toggled_7(56), toggled_7(55), toggled_197(57)>
  _198 = g_49->NavId;
  if (_198 == id_133(D))
    goto <bb 59>;
  else
    goto <bb 63>;

  <bb 59>:
  _199 = g_49->NavMoveRequest;
  if (_199 != 0)
    goto <bb 60>;
  else
    goto <bb 63>;

  <bb 60>:
  _200 = g_49->NavMoveDir;
  if (_200 == 0)
    goto <bb 61>;
  else
    goto <bb 63>;

  <bb 61>:
  if (is_open_136 != 0)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  toggled_201 = 1;
  ImGui::NavMoveRequestCancel ();

  <bb 63>:
  # toggled_9 = PHI <toggled_8(58), toggled_8(59), toggled_8(60), toggled_8(61), toggled_201(62)>
  _203 = g_49->NavId;
  if (_203 == id_133(D))
    goto <bb 64>;
  else
    goto <bb 68>;

  <bb 64>:
  _204 = g_49->NavMoveRequest;
  if (_204 != 0)
    goto <bb 65>;
  else
    goto <bb 68>;

  <bb 65>:
  _205 = g_49->NavMoveDir;
  if (_205 == 1)
    goto <bb 66>;
  else
    goto <bb 68>;

  <bb 66>:
  _206 = ~is_open_136;
  if (_206 != 0)
    goto <bb 67>;
  else
    goto <bb 68>;

  <bb 67>:
  toggled_207 = 1;
  ImGui::NavMoveRequestCancel ();

  <bb 68>:
  # toggled_10 = PHI <toggled_9(63), toggled_9(64), toggled_9(65), toggled_9(66), toggled_207(67)>
  if (toggled_10 != 0)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  is_open_209 = ~is_open_136;
  _210 = (int) is_open_209;
  _211 = window_46->DC.StateStorage;
  ImGuiStorage::SetInt (_211, id_133(D), _210);

  <bb 70>:
  # is_open_2 = PHI <is_open_136(68), is_open_209(69)>

  <bb 71>:
  # is_open_3 = PHI <is_open_136(41), is_open_2(70)>
  _213 = flags_51(D) & 4;
  if (_213 != 0)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  ImGui::SetItemAllowOverlap ();

  <bb 73>:
  held.1142_215 = held;
  _216 = ~held.1142_215;
  if (_216 != 0)
    goto <bb 75>;
  else
    goto <bb 74>;

  <bb 74>:
  hovered.1143_217 = hovered;
  _218 = ~hovered.1143_217;
  if (_218 != 0)
    goto <bb 75>;
  else
    goto <bb 79>;

  <bb 75>:
  hovered.1145_220 = hovered;
  if (hovered.1145_220 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  iftmp.1144_221 = 25;
  goto <bb 78>;

  <bb 77>:
  iftmp.1144_222 = 24;

  <bb 78>:
  # iftmp.1144_19 = PHI <iftmp.1144_221(76), iftmp.1144_222(77)>
  iftmp.1141_223 = iftmp.1144_19;
  goto <bb 80>;

  <bb 79>:
  iftmp.1141_219 = 26;

  <bb 80>:
  # iftmp.1141_18 = PHI <iftmp.1141_223(78), iftmp.1141_219(79)>
  col_225 = ImGui::GetColorU32 (iftmp.1141_18, 1.0e+0);
  ImVec2::ImVec2 (&D.18887, text_offset_x_111, text_base_offset_y_66);
  text_pos = operator+ (&frame_bb.Min, &D.18887);
  D.18887 ={v} {CLOBBER};
  if (display_frame_53 != 0)
    goto <bb 81>;
  else
    goto <bb 88>;

  <bb 81>:
  _229 = style_50->FrameRounding;
  ImGui::RenderFrame (frame_bb.Min, frame_bb.Max, col_225, 1, _229);
  ImGui::RenderNavHighlight (&frame_bb, id_133(D), 2);
  if (is_open_3 != 0)
    goto <bb 82>;
  else
    goto <bb 83>;

  <bb 82>:
  iftmp.1146_232 = 3;
  goto <bb 84>;

  <bb 83>:
  iftmp.1146_233 = 1;

  <bb 84>:
  # iftmp.1146_20 = PHI <iftmp.1146_232(82), iftmp.1146_233(83)>
  _234 = padding.x;
  ImVec2::ImVec2 (&D.18891, _234, text_base_offset_y_66);
  D.35362 = operator+ (&frame_bb.Min, &D.18891);
  ImGui::RenderArrow (D.35362, iftmp.1146_20, 1.0e+0);
  D.18891 ={v} {CLOBBER};
  _239 = g_49->LogEnabled;
  if (_239 != 0)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  log_prefix = "\n##";
  log_suffix = "##";
  _242 = &log_prefix + 3;
  LogRenderedText (&text_pos, &log_prefix, _242);
  ImVec2::ImVec2 (&D.18895, 0.0, 0.0);
  ImGui::RenderTextClipped (&text_pos, &frame_bb.Max, label_59(D), label_end_1, &label_size, &D.18895, 0B);
  D.18895 ={v} {CLOBBER};
  _247 = &log_suffix + 3;
  _248 = &log_suffix + 1;
  LogRenderedText (&text_pos, _248, _247);
  log_prefix ={v} {CLOBBER};
  log_suffix ={v} {CLOBBER};
  goto <bb 87>;

  <bb 86>:
  ImVec2::ImVec2 (&D.18896, 0.0, 0.0);
  ImGui::RenderTextClipped (&text_pos, &frame_bb.Max, label_59(D), label_end_1, &label_size, &D.18896, 0B);
  D.18896 ={v} {CLOBBER};

  <bb 87>:
  goto <bb 101>;

  <bb 88>:
  hovered.1147_260 = hovered;
  if (hovered.1147_260 != 0)
    goto <bb 90>;
  else
    goto <bb 89>;

  <bb 89>:
  _261 = flags_51(D) & 1;
  if (_261 != 0)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  ImGui::RenderFrame (frame_bb.Min, frame_bb.Max, col_225, 0, 0.0);
  ImGui::RenderNavHighlight (&frame_bb, id_133(D), 2);

  <bb 91>:
  _264 = flags_51(D) & 512;
  if (_264 != 0)
    goto <bb 92>;
  else
    goto <bb 93>;

  <bb 92>:
  _265 = g_49->FontSize;
  _266 = _265 * 5.0e-1;
  _267 = _266 + text_base_offset_y_66;
  _268 = text_offset_x_111 * 5.0e-1;
  ImVec2::ImVec2 (&D.18899, _268, _267);
  D.35383 = operator+ (&frame_bb.Min, &D.18899);
  ImGui::RenderBullet (D.35383);
  D.18899 ={v} {CLOBBER};
  goto <bb 98>;

  <bb 93>:
  _274 = flags_51(D) & 256;
  if (_274 == 0)
    goto <bb 94>;
  else
    goto <bb 98>;

  <bb 94>:
  if (is_open_3 != 0)
    goto <bb 95>;
  else
    goto <bb 96>;

  <bb 95>:
  iftmp.1148_275 = 3;
  goto <bb 97>;

  <bb 96>:
  iftmp.1148_276 = 1;

  <bb 97>:
  # iftmp.1148_21 = PHI <iftmp.1148_275(95), iftmp.1148_276(96)>
  _277 = g_49->FontSize;
  _278 = _277 * 1.500000059604644775390625e-1;
  _279 = _278 + text_base_offset_y_66;
  _280 = padding.x;
  ImVec2::ImVec2 (&D.18901, _280, _279);
  D.35396 = operator+ (&frame_bb.Min, &D.18901);
  ImGui::RenderArrow (D.35396, iftmp.1148_21, 6.99999988079071044921875e-1);
  D.18901 ={v} {CLOBBER};

  <bb 98>:
  _286 = g_49->LogEnabled;
  if (_286 != 0)
    goto <bb 99>;
  else
    goto <bb 100>;

  <bb 99>:
  LogRenderedText (&text_pos, ">", 0B);

  <bb 100>:
  ImGui::RenderText (text_pos, label_59(D), label_end_1, 0);

  <bb 101>:
  if (is_open_3 != 0)
    goto <bb 102>;
  else
    goto <bb 104>;

  <bb 102>:
  _289 = flags_51(D) & 8;
  if (_289 == 0)
    goto <bb 103>;
  else
    goto <bb 104>;

  <bb 103>:
  ImGui::TreePushRawID (id_133(D));

  <bb 104>:
  _291 = is_open_3;

  <bb 105>:
  # _11 = PHI <_48(3), _157(30), _291(104)>
  padding ={v} {CLOBBER};
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  interact_bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  text_pos ={v} {CLOBBER};

<L135>:
  return _11;

}



;; Function bool ImGui::CollapsingHeader(const char*, ImGuiTreeNodeFlags) (_ZN5ImGui16CollapsingHeaderEPKci, funcdef_no=972, decl_uid=3147, cgraph_uid=871, symbol_order=879)

bool ImGui::CollapsingHeader(const char*, ImGuiTreeNodeFlags) (const char * label, ImGuiTreeNodeFlags flags)
{
  bool D.35429;
  unsigned int D.35428;
  struct ImGuiWindow * window;
  unsigned int D.35426;
  int D.35425;
  bool D.35424;
  bool D.35421;
  bool _1;
  bool _6;
  bool _7;
  int _9;
  unsigned int _12;
  unsigned int _13;
  bool _15;
  bool _16;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 0;
  goto <bb 5> (<L2>);

  <bb 4>:
  _9 = flags_8(D) | 26;
  _12 = ImGuiWindow::GetID (window_5, label_10(D), 0B);
  _13 = _12;
  _15 = ImGui::TreeNodeBehavior (_13, _9, label_10(D), 0B);
  _16 = _15;

  # _1 = PHI <_7(3), _16(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::CollapsingHeader(const char*, bool*, ImGuiTreeNodeFlags) (_ZN5ImGui16CollapsingHeaderEPKcPbi, funcdef_no=973, decl_uid=3151, cgraph_uid=872, symbol_order=880)

bool ImGui::CollapsingHeader(const char*, bool*, ImGuiTreeNodeFlags) (const char * label, bool * p_open, ImGuiTreeNodeFlags flags)
{
  bool D.35472;
  unsigned int D.35471;
  bool D.35470;
  ImGuiID D.35469;
  struct ImGuiItemHoveredDataBackup last_item_backup;
  float button_sz;
  struct ImGuiContext & g;
  bool is_open;
  ImGuiID id;
  struct ImGuiWindow * window;
  unsigned int D.35463;
  const void * D.35462;
  long int D.35461;
  unsigned int D.35460;
  float D.35459;
  float D.35458;
  float D.35457;
  float D.35456;
  float D.35455;
  float D.35454;
  float D.35453;
  float D.35452;
  float D.35451;
  float D.35450;
  struct ImVec2 D.18947;
  bool retval.1150;
  float D.35448;
  int D.35445;
  int iftmp.1149;
  int D.35440;
  bool D.35437;
  bool D.35436;
  bool D.35433;
  bool D.35430;
  bool _1;
  int iftmp.1149_2;
  bool _11;
  bool _12;
  bool _14;
  bool _15;
  bool _16;
  ImGuiID _19;
  int _22;
  int iftmp.1149_23;
  int iftmp.1149_24;
  int _25;
  bool _27;
  float _30;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _38;
  float _40;
  float _41;
  float _42;
  float _43;
  unsigned int _45;
  long int _46;
  const void * _47;
  unsigned int _49;
  unsigned int _50;
  bool _52;
  bool retval.1150_53;
  bool _60;

  <bb 2>:
  window_10 = ImGui::GetCurrentWindow ();
  _11 = window_10->SkipItems;
  if (_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = 0;
  goto <bb 15> (<L15>);

  <bb 4>:
  if (p_open_13(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _14 = *p_open_13(D);
  _15 = ~_14;
  if (_15 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _16 = 0;
  goto <bb 15> (<L15>);

  <bb 7>:
  _19 = ImGuiWindow::GetID (window_10, label_17(D), 0B);
  id_20 = _19;
  _22 = flags_21(D) | 26;
  if (p_open_13(D) != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1149_23 = 4;
  goto <bb 10>;

  <bb 9>:
  iftmp.1149_24 = 0;

  <bb 10>:
  # iftmp.1149_2 = PHI <iftmp.1149_23(8), iftmp.1149_24(9)>
  _25 = _22 | iftmp.1149_2;
  _27 = ImGui::TreeNodeBehavior (id_20, _25, label_17(D), 0B);
  is_open_28 = _27;
  if (p_open_13(D) != 0B)
    goto <bb 11>;
  else
    goto <bb 14>;

  <bb 11>:
  g_29 = GImGui;
  _30 = g_29->FontSize;
  button_sz_31 = _30 * 5.0e-1;
  ImGuiItemHoveredDataBackup::ImGuiItemHoveredDataBackup (&last_item_backup);
  _33 = window_10->DC.LastItemRect.Min.y;
  _34 = g_29->Style.FramePadding.y;
  _35 = _33 + _34;
  _36 = _35 + button_sz_31;
  _37 = window_10->ClipRect.Max.x;
  _38 = window_10->DC.LastItemRect.Max.x;
  _40 = ImMin (_38, _37);
  _41 = g_29->Style.FramePadding.x;
  _42 = _40 - _41;
  _43 = _42 - button_sz_31;
  ImVec2::ImVec2 (&D.18947, _43, _36);
  _45 = id_20 + 1;
  _46 = (long int) _45;
  _47 = (const void *) _46;
  _49 = ImGuiWindow::GetID (window_10, _47);
  _50 = _49;
  _52 = ImGui::CloseButton (_50, &D.18947, button_sz_31);
  retval.1150_53 = _52;
  D.18947 ={v} {CLOBBER};
  if (retval.1150_53 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  *p_open_13(D) = 0;

  <bb 13>:
  ImGuiItemHoveredDataBackup::Restore (&last_item_backup);
  last_item_backup ={v} {CLOBBER};

  <bb 14>:
  _60 = is_open_28;

  # _1 = PHI <_12(3), _16(6), _60(14)>
<L15>:
  return _1;

}



;; Function bool ImGui::TreeNodeEx(const char*, ImGuiTreeNodeFlags) (_ZN5ImGui10TreeNodeExEPKci, funcdef_no=974, decl_uid=3116, cgraph_uid=873, symbol_order=881)

bool ImGui::TreeNodeEx(const char*, ImGuiTreeNodeFlags) (const char * label, ImGuiTreeNodeFlags flags)
{
  bool D.35490;
  unsigned int D.35489;
  struct ImGuiWindow * window;
  unsigned int D.35487;
  bool D.35486;
  bool D.35483;
  bool _1;
  bool _6;
  bool _7;
  unsigned int _10;
  unsigned int _11;
  bool _14;
  bool _15;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 0;
  goto <bb 5> (<L2>);

  <bb 4>:
  _10 = ImGuiWindow::GetID (window_5, label_8(D), 0B);
  _11 = _10;
  _14 = ImGui::TreeNodeBehavior (_11, flags_12(D), label_8(D), 0B);
  _15 = _14;

  # _1 = PHI <_7(3), _15(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::TreeNodeExV(const char*, ImGuiTreeNodeFlags, const char*, __va_list_tag*) (_ZN5ImGui11TreeNodeExVEPKciS1_P13__va_list_tag, funcdef_no=975, decl_uid=3129, cgraph_uid=874, symbol_order=882)

bool ImGui::TreeNodeExV(const char*, ImGuiTreeNodeFlags, const char*, __va_list_tag*) (const char * str_id, ImGuiTreeNodeFlags flags, const char * fmt, struct  * args)
{
  bool D.35503;
  unsigned int D.35502;
  const char * label_end;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  unsigned int D.35500;
  char[3073] * D.35499;
  sizetype D.35498;
  int D.35497;
  char[3073] * D.35496;
  char[3073] * D.35495;
  bool D.35494;
  bool D.35491;
  bool _1;
  bool _6;
  bool _7;
  char[3073] * _9;
  char[3073] * _10;
  int _14;
  sizetype _15;
  char[3073] * _17;
  unsigned int _20;
  unsigned int _21;
  bool _24;
  bool _25;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 0;
  goto <bb 5> (<L2>);

  <bb 4>:
  g_8 = GImGui;
  _9 = &g_8->TempBuffer;
  _10 = &g_8->TempBuffer;
  _14 = ImFormatStringV (_10, 3073, fmt_11(D), args_12(D));
  _15 = (sizetype) _14;
  label_end_16 = _9 + _15;
  _17 = &g_8->TempBuffer;
  _20 = ImGuiWindow::GetID (window_5, str_id_18(D), 0B);
  _21 = _20;
  _24 = ImGui::TreeNodeBehavior (_21, flags_22(D), _17, label_end_16);
  _25 = _24;

  # _1 = PHI <_7(3), _25(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::TreeNodeExV(const void*, ImGuiTreeNodeFlags, const char*, __va_list_tag*) (_ZN5ImGui11TreeNodeExVEPKviPKcP13__va_list_tag, funcdef_no=976, decl_uid=3134, cgraph_uid=875, symbol_order=883)

bool ImGui::TreeNodeExV(const void*, ImGuiTreeNodeFlags, const char*, __va_list_tag*) (const void * ptr_id, ImGuiTreeNodeFlags flags, const char * fmt, struct  * args)
{
  bool D.35516;
  unsigned int D.35515;
  const char * label_end;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  unsigned int D.35513;
  char[3073] * D.35512;
  sizetype D.35511;
  int D.35510;
  char[3073] * D.35509;
  char[3073] * D.35508;
  bool D.35507;
  bool D.35504;
  bool _1;
  bool _6;
  bool _7;
  char[3073] * _9;
  char[3073] * _10;
  int _14;
  sizetype _15;
  char[3073] * _17;
  unsigned int _20;
  unsigned int _21;
  bool _24;
  bool _25;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 0;
  goto <bb 5> (<L2>);

  <bb 4>:
  g_8 = GImGui;
  _9 = &g_8->TempBuffer;
  _10 = &g_8->TempBuffer;
  _14 = ImFormatStringV (_10, 3073, fmt_11(D), args_12(D));
  _15 = (sizetype) _14;
  label_end_16 = _9 + _15;
  _17 = &g_8->TempBuffer;
  _20 = ImGuiWindow::GetID (window_5, ptr_id_18(D));
  _21 = _20;
  _24 = ImGui::TreeNodeBehavior (_21, flags_22(D), _17, label_end_16);
  _25 = _24;

  # _1 = PHI <_7(3), _25(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::TreeNodeV(const char*, const char*, __va_list_tag*) (_ZN5ImGui9TreeNodeVEPKcS1_P13__va_list_tag, funcdef_no=977, decl_uid=3109, cgraph_uid=876, symbol_order=884)

bool ImGui::TreeNodeV(const char*, const char*, __va_list_tag*) (const char * str_id, const char * fmt, struct  * args)
{
  bool D.35519;
  bool D.35517;
  bool _6;
  bool _7;

  <bb 2>:
  _6 = ImGui::TreeNodeExV (str_id_2(D), 0, fmt_3(D), args_4(D));
  _7 = _6;

<L0>:
  return _7;

}



;; Function bool ImGui::TreeNodeV(const void*, const char*, __va_list_tag*) (_ZN5ImGui9TreeNodeVEPKvPKcP13__va_list_tag, funcdef_no=978, decl_uid=3113, cgraph_uid=877, symbol_order=885)

bool ImGui::TreeNodeV(const void*, const char*, __va_list_tag*) (const void * ptr_id, const char * fmt, struct  * args)
{
  bool D.35522;
  bool D.35520;
  bool _6;
  bool _7;

  <bb 2>:
  _6 = ImGui::TreeNodeExV (ptr_id_2(D), 0, fmt_3(D), args_4(D));
  _7 = _6;

<L0>:
  return _7;

}



;; Function bool ImGui::TreeNodeEx(const char*, ImGuiTreeNodeFlags, const char*, ...) (_ZN5ImGui10TreeNodeExEPKciS1_z, funcdef_no=979, decl_uid=3120, cgraph_uid=878, symbol_order=886)

bool ImGui::TreeNodeEx(const char*, ImGuiTreeNodeFlags, const char*, ...) (const char * str_id, ImGuiTreeNodeFlags flags, const char * fmt)
{
  bool D.35525;
  bool is_open;
  struct  args[1];
  bool D.35523;
  bool _7;
  bool _10;

  <bb 2>:
  __builtin_va_start (&args, 0);
  _7 = ImGui::TreeNodeExV (str_id_3(D), flags_4(D), fmt_5(D), &args);
  is_open_8 = _7;
  __builtin_va_end (&args);
  _10 = is_open_8;
  args ={v} {CLOBBER};

<L1>:
  return _10;

}



;; Function bool ImGui::TreeNodeEx(const void*, ImGuiTreeNodeFlags, const char*, ...) (_ZN5ImGui10TreeNodeExEPKviPKcz, funcdef_no=980, decl_uid=3124, cgraph_uid=879, symbol_order=887)

bool ImGui::TreeNodeEx(const void*, ImGuiTreeNodeFlags, const char*, ...) (const void * ptr_id, ImGuiTreeNodeFlags flags, const char * fmt)
{
  bool D.35530;
  bool is_open;
  struct  args[1];
  bool D.35528;
  bool _7;
  bool _10;

  <bb 2>:
  __builtin_va_start (&args, 0);
  _7 = ImGui::TreeNodeExV (ptr_id_3(D), flags_4(D), fmt_5(D), &args);
  is_open_8 = _7;
  __builtin_va_end (&args);
  _10 = is_open_8;
  args ={v} {CLOBBER};

<L1>:
  return _10;

}



;; Function bool ImGui::TreeNode(const char*, const char*, ...) (_ZN5ImGui8TreeNodeEPKcS1_z, funcdef_no=981, decl_uid=3102, cgraph_uid=880, symbol_order=888)

bool ImGui::TreeNode(const char*, const char*, ...) (const char * str_id, const char * fmt)
{
  bool D.35535;
  bool is_open;
  struct  args[1];
  bool D.35533;
  bool _6;
  bool _9;

  <bb 2>:
  __builtin_va_start (&args, 0);
  _6 = ImGui::TreeNodeExV (str_id_3(D), 0, fmt_4(D), &args);
  is_open_7 = _6;
  __builtin_va_end (&args);
  _9 = is_open_7;
  args ={v} {CLOBBER};

<L1>:
  return _9;

}



;; Function bool ImGui::TreeNode(const void*, const char*, ...) (_ZN5ImGui8TreeNodeEPKvPKcz, funcdef_no=982, decl_uid=3105, cgraph_uid=881, symbol_order=889)

bool ImGui::TreeNode(const void*, const char*, ...) (const void * ptr_id, const char * fmt)
{
  bool D.35540;
  bool is_open;
  struct  args[1];
  bool D.35538;
  bool _6;
  bool _9;

  <bb 2>:
  __builtin_va_start (&args, 0);
  _6 = ImGui::TreeNodeExV (ptr_id_3(D), 0, fmt_4(D), &args);
  is_open_7 = _6;
  __builtin_va_end (&args);
  _9 = is_open_7;
  args ={v} {CLOBBER};

<L1>:
  return _9;

}



;; Function bool ImGui::TreeNode(const char*) (_ZN5ImGui8TreeNodeEPKc, funcdef_no=983, decl_uid=3099, cgraph_uid=882, symbol_order=890)

bool ImGui::TreeNode(const char*) (const char * label)
{
  bool D.35550;
  unsigned int D.35549;
  struct ImGuiWindow * window;
  unsigned int D.35547;
  bool D.35546;
  bool D.35543;
  bool _1;
  bool _6;
  bool _7;
  unsigned int _10;
  unsigned int _11;
  bool _13;
  bool _14;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = 0;
  goto <bb 5> (<L2>);

  <bb 4>:
  _10 = ImGuiWindow::GetID (window_5, label_8(D), 0B);
  _11 = _10;
  _13 = ImGui::TreeNodeBehavior (_11, 0, label_8(D), 0B);
  _14 = _13;

  # _1 = PHI <_7(3), _14(4)>
<L2>:
  return _1;

}



;; Function void ImGui::TreeAdvanceToLabelPos() (_ZN5ImGui21TreeAdvanceToLabelPosEv, funcdef_no=984, decl_uid=3140, cgraph_uid=883, symbol_order=891)

void ImGui::TreeAdvanceToLabelPos() ()
{
  struct ImGuiContext & g;
  float D.35554;
  float D.35553;
  struct ImGuiWindow * D.35552;
  struct ImGuiWindow * D.35551;
  float D.19014;
  float _4;
  struct ImGuiWindow * _5;
  struct ImGuiWindow * _6;
  float _7;
  float _8;

  <bb 2>:
  g_2 = GImGui;
  _4 = ImGui::GetTreeNodeToLabelSpacing ();
  _5 = g_2->CurrentWindow;
  _6 = g_2->CurrentWindow;
  _7 = _6->DC.CursorPos.x;
  _8 = _7 + _4;
  _5->DC.CursorPos.x = _8;
  return;

}



;; Function float ImGui::GetTreeNodeToLabelSpacing() (_ZN5ImGui25GetTreeNodeToLabelSpacingEv, funcdef_no=985, decl_uid=3141, cgraph_uid=884, symbol_order=892)

float ImGui::GetTreeNodeToLabelSpacing() ()
{
  struct ImGuiContext & g;
  float D.35558;
  float D.35557;
  float D.35556;
  float D.35555;
  float _3;
  float _4;
  float _5;
  float _6;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->FontSize;
  _4 = g_2->Style.FramePadding.x;
  _5 = _4 * 2.0e+0;
  _6 = _3 + _5;

<L0>:
  return _6;

}



;; Function void ImGui::SetNextTreeNodeOpen(bool, ImGuiCond) (_ZN5ImGui19SetNextTreeNodeOpenEbi, funcdef_no=986, decl_uid=3144, cgraph_uid=885, symbol_order=893)

void ImGui::SetNextTreeNodeOpen(bool, ImGuiCond) (bool is_open, ImGuiCond cond)
{
  struct ImGuiContext & g;
  int iftmp.1153;
  bool D.35561;
  struct ImGuiWindow * D.35560;
  int iftmp.1153_1;
  struct ImGuiWindow * _5;
  bool _6;
  int iftmp.1153_10;
  int iftmp.1153_11;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->CurrentWindow;
  _6 = _5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 8> (<L5>);

  <bb 4>:
  g_4->NextTreeNodeOpenVal = is_open_7(D);
  if (cond_9(D) != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1153_10 = cond_9(D);
  goto <bb 7>;

  <bb 6>:
  iftmp.1153_11 = 1;

  <bb 7>:
  # iftmp.1153_1 = PHI <iftmp.1153_10(5), iftmp.1153_11(6)>
  g_4->NextTreeNodeOpenCond = iftmp.1153_1;

<L5>:
  return;

}



;; Function void ImGui::PushID(const char*) (_ZN5ImGui6PushIDEPKc, funcdef_no=987, decl_uid=2650, cgraph_uid=886, symbol_order=894)

void ImGui::PushID(const char*) (const char * str_id)
{
  unsigned int D.35571;
  struct ImGuiWindow * window;
  struct ImVector * D.35570;
  unsigned int D.35569;
  const value_type D.19027;
  unsigned int _6;
  unsigned int _7;
  struct ImVector * _9;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _6 = ImGuiWindow::GetID (window_3, str_id_4(D), 0B);
  _7 = _6;
  D.19027 = _7;
  _9 = &window_3->IDStack;
  ImVector<unsigned int>::push_back (_9, &D.19027);
  D.19027 ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PushID(const char*, const char*) (_ZN5ImGui6PushIDEPKcS1_, funcdef_no=988, decl_uid=2653, cgraph_uid=887, symbol_order=895)

void ImGui::PushID(const char*, const char*) (const char * str_id_begin, const char * str_id_end)
{
  unsigned int D.35575;
  struct ImGuiWindow * window;
  struct ImVector * D.35574;
  unsigned int D.35573;
  const value_type D.19033;
  unsigned int _7;
  unsigned int _8;
  struct ImVector * _10;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _7 = ImGuiWindow::GetID (window_3, str_id_begin_4(D), str_id_end_5(D));
  _8 = _7;
  D.19033 = _8;
  _10 = &window_3->IDStack;
  ImVector<unsigned int>::push_back (_10, &D.19033);
  D.19033 ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PushID(const void*) (_ZN5ImGui6PushIDEPKv, funcdef_no=989, decl_uid=2655, cgraph_uid=888, symbol_order=896)

void ImGui::PushID(const void*) (const void * ptr_id)
{
  unsigned int D.35579;
  struct ImGuiWindow * window;
  struct ImVector * D.35578;
  unsigned int D.35577;
  const value_type D.19038;
  unsigned int _6;
  unsigned int _7;
  struct ImVector * _9;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _6 = ImGuiWindow::GetID (window_3, ptr_id_4(D));
  _7 = _6;
  D.19038 = _7;
  _9 = &window_3->IDStack;
  ImVector<unsigned int>::push_back (_9, &D.19038);
  D.19038 ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PushID(int) (_ZN5ImGui6PushIDEi, funcdef_no=990, decl_uid=2657, cgraph_uid=889, symbol_order=897)

void ImGui::PushID(int) (int int_id)
{
  unsigned int D.35584;
  struct ImGuiWindow * window;
  const void * ptr_id;
  struct ImVector * D.35583;
  unsigned int D.35582;
  const value_type D.19044;
  long int D.35581;
  long int _2;
  unsigned int _8;
  unsigned int _9;
  struct ImVector * _11;

  <bb 2>:
  _2 = (long int) int_id_1(D);
  ptr_id_3 = (const void *) _2;
  window_6 = ImGui::GetCurrentWindowRead ();
  _8 = ImGuiWindow::GetID (window_6, ptr_id_3);
  _9 = _8;
  D.19044 = _9;
  _11 = &window_6->IDStack;
  ImVector<unsigned int>::push_back (_11, &D.19044);
  D.19044 ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PopID() (_ZN5ImGui5PopIDEv, funcdef_no=991, decl_uid=2658, cgraph_uid=890, symbol_order=898)

void ImGui::PopID() ()
{
  struct ImGuiWindow * window;
  struct ImVector * D.35586;
  struct ImVector * _4;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->IDStack;
  ImVector<unsigned int>::pop_back (_4);
  return;

}



;; Function ImGuiID ImGui::GetID(const char*) (_ZN5ImGui5GetIDEPKc, funcdef_no=992, decl_uid=2660, cgraph_uid=891, symbol_order=899)

ImGuiID ImGui::GetID(const char*) (const char * str_id)
{
  ImGuiID D.35597;
  struct ImGuiWindow * D.35595;
  struct ImGuiContext * GImGui.1154;
  ImGuiID D.35593;
  struct ImGuiContext * GImGui.1154_2;
  struct ImGuiWindow * _3;
  ImGuiID _6;
  ImGuiID _7;

  <bb 2>:
  GImGui.1154_2 = GImGui;
  _3 = GImGui.1154_2->CurrentWindow;
  _6 = ImGuiWindow::GetID (_3, str_id_4(D), 0B);
  _7 = _6;

<L0>:
  return _7;

}



;; Function ImGuiID ImGui::GetID(const char*, const char*) (_ZN5ImGui5GetIDEPKcS1_, funcdef_no=993, decl_uid=2663, cgraph_uid=892, symbol_order=900)

ImGuiID ImGui::GetID(const char*, const char*) (const char * str_id_begin, const char * str_id_end)
{
  ImGuiID D.35602;
  struct ImGuiWindow * D.35600;
  struct ImGuiContext * GImGui.1155;
  ImGuiID D.35598;
  struct ImGuiContext * GImGui.1155_2;
  struct ImGuiWindow * _3;
  ImGuiID _7;
  ImGuiID _8;

  <bb 2>:
  GImGui.1155_2 = GImGui;
  _3 = GImGui.1155_2->CurrentWindow;
  _7 = ImGuiWindow::GetID (_3, str_id_begin_4(D), str_id_end_5(D));
  _8 = _7;

<L0>:
  return _8;

}



;; Function ImGuiID ImGui::GetID(const void*) (_ZN5ImGui5GetIDEPKv, funcdef_no=994, decl_uid=2665, cgraph_uid=893, symbol_order=901)

ImGuiID ImGui::GetID(const void*) (const void * ptr_id)
{
  ImGuiID D.35607;
  struct ImGuiWindow * D.35605;
  struct ImGuiContext * GImGui.1156;
  ImGuiID D.35603;
  struct ImGuiContext * GImGui.1156_2;
  struct ImGuiWindow * _3;
  ImGuiID _6;
  ImGuiID _7;

  <bb 2>:
  GImGui.1156_2 = GImGui;
  _3 = GImGui.1156_2->CurrentWindow;
  _6 = ImGuiWindow::GetID (_3, ptr_id_4(D));
  _7 = _6;

<L0>:
  return _7;

}



;; Function void ImGui::Bullet() (_ZN5ImGui6BulletEv, funcdef_no=995, decl_uid=2832, cgraph_uid=894, symbol_order=902)

void ImGui::Bullet() ()
{
  bool D.35636;
  const struct ImRect bb;
  const float line_height;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.35634;
  float D.35633;
  struct ImVec2 D.35632;
  float D.35631;
  float D.35630;
  float D.35629;
  float D.35628;
  float D.35627;
  struct ImVec2 D.19067;
  float D.35626;
  float D.35625;
  bool D.35622;
  bool retval.1157;
  struct ImVec2 * D.35620;
  struct ImVec2 * D.35619;
  float D.35618;
  struct ImVec2 D.19065;
  struct ImVec2 D.19066;
  float D.35617;
  float D.35616;
  float D.35615;
  float D.35614;
  float D.35613;
  float D.35612;
  float D.35611;
  bool D.35608;
  bool _7;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  float _17;
  float _20;
  struct ImVec2 * _22;
  struct ImVec2 * _24;
  bool _30;
  bool _31;
  bool retval.1157_32;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _42;
  float _43;
  float _47;
  float _48;

  <bb 2>:
  window_6 = ImGui::GetCurrentWindow ();
  _7 = window_6->SkipItems;
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7>;

  <bb 4>:
  g_8 = GImGui;
  style_9 = &g_8->Style;
  _10 = g_8->FontSize;
  _11 = g_8->FontSize;
  _12 = g_8->Style.FramePadding.y;
  _13 = _12 * 2.0e+0;
  _14 = _11 + _13;
  _15 = window_6->DC.CurrentLineHeight;
  _17 = ImMin (_15, _14);
  line_height_19 = ImMax (_17, _10);
  _20 = g_8->FontSize;
  ImVec2::ImVec2 (&D.19065, _20, line_height_19);
  _22 = &window_6->DC.CursorPos;
  D.19066 = operator+ (_22, &D.19065);
  _24 = &window_6->DC.CursorPos;
  ImRect::ImRect (&bb, _24, &D.19066);
  D.19066 ={v} {CLOBBER};
  D.19065 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  _30 = ImGui::ItemAdd (&bb, 0, 0B);
  _31 = _30;
  retval.1157_32 = ~_31;
  if (retval.1157_32 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _47 = style_9->FramePadding.x;
  _48 = _47 * 2.0e+0;
  ImGui::SameLine (0.0, _48);
  goto <bb 7>;

  <bb 6>:
  _33 = line_height_19 * 5.0e-1;
  _34 = style_9->FramePadding.x;
  _35 = g_8->FontSize;
  _36 = _35 * 5.0e-1;
  _37 = _34 + _36;
  ImVec2::ImVec2 (&D.19067, _37, _33);
  D.35632 = operator+ (&bb.Min, &D.19067);
  ImGui::RenderBullet (D.35632);
  D.19067 ={v} {CLOBBER};
  _42 = style_9->FramePadding.x;
  _43 = _42 * 2.0e+0;
  ImGui::SameLine (0.0, _43);
  bb ={v} {CLOBBER};
  goto <bb 8> (<L6>);

  <bb 7>:
  bb ={v} {CLOBBER};

<L6>:
  return;

}



;; Function void ImGui::BulletTextV(const char*, __va_list_tag*) (_ZN5ImGui11BulletTextVEPKcP13__va_list_tag, funcdef_no=996, decl_uid=2702, cgraph_uid=895, symbol_order=903)

void ImGui::BulletTextV(const char*, __va_list_tag*) (const char * fmt, struct  * args)
{
  bool D.35685;
  const struct ImRect bb;
  const float line_height;
  const float text_base_offset_y;
  const struct ImVec2 label_size;
  const char * text_end;
  const char * text_begin;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  struct ImVec2 D.35683;
  float D.35682;
  float D.35681;
  float D.35680;
  float D.35679;
  struct ImVec2 D.19087;
  struct ImVec2 D.35678;
  float D.35677;
  float D.35676;
  float D.35675;
  float D.35674;
  float D.35673;
  struct ImVec2 D.19085;
  bool D.35670;
  bool retval.1159;
  struct ImVec2 * D.35668;
  struct ImVec2 * D.35667;
  float D.35666;
  float D.35664;
  float D.35663;
  float D.35662;
  float D.35659;
  float iftmp.1158;
  float D.35657;
  float D.35656;
  float D.35655;
  struct ImVec2 D.19083;
  struct ImVec2 D.19084;
  float D.35654;
  float D.35653;
  float D.35652;
  float D.35651;
  float D.35650;
  float D.35649;
  float D.35648;
  float D.35647;
  sizetype D.35646;
  int D.35645;
  char[3073] * D.35644;
  bool D.35641;
  float iftmp.1158_1;
  bool _8;
  char[3073] * _12;
  int _16;
  sizetype _17;
  float _20;
  float _23;
  float _24;
  float _25;
  float _26;
  float _27;
  float _28;
  float _30;
  float _33;
  float _35;
  float _36;
  float _37;
  float _38;
  float _39;
  float _40;
  float iftmp.1158_41;
  float iftmp.1158_42;
  float _43;
  struct ImVec2 * _45;
  struct ImVec2 * _47;
  bool _53;
  bool _54;
  bool retval.1159_55;
  float _56;
  float _57;
  float _58;
  float _59;
  float _60;
  float _65;
  float _66;
  float _67;
  float _68;

  <bb 2>:
  window_7 = ImGui::GetCurrentWindow ();
  _8 = window_7->SkipItems;
  if (_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 10>;

  <bb 4>:
  g_9 = GImGui;
  style_10 = &g_9->Style;
  text_begin_11 = &g_9->TempBuffer;
  _12 = &g_9->TempBuffer;
  _16 = ImFormatStringV (_12, 3073, fmt_13(D), args_14(D));
  _17 = (sizetype) _16;
  text_end_18 = text_begin_11 + _17;
  label_size = ImGui::CalcTextSize (text_begin_11, text_end_18, 0, -1.0e+0);
  _20 = window_7->DC.CurrentLineTextBaseOffset;
  text_base_offset_y_22 = ImMax (0.0, _20);
  _23 = g_9->FontSize;
  _24 = g_9->FontSize;
  _25 = g_9->Style.FramePadding.y;
  _26 = _25 * 2.0e+0;
  _27 = _24 + _26;
  _28 = window_7->DC.CurrentLineHeight;
  _30 = ImMin (_28, _27);
  line_height_32 = ImMax (_30, _23);
  _33 = label_size.y;
  _35 = ImMax (line_height_32, _33);
  _36 = g_9->FontSize;
  _37 = label_size.x;
  if (_37 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _38 = label_size.x;
  _39 = style_10->FramePadding.x;
  _40 = _39 * 2.0e+0;
  iftmp.1158_41 = _38 + _40;
  goto <bb 7>;

  <bb 6>:
  iftmp.1158_42 = 0.0;

  <bb 7>:
  # iftmp.1158_1 = PHI <iftmp.1158_41(5), iftmp.1158_42(6)>
  _43 = _36 + iftmp.1158_1;
  ImVec2::ImVec2 (&D.19083, _43, _35);
  _45 = &window_7->DC.CursorPos;
  D.19084 = operator+ (_45, &D.19083);
  _47 = &window_7->DC.CursorPos;
  ImRect::ImRect (&bb, _47, &D.19084);
  D.19084 ={v} {CLOBBER};
  D.19083 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  _53 = ImGui::ItemAdd (&bb, 0, 0B);
  _54 = _53;
  retval.1159_55 = ~_54;
  if (retval.1159_55 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 10>;

  <bb 9>:
  _56 = line_height_32 * 5.0e-1;
  _57 = style_10->FramePadding.x;
  _58 = g_9->FontSize;
  _59 = _58 * 5.0e-1;
  _60 = _57 + _59;
  ImVec2::ImVec2 (&D.19085, _60, _56);
  D.35678 = operator+ (&bb.Min, &D.19085);
  ImGui::RenderBullet (D.35678);
  D.19085 ={v} {CLOBBER};
  _65 = g_9->FontSize;
  _66 = style_10->FramePadding.x;
  _67 = _66 * 2.0e+0;
  _68 = _65 + _67;
  ImVec2::ImVec2 (&D.19087, _68, text_base_offset_y_22);
  D.35683 = operator+ (&bb.Min, &D.19087);
  ImGui::RenderText (D.35683, text_begin_11, text_end_18, 0);
  D.19087 ={v} {CLOBBER};
  label_size ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  goto <bb 11> (<L9>);

  <bb 10>:
  label_size ={v} {CLOBBER};
  bb ={v} {CLOBBER};

<L9>:
  return;

}



;; Function void ImGui::BulletText(const char*, ...) (_ZN5ImGui10BulletTextEPKcz, funcdef_no=997, decl_uid=2699, cgraph_uid=896, symbol_order=904)

void ImGui::BulletText(const char*, ...) (const char * fmt)
{
  struct  args[1];

  <bb 2>:
  __builtin_va_start (&args, 0);
  ImGui::BulletTextV (fmt_3(D), &args);
  __builtin_va_end (&args);
  args ={v} {CLOBBER};
  return;

}



;; Function void DataTypeFormatString(ImGuiDataType, void*, const char*, char*, int) (_ZL20DataTypeFormatString13ImGuiDataTypePvPKcPci, funcdef_no=998, decl_uid=15093, cgraph_uid=897, symbol_order=905)

void DataTypeFormatString(ImGuiDataType, void*, const char*, char*, int) (ImGuiDataType data_type, void * data_ptr, const char * display_format, char * buf, int buf_size)
{
  long unsigned int D.40438;
  double D.40437;
  long unsigned int D.40433;
  double D.40432;
  float D.40431;
  long unsigned int D.40427;
  int D.40426;
  int _5;
  long unsigned int _7;
  float _11;
  double _12;
  long unsigned int _13;
  double _15;
  long unsigned int _16;

  <bb 2>:
  if (data_type_2(D) == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = MEM[(int *)data_ptr_4(D)];
  _7 = (long unsigned int) buf_size_6(D);
  ImFormatString (buf_8(D), _7, display_format_9(D), _5);
  goto <bb 8>;

  <bb 4>:
  if (data_type_2(D) == 1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _11 = MEM[(float *)data_ptr_4(D)];
  _12 = (double) _11;
  _13 = (long unsigned int) buf_size_6(D);
  ImFormatString (buf_8(D), _13, display_format_9(D), _12);
  goto <bb 8>;

  <bb 6>:
  if (data_type_2(D) == 2)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _15 = MEM[(double *)data_ptr_4(D)];
  _16 = (long unsigned int) buf_size_6(D);
  ImFormatString (buf_8(D), _16, display_format_9(D), _15);

  <bb 8>:
  return;

}



;; Function void DataTypeFormatString(ImGuiDataType, void*, int, char*, int) (_ZL20DataTypeFormatString13ImGuiDataTypePviPci, funcdef_no=999, decl_uid=15099, cgraph_uid=898, symbol_order=906)

void DataTypeFormatString(ImGuiDataType, void*, int, char*, int) (ImGuiDataType data_type, void * data_ptr, int decimal_precision, char * buf, int buf_size)
{
  long unsigned int D.35989;
  double D.35988;
  long unsigned int D.35986;
  double D.35985;
  long unsigned int D.35979;
  double D.35978;
  float D.35977;
  long unsigned int D.35975;
  double D.35974;
  float D.35973;
  long unsigned int D.35967;
  int D.35966;
  long unsigned int D.35964;
  int D.35963;
  int _9;
  long unsigned int _11;
  int _14;
  long unsigned int _15;
  float _17;
  double _18;
  long unsigned int _19;
  float _21;
  double _22;
  long unsigned int _23;
  double _25;
  long unsigned int _26;
  double _28;
  long unsigned int _29;

  <bb 2>:
  if (data_type_5(D) == 0)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  if (decimal_precision_6(D) < 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _9 = MEM[(int *)data_ptr_8(D)];
  _11 = (long unsigned int) buf_size_10(D);
  ImFormatString (buf_12(D), _11, "%d", _9);
  goto <bb 6>;

  <bb 5>:
  _14 = MEM[(int *)data_ptr_8(D)];
  _15 = (long unsigned int) buf_size_10(D);
  ImFormatString (buf_12(D), _15, "%.*d", decimal_precision_6(D), _14);

  <bb 6>:
  goto <bb 17>;

  <bb 7>:
  if (data_type_5(D) == 1)
    goto <bb 8>;
  else
    goto <bb 12>;

  <bb 8>:
  if (decimal_precision_6(D) < 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _17 = MEM[(float *)data_ptr_8(D)];
  _18 = (double) _17;
  _19 = (long unsigned int) buf_size_10(D);
  ImFormatString (buf_12(D), _19, "%f", _18);
  goto <bb 11>;

  <bb 10>:
  _21 = MEM[(float *)data_ptr_8(D)];
  _22 = (double) _21;
  _23 = (long unsigned int) buf_size_10(D);
  ImFormatString (buf_12(D), _23, "%.*f", decimal_precision_6(D), _22);

  <bb 11>:
  goto <bb 17>;

  <bb 12>:
  if (data_type_5(D) == 2)
    goto <bb 13>;
  else
    goto <bb 17>;

  <bb 13>:
  if (decimal_precision_6(D) < 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _25 = MEM[(double *)data_ptr_8(D)];
  _26 = (long unsigned int) buf_size_10(D);
  ImFormatString (buf_12(D), _26, "%f", _25);
  goto <bb 16>;

  <bb 15>:
  _28 = MEM[(double *)data_ptr_8(D)];
  _29 = (long unsigned int) buf_size_10(D);
  ImFormatString (buf_12(D), _29, "%.*f", decimal_precision_6(D), _28);

  <bb 16>:

  <bb 17>:
  return;

}



;; Function void DataTypeApplyOp(ImGuiDataType, int, void*, void*, const void*) (_ZL15DataTypeApplyOp13ImGuiDataTypeiPvS0_PKv, funcdef_no=1000, decl_uid=15105, cgraph_uid=899, symbol_order=907)

void DataTypeApplyOp(ImGuiDataType, int, void*, void*, const void*) (ImGuiDataType data_type, int op, void * output, void * arg1, const void * arg2)
{
  static const char __PRETTY_FUNCTION__[68] = "void DataTypeApplyOp(ImGuiDataType, int, void*, void*, const void*)";
  double D.35739;
  double D.35738;
  double D.35737;
  double D.35733;
  double D.35732;
  double D.35731;
  float D.35724;
  float D.35723;
  float D.35722;
  float D.35718;
  float D.35717;
  float D.35716;
  int D.35709;
  int D.35708;
  int D.35707;
  int D.35703;
  int D.35702;
  int D.35701;
  int _7;
  int _9;
  int _10;
  int _13;
  int _14;
  int _15;
  float _17;
  float _18;
  float _19;
  float _21;
  float _22;
  float _23;
  double _25;
  double _26;
  double _27;
  double _29;
  double _30;
  double _31;

  <bb 2>:
  if (op_2(D) == 43)
    goto <bb 5>;
  else
    goto <bb 3>;

  <bb 3>:
  if (op_2(D) == 45)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __assert_fail ("op == \'+\' || op == \'-\'", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 8450, &__PRETTY_FUNCTION__);

  <bb 5>:
  if (data_type_5(D) == 0)
    goto <bb 6>;
  else
    goto <bb 10>;

  <bb 6>:
  if (op_2(D) == 43)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _13 = MEM[(int *)arg1_6(D)];
  _14 = MEM[(const int *)arg2_8(D)];
  _15 = _13 + _14;
  MEM[(int *)output_11(D)] = _15;
  goto <bb 20>;

  <bb 8>:
  if (op_2(D) == 45)
    goto <bb 9>;
  else
    goto <bb 20>;

  <bb 9>:
  _7 = MEM[(int *)arg1_6(D)];
  _9 = MEM[(const int *)arg2_8(D)];
  _10 = _7 - _9;
  MEM[(int *)output_11(D)] = _10;
  goto <bb 20>;

  <bb 10>:
  if (data_type_5(D) == 1)
    goto <bb 11>;
  else
    goto <bb 15>;

  <bb 11>:
  if (op_2(D) == 43)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _21 = MEM[(float *)arg1_6(D)];
  _22 = MEM[(const float *)arg2_8(D)];
  _23 = _21 + _22;
  MEM[(float *)output_11(D)] = _23;
  goto <bb 20>;

  <bb 13>:
  if (op_2(D) == 45)
    goto <bb 14>;
  else
    goto <bb 20>;

  <bb 14>:
  _17 = MEM[(float *)arg1_6(D)];
  _18 = MEM[(const float *)arg2_8(D)];
  _19 = _17 - _18;
  MEM[(float *)output_11(D)] = _19;
  goto <bb 20>;

  <bb 15>:
  if (data_type_5(D) == 2)
    goto <bb 16>;
  else
    goto <bb 20>;

  <bb 16>:
  if (op_2(D) == 43)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _29 = MEM[(double *)arg1_6(D)];
  _30 = MEM[(const double *)arg2_8(D)];
  _31 = _29 + _30;
  MEM[(double *)output_11(D)] = _31;
  goto <bb 20>;

  <bb 18>:
  if (op_2(D) == 45)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _25 = MEM[(double *)arg1_6(D)];
  _26 = MEM[(const double *)arg2_8(D)];
  _27 = _25 - _26;
  MEM[(double *)output_11(D)] = _27;

  <bb 20>:
  return;

}



;; Function bool DataTypeApplyOpFromText(const char*, const char*, ImGuiDataType, void*, const char*) (_ZL23DataTypeApplyOpFromTextPKcS0_13ImGuiDataTypePvS0_, funcdef_no=1001, decl_uid=15111, cgraph_uid=900, symbol_order=909)

bool DataTypeApplyOpFromText(const char*, const char*, ImGuiDataType, void*, const char*) (const char * buf, const char * initial_value_buf, ImGuiDataType data_type, void * data_ptr, const char * scalar_format)
{
  double arg1f;
  double arg0f;
  double * v;
  float arg1f;
  float arg0f;
  float * v;
  float arg1f;
  int arg0i;
  int * v;
  int data_backup[2];
  static const char __PRETTY_FUNCTION__[90] = "bool DataTypeApplyOpFromText(const char*, const char*, ImGuiDataType, void*, const char*)";
  char op;
  int D.35921;
  long unsigned int D.35920;
  int data_type.1205;
  double arg1f.1204;
  double D.35914;
  double arg1f.1203;
  double arg0f.1202;
  double arg1f.1201;
  double D.35905;
  double arg1f.1200;
  double arg0f.1199;
  double D.35899;
  double arg1f.1198;
  double arg0f.1197;
  int D.35892;
  bool retval.1196;
  int D.35887;
  bool iftmp.1195;
  bool retval.1194;
  double arg0f.1193;
  float arg1f.1192;
  float D.35874;
  float arg1f.1191;
  float arg0f.1190;
  float arg1f.1189;
  float D.35865;
  float arg1f.1188;
  float arg0f.1187;
  float D.35859;
  float arg1f.1186;
  float arg0f.1185;
  int D.35852;
  bool retval.1184;
  int D.35847;
  bool iftmp.1183;
  bool retval.1182;
  float arg0f.1181;
  int arg0i.1180;
  int D.35833;
  bool retval.1179;
  int D.35829;
  float D.35828;
  float arg1f.1178;
  float D.35826;
  int arg0i.1177;
  float arg1f.1176;
  int D.35819;
  bool iftmp.1175;
  bool retval.1174;
  int D.35810;
  float D.35809;
  float arg1f.1173;
  float D.35807;
  int arg0i.1172;
  int D.35803;
  bool retval.1171;
  int D.35797;
  float D.35796;
  float arg1f.1170;
  float D.35794;
  int arg0i.1169;
  int D.35790;
  bool retval.1168;
  int D.35783;
  bool iftmp.1167;
  bool retval.1166;
  int arg0i.1165;
  long unsigned int D.35771;
  int data_type.1164;
  long unsigned int D.35766;
  int data_type.1163;
  int data_type.1162;
  bool D.35760;
  char D.35757;
  unsigned int D.35755;
  char D.35754;
  bool retval.1161;
  unsigned int D.35745;
  char D.35744;
  bool retval.1160;
  bool _6;
  bool _7;
  bool _8;
  bool iftmp.1167_9;
  bool iftmp.1175_10;
  bool iftmp.1183_11;
  bool iftmp.1195_12;
  char _31;
  unsigned int _32;
  bool retval.1160_34;
  char _39;
  unsigned int _40;
  bool retval.1161_42;
  char _44;
  bool _45;
  int data_type.1162_47;
  int data_type.1163_48;
  long unsigned int _49;
  int data_type.1164_50;
  long unsigned int _51;
  int arg0i.1165_57;
  int _61;
  bool iftmp.1167_62;
  bool iftmp.1167_63;
  bool retval.1166_64;
  bool _65;
  int _70;
  bool retval.1168_71;
  int arg0i.1169_72;
  float _73;
  float arg1f.1170_74;
  float _75;
  int _76;
  int _79;
  bool retval.1171_80;
  int arg0i.1172_81;
  float _82;
  float arg1f.1173_83;
  float _84;
  int _85;
  int _88;
  float arg1f.1176_89;
  bool iftmp.1175_90;
  bool iftmp.1175_91;
  bool retval.1174_92;
  int arg0i.1177_93;
  float _94;
  float arg1f.1178_95;
  float _96;
  int _97;
  int _100;
  bool retval.1179_101;
  int arg0i.1180_102;
  float arg0f.1181_108;
  int _112;
  bool iftmp.1183_113;
  bool iftmp.1183_114;
  bool retval.1182_115;
  bool _116;
  int _118;
  bool retval.1184_119;
  bool _120;
  float arg0f.1185_121;
  float arg1f.1186_122;
  float _123;
  float arg0f.1187_125;
  float arg1f.1188_126;
  float _127;
  float arg1f.1189_129;
  float arg0f.1190_130;
  float arg1f.1191_131;
  float _132;
  float arg1f.1192_134;
  double arg0f.1193_142;
  int _146;
  bool iftmp.1195_147;
  bool iftmp.1195_148;
  bool retval.1194_149;
  bool _150;
  int _152;
  bool retval.1196_153;
  bool _154;
  double arg0f.1197_155;
  double arg1f.1198_156;
  double _157;
  double arg0f.1199_159;
  double arg1f.1200_160;
  double _161;
  double arg1f.1201_163;
  double arg0f.1202_164;
  double arg1f.1203_165;
  double _166;
  double arg1f.1204_168;
  int data_type.1205_174;
  long unsigned int _175;
  int _176;
  bool _177;

  <bb 2>:
  # buf_1 = PHI <buf_29(D)(0), buf_35(3)>
  _31 = *buf_1;
  _32 = (unsigned int) _31;
  retval.1160_34 = ImCharIsSpace (_32);
  if (retval.1160_34 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  buf_35 = buf_1 + 1;
  goto <bb 2>;

  <bb 4>:
  op_36 = *buf_1;
  if (op_36 == 43)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 5>:
  if (op_36 == 42)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  if (op_36 == 47)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  buf_38 = buf_1 + 1;

  <bb 8>:
  # buf_2 = PHI <buf_38(7), buf_43(9)>
  _39 = *buf_2;
  _40 = (unsigned int) _39;
  retval.1161_42 = ImCharIsSpace (_40);
  if (retval.1161_42 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  buf_43 = buf_2 + 1;
  goto <bb 8>;

  <bb 10>:
  goto <bb 12>;

  <bb 11>:
  op_37 = 0;

  <bb 12>:
  # buf_3 = PHI <buf_2(10), buf_1(11)>
  # op_5 = PHI <op_36(10), op_37(11)>
  _44 = *buf_3;
  if (_44 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _45 = 0;
  goto <bb 82>;

  <bb 14>:
  data_type.1162_47 = (int) data_type_46(D);
  if (data_type.1162_47 <= 2)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  __assert_fail ("data_type < ImGuiDataType_COUNT", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 8498, &__PRETTY_FUNCTION__);

  <bb 16>:
  data_type.1163_48 = (int) data_type_46(D);
  _49 = GDataTypeSize[data_type.1163_48];
  if (_49 <= 8)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  __assert_fail ("GDataTypeSize[data_type] <= sizeof(data_backup)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 8500, &__PRETTY_FUNCTION__);

  <bb 18>:
  data_type.1164_50 = (int) data_type_46(D);
  _51 = GDataTypeSize[data_type.1164_50];
  memcpy (&data_backup, data_ptr_52(D), _51);
  if (data_type_46(D) == 0)
    goto <bb 19>;
  else
    goto <bb 43>;

  <bb 19>:
  if (scalar_format_54(D) == 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  scalar_format_55 = "%d";

  <bb 21>:
  # scalar_format_4 = PHI <scalar_format_54(D)(19), scalar_format_55(20)>
  v_56 = data_ptr_52(D);
  arg0i.1165_57 = *v_56;
  arg0i = arg0i.1165_57;
  if (op_5 != 0)
    goto <bb 22>;
  else
    goto <bb 24>;

  <bb 22>:
  _61 = sscanf (initial_value_buf_59(D), scalar_format_4, &arg0i);
  if (_61 <= 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.1167_62 = 1;
  goto <bb 25>;

  <bb 24>:
  iftmp.1167_63 = 0;

  <bb 25>:
  # iftmp.1167_9 = PHI <iftmp.1167_62(23), iftmp.1167_63(24)>
  retval.1166_64 = iftmp.1167_9;
  if (retval.1166_64 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _65 = 0;
  arg0i ={v} {CLOBBER};
  arg1f ={v} {CLOBBER};
  goto <bb 82>;

  <bb 27>:
  arg1f = 0.0;
  if (op_5 == 43)
    goto <bb 28>;
  else
    goto <bb 30>;

  <bb 28>:
  _70 = sscanf (buf_3, "%f", &arg1f);
  retval.1168_71 = _70 == 1;
  if (retval.1168_71 != 0)
    goto <bb 29>;
  else
    goto <bb 42>;

  <bb 29>:
  arg0i.1169_72 = arg0i;
  _73 = (float) arg0i.1169_72;
  arg1f.1170_74 = arg1f;
  _75 = _73 + arg1f.1170_74;
  _76 = (int) _75;
  *v_56 = _76;
  goto <bb 42>;

  <bb 30>:
  if (op_5 == 42)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  _79 = sscanf (buf_3, "%f", &arg1f);
  retval.1171_80 = _79 == 1;
  if (retval.1171_80 != 0)
    goto <bb 32>;
  else
    goto <bb 42>;

  <bb 32>:
  arg0i.1172_81 = arg0i;
  _82 = (float) arg0i.1172_81;
  arg1f.1173_83 = arg1f;
  _84 = _82 * arg1f.1173_83;
  _85 = (int) _84;
  *v_56 = _85;
  goto <bb 42>;

  <bb 33>:
  if (op_5 == 47)
    goto <bb 34>;
  else
    goto <bb 40>;

  <bb 34>:
  _88 = sscanf (buf_3, "%f", &arg1f);
  if (_88 == 1)
    goto <bb 35>;
  else
    goto <bb 37>;

  <bb 35>:
  arg1f.1176_89 = arg1f;
  if (arg1f.1176_89 != 0.0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  iftmp.1175_90 = 1;
  goto <bb 38>;

  <bb 37>:
  iftmp.1175_91 = 0;

  <bb 38>:
  # iftmp.1175_10 = PHI <iftmp.1175_90(36), iftmp.1175_91(37)>
  retval.1174_92 = iftmp.1175_10;
  if (retval.1174_92 != 0)
    goto <bb 39>;
  else
    goto <bb 42>;

  <bb 39>:
  arg0i.1177_93 = arg0i;
  _94 = (float) arg0i.1177_93;
  arg1f.1178_95 = arg1f;
  _96 = _94 / arg1f.1178_95;
  _97 = (int) _96;
  *v_56 = _97;
  goto <bb 42>;

  <bb 40>:
  _100 = sscanf (buf_3, scalar_format_4, &arg0i);
  retval.1179_101 = _100 == 1;
  if (retval.1179_101 != 0)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  arg0i.1180_102 = arg0i;
  *v_56 = arg0i.1180_102;

  <bb 42>:
  arg0i ={v} {CLOBBER};
  arg1f ={v} {CLOBBER};
  goto <bb 81>;

  <bb 43>:
  if (data_type_46(D) == 1)
    goto <bb 44>;
  else
    goto <bb 62>;

  <bb 44>:
  scalar_format_106 = "%f";
  v_107 = data_ptr_52(D);
  arg0f.1181_108 = *v_107;
  arg0f = arg0f.1181_108;
  arg1f = 0.0;
  if (op_5 != 0)
    goto <bb 45>;
  else
    goto <bb 47>;

  <bb 45>:
  _112 = sscanf (initial_value_buf_59(D), scalar_format_106, &arg0f);
  if (_112 <= 0)
    goto <bb 46>;
  else
    goto <bb 47>;

  <bb 46>:
  iftmp.1183_113 = 1;
  goto <bb 48>;

  <bb 47>:
  iftmp.1183_114 = 0;

  <bb 48>:
  # iftmp.1183_11 = PHI <iftmp.1183_113(46), iftmp.1183_114(47)>
  retval.1182_115 = iftmp.1183_11;
  if (retval.1182_115 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  _116 = 0;
  goto <bb 61>;

  <bb 50>:
  _118 = sscanf (buf_3, scalar_format_106, &arg1f);
  retval.1184_119 = _118 <= 0;
  if (retval.1184_119 != 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  _120 = 0;
  goto <bb 61>;

  <bb 52>:
  if (op_5 == 43)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  arg0f.1185_121 = arg0f;
  arg1f.1186_122 = arg1f;
  _123 = arg0f.1185_121 + arg1f.1186_122;
  *v_107 = _123;
  goto <bb 60>;

  <bb 54>:
  if (op_5 == 42)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  arg0f.1187_125 = arg0f;
  arg1f.1188_126 = arg1f;
  _127 = arg0f.1187_125 * arg1f.1188_126;
  *v_107 = _127;
  goto <bb 60>;

  <bb 56>:
  if (op_5 == 47)
    goto <bb 57>;
  else
    goto <bb 59>;

  <bb 57>:
  arg1f.1189_129 = arg1f;
  if (arg1f.1189_129 != 0.0)
    goto <bb 58>;
  else
    goto <bb 60>;

  <bb 58>:
  arg0f.1190_130 = arg0f;
  arg1f.1191_131 = arg1f;
  _132 = arg0f.1190_130 / arg1f.1191_131;
  *v_107 = _132;
  goto <bb 60>;

  <bb 59>:
  arg1f.1192_134 = arg1f;
  *v_107 = arg1f.1192_134;

  <bb 60>:
  arg0f ={v} {CLOBBER};
  arg1f ={v} {CLOBBER};
  goto <bb 81>;

  <bb 61>:
  # _6 = PHI <_116(49), _120(51)>
  arg0f ={v} {CLOBBER};
  arg1f ={v} {CLOBBER};
  goto <bb 82>;

  <bb 62>:
  if (data_type_46(D) == 2)
    goto <bb 63>;
  else
    goto <bb 81>;

  <bb 63>:
  scalar_format_140 = "%lf";
  v_141 = data_ptr_52(D);
  arg0f.1193_142 = *v_141;
  arg0f = arg0f.1193_142;
  arg1f = 0.0;
  if (op_5 != 0)
    goto <bb 64>;
  else
    goto <bb 66>;

  <bb 64>:
  _146 = sscanf (initial_value_buf_59(D), scalar_format_140, &arg0f);
  if (_146 <= 0)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  iftmp.1195_147 = 1;
  goto <bb 67>;

  <bb 66>:
  iftmp.1195_148 = 0;

  <bb 67>:
  # iftmp.1195_12 = PHI <iftmp.1195_147(65), iftmp.1195_148(66)>
  retval.1194_149 = iftmp.1195_12;
  if (retval.1194_149 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

  <bb 68>:
  _150 = 0;
  goto <bb 80>;

  <bb 69>:
  _152 = sscanf (buf_3, scalar_format_140, &arg1f);
  retval.1196_153 = _152 <= 0;
  if (retval.1196_153 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  _154 = 0;
  goto <bb 80>;

  <bb 71>:
  if (op_5 == 43)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  arg0f.1197_155 = arg0f;
  arg1f.1198_156 = arg1f;
  _157 = arg0f.1197_155 + arg1f.1198_156;
  *v_141 = _157;
  goto <bb 79>;

  <bb 73>:
  if (op_5 == 42)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  arg0f.1199_159 = arg0f;
  arg1f.1200_160 = arg1f;
  _161 = arg0f.1199_159 * arg1f.1200_160;
  *v_141 = _161;
  goto <bb 79>;

  <bb 75>:
  if (op_5 == 47)
    goto <bb 76>;
  else
    goto <bb 78>;

  <bb 76>:
  arg1f.1201_163 = arg1f;
  if (arg1f.1201_163 != 0.0)
    goto <bb 77>;
  else
    goto <bb 79>;

  <bb 77>:
  arg0f.1202_164 = arg0f;
  arg1f.1203_165 = arg1f;
  _166 = arg0f.1202_164 / arg1f.1203_165;
  *v_141 = _166;
  goto <bb 79>;

  <bb 78>:
  arg1f.1204_168 = arg1f;
  *v_141 = arg1f.1204_168;

  <bb 79>:
  arg0f ={v} {CLOBBER};
  arg1f ={v} {CLOBBER};
  goto <bb 81>;

  <bb 80>:
  # _7 = PHI <_150(68), _154(70)>
  arg0f ={v} {CLOBBER};
  arg1f ={v} {CLOBBER};
  goto <bb 82>;

  <bb 81>:
  data_type.1205_174 = (int) data_type_46(D);
  _175 = GDataTypeSize[data_type.1205_174];
  _176 = memcmp (&data_backup, data_ptr_52(D), _175);
  _177 = _176 != 0;

  <bb 82>:
  # _8 = PHI <_45(13), _65(26), _6(61), _7(80), _177(81)>
  data_backup ={v} {CLOBBER};

<L109>:
  return _8;

}



;; Function bool ImGui::InputScalarAsWidgetReplacement(const ImRect&, const char*, ImGuiDataType, void*, ImGuiID, int) (_ZN5ImGui30InputScalarAsWidgetReplacementERK6ImRectPKc13ImGuiDataTypePvji, funcdef_no=1002, decl_uid=14028, cgraph_uid=901, symbol_order=910)

bool ImGui::InputScalarAsWidgetReplacement(const ImRect&, const char*, ImGuiDataType, void*, ImGuiID, int) (const struct ImRect & aabb, const char * label, ImGuiDataType data_type, void * data_ptr, ImGuiID id, int decimal_precision)
{
  bool D.35955;
  static const char __PRETTY_FUNCTION__[107] = "bool ImGui::InputScalarAsWidgetReplacement(const ImRect&, const char*, ImGuiDataType, void*, ImGuiID, int)";
  bool text_value_changed;
  char buf[32];
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  value_type * D.35953;
  struct ImVector * D.35952;
  struct ImGuiContext * GImGui.1207;
  bool D.35950;
  unsigned int D.35946;
  unsigned int D.35942;
  unsigned int D.35939;
  struct ImVec2 D.19151;
  unsigned int D.35938;
  bool _1;
  unsigned int _8;
  bool _21;
  unsigned int _24;
  unsigned int _25;
  unsigned int _27;
  struct ImGuiContext * GImGui.1207_31;
  struct ImVector * _32;
  value_type * _34;
  bool _36;
  bool _37;

  <bb 2>:
  g_5 = GImGui;
  window_7 = ImGui::GetCurrentWindow ();
  _8 = g_5->ScalarAsInputTextId;
  ImGui::SetActiveID (_8, window_7);
  g_5->ActiveIdAllowNavDirFlags = 12;
  ImGui::SetHoveredID (0);
  ImGui::FocusableItemUnregister (window_7);
  DataTypeFormatString (data_type_13(D), data_ptr_14(D), decimal_precision_15(D), &buf, 32);
  D.19151 = ImRect::GetSize (aabb_17(D));
  _21 = ImGui::InputTextEx (label_19(D), &buf, 32, &D.19151, 17, 0B, 0B);
  text_value_changed_22 = _21;
  D.19151 ={v} {CLOBBER};
  _24 = g_5->ScalarAsInputTextId;
  if (_24 == 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _25 = g_5->ActiveId;
  if (_25 == id_26(D))
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  __assert_fail ("g.ActiveId == id", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 8569, &__PRETTY_FUNCTION__);

  <bb 5>:
  _27 = g_5->ActiveId;
  g_5->ScalarAsInputTextId = _27;
  ImGui::SetHoveredID (id_26(D));

  <bb 6>:
  if (text_value_changed_22 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  GImGui.1207_31 = GImGui;
  _32 = &GImGui.1207_31->InputTextState.InitialText;
  _34 = ImVector<char>::begin (_32);
  _36 = DataTypeApplyOpFromText (&buf, _34, data_type_13(D), data_ptr_14(D), 0B);
  goto <bb 9>;

  <bb 8>:
  _37 = 0;

  <bb 9>:
  # _1 = PHI <_36(7), _37(8)>
  buf ={v} {CLOBBER};

<L9>:
  return _1;

}



;; Function int ImGui::ParseFormatPrecision(const char*, int) (_ZN5ImGui20ParseFormatPrecisionEPKci, funcdef_no=1003, decl_uid=14061, cgraph_uid=902, symbol_order=911)

int ImGui::ParseFormatPrecision(const char*, int) (const char * fmt, int default_precision)
{
  int precision;
  int D.36019;
  char D.36018;
  char D.36016;
  int precision.1210;
  int precision.1209;
  const char * D.36007;
  char D.36004;
  char D.36002;
  char D.36000;
  char D.35996;
  bool retval.1208;
  bool retval.1208_13;
  char _15;
  char _17;
  char _18;
  char _20;
  const char * _21;
  int precision.1209_24;
  int precision.1210_25;
  char _27;
  char _28;
  int _30;

  <bb 2>:
  precision = default_precision_9(D);

  <bb 3>:
  # fmt_1 = PHI <fmt_11(D)(2), fmt_16(18)>
  fmt_12 = strchr (fmt_1, 37);
  retval.1208_13 = fmt_12 != 0B;
  if (retval.1208_13 != 0)
    goto <bb 4>;
  else
    goto <bb 19>;

  <bb 4>:
  fmt_14 = fmt_12 + 1;
  _15 = *fmt_14;
  if (_15 == 37)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  fmt_16 = fmt_14 + 1;
  goto <bb 18>;

  <bb 6>:
  # fmt_2 = PHI <fmt_14(4), fmt_19(8)>
  _17 = *fmt_2;
  if (_17 <= 47)
    goto <bb 9>;
  else
    goto <bb 7>;

  <bb 7>:
  _18 = *fmt_2;
  if (_18 > 57)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  fmt_19 = fmt_2 + 1;
  goto <bb 6>;

  <bb 9>:
  _20 = *fmt_2;
  if (_20 == 46)
    goto <bb 10>;
  else
    goto <bb 14>;

  <bb 10>:
  _21 = fmt_2 + 1;
  fmt_23 = ImAtoi (_21, &precision);
  precision.1209_24 = precision;
  if (precision.1209_24 < 0)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  precision.1210_25 = precision;
  if (precision.1210_25 > 10)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  precision = default_precision_9(D);

  <bb 13>:

  <bb 14>:
  # fmt_3 = PHI <fmt_2(9), fmt_23(13)>
  _27 = *fmt_3;
  if (_27 == 101)
    goto <bb 16>;
  else
    goto <bb 15>;

  <bb 15>:
  _28 = *fmt_3;
  if (_28 == 69)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  precision = -1;

  <bb 17>:
  goto <bb 19>;

  <bb 18>:
  goto <bb 3>;

  <bb 19>:
  _30 = precision;
  precision ={v} {CLOBBER};

<L20>:
  return _30;

}



;; Function float GetMinimumStepAtDecimalPrecision(int) (_ZL32GetMinimumStepAtDecimalPrecisioni, funcdef_no=1004, decl_uid=19163, cgraph_uid=903, symbol_order=913)

float GetMinimumStepAtDecimalPrecision(int) (int decimal_precision)
{
  static const float min_steps[10] = {1.0e+0, 1.00000001490116119384765625e-1, 9.99999977648258209228515625e-3, 1.000000047497451305389404296875e-3, 9.99999974737875163555145263671875e-5, 9.99999974737875163555145263671875e-6, 9.999999974752427078783512115478515625e-7, 1.0000000116860974230803549289703369140625e-7, 9.99999993922529029077850282192230224609375e-9, 9.9999997171806853657471947371959686279296875e-10};
  float D.36029;
  int D.36028;
  float iftmp.1211;
  float D.36022;
  float iftmp.1211_1;
  float iftmp.1211_5;
  int _6;
  float _7;
  float iftmp.1211_9;
  float _10;

  <bb 2>:
  if (decimal_precision_3(D) >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (decimal_precision_3(D) <= 9)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1211_5 = min_steps[decimal_precision_3(D)];
  goto <bb 6>;

  <bb 5>:
  _6 = -decimal_precision_3(D);
  _7 = (float) _6;
  iftmp.1211_9 = powf (1.0e+1, _7);

  <bb 6>:
  # iftmp.1211_1 = PHI <iftmp.1211_5(4), iftmp.1211_9(5)>
  _10 = iftmp.1211_1;

<L4>:
  return _10;

}



;; Function float ImGui::RoundScalar(float, int) (_ZN5ImGui11RoundScalarEfi, funcdef_no=1005, decl_uid=14064, cgraph_uid=904, symbol_order=914)

float ImGui::RoundScalar(float, int) (float value, int decimal_precision)
{
  float remainder;
  bool negative;
  const float min_step;
  float iftmp.1212;
  float D.36038;
  float D.36034;
  float D.36033;
  float _2;
  float iftmp.1212_3;
  float _7;
  float _15;
  float _17;
  float iftmp.1212_19;
  float iftmp.1212_20;
  float _21;

  <bb 2>:
  if (decimal_precision_5(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = value_6(D);
  goto <bb 11> (<L8>);

  <bb 4>:
  min_step_10 = GetMinimumStepAtDecimalPrecision (decimal_precision_5(D));
  negative_11 = value_6(D) < 0.0;
  value_12 = ABS_EXPR <value_6(D)>;
  remainder_14 = fmodf (value_12, min_step_10);
  _15 = min_step_10 * 5.0e-1;
  if (_15 >= remainder_14)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  value_16 = value_12 - remainder_14;
  goto <bb 7>;

  <bb 6>:
  _17 = min_step_10 - remainder_14;
  value_18 = _17 + value_12;

  <bb 7>:
  # value_1 = PHI <value_16(5), value_18(6)>
  if (negative_11 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1212_19 = -value_1;
  goto <bb 10>;

  <bb 9>:
  iftmp.1212_20 = value_1;

  <bb 10>:
  # iftmp.1212_3 = PHI <iftmp.1212_19(8), iftmp.1212_20(9)>
  _21 = iftmp.1212_3;

  # _2 = PHI <_7(3), _21(10)>
<L8>:
  return _2;

}



;; Function float SliderBehaviorCalcRatioFromValue(float, float, float, float, float) (_ZL32SliderBehaviorCalcRatioFromValuefffff, funcdef_no=1006, decl_uid=19178, cgraph_uid=905, symbol_order=915)

float SliderBehaviorCalcRatioFromValue(float, float, float, float, float) (float v, float v_min, float v_max, float power, float linear_zero_pos)
{
  const float f;
  const float f;
  const float v_clamped;
  const bool is_non_linear;
  float D.36284;
  float D.36283;
  float D.36282;
  float D.36281;
  float D.36280;
  float D.36279;
  float D.36278;
  float D.36277;
  float D.36276;
  float D.36275;
  float D.36274;
  float D.36273;
  float D.36272;
  float D.36271;
  float D.36270;
  float D.36269;
  float D.36268;
  float iftmp.1233;
  bool iftmp.1232;
  float D.36254;
  float _1;
  bool iftmp.1232_2;
  float iftmp.1233_3;
  float _8;
  bool iftmp.1232_11;
  bool iftmp.1232_12;
  float iftmp.1233_16;
  float iftmp.1233_18;
  float _20;
  float _22;
  float _23;
  float _24;
  float _26;
  float _28;
  float _29;
  float _31;
  float _33;
  float _34;
  float _36;
  float _37;
  float _39;
  float _41;
  float _42;
  float _43;
  float _44;
  float _45;
  float _46;
  float _47;

  <bb 2>:
  if (v_min_6(D) == v_max_7(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = 0.0;
  goto <bb 16> (<L13>);

  <bb 4>:
  if (power_10(D) < 9.99989986419677734375e-1)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  if (power_10(D) > 1.000010013580322265625e+0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1232_12 = 1;
  goto <bb 8>;

  <bb 7>:
  iftmp.1232_11 = 0;

  <bb 8>:
  # iftmp.1232_2 = PHI <iftmp.1232_12(6), iftmp.1232_11(7)>
  is_non_linear_13 = iftmp.1232_2;
  if (v_min_6(D) < v_max_7(D))
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1233_16 = ImClamp (v_14(D), v_min_6(D), v_max_7(D));
  goto <bb 11>;

  <bb 10>:
  iftmp.1233_18 = ImClamp (v_14(D), v_max_7(D), v_min_6(D));

  <bb 11>:
  # iftmp.1233_3 = PHI <iftmp.1233_16(9), iftmp.1233_18(10)>
  v_clamped_19 = iftmp.1233_3;
  if (is_non_linear_13 != 0)
    goto <bb 12>;
  else
    goto <bb 15>;

  <bb 12>:
  if (v_clamped_19 < 0.0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _20 = v_clamped_19 - v_min_6(D);
  _22 = ImMin (0.0, v_max_7(D));
  _23 = _22 - v_min_6(D);
  _24 = _20 / _23;
  f_25 = 1.0e+0 - _24;
  _26 = 1.0e+0 / power_10(D);
  _28 = powf (f_25, _26);
  _29 = 1.0e+0 - _28;
  _31 = _29 * linear_zero_pos_30(D);
  goto <bb 16> (<L13>);

  <bb 14>:
  _33 = ImMax (0.0, v_min_6(D));
  _34 = v_clamped_19 - _33;
  _36 = ImMax (0.0, v_min_6(D));
  _37 = v_max_7(D) - _36;
  f_38 = _34 / _37;
  _39 = 1.0e+0 / power_10(D);
  _41 = powf (f_38, _39);
  _42 = 1.0e+0 - linear_zero_pos_30(D);
  _43 = _41 * _42;
  _44 = _43 + linear_zero_pos_30(D);
  goto <bb 16> (<L13>);

  <bb 15>:
  _45 = v_clamped_19 - v_min_6(D);
  _46 = v_max_7(D) - v_min_6(D);
  _47 = _45 / _46;

  # _1 = PHI <_8(3), _31(13), _44(14), _47(15)>
<L13>:
  return _1;

}



;; Function bool ImGui::SliderBehavior(const ImRect&, ImGuiID, float*, float, float, float, int, ImGuiSliderFlags) (_ZN5ImGui14SliderBehaviorERK6ImRectjPffffii, funcdef_no=1007, decl_uid=13953, cgraph_uid=906, symbol_order=916)

bool ImGui::SliderBehavior(const ImRect&, ImGuiID, float*, float, float, float, int, ImGuiSliderFlags) (const struct ImRect & frame_bb, ImGuiID id, float * v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)
{
  float a;
  float a;
  float new_value;
  float delta;
  const struct ImVec2 delta2;
  const float mouse_abs_pos;
  float clicked_t;
  bool set_new_value;
  const float linear_dist_max_to_0;
  const float linear_dist_min_to_0;
  struct ImRect grab_bb;
  const float grab_pos;
  float grab_t;
  bool value_changed;
  float linear_zero_pos;
  const float slider_usable_pos_max;
  const float slider_usable_pos_min;
  const float slider_usable_sz;
  float grab_sz;
  const float slider_sz;
  const float grab_padding;
  const bool is_horizontal;
  const bool is_non_linear;
  const ImU32 frame_col;
  const struct ImGuiStyle & style;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  bool D.36247;
  struct ImDrawList * D.36246;
  unsigned int D.36245;
  unsigned int D.36241;
  ImGuiCol iftmp.1231;
  float D.36239;
  float D.36238;
  float D.36237;
  float D.36236;
  float D.36235;
  struct ImVec2 D.19227;
  float D.36234;
  float D.36233;
  float D.36232;
  float D.36231;
  struct ImVec2 D.19228;
  struct ImRect grab_bb.1230;
  float D.36229;
  float D.36228;
  float D.36227;
  float D.36226;
  struct ImVec2 D.19224;
  float D.36225;
  float D.36224;
  float D.36223;
  float D.36222;
  struct ImVec2 D.19225;
  struct ImRect grab_bb.1229;
  bool D.36216;
  float D.36215;
  float D.36209;
  float D.36207;
  float D.36205;
  float D.36204;
  float D.36201;
  float D.36200;
  float D.36198;
  float D.36197;
  float D.36188;
  bool retval.1228;
  bool retval.1227;
  float D.36172;
  float iftmp.1226;
  bool D.36165;
  float D.36163;
  float D.36162;
  bool iftmp.1225;
  bool retval.1224;
  bool D.36155;
  float D.36151;
  bool D.36147;
  bool D.36146;
  unsigned int D.36144;
  float D.36141;
  float iftmp.1223;
  ImGuiInputSource D.36134;
  bool D.36129;
  float D.36127;
  float D.36126;
  float iftmp.1222;
  float iftmp.1221;
  bool D.36115;
  bool D.36114;
  ImGuiInputSource D.36111;
  unsigned int D.36108;
  float iftmp.1220;
  float D.36102;
  float D.36101;
  float D.36100;
  float D.36099;
  float D.36098;
  float D.36097;
  float D.36094;
  float D.36093;
  float D.36092;
  float D.36090;
  float iftmp.1219;
  float D.36086;
  float D.36085;
  float D.36083;
  float iftmp.1218;
  float D.36079;
  float D.36078;
  float D.36077;
  float D.36075;
  float iftmp.1217;
  float D.36071;
  float D.36069;
  float D.36066;
  float D.36064;
  float iftmp.1216;
  int D.36060;
  bool iftmp.1215;
  float D.36054;
  unsigned int D.36049;
  ImGuiCol iftmp.1214;
  unsigned int D.36045;
  ImGuiCol iftmp.1213;
  ImGuiCol iftmp.1213_22;
  ImGuiCol iftmp.1214_23;
  bool iftmp.1215_24;
  float iftmp.1216_25;
  float iftmp.1217_26;
  float iftmp.1218_27;
  float iftmp.1219_28;
  float iftmp.1220_29;
  float iftmp.1221_30;
  float iftmp.1222_31;
  float iftmp.1223_32;
  bool iftmp.1225_33;
  float iftmp.1226_34;
  ImGuiCol iftmp.1231_35;
  unsigned int _59;
  unsigned int _61;
  ImGuiCol iftmp.1214_62;
  ImGuiCol iftmp.1214_63;
  ImGuiCol iftmp.1213_64;
  ImGuiCol iftmp.1213_65;
  float _70;
  bool iftmp.1215_73;
  bool iftmp.1215_74;
  int _77;
  float _81;
  float iftmp.1216_82;
  float _84;
  float iftmp.1216_85;
  float _88;
  float _91;
  float _94;
  float iftmp.1217_95;
  float _96;
  float iftmp.1217_97;
  float _98;
  float _100;
  float _104;
  float iftmp.1218_105;
  float _106;
  float iftmp.1218_107;
  float _108;
  float _110;
  float iftmp.1219_111;
  float _112;
  float iftmp.1219_113;
  float _114;
  float _117;
  float _118;
  float _119;
  float _120;
  float _123;
  float _124;
  float _127;
  float iftmp.1220_129;
  float iftmp.1220_130;
  unsigned int _133;
  ImGuiInputSource _136;
  bool _137;
  bool _138;
  float iftmp.1221_140;
  float iftmp.1221_141;
  float _143;
  float _144;
  float iftmp.1222_146;
  float iftmp.1222_147;
  bool _149;
  ImGuiInputSource _152;
  float iftmp.1223_154;
  float _155;
  float iftmp.1223_156;
  unsigned int _158;
  bool _159;
  bool _160;
  float _163;
  bool _166;
  float _167;
  float _168;
  bool _170;
  bool iftmp.1225_171;
  bool iftmp.1225_172;
  bool retval.1224_173;
  float iftmp.1226_174;
  float iftmp.1226_175;
  float _176;
  bool retval.1227_181;
  bool retval.1228_184;
  float _187;
  float _193;
  float _198;
  float _201;
  float _202;
  float _203;
  float _204;
  float _210;
  float _217;
  float _220;
  bool _223;
  float _228;
  float _229;
  float _230;
  float _231;
  float _233;
  float _234;
  float _235;
  float _236;
  float _243;
  float _244;
  float _245;
  float _246;
  float _248;
  float _249;
  float _250;
  float _251;
  float _258;
  unsigned int _259;
  ImGuiCol iftmp.1231_260;
  ImGuiCol iftmp.1231_261;
  unsigned int _263;
  struct ImDrawList * _264;
  bool _266;

  <bb 2>:
  g_55 = GImGui;
  window_57 = ImGui::GetCurrentWindow ();
  style_58 = &g_55->Style;
  _59 = g_55->ActiveId;
  if (_59 != id_60(D))
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _61 = g_55->HoveredId;
  if (_61 == id_60(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1214_62 = 8;
  goto <bb 6>;

  <bb 5>:
  iftmp.1214_63 = 7;

  <bb 6>:
  # iftmp.1214_23 = PHI <iftmp.1214_62(4), iftmp.1214_63(5)>
  iftmp.1213_64 = iftmp.1214_23;
  goto <bb 8>;

  <bb 7>:
  iftmp.1213_65 = 9;

  <bb 8>:
  # iftmp.1213_22 = PHI <iftmp.1213_64(6), iftmp.1213_65(7)>
  frame_col_67 = ImGui::GetColorU32 (iftmp.1213_22, 1.0e+0);
  ImGui::RenderNavHighlight (frame_bb_68(D), id_60(D), 1);
  _70 = style_58->FrameRounding;
  ImGui::RenderFrame (frame_bb_68(D)->Min, frame_bb_68(D)->Max, frame_col_67, 1, _70);
  if (power_72(D) < 9.99989986419677734375e-1)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  if (power_72(D) > 1.000010013580322265625e+0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1215_74 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.1215_73 = 0;

  <bb 12>:
  # iftmp.1215_24 = PHI <iftmp.1215_74(10), iftmp.1215_73(11)>
  is_non_linear_75 = iftmp.1215_24;
  _77 = flags_76(D) & 1;
  is_horizontal_78 = _77 == 0;
  grab_padding_79 = 2.0e+0;
  if (is_horizontal_78 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _81 = ImRect::GetWidth (frame_bb_68(D));
  iftmp.1216_82 = _81 - 4.0e+0;
  goto <bb 15>;

  <bb 14>:
  _84 = ImRect::GetHeight (frame_bb_68(D));
  iftmp.1216_85 = _84 - 4.0e+0;

  <bb 15>:
  # iftmp.1216_25 = PHI <iftmp.1216_82(13), iftmp.1216_85(14)>
  slider_sz_86 = iftmp.1216_25;
  if (decimal_precision_87(D) != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _88 = style_58->GrabMinSize;
  grab_sz_90 = ImMin (_88, slider_sz_86);
  goto <bb 21>;

  <bb 17>:
  _91 = style_58->GrabMinSize;
  if (v_min_92(D) < v_max_93(D))
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _94 = v_max_93(D) - v_min_92(D);
  iftmp.1217_95 = _94 + 1.0e+0;
  goto <bb 20>;

  <bb 19>:
  _96 = v_min_92(D) - v_max_93(D);
  iftmp.1217_97 = _96 + 1.0e+0;

  <bb 20>:
  # iftmp.1217_26 = PHI <iftmp.1217_95(18), iftmp.1217_97(19)>
  _98 = slider_sz_86 / iftmp.1217_26;
  _100 = ImMax (_98, _91);
  grab_sz_102 = ImMin (_100, slider_sz_86);

  <bb 21>:
  # grab_sz_1 = PHI <grab_sz_90(16), grab_sz_102(20)>
  slider_usable_sz_103 = slider_sz_86 - grab_sz_1;
  if (is_horizontal_78 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  _104 = frame_bb_68(D)->Min.x;
  iftmp.1218_105 = _104 + 2.0e+0;
  goto <bb 24>;

  <bb 23>:
  _106 = frame_bb_68(D)->Min.y;
  iftmp.1218_107 = _106 + 2.0e+0;

  <bb 24>:
  # iftmp.1218_27 = PHI <iftmp.1218_105(22), iftmp.1218_107(23)>
  _108 = grab_sz_1 * 5.0e-1;
  slider_usable_pos_min_109 = iftmp.1218_27 + _108;
  if (is_horizontal_78 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _110 = frame_bb_68(D)->Max.x;
  iftmp.1219_111 = _110 - 2.0e+0;
  goto <bb 27>;

  <bb 26>:
  _112 = frame_bb_68(D)->Max.y;
  iftmp.1219_113 = _112 - 2.0e+0;

  <bb 27>:
  # iftmp.1219_28 = PHI <iftmp.1219_111(25), iftmp.1219_113(26)>
  _114 = grab_sz_1 * 5.0e-1;
  slider_usable_pos_max_115 = iftmp.1219_28 - _114;
  linear_zero_pos_116 = 0.0;
  _117 = v_min_92(D) * v_max_93(D);
  if (_117 < 0.0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  _118 = 1.0e+0 / power_72(D);
  _119 = 0.0 - v_min_92(D);
  _120 = ABS_EXPR <_119>;
  linear_dist_min_to_0_122 = powf (_120, _118);
  _123 = 1.0e+0 / power_72(D);
  _124 = ABS_EXPR <v_max_93(D)>;
  linear_dist_max_to_0_126 = powf (_124, _123);
  _127 = linear_dist_min_to_0_122 + linear_dist_max_to_0_126;
  linear_zero_pos_128 = linear_dist_min_to_0_122 / _127;
  goto <bb 33>;

  <bb 29>:
  if (v_min_92(D) < 0.0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  iftmp.1220_129 = 1.0e+0;
  goto <bb 32>;

  <bb 31>:
  iftmp.1220_130 = 0.0;

  <bb 32>:
  # iftmp.1220_29 = PHI <iftmp.1220_129(30), iftmp.1220_130(31)>
  linear_zero_pos_131 = iftmp.1220_29;

  <bb 33>:
  # linear_zero_pos_2 = PHI <linear_zero_pos_128(28), linear_zero_pos_131(32)>
  value_changed_132 = 0;
  _133 = g_55->ActiveId;
  if (_133 == id_60(D))
    goto <bb 34>;
  else
    goto <bb 94>;

  <bb 34>:
  set_new_value_134 = 0;
  clicked_t_135 = 0.0;
  _136 = g_55->ActiveIdSource;
  if (_136 == 1)
    goto <bb 35>;
  else
    goto <bb 47>;

  <bb 35>:
  _137 = g_55->IO.MouseDown[0];
  _138 = ~_137;
  if (_138 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  ImGui::ClearActiveID ();
  goto <bb 46>;

  <bb 37>:
  if (is_horizontal_78 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  iftmp.1221_140 = g_55->IO.MousePos.x;
  goto <bb 40>;

  <bb 39>:
  iftmp.1221_141 = g_55->IO.MousePos.y;

  <bb 40>:
  # iftmp.1221_30 = PHI <iftmp.1221_140(38), iftmp.1221_141(39)>
  mouse_abs_pos_142 = iftmp.1221_30;
  if (slider_usable_sz_103 > 0.0)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  _143 = mouse_abs_pos_142 - slider_usable_pos_min_109;
  _144 = _143 / slider_usable_sz_103;
  iftmp.1222_146 = ImClamp (_144, 0.0, 1.0e+0);
  goto <bb 43>;

  <bb 42>:
  iftmp.1222_147 = 0.0;

  <bb 43>:
  # iftmp.1222_31 = PHI <iftmp.1222_146(41), iftmp.1222_147(42)>
  clicked_t_148 = iftmp.1222_31;
  _149 = ~is_horizontal_78;
  if (_149 != 0)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  clicked_t_150 = 1.0e+0 - clicked_t_148;

  <bb 45>:
  # clicked_t_10 = PHI <clicked_t_148(43), clicked_t_150(44)>
  set_new_value_151 = 1;

  <bb 46>:
  # set_new_value_6 = PHI <set_new_value_134(36), set_new_value_151(45)>
  # clicked_t_11 = PHI <clicked_t_135(36), clicked_t_10(45)>
  goto <bb 80>;

  <bb 47>:
  _152 = g_55->ActiveIdSource;
  if (_152 == 2)
    goto <bb 48>;
  else
    goto <bb 80>;

  <bb 48>:
  delta2 = ImGui::GetNavInputAmount2d (3, 5, 0.0, 0.0);
  if (is_horizontal_78 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.1223_154 = delta2.x;
  goto <bb 51>;

  <bb 50>:
  _155 = delta2.y;
  iftmp.1223_156 = -_155;

  <bb 51>:
  # iftmp.1223_32 = PHI <iftmp.1223_154(49), iftmp.1223_156(50)>
  delta_157 = iftmp.1223_32;
  _158 = g_55->NavActivatePressedId;
  if (_158 == id_60(D))
    goto <bb 52>;
  else
    goto <bb 54>;

  <bb 52>:
  _159 = g_55->ActiveIdIsJustActivated;
  _160 = ~_159;
  if (_160 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  ImGui::ClearActiveID ();
  goto <bb 79>;

  <bb 54>:
  if (delta_157 != 0.0)
    goto <bb 55>;
  else
    goto <bb 79>;

  <bb 55>:
  _163 = *v_162(D);
  clicked_t_165 = SliderBehaviorCalcRatioFromValue (_163, v_min_92(D), v_max_93(D), power_72(D), linear_zero_pos_2);
  if (decimal_precision_87(D) == 0)
    goto <bb 56>;
  else
    goto <bb 68>;

  <bb 56>:
  _166 = ~is_non_linear_75;
  if (_166 != 0)
    goto <bb 57>;
  else
    goto <bb 68>;

  <bb 57>:
  _167 = v_max_93(D) - v_min_92(D);
  _168 = ABS_EXPR <_167>;
  if (_168 <= 1.0e+2)
    goto <bb 59>;
  else
    goto <bb 58>;

  <bb 58>:
  _170 = IsNavInputDown (14);
  if (_170 != 0)
    goto <bb 59>;
  else
    goto <bb 60>;

  <bb 59>:
  iftmp.1225_172 = 1;
  goto <bb 61>;

  <bb 60>:
  iftmp.1225_171 = 0;

  <bb 61>:
  # iftmp.1225_33 = PHI <iftmp.1225_172(59), iftmp.1225_171(60)>
  retval.1224_173 = iftmp.1225_33;
  if (retval.1224_173 != 0)
    goto <bb 62>;
  else
    goto <bb 66>;

  <bb 62>:
  if (delta_157 < 0.0)
    goto <bb 63>;
  else
    goto <bb 64>;

  <bb 63>:
  iftmp.1226_174 = -1.0e+0;
  goto <bb 65>;

  <bb 64>:
  iftmp.1226_175 = 1.0e+0;

  <bb 65>:
  # iftmp.1226_34 = PHI <iftmp.1226_174(63), iftmp.1226_175(64)>
  _176 = v_max_93(D) - v_min_92(D);
  delta_177 = iftmp.1226_34 / _176;
  goto <bb 67>;

  <bb 66>:
  delta_178 = delta_157 / 1.0e+2;

  <bb 67>:
  # delta_15 = PHI <delta_177(65), delta_178(66)>
  goto <bb 70>;

  <bb 68>:
  delta_179 = delta_157 / 1.0e+2;
  retval.1227_181 = IsNavInputDown (14);
  if (retval.1227_181 != 0)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  delta_182 = delta_179 / 1.0e+1;

  <bb 70>:
  # delta_16 = PHI <delta_15(67), delta_179(68), delta_182(69)>
  retval.1228_184 = IsNavInputDown (15);
  if (retval.1228_184 != 0)
    goto <bb 71>;
  else
    goto <bb 72>;

  <bb 71>:
  delta_185 = delta_16 * 1.0e+1;

  <bb 72>:
  # delta_17 = PHI <delta_16(70), delta_185(71)>
  set_new_value_186 = 1;
  if (clicked_t_165 >= 1.0e+0)
    goto <bb 73>;
  else
    goto <bb 74>;

  <bb 73>:
  if (delta_17 > 0.0)
    goto <bb 76>;
  else
    goto <bb 74>;

  <bb 74>:
  if (clicked_t_165 <= 0.0)
    goto <bb 75>;
  else
    goto <bb 77>;

  <bb 75>:
  if (delta_17 < 0.0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  set_new_value_190 = 0;
  goto <bb 78>;

  <bb 77>:
  _187 = clicked_t_165 + delta_17;
  clicked_t_189 = ImSaturate (_187);

  <bb 78>:
  # set_new_value_7 = PHI <set_new_value_190(76), set_new_value_186(77)>
  # clicked_t_12 = PHI <clicked_t_165(76), clicked_t_189(77)>

  <bb 79>:
  # set_new_value_8 = PHI <set_new_value_134(53), set_new_value_134(54), set_new_value_7(78)>
  # clicked_t_13 = PHI <clicked_t_135(53), clicked_t_135(54), clicked_t_12(78)>
  delta2 ={v} {CLOBBER};

  <bb 80>:
  # set_new_value_9 = PHI <set_new_value_6(46), set_new_value_134(47), set_new_value_8(79)>
  # clicked_t_14 = PHI <clicked_t_11(46), clicked_t_135(47), clicked_t_13(79)>
  if (set_new_value_9 != 0)
    goto <bb 81>;
  else
    goto <bb 93>;

  <bb 81>:
  if (is_non_linear_75 != 0)
    goto <bb 82>;
  else
    goto <bb 89>;

  <bb 82>:
  if (clicked_t_14 < linear_zero_pos_2)
    goto <bb 83>;
  else
    goto <bb 84>;

  <bb 83>:
  _193 = clicked_t_14 / linear_zero_pos_2;
  a_194 = 1.0e+0 - _193;
  a_196 = powf (a_194, power_72(D));
  _198 = ImMin (v_max_93(D), 0.0);
  new_value_200 = ImLerp (_198, v_min_92(D), a_196);
  goto <bb 88>;

  <bb 84>:
  _201 = linear_zero_pos_2 - 1.0e+0;
  _202 = ABS_EXPR <_201>;
  if (_202 > 9.999999974752427078783512115478515625e-7)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  _203 = clicked_t_14 - linear_zero_pos_2;
  _204 = 1.0e+0 - linear_zero_pos_2;
  a_205 = _203 / _204;
  goto <bb 87>;

  <bb 86>:
  a_206 = clicked_t_14;

  <bb 87>:
  # a_20 = PHI <a_205(85), a_206(86)>
  a_208 = powf (a_20, power_72(D));
  _210 = ImMax (v_min_92(D), 0.0);
  new_value_212 = ImLerp (_210, v_max_93(D), a_208);

  <bb 88>:
  # new_value_18 = PHI <new_value_200(83), new_value_212(87)>
  goto <bb 90>;

  <bb 89>:
  new_value_214 = ImLerp (v_min_92(D), v_max_93(D), clicked_t_14);

  <bb 90>:
  # new_value_19 = PHI <new_value_18(88), new_value_214(89)>
  new_value_216 = ImGui::RoundScalar (new_value_19, decimal_precision_87(D));
  _217 = *v_162(D);
  if (_217 != new_value_216)
    goto <bb 91>;
  else
    goto <bb 92>;

  <bb 91>:
  *v_162(D) = new_value_216;
  value_changed_219 = 1;

  <bb 92>:
  # value_changed_3 = PHI <value_changed_132(90), value_changed_219(91)>

  <bb 93>:
  # value_changed_4 = PHI <value_changed_132(80), value_changed_3(92)>

  <bb 94>:
  # value_changed_5 = PHI <value_changed_132(33), value_changed_4(93)>
  _220 = *v_162(D);
  grab_t_222 = SliderBehaviorCalcRatioFromValue (_220, v_min_92(D), v_max_93(D), power_72(D), linear_zero_pos_2);
  _223 = ~is_horizontal_78;
  if (_223 != 0)
    goto <bb 95>;
  else
    goto <bb 96>;

  <bb 95>:
  grab_t_224 = 1.0e+0 - grab_t_222;

  <bb 96>:
  # grab_t_21 = PHI <grab_t_222(94), grab_t_224(95)>
  grab_pos_226 = ImLerp (slider_usable_pos_min_109, slider_usable_pos_max_115, grab_t_21);
  ImRect::ImRect (&grab_bb);
  if (is_horizontal_78 != 0)
    goto <bb 97>;
  else
    goto <bb 98>;

  <bb 97>:
  _228 = frame_bb_68(D)->Max.y;
  _229 = _228 - 2.0e+0;
  _230 = grab_sz_1 * 5.0e-1;
  _231 = _230 + grab_pos_226;
  ImVec2::ImVec2 (&D.19225, _231, _229);
  _233 = frame_bb_68(D)->Min.y;
  _234 = _233 + 2.0e+0;
  _235 = grab_sz_1 * 5.0e-1;
  _236 = grab_pos_226 - _235;
  ImVec2::ImVec2 (&D.19224, _236, _234);
  ImRect::ImRect (&grab_bb.1229, &D.19224, &D.19225);
  grab_bb = grab_bb.1229;
  grab_bb.1229 ={v} {CLOBBER};
  D.19224 ={v} {CLOBBER};
  D.19225 ={v} {CLOBBER};
  goto <bb 99>;

  <bb 98>:
  _243 = grab_sz_1 * 5.0e-1;
  _244 = _243 + grab_pos_226;
  _245 = frame_bb_68(D)->Max.x;
  _246 = _245 - 2.0e+0;
  ImVec2::ImVec2 (&D.19228, _246, _244);
  _248 = grab_sz_1 * 5.0e-1;
  _249 = grab_pos_226 - _248;
  _250 = frame_bb_68(D)->Min.x;
  _251 = _250 + 2.0e+0;
  ImVec2::ImVec2 (&D.19227, _251, _249);
  ImRect::ImRect (&grab_bb.1230, &D.19227, &D.19228);
  grab_bb = grab_bb.1230;
  grab_bb.1230 ={v} {CLOBBER};
  D.19227 ={v} {CLOBBER};
  D.19228 ={v} {CLOBBER};

  <bb 99>:
  _258 = style_58->GrabRounding;
  _259 = g_55->ActiveId;
  if (_259 == id_60(D))
    goto <bb 100>;
  else
    goto <bb 101>;

  <bb 100>:
  iftmp.1231_260 = 20;
  goto <bb 102>;

  <bb 101>:
  iftmp.1231_261 = 19;

  <bb 102>:
  # iftmp.1231_35 = PHI <iftmp.1231_260(100), iftmp.1231_261(101)>
  _263 = ImGui::GetColorU32 (iftmp.1231_35, 1.0e+0);
  _264 = window_57->DrawList;
  ImDrawList::AddRectFilled (_264, &grab_bb.Min, &grab_bb.Max, _263, _258, 15);
  _266 = value_changed_5;
  grab_bb ={v} {CLOBBER};

<L113>:
  return _266;

}



;; Function bool ImGui::SliderFloat(const char*, float*, float, float, const char*, float) (_ZN5ImGui11SliderFloatEPKcPfffS1_f, funcdef_no=1008, decl_uid=3007, cgraph_uid=907, symbol_order=917)

bool ImGui::SliderFloat(const char*, float*, float, float, const char*, float) (const char * label, float * v, float v_min, float v_max, const char * display_format, float power)
{
  const bool D.36356;
  bool D.36355;
  const bool D.36354;
  const bool D.36353;
  bool D.36352;
  const float D.36351;
  const ImGuiID D.36350;
  const char * value_buf_end;
  char value_buf[64];
  const bool value_changed;
  const bool tab_focus_requested;
  bool start_text_input;
  int decimal_precision;
  const bool hovered;
  const struct ImRect total_bb;
  const struct ImRect frame_bb;
  const struct ImVec2 label_size;
  const float w;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.36347;
  float D.36346;
  float D.36345;
  float D.36344;
  float D.36343;
  float D.36342;
  struct ImVec2 D.19259;
  float D.36339;
  struct ImVec2 D.19258;
  sizetype D.36338;
  int D.36337;
  double D.36336;
  float D.36335;
  float D.36334;
  unsigned int D.36333;
  unsigned int D.36331;
  unsigned int D.36327;
  bool D.36325;
  unsigned int D.36321;
  unsigned int D.36319;
  unsigned int D.36317;
  bool D.36316;
  float D.36307;
  bool D.36304;
  bool retval.1235;
  float D.36301;
  float D.36300;
  float D.36297;
  float iftmp.1234;
  struct ImVec2 D.19249;
  struct ImVec2 D.19250;
  struct ImVec2 * D.36295;
  struct ImVec2 * D.36294;
  float D.36293;
  float D.36292;
  float D.36291;
  float D.36290;
  struct ImVec2 D.19246;
  struct ImVec2 D.19247;
  bool D.36289;
  bool D.36286;
  bool _3;
  float iftmp.1234_4;
  bool _12;
  bool _13;
  const ImGuiID _18;
  const float _21;
  float _24;
  float _25;
  float _26;
  float _27;
  struct ImVec2 * _29;
  struct ImVec2 * _31;
  float _35;
  float _36;
  float _37;
  float iftmp.1234_38;
  float iftmp.1234_39;
  bool _46;
  bool _47;
  bool retval.1235_48;
  float _49;
  bool _51;
  const bool _53;
  const bool _61;
  bool _63;
  unsigned int _64;
  unsigned int _65;
  unsigned int _66;
  bool _71;
  unsigned int _72;
  unsigned int _75;
  unsigned int _76;
  float _77;
  const bool _84;
  float _86;
  double _87;
  int _89;
  sizetype _90;
  float _95;
  float _96;
  float _97;
  float _98;
  float _99;
  float _100;
  float _101;
  bool _106;
  bool _109;
  bool _110;

  <bb 2>:
  window_11 = ImGui::GetCurrentWindow ();
  _12 = window_11->SkipItems;
  if (_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = 0;
  goto <bb 28>;

  <bb 4>:
  g_14 = GImGui;
  style_15 = &g_14->Style;
  _18 = ImGuiWindow::GetID (window_11, label_16(D), 0B);
  id_19 = _18;
  _21 = ImGui::CalcItemWidth ();
  w_22 = _21;
  label_size = ImGui::CalcTextSize (label_16(D), 0B, 1, -1.0e+0);
  _24 = label_size.y;
  _25 = style_15->FramePadding.y;
  _26 = _25 * 2.0e+0;
  _27 = _24 + _26;
  ImVec2::ImVec2 (&D.19246, w_22, _27);
  _29 = &window_11->DC.CursorPos;
  D.19247 = operator+ (_29, &D.19246);
  _31 = &window_11->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _31, &D.19247);
  D.19247 ={v} {CLOBBER};
  D.19246 ={v} {CLOBBER};
  _35 = label_size.x;
  if (_35 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _36 = style_15->ItemInnerSpacing.x;
  _37 = label_size.x;
  iftmp.1234_38 = _36 + _37;
  goto <bb 7>;

  <bb 6>:
  iftmp.1234_39 = 0.0;

  <bb 7>:
  # iftmp.1234_4 = PHI <iftmp.1234_38(5), iftmp.1234_39(6)>
  ImVec2::ImVec2 (&D.19249, iftmp.1234_4, 0.0);
  D.19250 = operator+ (&frame_bb.Max, &D.19249);
  ImRect::ImRect (&total_bb, &frame_bb.Min, &D.19250);
  D.19250 ={v} {CLOBBER};
  D.19249 ={v} {CLOBBER};
  _46 = ImGui::ItemAdd (&total_bb, id_19, &frame_bb);
  _47 = _46;
  retval.1235_48 = ~_47;
  if (retval.1235_48 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _49 = style_15->FramePadding.y;
  ImGui::ItemSize (&total_bb, _49);
  _51 = 0;
  goto <bb 28>;

  <bb 9>:
  _53 = ImGui::ItemHoverable (&frame_bb, id_19);
  hovered_54 = _53;
  if (display_format_55(D) == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  display_format_56 = "%.3f";

  <bb 11>:
  # display_format_1 = PHI <display_format_55(D)(9), display_format_56(10)>
  decimal_precision_58 = ImGui::ParseFormatPrecision (display_format_1, 3);
  start_text_input_59 = 0;
  _61 = ImGui::FocusableItemRegister (window_11, id_19, 1);
  tab_focus_requested_62 = _61;
  if (tab_focus_requested_62 != 0)
    goto <bb 17>;
  else
    goto <bb 12>;

  <bb 12>:
  if (hovered_54 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _63 = g_14->IO.MouseClicked[0];
  if (_63 != 0)
    goto <bb 17>;
  else
    goto <bb 14>;

  <bb 14>:
  _64 = g_14->NavActivateId;
  if (_64 == id_19)
    goto <bb 17>;
  else
    goto <bb 15>;

  <bb 15>:
  _65 = g_14->NavInputId;
  if (_65 == id_19)
    goto <bb 16>;
  else
    goto <bb 21>;

  <bb 16>:
  _66 = g_14->ScalarAsInputTextId;
  if (_66 != id_19)
    goto <bb 17>;
  else
    goto <bb 21>;

  <bb 17>:
  ImGui::SetActiveID (id_19, window_11);
  ImGui::SetFocusID (id_19, window_11);
  ImGui::FocusWindow (window_11);
  g_14->ActiveIdAllowNavDirFlags = 12;
  if (tab_focus_requested_62 != 0)
    goto <bb 20>;
  else
    goto <bb 18>;

  <bb 18>:
  _71 = g_14->IO.KeyCtrl;
  if (_71 != 0)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  _72 = g_14->NavInputId;
  if (_72 == id_19)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  start_text_input_73 = 1;
  g_14->ScalarAsInputTextId = 0;

  <bb 21>:
  # start_text_input_2 = PHI <start_text_input_59(15), start_text_input_59(16), start_text_input_59(19), start_text_input_73(20)>
  if (start_text_input_2 != 0)
    goto <bb 24>;
  else
    goto <bb 22>;

  <bb 22>:
  _75 = g_14->ActiveId;
  if (_75 == id_19)
    goto <bb 23>;
  else
    goto <bb 25>;

  <bb 23>:
  _76 = g_14->ScalarAsInputTextId;
  if (_76 == id_19)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _109 = ImGui::InputScalarAsWidgetReplacement (&frame_bb, label_16(D), 1, v_79(D), id_19, decimal_precision_58);
  _110 = _109;
  goto <bb 28>;

  <bb 25>:
  _77 = style_15->FramePadding.y;
  ImGui::ItemSize (&total_bb, _77);
  _84 = ImGui::SliderBehavior (&frame_bb, id_19, v_79(D), v_min_80(D), v_max_81(D), power_82(D), decimal_precision_58, 0);
  value_changed_85 = _84;
  _86 = *v_79(D);
  _87 = (double) _86;
  _89 = ImFormatString (&value_buf, 64, display_format_1, _87);
  _90 = (sizetype) _89;
  value_buf_end_91 = &value_buf + _90;
  ImVec2::ImVec2 (&D.19258, 5.0e-1, 5.0e-1);
  ImGui::RenderTextClipped (&frame_bb.Min, &frame_bb.Max, &value_buf, value_buf_end_91, 0B, &D.19258, 0B);
  D.19258 ={v} {CLOBBER};
  _95 = label_size.x;
  if (_95 > 0.0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _96 = frame_bb.Min.y;
  _97 = style_15->FramePadding.y;
  _98 = _96 + _97;
  _99 = frame_bb.Max.x;
  _100 = style_15->ItemInnerSpacing.x;
  _101 = _99 + _100;
  ImVec2::ImVec2 (&D.19259, _101, _98);
  ImGui::RenderText (D.19259, label_16(D), 0B, 1);
  D.19259 ={v} {CLOBBER};

  <bb 27>:
  _106 = value_changed_85;

  <bb 28>:
  # _3 = PHI <_13(3), _51(8), _110(24), _106(27)>
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  value_buf ={v} {CLOBBER};

<L29>:
  return _3;

}



;; Function bool ImGui::VSliderFloat(const char*, const ImVec2&, float*, float, float, const char*, float) (_ZN5ImGui12VSliderFloatEPKcRK6ImVec2PfffS1_f, funcdef_no=1009, decl_uid=3065, cgraph_uid=908, symbol_order=918)

bool ImGui::VSliderFloat(const char*, const ImVec2&, float*, float, float, const char*, float) (const char * label, const struct ImVec2 & size, float * v, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36412;
  const bool D.36411;
  bool D.36410;
  const ImGuiID D.36409;
  char * value_buf_end;
  char value_buf[64];
  bool value_changed;
  int decimal_precision;
  const bool hovered;
  const struct ImRect bb;
  const struct ImRect frame_bb;
  const struct ImVec2 label_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.36406;
  float D.36405;
  float D.36404;
  float D.36403;
  float D.36402;
  float D.36401;
  struct ImVec2 D.19287;
  float D.36398;
  float D.36397;
  float D.36396;
  float D.36395;
  float D.36394;
  struct ImVec2 D.19285;
  struct ImVec2 D.19286;
  sizetype D.36393;
  int D.36392;
  double D.36391;
  float D.36390;
  unsigned int D.36389;
  unsigned int D.36387;
  bool D.36386;
  bool D.36376;
  bool retval.1237;
  float D.36374;
  float D.36372;
  float D.36371;
  float D.36368;
  float iftmp.1236;
  struct ImVec2 D.19278;
  struct ImVec2 D.19279;
  struct ImVec2 * D.36366;
  struct ImVec2 * D.36365;
  struct ImVec2 D.19276;
  bool D.36364;
  bool D.36361;
  bool _2;
  float iftmp.1236_3;
  bool _11;
  bool _12;
  const ImGuiID _17;
  struct ImVec2 * _20;
  struct ImVec2 * _23;
  float _26;
  float _27;
  float _28;
  float iftmp.1236_29;
  float iftmp.1236_30;
  float _36;
  bool _39;
  bool _40;
  bool retval.1237_41;
  bool _42;
  const bool _44;
  bool _50;
  unsigned int _51;
  unsigned int _52;
  bool _62;
  float _64;
  double _65;
  int _67;
  sizetype _68;
  float _71;
  float _72;
  float _73;
  float _74;
  float _79;
  float _80;
  float _81;
  float _82;
  float _83;
  float _84;
  float _85;
  bool _90;

  <bb 2>:
  window_10 = ImGui::GetCurrentWindow ();
  _11 = window_10->SkipItems;
  if (_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = 0;
  goto <bb 19>;

  <bb 4>:
  g_13 = GImGui;
  style_14 = &g_13->Style;
  _17 = ImGuiWindow::GetID (window_10, label_15(D), 0B);
  id_18 = _17;
  label_size = ImGui::CalcTextSize (label_15(D), 0B, 1, -1.0e+0);
  _20 = &window_10->DC.CursorPos;
  D.19276 = operator+ (_20, size_21(D));
  _23 = &window_10->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _23, &D.19276);
  D.19276 ={v} {CLOBBER};
  _26 = label_size.x;
  if (_26 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _27 = style_14->ItemInnerSpacing.x;
  _28 = label_size.x;
  iftmp.1236_29 = _27 + _28;
  goto <bb 7>;

  <bb 6>:
  iftmp.1236_30 = 0.0;

  <bb 7>:
  # iftmp.1236_3 = PHI <iftmp.1236_29(5), iftmp.1236_30(6)>
  ImVec2::ImVec2 (&D.19278, iftmp.1236_3, 0.0);
  D.19279 = operator+ (&frame_bb.Max, &D.19278);
  ImRect::ImRect (&bb, &frame_bb.Min, &D.19279);
  D.19279 ={v} {CLOBBER};
  D.19278 ={v} {CLOBBER};
  _36 = style_14->FramePadding.y;
  ImGui::ItemSize (&bb, _36);
  _39 = ImGui::ItemAdd (&frame_bb, id_18, 0B);
  _40 = _39;
  retval.1237_41 = ~_40;
  if (retval.1237_41 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _42 = 0;
  goto <bb 19>;

  <bb 9>:
  _44 = ImGui::ItemHoverable (&frame_bb, id_18);
  hovered_45 = _44;
  if (display_format_46(D) == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  display_format_47 = "%.3f";

  <bb 11>:
  # display_format_1 = PHI <display_format_46(D)(9), display_format_47(10)>
  decimal_precision_49 = ImGui::ParseFormatPrecision (display_format_1, 3);
  if (hovered_45 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _50 = g_13->IO.MouseClicked[0];
  if (_50 != 0)
    goto <bb 15>;
  else
    goto <bb 13>;

  <bb 13>:
  _51 = g_13->NavActivateId;
  if (_51 == id_18)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  _52 = g_13->NavInputId;
  if (_52 == id_18)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  ImGui::SetActiveID (id_18, window_10);
  ImGui::SetFocusID (id_18, window_10);
  ImGui::FocusWindow (window_10);
  g_13->ActiveIdAllowNavDirFlags = 3;

  <bb 16>:
  _62 = ImGui::SliderBehavior (&frame_bb, id_18, v_57(D), v_min_58(D), v_max_59(D), power_60(D), decimal_precision_49, 1);
  value_changed_63 = _62;
  _64 = *v_57(D);
  _65 = (double) _64;
  _67 = ImFormatString (&value_buf, 64, display_format_1, _65);
  _68 = (sizetype) _67;
  value_buf_end_69 = &value_buf + _68;
  ImVec2::ImVec2 (&D.19286, 5.0e-1, 0.0);
  _71 = frame_bb.Min.y;
  _72 = style_14->FramePadding.y;
  _73 = _71 + _72;
  _74 = frame_bb.Min.x;
  ImVec2::ImVec2 (&D.19285, _74, _73);
  ImGui::RenderTextClipped (&D.19285, &frame_bb.Max, &value_buf, value_buf_end_69, 0B, &D.19286, 0B);
  D.19285 ={v} {CLOBBER};
  D.19286 ={v} {CLOBBER};
  _79 = label_size.x;
  if (_79 > 0.0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _80 = frame_bb.Min.y;
  _81 = style_14->FramePadding.y;
  _82 = _80 + _81;
  _83 = frame_bb.Max.x;
  _84 = style_14->ItemInnerSpacing.x;
  _85 = _83 + _84;
  ImVec2::ImVec2 (&D.19287, _85, _82);
  ImGui::RenderText (D.19287, label_15(D), 0B, 1);
  D.19287 ={v} {CLOBBER};

  <bb 18>:
  _90 = value_changed_63;

  <bb 19>:
  # _2 = PHI <_12(3), _42(8), _90(18)>
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  value_buf ={v} {CLOBBER};

<L19>:
  return _2;

}



;; Function bool ImGui::SliderAngle(const char*, float*, float, float) (_ZN5ImGui11SliderAngleEPKcPfff, funcdef_no=1010, decl_uid=3033, cgraph_uid=909, symbol_order=919)

bool ImGui::SliderAngle(const char*, float*, float, float) (const char * label, float * v_rad, float v_degrees_min, float v_degrees_max)
{
  bool D.36426;
  bool value_changed;
  float v_deg;
  bool D.36424;
  float D.36423;
  float D.36422;
  float v_deg.1239;
  float v_deg.1238;
  float D.36419;
  float D.36418;
  float _3;
  float _4;
  float v_deg.1238_5;
  bool _11;
  float v_deg.1239_13;
  float _14;
  float _15;
  bool _17;

  <bb 2>:
  _3 = *v_rad_2(D);
  _4 = _3 * 3.6e+2;
  v_deg.1238_5 = _4 / 6.283185482025146484375e+0;
  v_deg = v_deg.1238_5;
  _11 = ImGui::SliderFloat (label_7(D), &v_deg, v_degrees_min_8(D), v_degrees_max_9(D), "%.0f deg", 1.0e+0);
  value_changed_12 = _11;
  v_deg.1239_13 = v_deg;
  _14 = v_deg.1239_13 * 6.283185482025146484375e+0;
  _15 = _14 / 3.6e+2;
  *v_rad_2(D) = _15;
  _17 = value_changed_12;
  v_deg ={v} {CLOBBER};

<L1>:
  return _17;

}



;; Function bool ImGui::SliderInt(const char*, int*, int, int, const char*) (_ZN5ImGui9SliderIntEPKcPiiiS1_, funcdef_no=1011, decl_uid=3039, cgraph_uid=910, symbol_order=920)

bool ImGui::SliderInt(const char*, int*, int, int, const char*) (const char * label, int * v, int v_min, int v_max, const char * display_format)
{
  bool D.36440;
  bool value_changed;
  float v_f;
  bool D.36438;
  int D.36437;
  float v_f.1241;
  float D.36435;
  float D.36434;
  float v_f.1240;
  int D.36432;
  int _6;
  float v_f.1240_7;
  float _10;
  float _12;
  bool _15;
  float v_f.1241_17;
  int _18;
  bool _20;

  <bb 2>:
  if (display_format_2(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  display_format_3 = "%.0f";

  <bb 4>:
  # display_format_1 = PHI <display_format_2(D)(2), display_format_3(3)>
  _6 = *v_5(D);
  v_f.1240_7 = (float) _6;
  v_f = v_f.1240_7;
  _10 = (float) v_max_9(D);
  _12 = (float) v_min_11(D);
  _15 = ImGui::SliderFloat (label_13(D), &v_f, _12, _10, display_format_1, 1.0e+0);
  value_changed_16 = _15;
  v_f.1241_17 = v_f;
  _18 = (int) v_f.1241_17;
  *v_5(D) = _18;
  _20 = value_changed_16;
  v_f ={v} {CLOBBER};

<L4>:
  return _20;

}



;; Function bool ImGui::VSliderInt(const char*, const ImVec2&, int*, int, int, const char*) (_ZN5ImGui10VSliderIntEPKcRK6ImVec2PiiiS1_, funcdef_no=1012, decl_uid=3072, cgraph_uid=911, symbol_order=921)

bool ImGui::VSliderInt(const char*, const ImVec2&, int*, int, int, const char*) (const char * label, const struct ImVec2 & size, int * v, int v_min, int v_max, const char * display_format)
{
  bool D.36454;
  bool value_changed;
  float v_f;
  bool D.36452;
  int D.36451;
  float v_f.1243;
  float D.36449;
  float D.36448;
  float v_f.1242;
  int D.36446;
  int _6;
  float v_f.1242_7;
  float _10;
  float _12;
  bool _16;
  float v_f.1243_18;
  int _19;
  bool _21;

  <bb 2>:
  if (display_format_2(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  display_format_3 = "%.0f";

  <bb 4>:
  # display_format_1 = PHI <display_format_2(D)(2), display_format_3(3)>
  _6 = *v_5(D);
  v_f.1242_7 = (float) _6;
  v_f = v_f.1242_7;
  _10 = (float) v_max_9(D);
  _12 = (float) v_min_11(D);
  _16 = ImGui::VSliderFloat (label_13(D), size_14(D), &v_f, _12, _10, display_format_1, 1.0e+0);
  value_changed_17 = _16;
  v_f.1243_18 = v_f;
  _19 = (int) v_f.1243_18;
  *v_5(D) = _19;
  _21 = value_changed_17;
  v_f ={v} {CLOBBER};

<L4>:
  return _21;

}



;; Function bool ImGui::SliderFloatN(const char*, float*, int, float, float, const char*, float) (_ZN5ImGui12SliderFloatNEPKcPfiffS1_f, funcdef_no=1013, decl_uid=13961, cgraph_uid=912, symbol_order=922)

bool ImGui::SliderFloatN(const char*, float*, int, float, float, const char*, float) (const char * label, float * v, int components, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36469;
  int i;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.36467;
  float D.36466;
  float * D.36465;
  long unsigned int D.36464;
  long unsigned int D.36463;
  bool D.19328;
  bool D.36460;
  bool D.36457;
  bool _3;
  bool _9;
  bool _10;
  long unsigned int _20;
  long unsigned int _21;
  float * _23;
  bool _29;
  bool _30;
  float _32;
  const char * _39;
  bool _42;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 8> (<L5>);

  <bb 4>:
  g_11 = GImGui;
  value_changed_12 = 0;
  ImGui::BeginGroup ();
  ImGui::PushID (label_14(D));
  ImGui::PushMultiItemsWidths (components_16(D), 0.0);
  i_18 = 0;

  <bb 5>:
  # value_changed_1 = PHI <value_changed_12(4), value_changed_31(6)>
  # i_2 = PHI <i_18(4), i_36(6)>
  if (i_2 >= components_16(D))
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ImGui::PushID (i_2);
  _20 = (long unsigned int) i_2;
  _21 = _20 * 4;
  _23 = v_22(D) + _21;
  _29 = ImGui::SliderFloat ("##v", _23, v_min_24(D), v_max_25(D), display_format_26(D), power_27(D));
  _30 = _29;
  value_changed_31 = value_changed_1 | _30;
  _32 = g_11->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _32);
  ImGui::PopID ();
  ImGui::PopItemWidth ();
  i_36 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::PopID ();
  _39 = ImGui::FindRenderedTextEnd (label_14(D), 0B);
  ImGui::TextUnformatted (label_14(D), _39);
  ImGui::EndGroup ();
  _42 = value_changed_1;

  # _3 = PHI <_10(3), _42(7)>
<L5>:
  return _3;

}



;; Function bool ImGui::SliderFloat2(const char*, float*, float, float, const char*, float) (_ZN5ImGui12SliderFloat2EPKcPfffS1_f, funcdef_no=1014, decl_uid=3014, cgraph_uid=913, symbol_order=923)

bool ImGui::SliderFloat2(const char*, float*, float, float, const char*, float) (const char * label, float * v, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36472;
  bool D.36470;
  bool _9;
  bool _10;

  <bb 2>:
  _9 = ImGui::SliderFloatN (label_2(D), v_3(D), 2, v_min_4(D), v_max_5(D), display_format_6(D), power_7(D));
  _10 = _9;

<L0>:
  return _10;

}



;; Function bool ImGui::SliderFloat3(const char*, float*, float, float, const char*, float) (_ZN5ImGui12SliderFloat3EPKcPfffS1_f, funcdef_no=1015, decl_uid=3021, cgraph_uid=914, symbol_order=924)

bool ImGui::SliderFloat3(const char*, float*, float, float, const char*, float) (const char * label, float * v, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36475;
  bool D.36473;
  bool _9;
  bool _10;

  <bb 2>:
  _9 = ImGui::SliderFloatN (label_2(D), v_3(D), 3, v_min_4(D), v_max_5(D), display_format_6(D), power_7(D));
  _10 = _9;

<L0>:
  return _10;

}



;; Function bool ImGui::SliderFloat4(const char*, float*, float, float, const char*, float) (_ZN5ImGui12SliderFloat4EPKcPfffS1_f, funcdef_no=1016, decl_uid=3028, cgraph_uid=915, symbol_order=925)

bool ImGui::SliderFloat4(const char*, float*, float, float, const char*, float) (const char * label, float * v, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36478;
  bool D.36476;
  bool _9;
  bool _10;

  <bb 2>:
  _9 = ImGui::SliderFloatN (label_2(D), v_3(D), 4, v_min_4(D), v_max_5(D), display_format_6(D), power_7(D));
  _10 = _9;

<L0>:
  return _10;

}



;; Function bool ImGui::SliderIntN(const char*, int*, int, int, int, const char*) (_ZN5ImGui10SliderIntNEPKcPiiiiS1_, funcdef_no=1017, decl_uid=13968, cgraph_uid=916, symbol_order=926)

bool ImGui::SliderIntN(const char*, int*, int, int, int, const char*) (const char * label, int * v, int components, int v_min, int v_max, const char * display_format)
{
  bool D.36491;
  int i;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.36489;
  float D.36488;
  int * D.36487;
  long unsigned int D.36486;
  long unsigned int D.36485;
  bool D.19367;
  bool D.36482;
  bool D.36479;
  bool _3;
  bool _9;
  bool _10;
  long unsigned int _20;
  long unsigned int _21;
  int * _23;
  bool _28;
  bool _29;
  float _31;
  const char * _38;
  bool _41;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 8> (<L5>);

  <bb 4>:
  g_11 = GImGui;
  value_changed_12 = 0;
  ImGui::BeginGroup ();
  ImGui::PushID (label_14(D));
  ImGui::PushMultiItemsWidths (components_16(D), 0.0);
  i_18 = 0;

  <bb 5>:
  # value_changed_1 = PHI <value_changed_12(4), value_changed_30(6)>
  # i_2 = PHI <i_18(4), i_35(6)>
  if (i_2 >= components_16(D))
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ImGui::PushID (i_2);
  _20 = (long unsigned int) i_2;
  _21 = _20 * 4;
  _23 = v_22(D) + _21;
  _28 = ImGui::SliderInt ("##v", _23, v_min_24(D), v_max_25(D), display_format_26(D));
  _29 = _28;
  value_changed_30 = value_changed_1 | _29;
  _31 = g_11->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _31);
  ImGui::PopID ();
  ImGui::PopItemWidth ();
  i_35 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::PopID ();
  _38 = ImGui::FindRenderedTextEnd (label_14(D), 0B);
  ImGui::TextUnformatted (label_14(D), _38);
  ImGui::EndGroup ();
  _41 = value_changed_1;

  # _3 = PHI <_10(3), _41(7)>
<L5>:
  return _3;

}



;; Function bool ImGui::SliderInt2(const char*, int*, int, int, const char*) (_ZN5ImGui10SliderInt2EPKcPiiiS1_, funcdef_no=1018, decl_uid=3045, cgraph_uid=917, symbol_order=927)

bool ImGui::SliderInt2(const char*, int*, int, int, const char*) (const char * label, int * v, int v_min, int v_max, const char * display_format)
{
  bool D.36494;
  bool D.36492;
  bool _8;
  bool _9;

  <bb 2>:
  _8 = ImGui::SliderIntN (label_2(D), v_3(D), 2, v_min_4(D), v_max_5(D), display_format_6(D));
  _9 = _8;

<L0>:
  return _9;

}



;; Function bool ImGui::SliderInt3(const char*, int*, int, int, const char*) (_ZN5ImGui10SliderInt3EPKcPiiiS1_, funcdef_no=1019, decl_uid=3051, cgraph_uid=918, symbol_order=928)

bool ImGui::SliderInt3(const char*, int*, int, int, const char*) (const char * label, int * v, int v_min, int v_max, const char * display_format)
{
  bool D.36497;
  bool D.36495;
  bool _8;
  bool _9;

  <bb 2>:
  _8 = ImGui::SliderIntN (label_2(D), v_3(D), 3, v_min_4(D), v_max_5(D), display_format_6(D));
  _9 = _8;

<L0>:
  return _9;

}



;; Function bool ImGui::SliderInt4(const char*, int*, int, int, const char*) (_ZN5ImGui10SliderInt4EPKcPiiiS1_, funcdef_no=1020, decl_uid=3057, cgraph_uid=919, symbol_order=929)

bool ImGui::SliderInt4(const char*, int*, int, int, const char*) (const char * label, int * v, int v_min, int v_max, const char * display_format)
{
  bool D.36500;
  bool D.36498;
  bool _8;
  bool _9;

  <bb 2>:
  _8 = ImGui::SliderIntN (label_2(D), v_3(D), 4, v_min_4(D), v_max_5(D), display_format_6(D));
  _9 = _8;

<L0>:
  return _9;

}



;; Function bool ImGui::DragBehavior(const ImRect&, ImGuiID, float*, float, float, float, int, float) (_ZN5ImGui12DragBehaviorERK6ImRectjPffffif, funcdef_no=1021, decl_uid=13977, cgraph_uid=920, symbol_order=930)

bool ImGui::DragBehavior(const ImRect&, ImGuiID, float*, float, float, float, int, float) (const struct ImRect & frame_bb, ImGuiID id, float * v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
{
  float v1_sign;
  float v1_abs;
  float v1;
  float v0_sign;
  float v0_abs;
  float adjust_delta;
  const struct ImVec2 mouse_drag_delta;
  float v_cur;
  bool value_changed;
  const ImU32 frame_col;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  bool D.36633;
  float D.36628;
  float D.36622;
  float D.36621;
  float iftmp.1251;
  float iftmp.1250;
  float D.36612;
  float D.36611;
  float D.36610;
  float iftmp.1249;
  float iftmp.1248;
  float D.36599;
  float D.36598;
  float D.36595;
  float D.36593;
  struct ImVec2 D.19412;
  ImGuiInputSource D.36583;
  float D.36581;
  float D.36579;
  float D.36576;
  bool D.36573;
  float D.36571;
  float D.36568;
  bool D.36565;
  float D.36564;
  float D.36563;
  bool D.36559;
  ImGuiInputSource D.36557;
  bool iftmp.1247;
  bool retval.1246;
  float D.36551;
  float D.36550;
  float D.36547;
  float D.36544;
  struct ImVec2 D.19407;
  float D.36540;
  bool D.36537;
  unsigned int D.36534;
  bool D.36529;
  bool D.36528;
  unsigned int D.36525;
  ImGuiInputSource D.36522;
  bool D.36520;
  bool D.36519;
  ImGuiInputSource D.36517;
  unsigned int D.36512;
  float D.36511;
  unsigned int D.36506;
  ImGuiCol iftmp.1245;
  unsigned int D.36502;
  ImGuiCol iftmp.1244;
  ImGuiCol iftmp.1244_13;
  ImGuiCol iftmp.1245_14;
  bool iftmp.1247_15;
  float iftmp.1248_16;
  float iftmp.1249_17;
  float iftmp.1250_18;
  float iftmp.1251_19;
  unsigned int _35;
  unsigned int _37;
  ImGuiCol iftmp.1245_38;
  ImGuiCol iftmp.1245_39;
  ImGuiCol iftmp.1244_40;
  ImGuiCol iftmp.1244_41;
  float _46;
  unsigned int _49;
  ImGuiInputSource _50;
  bool _51;
  bool _52;
  ImGuiInputSource _54;
  unsigned int _55;
  bool _56;
  bool _57;
  unsigned int _59;
  bool _60;
  float _62;
  float _70;
  float _71;
  float _72;
  float _73;
  ImGuiInputSource _78;
  bool _80;
  bool iftmp.1247_81;
  bool iftmp.1247_82;
  bool retval.1246_83;
  float _84;
  float _85;
  bool _87;
  float _88;
  float _89;
  bool _91;
  float _92;
  float _93;
  float _95;
  ImGuiInputSource _97;
  float _103;
  float _108;
  float _110;
  float _111;
  float iftmp.1248_112;
  float iftmp.1248_113;
  float iftmp.1249_115;
  float iftmp.1249_116;
  float _118;
  float _120;
  float _121;
  float iftmp.1250_123;
  float iftmp.1250_124;
  float iftmp.1251_126;
  float iftmp.1251_127;
  float _130;
  float _131;
  float _139;
  bool _143;

  <bb 2>:
  g_33 = GImGui;
  style_34 = &g_33->Style;
  _35 = g_33->ActiveId;
  if (_35 != id_36(D))
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  _37 = g_33->HoveredId;
  if (_37 == id_36(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1245_38 = 8;
  goto <bb 6>;

  <bb 5>:
  iftmp.1245_39 = 7;

  <bb 6>:
  # iftmp.1245_14 = PHI <iftmp.1245_38(4), iftmp.1245_39(5)>
  iftmp.1244_40 = iftmp.1245_14;
  goto <bb 8>;

  <bb 7>:
  iftmp.1244_41 = 9;

  <bb 8>:
  # iftmp.1244_13 = PHI <iftmp.1244_40(6), iftmp.1244_41(7)>
  frame_col_43 = ImGui::GetColorU32 (iftmp.1244_13, 1.0e+0);
  ImGui::RenderNavHighlight (frame_bb_44(D), id_36(D), 1);
  _46 = style_34->FrameRounding;
  ImGui::RenderFrame (frame_bb_44(D)->Min, frame_bb_44(D)->Max, frame_col_43, 1, _46);
  value_changed_48 = 0;
  _49 = g_33->ActiveId;
  if (_49 == id_36(D))
    goto <bb 9>;
  else
    goto <bb 17>;

  <bb 9>:
  _50 = g_33->ActiveIdSource;
  if (_50 == 1)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _51 = g_33->IO.MouseDown[0];
  _52 = ~_51;
  if (_52 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  ImGui::ClearActiveID ();
  goto <bb 16>;

  <bb 12>:
  _54 = g_33->ActiveIdSource;
  if (_54 == 2)
    goto <bb 13>;
  else
    goto <bb 16>;

  <bb 13>:
  _55 = g_33->NavActivatePressedId;
  if (_55 == id_36(D))
    goto <bb 14>;
  else
    goto <bb 16>;

  <bb 14>:
  _56 = g_33->ActiveIdIsJustActivated;
  _57 = ~_56;
  if (_57 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  ImGui::ClearActiveID ();

  <bb 16>:

  <bb 17>:
  _59 = g_33->ActiveId;
  if (_59 == id_36(D))
    goto <bb 18>;
  else
    goto <bb 66>;

  <bb 18>:
  _60 = g_33->ActiveIdIsJustActivated;
  if (_60 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _62 = *v_61(D);
  g_33->DragCurrentValue = _62;
  ImVec2::ImVec2 (&D.19407, 0.0, 0.0);
  g_33->DragLastMouseDelta = D.19407;
  D.19407 ={v} {CLOBBER};

  <bb 20>:
  if (v_speed_67(D) == 0.0)
    goto <bb 21>;
  else
    goto <bb 24>;

  <bb 21>:
  _70 = v_max_68(D) - v_min_69(D);
  if (_70 != 0.0)
    goto <bb 22>;
  else
    goto <bb 24>;

  <bb 22>:
  _71 = v_max_68(D) - v_min_69(D);
  if (_71 < 3.4028234663852885981170418348451692544e+38)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _72 = v_max_68(D) - v_min_69(D);
  _73 = g_33->DragSpeedDefaultRatio;
  v_speed_74 = _72 * _73;

  <bb 24>:
  # v_speed_1 = PHI <v_speed_67(D)(20), v_speed_67(D)(21), v_speed_67(D)(22), v_speed_74(23)>
  v_cur_75 = g_33->DragCurrentValue;
  mouse_drag_delta = ImGui::GetMouseDragDelta (0, 1.0e+0);
  adjust_delta_77 = 0.0;
  _78 = g_33->ActiveIdSource;
  if (_78 == 1)
    goto <bb 25>;
  else
    goto <bb 27>;

  <bb 25>:
  _80 = ImGui::IsMousePosValid (0B);
  if (_80 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  iftmp.1247_81 = 1;
  goto <bb 28>;

  <bb 27>:
  iftmp.1247_82 = 0;

  <bb 28>:
  # iftmp.1247_15 = PHI <iftmp.1247_81(26), iftmp.1247_82(27)>
  retval.1246_83 = iftmp.1247_15;
  if (retval.1246_83 != 0)
    goto <bb 29>;
  else
    goto <bb 36>;

  <bb 29>:
  _84 = mouse_drag_delta.x;
  _85 = g_33->DragLastMouseDelta.x;
  adjust_delta_86 = _84 - _85;
  _87 = g_33->IO.KeyShift;
  if (_87 != 0)
    goto <bb 30>;
  else
    goto <bb 32>;

  <bb 30>:
  _88 = g_33->DragSpeedScaleFast;
  if (_88 >= 0.0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  _89 = g_33->DragSpeedScaleFast;
  adjust_delta_90 = _89 * adjust_delta_86;

  <bb 32>:
  # adjust_delta_8 = PHI <adjust_delta_86(29), adjust_delta_86(30), adjust_delta_90(31)>
  _91 = g_33->IO.KeyAlt;
  if (_91 != 0)
    goto <bb 33>;
  else
    goto <bb 35>;

  <bb 33>:
  _92 = g_33->DragSpeedScaleSlow;
  if (_92 >= 0.0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  _93 = g_33->DragSpeedScaleSlow;
  adjust_delta_94 = _93 * adjust_delta_8;

  <bb 35>:
  # adjust_delta_9 = PHI <adjust_delta_8(32), adjust_delta_8(33), adjust_delta_94(34)>
  _95 = mouse_drag_delta.x;
  g_33->DragLastMouseDelta.x = _95;

  <bb 36>:
  # adjust_delta_10 = PHI <adjust_delta_77(28), adjust_delta_9(35)>
  _97 = g_33->ActiveIdSource;
  if (_97 == 2)
    goto <bb 37>;
  else
    goto <bb 44>;

  <bb 37>:
  D.19412 = ImGui::GetNavInputAmount2d (3, 5, 1.00000001490116119384765625e-1, 1.0e+1);
  adjust_delta_99 = D.19412.x;
  if (v_min_69(D) < v_max_68(D))
    goto <bb 38>;
  else
    goto <bb 43>;

  <bb 38>:
  if (v_cur_75 >= v_max_68(D))
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  if (adjust_delta_99 > 0.0)
    goto <bb 42>;
  else
    goto <bb 40>;

  <bb 40>:
  if (v_cur_75 <= v_min_69(D))
    goto <bb 41>;
  else
    goto <bb 43>;

  <bb 41>:
  if (adjust_delta_99 < 0.0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  adjust_delta_100 = 0.0;

  <bb 43>:
  # adjust_delta_11 = PHI <adjust_delta_99(37), adjust_delta_99(40), adjust_delta_99(41), adjust_delta_100(42)>
  _103 = GetMinimumStepAtDecimalPrecision (decimal_precision_101(D));
  v_speed_105 = ImMax (v_speed_1, _103);

  <bb 44>:
  # v_speed_2 = PHI <v_speed_1(36), v_speed_105(43)>
  # adjust_delta_12 = PHI <adjust_delta_10(36), adjust_delta_11(43)>
  adjust_delta_107 = adjust_delta_12 * v_speed_2;
  _108 = ABS_EXPR <adjust_delta_107>;
  if (_108 > 0.0)
    goto <bb 45>;
  else
    goto <bb 63>;

  <bb 45>:
  _110 = power_109(D) - 1.0e+0;
  _111 = ABS_EXPR <_110>;
  if (_111 > 1.000000047497451305389404296875e-3)
    goto <bb 46>;
  else
    goto <bb 59>;

  <bb 46>:
  if (v_cur_75 >= 0.0)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  iftmp.1248_112 = v_cur_75;
  goto <bb 49>;

  <bb 48>:
  iftmp.1248_113 = -v_cur_75;

  <bb 49>:
  # iftmp.1248_16 = PHI <iftmp.1248_112(47), iftmp.1248_113(48)>
  v0_abs_114 = iftmp.1248_16;
  if (v_cur_75 >= 0.0)
    goto <bb 50>;
  else
    goto <bb 51>;

  <bb 50>:
  iftmp.1249_115 = 1.0e+0;
  goto <bb 52>;

  <bb 51>:
  iftmp.1249_116 = -1.0e+0;

  <bb 52>:
  # iftmp.1249_17 = PHI <iftmp.1249_115(50), iftmp.1249_116(51)>
  v0_sign_117 = iftmp.1249_17;
  _118 = 1.0e+0 / power_109(D);
  _120 = powf (v0_abs_114, _118);
  _121 = adjust_delta_107 * v0_sign_117;
  v1_122 = _120 + _121;
  if (v1_122 >= 0.0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  iftmp.1250_123 = v1_122;
  goto <bb 55>;

  <bb 54>:
  iftmp.1250_124 = -v1_122;

  <bb 55>:
  # iftmp.1250_18 = PHI <iftmp.1250_123(53), iftmp.1250_124(54)>
  v1_abs_125 = iftmp.1250_18;
  if (v1_122 >= 0.0)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  iftmp.1251_126 = 1.0e+0;
  goto <bb 58>;

  <bb 57>:
  iftmp.1251_127 = -1.0e+0;

  <bb 58>:
  # iftmp.1251_19 = PHI <iftmp.1251_126(56), iftmp.1251_127(57)>
  v1_sign_128 = iftmp.1251_19;
  _130 = powf (v1_abs_125, power_109(D));
  _131 = _130 * v0_sign_117;
  v_cur_132 = _131 * v1_sign_128;
  goto <bb 60>;

  <bb 59>:
  v_cur_133 = v_cur_75 + adjust_delta_107;

  <bb 60>:
  # v_cur_5 = PHI <v_cur_132(58), v_cur_133(59)>
  if (v_min_69(D) < v_max_68(D))
    goto <bb 61>;
  else
    goto <bb 62>;

  <bb 61>:
  v_cur_135 = ImClamp (v_cur_5, v_min_69(D), v_max_68(D));

  <bb 62>:
  # v_cur_6 = PHI <v_cur_5(60), v_cur_135(61)>
  g_33->DragCurrentValue = v_cur_6;

  <bb 63>:
  # v_cur_7 = PHI <v_cur_75(44), v_cur_6(62)>
  v_cur_138 = ImGui::RoundScalar (v_cur_7, decimal_precision_101(D));
  _139 = *v_61(D);
  if (_139 != v_cur_138)
    goto <bb 64>;
  else
    goto <bb 65>;

  <bb 64>:
  *v_61(D) = v_cur_138;
  value_changed_141 = 1;

  <bb 65>:
  # value_changed_3 = PHI <value_changed_48(63), value_changed_141(64)>
  mouse_drag_delta ={v} {CLOBBER};

  <bb 66>:
  # value_changed_4 = PHI <value_changed_48(17), value_changed_3(65)>
  _143 = value_changed_4;

<L84>:
  return _143;

}



;; Function bool ImGui::DragFloat(const char*, float*, float, float, float, const char*, float) (_ZN5ImGui9DragFloatEPKcPffffS1_f, funcdef_no=1022, decl_uid=2866, cgraph_uid=921, symbol_order=931)

bool ImGui::DragFloat(const char*, float*, float, float, float, const char*, float) (const char * label, float * v, float v_speed, float v_min, float v_max, const char * display_format, float power)
{
  const bool D.36710;
  bool D.36709;
  const bool D.36708;
  const bool D.36707;
  bool D.36706;
  const float D.36705;
  const ImGuiID D.36704;
  const char * value_buf_end;
  char value_buf[64];
  const bool value_changed;
  const bool tab_focus_requested;
  bool start_text_input;
  int decimal_precision;
  const bool hovered;
  const struct ImRect total_bb;
  const struct ImRect inner_bb;
  const struct ImRect frame_bb;
  const struct ImVec2 label_size;
  const float w;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.36701;
  float D.36700;
  float D.36699;
  float D.36698;
  struct ImVec2 D.19451;
  float D.36695;
  struct ImVec2 D.19450;
  sizetype D.36694;
  int D.36693;
  double D.36692;
  float D.36691;
  float D.36690;
  unsigned int D.36689;
  unsigned int D.36687;
  unsigned int D.36683;
  bool D.36681;
  bool D.36679;
  unsigned int D.36675;
  unsigned int D.36673;
  unsigned int D.36671;
  bool D.36670;
  bool D.36668;
  float D.36659;
  bool D.36656;
  bool retval.1253;
  float D.36653;
  float D.36652;
  float D.36649;
  float iftmp.1252;
  struct ImVec2 D.19441;
  struct ImVec2 D.19442;
  const struct ImVec2 * D.36647;
  struct ImVec2 D.19438;
  const struct ImVec2 * D.36646;
  struct ImVec2 D.19439;
  struct ImVec2 * D.36645;
  struct ImVec2 * D.36644;
  float D.36643;
  float D.36642;
  float D.36641;
  float D.36640;
  struct ImVec2 D.19435;
  struct ImVec2 D.19436;
  bool D.36639;
  bool D.36636;
  bool _3;
  float iftmp.1252_4;
  bool _12;
  bool _13;
  const ImGuiID _18;
  const float _21;
  float _24;
  float _25;
  float _26;
  float _27;
  struct ImVec2 * _29;
  struct ImVec2 * _31;
  const struct ImVec2 * _35;
  const struct ImVec2 * _37;
  float _42;
  float _43;
  float _44;
  float iftmp.1252_45;
  float iftmp.1252_46;
  bool _53;
  bool _54;
  bool retval.1253_55;
  float _56;
  bool _58;
  const bool _60;
  const bool _68;
  bool _70;
  bool _71;
  unsigned int _72;
  unsigned int _73;
  unsigned int _74;
  bool _79;
  bool _80;
  unsigned int _81;
  unsigned int _84;
  unsigned int _85;
  float _86;
  const bool _94;
  float _96;
  double _97;
  int _99;
  sizetype _100;
  float _105;
  float _106;
  float _107;
  float _108;
  float _109;
  bool _114;
  bool _117;
  bool _118;

  <bb 2>:
  window_11 = ImGui::GetCurrentWindow ();
  _12 = window_11->SkipItems;
  if (_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = 0;
  goto <bb 30>;

  <bb 4>:
  g_14 = GImGui;
  style_15 = &g_14->Style;
  _18 = ImGuiWindow::GetID (window_11, label_16(D), 0B);
  id_19 = _18;
  _21 = ImGui::CalcItemWidth ();
  w_22 = _21;
  label_size = ImGui::CalcTextSize (label_16(D), 0B, 1, -1.0e+0);
  _24 = label_size.y;
  _25 = style_15->FramePadding.y;
  _26 = _25 * 2.0e+0;
  _27 = _24 + _26;
  ImVec2::ImVec2 (&D.19435, w_22, _27);
  _29 = &window_11->DC.CursorPos;
  D.19436 = operator+ (_29, &D.19435);
  _31 = &window_11->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _31, &D.19436);
  D.19436 ={v} {CLOBBER};
  D.19435 ={v} {CLOBBER};
  _35 = &style_15->FramePadding;
  D.19439 = operator- (&frame_bb.Max, _35);
  _37 = &style_15->FramePadding;
  D.19438 = operator+ (&frame_bb.Min, _37);
  ImRect::ImRect (&inner_bb, &D.19438, &D.19439);
  D.19438 ={v} {CLOBBER};
  D.19439 ={v} {CLOBBER};
  _42 = label_size.x;
  if (_42 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _43 = style_15->ItemInnerSpacing.x;
  _44 = label_size.x;
  iftmp.1252_45 = _43 + _44;
  goto <bb 7>;

  <bb 6>:
  iftmp.1252_46 = 0.0;

  <bb 7>:
  # iftmp.1252_4 = PHI <iftmp.1252_45(5), iftmp.1252_46(6)>
  ImVec2::ImVec2 (&D.19441, iftmp.1252_4, 0.0);
  D.19442 = operator+ (&frame_bb.Max, &D.19441);
  ImRect::ImRect (&total_bb, &frame_bb.Min, &D.19442);
  D.19442 ={v} {CLOBBER};
  D.19441 ={v} {CLOBBER};
  _53 = ImGui::ItemAdd (&total_bb, id_19, &frame_bb);
  _54 = _53;
  retval.1253_55 = ~_54;
  if (retval.1253_55 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _56 = style_15->FramePadding.y;
  ImGui::ItemSize (&total_bb, _56);
  _58 = 0;
  goto <bb 30>;

  <bb 9>:
  _60 = ImGui::ItemHoverable (&frame_bb, id_19);
  hovered_61 = _60;
  if (display_format_62(D) == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  display_format_63 = "%.3f";

  <bb 11>:
  # display_format_1 = PHI <display_format_62(D)(9), display_format_63(10)>
  decimal_precision_65 = ImGui::ParseFormatPrecision (display_format_1, 3);
  start_text_input_66 = 0;
  _68 = ImGui::FocusableItemRegister (window_11, id_19, 1);
  tab_focus_requested_69 = _68;
  if (tab_focus_requested_69 != 0)
    goto <bb 18>;
  else
    goto <bb 12>;

  <bb 12>:
  if (hovered_61 != 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  _70 = g_14->IO.MouseClicked[0];
  if (_70 != 0)
    goto <bb 18>;
  else
    goto <bb 14>;

  <bb 14>:
  _71 = g_14->IO.MouseDoubleClicked[0];
  if (_71 != 0)
    goto <bb 18>;
  else
    goto <bb 15>;

  <bb 15>:
  _72 = g_14->NavActivateId;
  if (_72 == id_19)
    goto <bb 18>;
  else
    goto <bb 16>;

  <bb 16>:
  _73 = g_14->NavInputId;
  if (_73 == id_19)
    goto <bb 17>;
  else
    goto <bb 23>;

  <bb 17>:
  _74 = g_14->ScalarAsInputTextId;
  if (_74 != id_19)
    goto <bb 18>;
  else
    goto <bb 23>;

  <bb 18>:
  ImGui::SetActiveID (id_19, window_11);
  ImGui::SetFocusID (id_19, window_11);
  ImGui::FocusWindow (window_11);
  g_14->ActiveIdAllowNavDirFlags = 12;
  if (tab_focus_requested_69 != 0)
    goto <bb 22>;
  else
    goto <bb 19>;

  <bb 19>:
  _79 = g_14->IO.KeyCtrl;
  if (_79 != 0)
    goto <bb 22>;
  else
    goto <bb 20>;

  <bb 20>:
  _80 = g_14->IO.MouseDoubleClicked[0];
  if (_80 != 0)
    goto <bb 22>;
  else
    goto <bb 21>;

  <bb 21>:
  _81 = g_14->NavInputId;
  if (_81 == id_19)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  start_text_input_82 = 1;
  g_14->ScalarAsInputTextId = 0;

  <bb 23>:
  # start_text_input_2 = PHI <start_text_input_66(16), start_text_input_66(17), start_text_input_66(21), start_text_input_82(22)>
  if (start_text_input_2 != 0)
    goto <bb 26>;
  else
    goto <bb 24>;

  <bb 24>:
  _84 = g_14->ActiveId;
  if (_84 == id_19)
    goto <bb 25>;
  else
    goto <bb 27>;

  <bb 25>:
  _85 = g_14->ScalarAsInputTextId;
  if (_85 == id_19)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _117 = ImGui::InputScalarAsWidgetReplacement (&frame_bb, label_16(D), 1, v_88(D), id_19, decimal_precision_65);
  _118 = _117;
  goto <bb 30>;

  <bb 27>:
  _86 = style_15->FramePadding.y;
  ImGui::ItemSize (&total_bb, _86);
  _94 = ImGui::DragBehavior (&frame_bb, id_19, v_88(D), v_speed_89(D), v_min_90(D), v_max_91(D), decimal_precision_65, power_92(D));
  value_changed_95 = _94;
  _96 = *v_88(D);
  _97 = (double) _96;
  _99 = ImFormatString (&value_buf, 64, display_format_1, _97);
  _100 = (sizetype) _99;
  value_buf_end_101 = &value_buf + _100;
  ImVec2::ImVec2 (&D.19450, 5.0e-1, 5.0e-1);
  ImGui::RenderTextClipped (&frame_bb.Min, &frame_bb.Max, &value_buf, value_buf_end_101, 0B, &D.19450, 0B);
  D.19450 ={v} {CLOBBER};
  _105 = label_size.x;
  if (_105 > 0.0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  _106 = inner_bb.Min.y;
  _107 = frame_bb.Max.x;
  _108 = style_15->ItemInnerSpacing.x;
  _109 = _107 + _108;
  ImVec2::ImVec2 (&D.19451, _109, _106);
  ImGui::RenderText (D.19451, label_16(D), 0B, 1);
  D.19451 ={v} {CLOBBER};

  <bb 29>:
  _114 = value_changed_95;

  <bb 30>:
  # _3 = PHI <_13(3), _58(8), _118(26), _114(29)>
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  inner_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  value_buf ={v} {CLOBBER};

<L31>:
  return _3;

}



;; Function bool ImGui::DragFloatN(const char*, float*, int, float, float, float, const char*, float) (_ZN5ImGui10DragFloatNEPKcPfifffS1_f, funcdef_no=1023, decl_uid=13986, cgraph_uid=922, symbol_order=932)

bool ImGui::DragFloatN(const char*, float*, int, float, float, float, const char*, float) (const char * label, float * v, int components, float v_speed, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36727;
  int i;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.36725;
  float D.36724;
  float * D.36723;
  long unsigned int D.36722;
  long unsigned int D.36721;
  bool D.19466;
  bool D.36718;
  bool D.36715;
  bool _3;
  bool _9;
  bool _10;
  long unsigned int _20;
  long unsigned int _21;
  float * _23;
  bool _30;
  bool _31;
  float _33;
  const char * _40;
  bool _43;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 8> (<L5>);

  <bb 4>:
  g_11 = GImGui;
  value_changed_12 = 0;
  ImGui::BeginGroup ();
  ImGui::PushID (label_14(D));
  ImGui::PushMultiItemsWidths (components_16(D), 0.0);
  i_18 = 0;

  <bb 5>:
  # value_changed_1 = PHI <value_changed_12(4), value_changed_32(6)>
  # i_2 = PHI <i_18(4), i_37(6)>
  if (i_2 >= components_16(D))
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ImGui::PushID (i_2);
  _20 = (long unsigned int) i_2;
  _21 = _20 * 4;
  _23 = v_22(D) + _21;
  _30 = ImGui::DragFloat ("##v", _23, v_speed_24(D), v_min_25(D), v_max_26(D), display_format_27(D), power_28(D));
  _31 = _30;
  value_changed_32 = value_changed_1 | _31;
  _33 = g_11->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _33);
  ImGui::PopID ();
  ImGui::PopItemWidth ();
  i_37 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::PopID ();
  _40 = ImGui::FindRenderedTextEnd (label_14(D), 0B);
  ImGui::TextUnformatted (label_14(D), _40);
  ImGui::EndGroup ();
  _43 = value_changed_1;

  # _3 = PHI <_10(3), _43(7)>
<L5>:
  return _3;

}



;; Function bool ImGui::DragFloat2(const char*, float*, float, float, float, const char*, float) (_ZN5ImGui10DragFloat2EPKcPffffS1_f, funcdef_no=1024, decl_uid=2874, cgraph_uid=923, symbol_order=933)

bool ImGui::DragFloat2(const char*, float*, float, float, float, const char*, float) (const char * label, float * v, float v_speed, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36730;
  bool D.36728;
  bool _10;
  bool _11;

  <bb 2>:
  _10 = ImGui::DragFloatN (label_2(D), v_3(D), 2, v_speed_4(D), v_min_5(D), v_max_6(D), display_format_7(D), power_8(D));
  _11 = _10;

<L0>:
  return _11;

}



;; Function bool ImGui::DragFloat3(const char*, float*, float, float, float, const char*, float) (_ZN5ImGui10DragFloat3EPKcPffffS1_f, funcdef_no=1025, decl_uid=2882, cgraph_uid=924, symbol_order=934)

bool ImGui::DragFloat3(const char*, float*, float, float, float, const char*, float) (const char * label, float * v, float v_speed, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36733;
  bool D.36731;
  bool _10;
  bool _11;

  <bb 2>:
  _10 = ImGui::DragFloatN (label_2(D), v_3(D), 3, v_speed_4(D), v_min_5(D), v_max_6(D), display_format_7(D), power_8(D));
  _11 = _10;

<L0>:
  return _11;

}



;; Function bool ImGui::DragFloat4(const char*, float*, float, float, float, const char*, float) (_ZN5ImGui10DragFloat4EPKcPffffS1_f, funcdef_no=1026, decl_uid=2890, cgraph_uid=925, symbol_order=935)

bool ImGui::DragFloat4(const char*, float*, float, float, float, const char*, float) (const char * label, float * v, float v_speed, float v_min, float v_max, const char * display_format, float power)
{
  bool D.36736;
  bool D.36734;
  bool _10;
  bool _11;

  <bb 2>:
  _10 = ImGui::DragFloatN (label_2(D), v_3(D), 4, v_speed_4(D), v_min_5(D), v_max_6(D), display_format_7(D), power_8(D));
  _11 = _10;

<L0>:
  return _11;

}



;; Function bool ImGui::DragFloatRange2(const char*, float*, float*, float, float, float, const char*, const char*, float) (_ZN5ImGui15DragFloatRange2EPKcPfS2_fffS1_S1_f, funcdef_no=1027, decl_uid=2900, cgraph_uid=926, symbol_order=936)

bool ImGui::DragFloatRange2(const char*, float*, float*, float, float, float, const char*, const char*, float) (const char * label, float * v_current_min, float * v_current_max, float v_speed, float v_min, float v_max, const char * display_format, const char * display_format_max, float power)
{
  bool D.36768;
  bool D.36767;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.36765;
  float D.36764;
  float D.36763;
  float iftmp.1258;
  float iftmp.1257;
  const char * iftmp.1256;
  bool D.19510;
  float D.36750;
  float iftmp.1255;
  float D.36745;
  float iftmp.1254;
  bool D.36740;
  bool D.36737;
  bool _1;
  float iftmp.1254_2;
  float iftmp.1255_3;
  const char * iftmp.1256_4;
  float iftmp.1257_5;
  float iftmp.1258_6;
  bool _13;
  bool _14;
  float iftmp.1254_23;
  float _24;
  float iftmp.1254_26;
  float iftmp.1255_27;
  float iftmp.1255_28;
  bool _34;
  float _37;
  const char * iftmp.1256_40;
  const char * iftmp.1256_41;
  float iftmp.1257_42;
  float iftmp.1257_43;
  float iftmp.1258_44;
  float _45;
  float iftmp.1258_47;
  bool _49;
  bool _50;
  float _53;
  const char * _56;
  bool _60;

  <bb 2>:
  window_12 = ImGui::GetCurrentWindow ();
  _13 = window_12->SkipItems;
  if (_13 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _14 = 0;
  goto <bb 20> (<L17>);

  <bb 4>:
  g_15 = GImGui;
  ImGui::PushID (label_16(D));
  ImGui::BeginGroup ();
  ImGui::PushMultiItemsWidths (2, 0.0);
  if (v_min_20(D) >= v_max_21(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1254_23 = *v_current_max_22(D);
  goto <bb 7>;

  <bb 6>:
  _24 = *v_current_max_22(D);
  iftmp.1254_26 = ImMin (v_max_21(D), _24);

  <bb 7>:
  # iftmp.1254_2 = PHI <iftmp.1254_23(5), iftmp.1254_26(6)>
  if (v_min_20(D) >= v_max_21(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1255_27 = -3.4028234663852885981170418348451692544e+38;
  goto <bb 10>;

  <bb 9>:
  iftmp.1255_28 = v_min_20(D);

  <bb 10>:
  # iftmp.1255_3 = PHI <iftmp.1255_27(8), iftmp.1255_28(9)>
  _34 = ImGui::DragFloat ("##min", v_current_min_29(D), v_speed_30(D), iftmp.1255_3, iftmp.1254_2, display_format_31(D), power_32(D));
  value_changed_35 = _34;
  ImGui::PopItemWidth ();
  _37 = g_15->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _37);
  if (display_format_max_39(D) != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.1256_40 = display_format_max_39(D);
  goto <bb 13>;

  <bb 12>:
  iftmp.1256_41 = display_format_31(D);

  <bb 13>:
  # iftmp.1256_4 = PHI <iftmp.1256_40(11), iftmp.1256_41(12)>
  if (v_min_20(D) >= v_max_21(D))
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  iftmp.1257_42 = 3.4028234663852885981170418348451692544e+38;
  goto <bb 16>;

  <bb 15>:
  iftmp.1257_43 = v_max_21(D);

  <bb 16>:
  # iftmp.1257_5 = PHI <iftmp.1257_42(14), iftmp.1257_43(15)>
  if (v_min_20(D) >= v_max_21(D))
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.1258_44 = *v_current_min_29(D);
  goto <bb 19>;

  <bb 18>:
  _45 = *v_current_min_29(D);
  iftmp.1258_47 = ImMax (v_min_20(D), _45);

  <bb 19>:
  # iftmp.1258_6 = PHI <iftmp.1258_44(17), iftmp.1258_47(18)>
  _49 = ImGui::DragFloat ("##max", v_current_max_22(D), v_speed_30(D), iftmp.1258_6, iftmp.1257_5, iftmp.1256_4, power_32(D));
  _50 = _49;
  value_changed_51 = value_changed_35 | _50;
  ImGui::PopItemWidth ();
  _53 = g_15->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _53);
  _56 = ImGui::FindRenderedTextEnd (label_16(D), 0B);
  ImGui::TextUnformatted (label_16(D), _56);
  ImGui::EndGroup ();
  ImGui::PopID ();
  _60 = value_changed_51;

  # _1 = PHI <_14(3), _60(19)>
<L17>:
  return _1;

}



;; Function bool ImGui::DragInt(const char*, int*, float, int, int, const char*) (_ZN5ImGui7DragIntEPKcPifiiS1_, funcdef_no=1028, decl_uid=2907, cgraph_uid=927, symbol_order=937)

bool ImGui::DragInt(const char*, int*, float, int, int, const char*) (const char * label, int * v, float v_speed, int v_min, int v_max, const char * display_format)
{
  bool D.36780;
  bool value_changed;
  float v_f;
  bool D.36778;
  int D.36777;
  float v_f.1260;
  float D.36775;
  float D.36774;
  float v_f.1259;
  int D.36772;
  int _6;
  float v_f.1259_7;
  float _10;
  float _12;
  bool _16;
  float v_f.1260_18;
  int _19;
  bool _21;

  <bb 2>:
  if (display_format_2(D) == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  display_format_3 = "%.0f";

  <bb 4>:
  # display_format_1 = PHI <display_format_2(D)(2), display_format_3(3)>
  _6 = *v_5(D);
  v_f.1259_7 = (float) _6;
  v_f = v_f.1259_7;
  _10 = (float) v_max_9(D);
  _12 = (float) v_min_11(D);
  _16 = ImGui::DragFloat (label_13(D), &v_f, v_speed_14(D), _12, _10, display_format_1, 1.0e+0);
  value_changed_17 = _16;
  v_f.1260_18 = v_f;
  _19 = (int) v_f.1260_18;
  *v_5(D) = _19;
  _21 = value_changed_17;
  v_f ={v} {CLOBBER};

<L4>:
  return _21;

}



;; Function bool ImGui::DragIntN(const char*, int*, int, float, int, int, const char*) (_ZN5ImGui8DragIntNEPKcPiifiiS1_, funcdef_no=1029, decl_uid=13994, cgraph_uid=928, symbol_order=938)

bool ImGui::DragIntN(const char*, int*, int, float, int, int, const char*) (const char * label, int * v, int components, float v_speed, int v_min, int v_max, const char * display_format)
{
  bool D.36795;
  int i;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.36793;
  float D.36792;
  int * D.36791;
  long unsigned int D.36790;
  long unsigned int D.36789;
  bool D.19534;
  bool D.36786;
  bool D.36783;
  bool _3;
  bool _9;
  bool _10;
  long unsigned int _20;
  long unsigned int _21;
  int * _23;
  bool _29;
  bool _30;
  float _32;
  const char * _39;
  bool _42;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 8> (<L5>);

  <bb 4>:
  g_11 = GImGui;
  value_changed_12 = 0;
  ImGui::BeginGroup ();
  ImGui::PushID (label_14(D));
  ImGui::PushMultiItemsWidths (components_16(D), 0.0);
  i_18 = 0;

  <bb 5>:
  # value_changed_1 = PHI <value_changed_12(4), value_changed_31(6)>
  # i_2 = PHI <i_18(4), i_36(6)>
  if (i_2 >= components_16(D))
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ImGui::PushID (i_2);
  _20 = (long unsigned int) i_2;
  _21 = _20 * 4;
  _23 = v_22(D) + _21;
  _29 = ImGui::DragInt ("##v", _23, v_speed_24(D), v_min_25(D), v_max_26(D), display_format_27(D));
  _30 = _29;
  value_changed_31 = value_changed_1 | _30;
  _32 = g_11->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _32);
  ImGui::PopID ();
  ImGui::PopItemWidth ();
  i_36 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::PopID ();
  _39 = ImGui::FindRenderedTextEnd (label_14(D), 0B);
  ImGui::TextUnformatted (label_14(D), _39);
  ImGui::EndGroup ();
  _42 = value_changed_1;

  # _3 = PHI <_10(3), _42(7)>
<L5>:
  return _3;

}



;; Function bool ImGui::DragInt2(const char*, int*, float, int, int, const char*) (_ZN5ImGui8DragInt2EPKcPifiiS1_, funcdef_no=1030, decl_uid=2914, cgraph_uid=929, symbol_order=939)

bool ImGui::DragInt2(const char*, int*, float, int, int, const char*) (const char * label, int * v, float v_speed, int v_min, int v_max, const char * display_format)
{
  bool D.36798;
  bool D.36796;
  bool _9;
  bool _10;

  <bb 2>:
  _9 = ImGui::DragIntN (label_2(D), v_3(D), 2, v_speed_4(D), v_min_5(D), v_max_6(D), display_format_7(D));
  _10 = _9;

<L0>:
  return _10;

}



;; Function bool ImGui::DragInt3(const char*, int*, float, int, int, const char*) (_ZN5ImGui8DragInt3EPKcPifiiS1_, funcdef_no=1031, decl_uid=2921, cgraph_uid=930, symbol_order=940)

bool ImGui::DragInt3(const char*, int*, float, int, int, const char*) (const char * label, int * v, float v_speed, int v_min, int v_max, const char * display_format)
{
  bool D.36801;
  bool D.36799;
  bool _9;
  bool _10;

  <bb 2>:
  _9 = ImGui::DragIntN (label_2(D), v_3(D), 3, v_speed_4(D), v_min_5(D), v_max_6(D), display_format_7(D));
  _10 = _9;

<L0>:
  return _10;

}



;; Function bool ImGui::DragInt4(const char*, int*, float, int, int, const char*) (_ZN5ImGui8DragInt4EPKcPifiiS1_, funcdef_no=1032, decl_uid=2928, cgraph_uid=931, symbol_order=941)

bool ImGui::DragInt4(const char*, int*, float, int, int, const char*) (const char * label, int * v, float v_speed, int v_min, int v_max, const char * display_format)
{
  bool D.36804;
  bool D.36802;
  bool _9;
  bool _10;

  <bb 2>:
  _9 = ImGui::DragIntN (label_2(D), v_3(D), 4, v_speed_4(D), v_min_5(D), v_max_6(D), display_format_7(D));
  _10 = _9;

<L0>:
  return _10;

}



;; Function bool ImGui::DragIntRange2(const char*, int*, int*, float, int, int, const char*, const char*) (_ZN5ImGui13DragIntRange2EPKcPiS2_fiiS1_S1_, funcdef_no=1033, decl_uid=2937, cgraph_uid=932, symbol_order=942)

bool ImGui::DragIntRange2(const char*, int*, int*, float, int, int, const char*, const char*) (const char * label, int * v_current_min, int * v_current_max, float v_speed, int v_min, int v_max, const char * display_format, const char * display_format_max)
{
  bool D.36836;
  bool D.36835;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.36833;
  float D.36832;
  int D.36831;
  int iftmp.1265;
  int iftmp.1264;
  const char * iftmp.1263;
  bool D.19574;
  float D.36818;
  int iftmp.1262;
  int D.36813;
  int iftmp.1261;
  bool D.36808;
  bool D.36805;
  bool _1;
  int iftmp.1261_2;
  int iftmp.1262_3;
  const char * iftmp.1263_4;
  int iftmp.1264_5;
  int iftmp.1265_6;
  bool _13;
  bool _14;
  int iftmp.1261_23;
  int _24;
  int iftmp.1261_26;
  int iftmp.1262_27;
  int iftmp.1262_28;
  bool _33;
  float _36;
  const char * iftmp.1263_39;
  const char * iftmp.1263_40;
  int iftmp.1264_41;
  int iftmp.1264_42;
  int iftmp.1265_43;
  int _44;
  int iftmp.1265_46;
  bool _48;
  bool _49;
  float _52;
  const char * _55;
  bool _59;

  <bb 2>:
  window_12 = ImGui::GetCurrentWindow ();
  _13 = window_12->SkipItems;
  if (_13 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _14 = 0;
  goto <bb 20> (<L17>);

  <bb 4>:
  g_15 = GImGui;
  ImGui::PushID (label_16(D));
  ImGui::BeginGroup ();
  ImGui::PushMultiItemsWidths (2, 0.0);
  if (v_min_20(D) >= v_max_21(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1261_23 = *v_current_max_22(D);
  goto <bb 7>;

  <bb 6>:
  _24 = *v_current_max_22(D);
  iftmp.1261_26 = ImMin (v_max_21(D), _24);

  <bb 7>:
  # iftmp.1261_2 = PHI <iftmp.1261_23(5), iftmp.1261_26(6)>
  if (v_min_20(D) < v_max_21(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1262_27 = v_min_20(D);
  goto <bb 10>;

  <bb 9>:
  iftmp.1262_28 = -2147483648;

  <bb 10>:
  # iftmp.1262_3 = PHI <iftmp.1262_27(8), iftmp.1262_28(9)>
  _33 = ImGui::DragInt ("##min", v_current_min_29(D), v_speed_30(D), iftmp.1262_3, iftmp.1261_2, display_format_31(D));
  value_changed_34 = _33;
  ImGui::PopItemWidth ();
  _36 = g_15->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _36);
  if (display_format_max_38(D) != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.1263_39 = display_format_max_38(D);
  goto <bb 13>;

  <bb 12>:
  iftmp.1263_40 = display_format_31(D);

  <bb 13>:
  # iftmp.1263_4 = PHI <iftmp.1263_39(11), iftmp.1263_40(12)>
  if (v_min_20(D) < v_max_21(D))
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  iftmp.1264_41 = v_max_21(D);
  goto <bb 16>;

  <bb 15>:
  iftmp.1264_42 = 2147483647;

  <bb 16>:
  # iftmp.1264_5 = PHI <iftmp.1264_41(14), iftmp.1264_42(15)>
  if (v_min_20(D) >= v_max_21(D))
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.1265_43 = *v_current_min_29(D);
  goto <bb 19>;

  <bb 18>:
  _44 = *v_current_min_29(D);
  iftmp.1265_46 = ImMax (v_min_20(D), _44);

  <bb 19>:
  # iftmp.1265_6 = PHI <iftmp.1265_43(17), iftmp.1265_46(18)>
  _48 = ImGui::DragInt ("##max", v_current_max_22(D), v_speed_30(D), iftmp.1265_6, iftmp.1264_5, iftmp.1263_4);
  _49 = _48;
  value_changed_50 = value_changed_34 | _49;
  ImGui::PopItemWidth ();
  _52 = g_15->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _52);
  _55 = ImGui::FindRenderedTextEnd (label_16(D), 0B);
  ImGui::TextUnformatted (label_16(D), _55);
  ImGui::EndGroup ();
  ImGui::PopID ();
  _59 = value_changed_50;

  # _1 = PHI <_14(3), _59(19)>
<L17>:
  return _1;

}



;; Function void ImGui::PlotEx(ImGuiPlotType, const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2) (_ZN5ImGui6PlotExE13ImGuiPlotTypePKcPFfPviES3_iiS2_ff6ImVec2, funcdef_no=1034, decl_uid=14058, cgraph_uid=933, symbol_order=943)

void ImGui::PlotEx(ImGuiPlotType, const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2) (ImGuiPlotType plot_type, const char * label, float (*<T6b3>) (void *, int) values_getter, void * data, int values_count, int values_offset, const char * overlay_text, float scale_min, float scale_max, struct ImVec2 graph_size)
{
  const float D.37037;
  float D.37036;
  const float D.37035;
  const float D.37034;
  const float D.37033;
  const bool D.37032;
  bool D.37031;
  float D.37030;
  struct ImVec2 pos1;
  struct ImVec2 pos0;
  const struct ImVec2 tp1;
  const float v1;
  const int v1_idx;
  const float t1;
  int n;
  const float v1;
  const float v0;
  const int v_idx;
  const float t;
  const ImU32 col_hovered;
  const ImU32 col_base;
  float histogram_zero_line_t;
  struct ImVec2 tp0;
  float t0;
  float v0;
  const float inv_scale;
  const float t_step;
  int v_hovered;
  int item_count;
  int res_w;
  const float v;
  int i;
  float v_max;
  float v_min;
  static const char __PRETTY_FUNCTION__[122] = "void ImGui::PlotEx(ImGuiPlotType, const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2)";
  const bool hovered;
  const struct ImRect total_bb;
  const struct ImRect inner_bb;
  const struct ImRect frame_bb;
  const struct ImVec2 label_size;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.37027;
  float D.37026;
  float D.37025;
  float D.37024;
  struct ImVec2 D.19642;
  float D.37021;
  float D.37019;
  float D.37018;
  float D.37017;
  float D.37016;
  struct ImVec2 D.19640;
  struct ImVec2 D.19641;
  struct ImDrawList * D.37011;
  ImU32 iftmp.1278;
  float D.37005;
  float D.37004;
  float D.37001;
  float D.37000;
  float D.36999;
  struct ImDrawList * D.36995;
  ImU32 iftmp.1277;
  float D.36988;
  const struct ImVec2 D.19638;
  float D.36984;
  float D.36983;
  float D.36982;
  float D.36981;
  int D.36980;
  int D.36979;
  int D.36978;
  float D.36973;
  float D.36972;
  float D.36971;
  ImGuiCol iftmp.1276;
  ImGuiCol iftmp.1275;
  float iftmp.1274;
  float D.36955;
  float D.36952;
  float iftmp.1273;
  float D.36950;
  float D.36949;
  float D.36948;
  float D.36947;
  int D.36946;
  float D.36944;
  float iftmp.1272;
  float D.36940;
  double D.36937;
  double D.36933;
  int D.36932;
  double D.36931;
  int D.36928;
  int D.36927;
  int D.36926;
  int D.36925;
  int D.36924;
  float D.36919;
  float D.36918;
  float D.36917;
  float D.36916;
  float D.36915;
  float D.36914;
  float D.36913;
  float D.36912;
  float D.36911;
  int iftmp.1271;
  int iftmp.1270;
  int D.36900;
  int D.36899;
  float D.36898;
  unsigned int D.36895;
  float D.36894;
  bool D.36880;
  bool retval.1269;
  float D.36878;
  float D.36876;
  float D.36875;
  float D.36872;
  float iftmp.1268;
  struct ImVec2 D.19601;
  struct ImVec2 D.19602;
  const struct ImVec2 * D.36870;
  struct ImVec2 D.19598;
  const struct ImVec2 * D.36869;
  struct ImVec2 D.19599;
  struct ImVec2 * D.36868;
  struct ImVec2 * D.36867;
  float D.36866;
  float D.36865;
  struct ImVec2 D.19595;
  struct ImVec2 D.19596;
  float D.36863;
  float D.36862;
  float D.36861;
  float D.36860;
  float D.36857;
  float D.36855;
  float D.36852;
  bool D.36849;
  float iftmp.1268_10;
  int iftmp.1270_11;
  int iftmp.1271_12;
  float iftmp.1272_13;
  float iftmp.1273_14;
  float iftmp.1274_15;
  ImGuiCol iftmp.1275_16;
  ImGuiCol iftmp.1276_17;
  ImU32 iftmp.1277_18;
  ImU32 iftmp.1278_19;
  bool _41;
  float _46;
  float _48;
  float _49;
  float _51;
  float _52;
  float _53;
  float _54;
  float _55;
  float _57;
  float _58;
  struct ImVec2 * _60;
  struct ImVec2 * _62;
  const struct ImVec2 * _66;
  const struct ImVec2 * _68;
  float _73;
  float _74;
  float _75;
  float iftmp.1268_76;
  float iftmp.1268_77;
  float _83;
  bool _86;
  bool _87;
  bool retval.1269_88;
  const bool _90;
  const float _101;
  float _110;
  unsigned int _112;
  float _114;
  int _115;
  int _117;
  int iftmp.1270_119;
  int iftmp.1270_120;
  int iftmp.1271_122;
  int iftmp.1271_123;
  float _126;
  float _127;
  float _128;
  float _129;
  float _130;
  float _131;
  float _132;
  float _135;
  float _136;
  int _139;
  int _140;
  const float _142;
  int _144;
  int _145;
  int _146;
  const float _148;
  double _150;
  int _151;
  double _152;
  double _154;
  float _158;
  float _160;
  float iftmp.1272_161;
  float iftmp.1272_162;
  int _164;
  float _166;
  float _169;
  float _170;
  float _172;
  float _173;
  float _175;
  float _176;
  float iftmp.1273_177;
  float iftmp.1274_178;
  float iftmp.1274_179;
  float iftmp.1273_180;
  ImGuiCol iftmp.1275_182;
  ImGuiCol iftmp.1275_183;
  ImGuiCol iftmp.1276_186;
  ImGuiCol iftmp.1276_187;
  float _192;
  float _193;
  float _194;
  int _196;
  int _197;
  int _198;
  const float _200;
  float _202;
  float _203;
  float _205;
  float _206;
  float _210;
  ImU32 iftmp.1277_214;
  ImU32 iftmp.1277_215;
  struct ImDrawList * _216;
  float _218;
  float _219;
  float _220;
  float _221;
  float _222;
  ImU32 iftmp.1278_224;
  ImU32 iftmp.1278_225;
  struct ImDrawList * _226;
  float _242;
  float _243;
  float _244;
  float _245;
  float _252;
  float _253;
  float _254;
  float _255;
  float _256;

  <bb 2>:
  window_40 = ImGui::GetCurrentWindow ();
  _41 = window_40->SkipItems;
  if (_41 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 82>;

  <bb 4>:
  g_42 = GImGui;
  style_43 = &g_42->Style;
  label_size = ImGui::CalcTextSize (label_44(D), 0B, 1, -1.0e+0);
  _46 = graph_size.x;
  if (_46 == 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _48 = ImGui::CalcItemWidth ();
  _49 = _48;
  graph_size.x = _49;

  <bb 6>:
  _51 = graph_size.y;
  if (_51 == 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _52 = label_size.y;
  _53 = style_43->FramePadding.y;
  _54 = _53 * 2.0e+0;
  _55 = _52 + _54;
  graph_size.y = _55;

  <bb 8>:
  _57 = graph_size.y;
  _58 = graph_size.x;
  ImVec2::ImVec2 (&D.19595, _58, _57);
  _60 = &window_40->DC.CursorPos;
  D.19596 = operator+ (_60, &D.19595);
  _62 = &window_40->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _62, &D.19596);
  D.19596 ={v} {CLOBBER};
  D.19595 ={v} {CLOBBER};
  _66 = &style_43->FramePadding;
  D.19599 = operator- (&frame_bb.Max, _66);
  _68 = &style_43->FramePadding;
  D.19598 = operator+ (&frame_bb.Min, _68);
  ImRect::ImRect (&inner_bb, &D.19598, &D.19599);
  D.19598 ={v} {CLOBBER};
  D.19599 ={v} {CLOBBER};
  _73 = label_size.x;
  if (_73 > 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _74 = style_43->ItemInnerSpacing.x;
  _75 = label_size.x;
  iftmp.1268_76 = _74 + _75;
  goto <bb 11>;

  <bb 10>:
  iftmp.1268_77 = 0.0;

  <bb 11>:
  # iftmp.1268_10 = PHI <iftmp.1268_76(9), iftmp.1268_77(10)>
  ImVec2::ImVec2 (&D.19601, iftmp.1268_10, 0.0);
  D.19602 = operator+ (&frame_bb.Max, &D.19601);
  ImRect::ImRect (&total_bb, &frame_bb.Min, &D.19602);
  D.19602 ={v} {CLOBBER};
  D.19601 ={v} {CLOBBER};
  _83 = style_43->FramePadding.y;
  ImGui::ItemSize (&total_bb, _83);
  _86 = ImGui::ItemAdd (&total_bb, 0, &frame_bb);
  _87 = _86;
  retval.1269_88 = ~_87;
  if (retval.1269_88 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  goto <bb 82>;

  <bb 13>:
  _90 = ImGui::ItemHoverable (&inner_bb, 0);
  hovered_91 = _90;
  if (scale_min_92(D) == 3.4028234663852885981170418348451692544e+38)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  if (scale_max_93(D) == 3.4028234663852885981170418348451692544e+38)
    goto <bb 15>;
  else
    goto <bb 22>;

  <bb 15>:
  v_min_94 = 3.4028234663852885981170418348451692544e+38;
  v_max_95 = -3.4028234663852885981170418348451692544e+38;
  i_96 = 0;

  <bb 16>:
  # v_min_4 = PHI <v_min_94(15), v_min_104(17)>
  # v_max_5 = PHI <v_max_95(15), v_max_106(17)>
  # i_6 = PHI <i_96(15), i_107(17)>
  if (i_6 >= values_count_97(D))
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  _101 = values_getter_98(D) (data_99(D), i_6);
  v_102 = _101;
  v_min_104 = ImMin (v_min_4, v_102);
  v_max_106 = ImMax (v_max_5, v_102);
  i_107 = i_6 + 1;
  goto <bb 16>;

  <bb 18>:
  if (scale_min_92(D) == 3.4028234663852885981170418348451692544e+38)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  scale_min_108 = v_min_4;

  <bb 20>:
  # scale_min_1 = PHI <scale_min_92(D)(18), scale_min_108(19)>
  if (scale_max_93(D) == 3.4028234663852885981170418348451692544e+38)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  scale_max_109 = v_max_5;

  <bb 22>:
  # scale_min_2 = PHI <scale_min_92(D)(14), scale_min_1(20), scale_min_1(21)>
  # scale_max_3 = PHI <scale_max_93(D)(14), scale_max_93(D)(20), scale_max_109(21)>
  _110 = style_43->FrameRounding;
  _112 = ImGui::GetColorU32 (7, 1.0e+0);
  ImGui::RenderFrame (frame_bb.Min, frame_bb.Max, _112, 1, _110);
  if (values_count_97(D) > 0)
    goto <bb 23>;
  else
    goto <bb 77>;

  <bb 23>:
  _114 = graph_size.x;
  _115 = (int) _114;
  _117 = ImMin (_115, values_count_97(D));
  if (plot_type_118(D) == 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  iftmp.1270_119 = -1;
  goto <bb 26>;

  <bb 25>:
  iftmp.1270_120 = 0;

  <bb 26>:
  # iftmp.1270_11 = PHI <iftmp.1270_119(24), iftmp.1270_120(25)>
  res_w_121 = _117 + iftmp.1270_11;
  if (plot_type_118(D) == 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  iftmp.1271_122 = -1;
  goto <bb 29>;

  <bb 28>:
  iftmp.1271_123 = 0;

  <bb 29>:
  # iftmp.1271_12 = PHI <iftmp.1271_122(27), iftmp.1271_123(28)>
  item_count_124 = iftmp.1271_12 + values_count_97(D);
  v_hovered_125 = -1;
  if (hovered_91 != 0)
    goto <bb 30>;
  else
    goto <bb 39>;

  <bb 30>:
  _126 = g_42->IO.MousePos.x;
  _127 = inner_bb.Min.x;
  _128 = _126 - _127;
  _129 = inner_bb.Max.x;
  _130 = inner_bb.Min.x;
  _131 = _129 - _130;
  _132 = _128 / _131;
  t_134 = ImClamp (_132, 0.0, 9.9989998340606689453125e-1);
  _135 = (float) item_count_124;
  _136 = _135 * t_134;
  v_idx_137 = (const int) _136;
  if (v_idx_137 >= 0)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  if (v_idx_137 < values_count_97(D))
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  goto <bb 34>;

  <bb 33>:
  __assert_fail ("v_idx >= 0 && v_idx < values_count", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9371, &__PRETTY_FUNCTION__);

  <bb 34>:
  _139 = v_idx_137 + values_offset_138(D);
  _140 = _139 % values_count_97(D);
  _142 = values_getter_98(D) (data_99(D), _140);
  v0_143 = _142;
  _144 = v_idx_137 + 1;
  _145 = _144 + values_offset_138(D);
  _146 = _145 % values_count_97(D);
  _148 = values_getter_98(D) (data_99(D), _146);
  v1_149 = _148;
  if (plot_type_118(D) == 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  _150 = (double) v1_149;
  _151 = v_idx_137 + 1;
  _152 = (double) v0_143;
  ImGui::SetTooltip ("%d: %8.4g\n%d: %8.4g", v_idx_137, _152, _151, _150);
  goto <bb 38>;

  <bb 36>:
  if (plot_type_118(D) == 1)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  _154 = (double) v0_143;
  ImGui::SetTooltip ("%d: %8.4g", v_idx_137, _154);

  <bb 38>:
  v_hovered_156 = v_idx_137;

  <bb 39>:
  # v_hovered_7 = PHI <v_hovered_125(29), v_hovered_156(38)>
  _158 = (float) res_w_121;
  t_step_159 = 1.0e+0 / _158;
  if (scale_min_2 != scale_max_3)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  _160 = scale_max_3 - scale_min_2;
  iftmp.1272_161 = 1.0e+0 / _160;
  goto <bb 42>;

  <bb 41>:
  iftmp.1272_162 = 0.0;

  <bb 42>:
  # iftmp.1272_13 = PHI <iftmp.1272_161(40), iftmp.1272_162(41)>
  inv_scale_163 = iftmp.1272_13;
  _164 = values_offset_138(D) % values_count_97(D);
  _166 = values_getter_98(D) (data_99(D), _164);
  v0_167 = _166;
  t0_168 = 0.0;
  _169 = v0_167 - scale_min_2;
  _170 = _169 * inv_scale_163;
  _172 = ImSaturate (_170);
  _173 = 1.0e+0 - _172;
  ImVec2::ImVec2 (&tp0, t0_168, _173);
  _175 = scale_min_2 * scale_max_3;
  if (_175 < 0.0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  _176 = -scale_min_2;
  iftmp.1273_177 = _176 * inv_scale_163;
  goto <bb 48>;

  <bb 44>:
  if (scale_min_2 < 0.0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  iftmp.1274_178 = 0.0;
  goto <bb 47>;

  <bb 46>:
  iftmp.1274_179 = 1.0e+0;

  <bb 47>:
  # iftmp.1274_15 = PHI <iftmp.1274_178(45), iftmp.1274_179(46)>
  iftmp.1273_180 = iftmp.1274_15;

  <bb 48>:
  # iftmp.1273_14 = PHI <iftmp.1273_177(43), iftmp.1273_180(47)>
  histogram_zero_line_t_181 = iftmp.1273_14;
  if (plot_type_118(D) == 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.1275_182 = 33;
  goto <bb 51>;

  <bb 50>:
  iftmp.1275_183 = 35;

  <bb 51>:
  # iftmp.1275_16 = PHI <iftmp.1275_182(49), iftmp.1275_183(50)>
  col_base_185 = ImGui::GetColorU32 (iftmp.1275_16, 1.0e+0);
  if (plot_type_118(D) == 0)
    goto <bb 52>;
  else
    goto <bb 53>;

  <bb 52>:
  iftmp.1276_186 = 34;
  goto <bb 54>;

  <bb 53>:
  iftmp.1276_187 = 36;

  <bb 54>:
  # iftmp.1276_17 = PHI <iftmp.1276_186(52), iftmp.1276_187(53)>
  col_hovered_189 = ImGui::GetColorU32 (iftmp.1276_17, 1.0e+0);
  n_190 = 0;

  <bb 55>:
  # t0_8 = PHI <t0_168(54), t0_228(75)>
  # n_9 = PHI <n_190(54), n_233(75)>
  if (n_9 >= res_w_121)
    goto <bb 76>;
  else
    goto <bb 56>;

  <bb 56>:
  t1_191 = t0_8 + t_step_159;
  _192 = (float) item_count_124;
  _193 = _192 * t0_8;
  _194 = _193 + 5.0e-1;
  v1_idx_195 = (const int) _194;
  if (v1_idx_195 >= 0)
    goto <bb 57>;
  else
    goto <bb 59>;

  <bb 57>:
  if (v1_idx_195 < values_count_97(D))
    goto <bb 58>;
  else
    goto <bb 59>;

  <bb 58>:
  goto <bb 60>;

  <bb 59>:
  __assert_fail ("v1_idx >= 0 && v1_idx < values_count", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9397, &__PRETTY_FUNCTION__);

  <bb 60>:
  _196 = v1_idx_195 + values_offset_138(D);
  _197 = _196 + 1;
  _198 = _197 % values_count_97(D);
  _200 = values_getter_98(D) (data_99(D), _198);
  v1_201 = _200;
  _202 = v1_201 - scale_min_2;
  _203 = _202 * inv_scale_163;
  _205 = ImSaturate (_203);
  _206 = 1.0e+0 - _205;
  ImVec2::ImVec2 (&tp1, t1_191, _206);
  pos0 = ImLerp (&inner_bb.Min, &inner_bb.Max, &tp0);
  if (plot_type_118(D) == 0)
    goto <bb 61>;
  else
    goto <bb 62>;

  <bb 61>:
  D.19638 = tp1;
  goto <bb 63>;

  <bb 62>:
  _210 = tp1.x;
  ImVec2::ImVec2 (&D.19638, _210, histogram_zero_line_t_181);

  <bb 63>:
  pos1 = ImLerp (&inner_bb.Min, &inner_bb.Max, &D.19638);
  D.19638 ={v} {CLOBBER};
  if (plot_type_118(D) == 0)
    goto <bb 64>;
  else
    goto <bb 68>;

  <bb 64>:
  if (v_hovered_7 == v1_idx_195)
    goto <bb 65>;
  else
    goto <bb 66>;

  <bb 65>:
  iftmp.1277_214 = col_hovered_189;
  goto <bb 67>;

  <bb 66>:
  iftmp.1277_215 = col_base_185;

  <bb 67>:
  # iftmp.1277_18 = PHI <iftmp.1277_214(65), iftmp.1277_215(66)>
  _216 = window_40->DrawList;
  ImDrawList::AddLine (_216, &pos0, &pos1, iftmp.1277_18, 1.0e+0);
  goto <bb 75>;

  <bb 68>:
  if (plot_type_118(D) == 1)
    goto <bb 69>;
  else
    goto <bb 75>;

  <bb 69>:
  _218 = pos1.x;
  _219 = pos0.x;
  _220 = _219 + 2.0e+0;
  if (_218 >= _220)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  _221 = pos1.x;
  _222 = _221 - 1.0e+0;
  pos1.x = _222;

  <bb 71>:
  if (v_hovered_7 == v1_idx_195)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  iftmp.1278_224 = col_hovered_189;
  goto <bb 74>;

  <bb 73>:
  iftmp.1278_225 = col_base_185;

  <bb 74>:
  # iftmp.1278_19 = PHI <iftmp.1278_224(72), iftmp.1278_225(73)>
  _226 = window_40->DrawList;
  ImDrawList::AddRectFilled (_226, &pos0, &pos1, iftmp.1278_19, 0.0, 15);

  <bb 75>:
  t0_228 = t1_191;
  tp0 = tp1;
  tp1 ={v} {CLOBBER};
  pos0 ={v} {CLOBBER};
  pos1 ={v} {CLOBBER};
  n_233 = n_9 + 1;
  goto <bb 55>;

  <bb 76>:
  tp0 ={v} {CLOBBER};

  <bb 77>:
  if (overlay_text_240(D) != 0B)
    goto <bb 78>;
  else
    goto <bb 79>;

  <bb 78>:
  ImVec2::ImVec2 (&D.19641, 5.0e-1, 0.0);
  _242 = frame_bb.Min.y;
  _243 = style_43->FramePadding.y;
  _244 = _242 + _243;
  _245 = frame_bb.Min.x;
  ImVec2::ImVec2 (&D.19640, _245, _244);
  ImGui::RenderTextClipped (&D.19640, &frame_bb.Max, overlay_text_240(D), 0B, 0B, &D.19641, 0B);
  D.19640 ={v} {CLOBBER};
  D.19641 ={v} {CLOBBER};

  <bb 79>:
  _252 = label_size.x;
  if (_252 > 0.0)
    goto <bb 80>;
  else
    goto <bb 81>;

  <bb 80>:
  _253 = inner_bb.Min.y;
  _254 = frame_bb.Max.x;
  _255 = style_43->ItemInnerSpacing.x;
  _256 = _254 + _255;
  ImVec2::ImVec2 (&D.19642, _256, _253);
  ImGui::RenderText (D.19642, label_44(D), 0B, 1);
  D.19642 ={v} {CLOBBER};

  <bb 81>:
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  inner_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  goto <bb 83> (<L95>);

  <bb 82>:
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  inner_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};

<L95>:
  return;

}



;; Function ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData(const float*, int) (_ZN24ImGuiPlotArrayGetterDataC2EPKfi, funcdef_no=1036, decl_uid=19659, cgraph_uid=935, symbol_order=945)

ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData(const float*, int) (struct ImGuiPlotArrayGetterData * const this, const float * values, int stride)
{
  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Values = values_4(D);
  this_2(D)->Stride = stride_6(D);
  return;

}



;; Function float Plot_ArrayGetter(void*, int) (_ZL16Plot_ArrayGetterPvi, funcdef_no=1038, decl_uid=19670, cgraph_uid=937, symbol_order=947)

float Plot_ArrayGetter(void*, int) (void * data, int idx)
{
  const float v;
  struct ImGuiPlotArrayGetterData * plot_data;
  float D.37052;
  const float * D.37051;
  long unsigned int D.37050;
  long unsigned int D.37049;
  int D.37048;
  long unsigned int D.37047;
  const float * D.37046;
  const float * _4;
  long unsigned int _6;
  int _7;
  long unsigned int _8;
  long unsigned int _9;
  const float * _10;
  float _12;

  <bb 2>:
  plot_data_2 = data_1(D);
  _4 = plot_data_2->Values;
  _6 = (long unsigned int) idx_5(D);
  _7 = plot_data_2->Stride;
  _8 = (long unsigned int) _7;
  _9 = _6 * _8;
  _10 = _4 + _9;
  v_11 = *_10;
  _12 = v_11;

<L0>:
  return _12;

}



;; Function void ImGui::PlotLines(const char*, const float*, int, int, const char*, float, float, ImVec2, int) (_ZN5ImGui9PlotLinesEPKcPKfiiS1_ff6ImVec2i, funcdef_no=1039, decl_uid=2789, cgraph_uid=938, symbol_order=948)

void ImGui::PlotLines(const char*, const float*, int, int, const char*, float, float, ImVec2, int) (const char * label, const float * values, int values_count, int values_offset, const char * overlay_text, float scale_min, float scale_max, struct ImVec2 graph_size, int stride)
{
  struct ImGuiPlotArrayGetterData data;

  <bb 2>:
  ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData (&data, values_2(D), stride_3(D));
  ImGui::PlotEx (0, label_5(D), Plot_ArrayGetter, &data, values_count_6(D), values_offset_7(D), overlay_text_8(D), scale_min_9(D), scale_max_10(D), graph_size);
  data ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PlotLines(const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2) (_ZN5ImGui9PlotLinesEPKcPFfPviES2_iiS1_ff6ImVec2, funcdef_no=1040, decl_uid=2802, cgraph_uid=939, symbol_order=949)

void ImGui::PlotLines(const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2) (const char * label, float (*<T6b3>) (void *, int) values_getter, void * data, int values_count, int values_offset, const char * overlay_text, float scale_min, float scale_max, struct ImVec2 graph_size)
{
  <bb 2>:
  ImGui::PlotEx (0, label_2(D), values_getter_3(D), data_4(D), values_count_5(D), values_offset_6(D), overlay_text_7(D), scale_min_8(D), scale_max_9(D), graph_size);
  return;

}



;; Function void ImGui::PlotHistogram(const char*, const float*, int, int, const char*, float, float, ImVec2, int) (_ZN5ImGui13PlotHistogramEPKcPKfiiS1_ff6ImVec2i, funcdef_no=1041, decl_uid=2813, cgraph_uid=940, symbol_order=950)

void ImGui::PlotHistogram(const char*, const float*, int, int, const char*, float, float, ImVec2, int) (const char * label, const float * values, int values_count, int values_offset, const char * overlay_text, float scale_min, float scale_max, struct ImVec2 graph_size, int stride)
{
  struct ImGuiPlotArrayGetterData data;

  <bb 2>:
  ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData (&data, values_2(D), stride_3(D));
  ImGui::PlotEx (1, label_5(D), Plot_ArrayGetter, &data, values_count_6(D), values_offset_7(D), overlay_text_8(D), scale_min_9(D), scale_max_10(D), graph_size);
  data ={v} {CLOBBER};
  return;

}



;; Function void ImGui::PlotHistogram(const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2) (_ZN5ImGui13PlotHistogramEPKcPFfPviES2_iiS1_ff6ImVec2, funcdef_no=1042, decl_uid=2826, cgraph_uid=941, symbol_order=951)

void ImGui::PlotHistogram(const char*, float (*)(void*, int), void*, int, int, const char*, float, float, ImVec2) (const char * label, float (*<T6b3>) (void *, int) values_getter, void * data, int values_count, int values_offset, const char * overlay_text, float scale_min, float scale_max, struct ImVec2 graph_size)
{
  <bb 2>:
  ImGui::PlotEx (1, label_2(D), values_getter_3(D), data_4(D), values_count_5(D), values_offset_6(D), overlay_text_7(D), scale_min_8(D), scale_max_9(D), graph_size);
  return;

}



;; Function void ImGui::ProgressBar(float, const ImVec2&, const char*) (_ZN5ImGui11ProgressBarEfRK6ImVec2PKc, funcdef_no=1043, decl_uid=2831, cgraph_uid=942, symbol_order=952)

void ImGui::ProgressBar(float, const ImVec2&, const char*) (float fraction, const struct ImVec2 & size_arg, const char * overlay)
{
  bool D.37105;
  float D.37104;
  struct ImVec2 overlay_size;
  char overlay_buf[32];
  const struct ImVec2 fill_br;
  struct ImRect bb;
  struct ImVec2 pos;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.37101;
  float D.37100;
  float D.37099;
  float D.37098;
  float D.37097;
  float D.37096;
  float D.37095;
  float D.37094;
  float D.37093;
  float D.37092;
  float D.37091;
  struct ImVec2 D.19777;
  struct ImVec2 D.19778;
  float D.37088;
  double D.37086;
  float D.37085;
  float D.37084;
  struct ImDrawList * D.37081;
  unsigned int D.37080;
  float D.37079;
  float D.37078;
  float D.37077;
  float D.37076;
  float D.37075;
  float D.37074;
  float D.37073;
  float D.37072;
  float D.37071;
  struct ImVec2 D.19771;
  unsigned int D.37070;
  float D.37069;
  bool D.37066;
  bool retval.1279;
  float D.37064;
  float D.37063;
  float D.37062;
  float D.37061;
  float D.37060;
  float D.37059;
  struct ImVec2 D.19767;
  struct ImVec2 D.19768;
  bool D.37056;
  bool _10;
  float _14;
  float _15;
  float _16;
  float _17;
  float _19;
  float _20;
  float _27;
  bool _30;
  bool _31;
  bool retval.1279_32;
  float _36;
  unsigned int _38;
  float _40;
  float _41;
  float _42;
  float _43;
  float _47;
  float _48;
  float _49;
  float _51;
  float _53;
  unsigned int _55;
  struct ImDrawList * _56;
  float _59;
  float _60;
  double _61;
  float _65;
  float _67;
  float _68;
  float _69;
  float _70;
  float _71;
  float _72;
  float _73;
  float _74;
  float _75;
  float _76;
  float _78;

  <bb 2>:
  window_9 = ImGui::GetCurrentWindow ();
  _10 = window_9->SkipItems;
  if (_10 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 11>;

  <bb 4>:
  g_11 = GImGui;
  style_12 = &g_11->Style;
  pos = window_9->DC.CursorPos;
  _14 = g_11->FontSize;
  _15 = style_12->FramePadding.y;
  _16 = _15 * 2.0e+0;
  _17 = _14 + _16;
  _19 = ImGui::CalcItemWidth ();
  _20 = _19;
  D.19767 = ImGui::CalcItemSize (*size_arg_21(D), _20, _17);
  D.19768 = operator+ (&pos, &D.19767);
  ImRect::ImRect (&bb, &pos, &D.19768);
  D.19768 ={v} {CLOBBER};
  D.19767 ={v} {CLOBBER};
  _27 = style_12->FramePadding.y;
  ImGui::ItemSize (&bb, _27);
  _30 = ImGui::ItemAdd (&bb, 0, 0B);
  _31 = _30;
  retval.1279_32 = ~_31;
  if (retval.1279_32 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 11>;

  <bb 6>:
  fraction_35 = ImSaturate (fraction_33(D));
  _36 = style_12->FrameRounding;
  _38 = ImGui::GetColorU32 (7, 1.0e+0);
  ImGui::RenderFrame (bb.Min, bb.Max, _38, 1, _36);
  _40 = style_12->FrameBorderSize;
  _41 = -_40;
  _42 = style_12->FrameBorderSize;
  _43 = -_42;
  ImVec2::ImVec2 (&D.19771, _43, _41);
  ImRect::Expand (&bb, &D.19771);
  D.19771 ={v} {CLOBBER};
  _47 = bb.Max.y;
  _48 = bb.Max.x;
  _49 = bb.Min.x;
  _51 = ImLerp (_49, _48, fraction_35);
  ImVec2::ImVec2 (&fill_br, _51, _47);
  _53 = style_12->FrameRounding;
  _55 = ImGui::GetColorU32 (35, 1.0e+0);
  _56 = window_9->DrawList;
  ImGui::RenderRectFilledRangeH (_56, &bb, _55, 0.0, fraction_35, _53);
  if (overlay_58(D) == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _59 = fraction_35 * 1.0e+2;
  _60 = _59 + 9.99999977648258209228515625e-3;
  _61 = (double) _60;
  ImFormatString (&overlay_buf, 32, "%.0f%%", _61);
  overlay_63 = &overlay_buf;

  <bb 8>:
  # overlay_1 = PHI <overlay_58(D)(6), overlay_63(7)>
  overlay_size = ImGui::CalcTextSize (overlay_1, 0B, 0, -1.0e+0);
  _65 = overlay_size.x;
  if (_65 > 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  ImVec2::ImVec2 (&D.19778, 0.0, 5.0e-1);
  _67 = bb.Min.y;
  _68 = bb.Max.x;
  _69 = overlay_size.x;
  _70 = _68 - _69;
  _71 = style_12->ItemInnerSpacing.x;
  _72 = _70 - _71;
  _73 = bb.Min.x;
  _74 = fill_br.x;
  _75 = style_12->ItemSpacing.x;
  _76 = _74 + _75;
  _78 = ImClamp (_76, _73, _72);
  ImVec2::ImVec2 (&D.19777, _78, _67);
  ImGui::RenderTextClipped (&D.19777, &bb.Max, overlay_1, 0B, &overlay_size, &D.19778, &bb);
  D.19777 ={v} {CLOBBER};
  D.19778 ={v} {CLOBBER};

  <bb 10>:
  pos ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  fill_br ={v} {CLOBBER};
  overlay_buf ={v} {CLOBBER};
  overlay_size ={v} {CLOBBER};
  goto <bb 12> (<L12>);

  <bb 11>:
  pos ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  fill_br ={v} {CLOBBER};
  overlay_buf ={v} {CLOBBER};
  overlay_size ={v} {CLOBBER};

<L12>:
  return;

}



;; Function bool ImGui::Checkbox(const char*, bool*) (_ZN5ImGui8CheckboxEPKcPb, funcdef_no=1044, decl_uid=2767, cgraph_uid=943, symbol_order=953)

bool ImGui::Checkbox(const char*, bool*) (const char * label, bool * v)
{
  bool D.37198;
  bool D.37197;
  const ImGuiID D.37195;
  const float pad;
  const float check_sz;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect text_bb;
  struct ImRect total_bb;
  const struct ImRect check_bb;
  const struct ImVec2 label_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.37190;
  bool D.37185;
  const char[4] * iftmp.1287;
  bool D.37181;
  struct ImVec2 D.37179;
  struct ImVec2 D.19811;
  unsigned int D.37178;
  float D.37177;
  float D.37176;
  float D.37175;
  float D.37174;
  int D.37173;
  float D.37172;
  float D.37171;
  float D.37170;
  bool D.37167;
  unsigned int D.37166;
  bool hovered.1286;
  ImGuiCol iftmp.1285;
  bool D.37160;
  bool hovered.1284;
  bool D.37157;
  bool held.1283;
  ImGuiCol iftmp.1282;
  float D.37151;
  bool D.37149;
  bool D.37148;
  bool D.37143;
  bool retval.1281;
  struct ImVec2 D.19801;
  struct ImVec2 D.19802;
  struct ImRect total_bb.1280;
  float D.37140;
  float D.37139;
  struct ImVec2 D.19800;
  float D.37138;
  float D.37135;
  struct ImVec2 * D.37134;
  float D.37133;
  struct ImVec2 D.19795;
  struct ImVec2 D.19796;
  struct ImVec2 * D.37132;
  float D.37131;
  struct ImVec2 D.19797;
  struct ImVec2 D.19798;
  struct ImVec2 D.19799;
  float D.37129;
  float D.37126;
  float D.37125;
  struct ImVec2 * D.37124;
  struct ImVec2 * D.37123;
  float D.37122;
  float D.37121;
  float D.37120;
  float D.37119;
  float D.37118;
  float D.37117;
  float D.37116;
  float D.37115;
  struct ImVec2 D.19790;
  struct ImVec2 D.19791;
  bool D.37114;
  bool D.37111;
  bool _1;
  ImGuiCol iftmp.1282_2;
  ImGuiCol iftmp.1285_3;
  const char[4] * iftmp.1287_4;
  bool _16;
  bool _17;
  const ImGuiID _22;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  struct ImVec2 * _34;
  struct ImVec2 * _36;
  float _40;
  float _43;
  float _44;
  float _46;
  struct ImVec2 * _48;
  float _51;
  struct ImVec2 * _53;
  float _61;
  float _62;
  float _64;
  float _66;
  bool _79;
  bool _80;
  bool retval.1281_81;
  bool _82;
  bool _84;
  bool _87;
  bool _88;
  float _91;
  bool held.1283_92;
  bool _93;
  bool hovered.1284_94;
  bool _95;
  ImGuiCol iftmp.1282_96;
  bool hovered.1286_97;
  ImGuiCol iftmp.1285_98;
  ImGuiCol iftmp.1285_99;
  ImGuiCol iftmp.1282_100;
  unsigned int _102;
  bool _104;
  float _106;
  float _108;
  float _111;
  int _112;
  float _113;
  float _117;
  float _118;
  float _119;
  unsigned int _121;
  bool _127;
  bool _128;
  const char[4] * iftmp.1287_129;
  const char[4] * iftmp.1287_130;
  float _132;
  bool _134;

  <bb 2>:
  window_15 = ImGui::GetCurrentWindow ();
  _16 = window_15->SkipItems;
  if (_16 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _17 = 0;
  goto <bb 29>;

  <bb 4>:
  g_18 = GImGui;
  style_19 = &g_18->Style;
  _22 = ImGuiWindow::GetID (window_15, label_20(D), 0B);
  id_23 = _22;
  label_size = ImGui::CalcTextSize (label_20(D), 0B, 1, -1.0e+0);
  _25 = label_size.y;
  _26 = style_19->FramePadding.y;
  _27 = _26 * 2.0e+0;
  _28 = _25 + _27;
  _29 = label_size.y;
  _30 = style_19->FramePadding.y;
  _31 = _30 * 2.0e+0;
  _32 = _29 + _31;
  ImVec2::ImVec2 (&D.19790, _32, _28);
  _34 = &window_15->DC.CursorPos;
  D.19791 = operator+ (_34, &D.19790);
  _36 = &window_15->DC.CursorPos;
  ImRect::ImRect (&check_bb, _36, &D.19791);
  D.19791 ={v} {CLOBBER};
  D.19790 ={v} {CLOBBER};
  _40 = style_19->FramePadding.y;
  ImGui::ItemSize (&check_bb, _40);
  total_bb = check_bb;
  _43 = label_size.x;
  if (_43 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _44 = style_19->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _44);

  <bb 6>:
  _46 = style_19->FramePadding.y;
  ImVec2::ImVec2 (&D.19797, 0.0, _46);
  _48 = &window_15->DC.CursorPos;
  D.19798 = operator+ (_48, &D.19797);
  D.19799 = operator+ (&D.19798, &label_size);
  _51 = style_19->FramePadding.y;
  ImVec2::ImVec2 (&D.19795, 0.0, _51);
  _53 = &window_15->DC.CursorPos;
  D.19796 = operator+ (_53, &D.19795);
  ImRect::ImRect (&text_bb, &D.19796, &D.19799);
  D.19796 ={v} {CLOBBER};
  D.19795 ={v} {CLOBBER};
  D.19799 ={v} {CLOBBER};
  D.19798 ={v} {CLOBBER};
  D.19797 ={v} {CLOBBER};
  _61 = label_size.x;
  if (_61 > 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _62 = style_19->FramePadding.y;
  _64 = ImRect::GetHeight (&check_bb);
  _66 = ImRect::GetWidth (&text_bb);
  ImVec2::ImVec2 (&D.19800, _66, _64);
  ImGui::ItemSize (&D.19800, _62);
  D.19800 ={v} {CLOBBER};
  D.19802 = ImMax (&check_bb.Max, &text_bb.Max);
  D.19801 = ImMin (&check_bb.Min, &text_bb.Min);
  ImRect::ImRect (&total_bb.1280, &D.19801, &D.19802);
  total_bb = total_bb.1280;
  total_bb.1280 ={v} {CLOBBER};
  D.19801 ={v} {CLOBBER};
  D.19802 ={v} {CLOBBER};

  <bb 8>:
  _79 = ImGui::ItemAdd (&total_bb, id_23, 0B);
  _80 = _79;
  retval.1281_81 = ~_80;
  if (retval.1281_81 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _82 = 0;
  goto <bb 29>;

  <bb 10>:
  _84 = ImGui::ButtonBehavior (&total_bb, id_23, &hovered, &held, 0);
  pressed_85 = _84;
  if (pressed_85 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _87 = *v_86(D);
  _88 = ~_87;
  *v_86(D) = _88;

  <bb 12>:
  ImGui::RenderNavHighlight (&total_bb, id_23, 1);
  _91 = style_19->FrameRounding;
  held.1283_92 = held;
  _93 = ~held.1283_92;
  if (_93 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  hovered.1284_94 = hovered;
  _95 = ~hovered.1284_94;
  if (_95 != 0)
    goto <bb 14>;
  else
    goto <bb 18>;

  <bb 14>:
  hovered.1286_97 = hovered;
  if (hovered.1286_97 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.1285_98 = 8;
  goto <bb 17>;

  <bb 16>:
  iftmp.1285_99 = 7;

  <bb 17>:
  # iftmp.1285_3 = PHI <iftmp.1285_98(15), iftmp.1285_99(16)>
  iftmp.1282_100 = iftmp.1285_3;
  goto <bb 19>;

  <bb 18>:
  iftmp.1282_96 = 9;

  <bb 19>:
  # iftmp.1282_2 = PHI <iftmp.1282_100(17), iftmp.1282_96(18)>
  _102 = ImGui::GetColorU32 (iftmp.1282_2, 1.0e+0);
  ImGui::RenderFrame (check_bb.Min, check_bb.Max, _102, 1, _91);
  _104 = *v_86(D);
  if (_104 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _106 = ImRect::GetHeight (&check_bb);
  _108 = ImRect::GetWidth (&check_bb);
  check_sz_110 = ImMin (_108, _106);
  _111 = check_sz_110 / 6.0e+0;
  _112 = (int) _111;
  _113 = (float) _112;
  pad_115 = ImMax (1.0e+0, _113);
  _117 = ImRect::GetWidth (&check_bb);
  _118 = pad_115 * 2.0e+0;
  _119 = _117 - _118;
  _121 = ImGui::GetColorU32 (18, 1.0e+0);
  ImVec2::ImVec2 (&D.19811, pad_115, pad_115);
  D.37179 = operator+ (&check_bb.Min, &D.19811);
  ImGui::RenderCheckMark (D.37179, _121, _119);
  D.19811 ={v} {CLOBBER};

  <bb 21>:
  _127 = g_18->LogEnabled;
  if (_127 != 0)
    goto <bb 22>;
  else
    goto <bb 26>;

  <bb 22>:
  _128 = *v_86(D);
  if (_128 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.1287_129 = "[x]";
  goto <bb 25>;

  <bb 24>:
  iftmp.1287_130 = "[ ]";

  <bb 25>:
  # iftmp.1287_4 = PHI <iftmp.1287_129(23), iftmp.1287_130(24)>
  LogRenderedText (&text_bb.Min, iftmp.1287_4, 0B);

  <bb 26>:
  _132 = label_size.x;
  if (_132 > 0.0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  ImGui::RenderText (text_bb.Min, label_20(D), 0B, 1);

  <bb 28>:
  _134 = pressed_85;

  <bb 29>:
  # _1 = PHI <_17(3), _82(9), _134(28)>
  label_size ={v} {CLOBBER};
  check_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  text_bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L33>:
  return _1;

}



;; Function bool ImGui::CheckboxFlags(const char*, unsigned int*, unsigned int) (_ZN5ImGui13CheckboxFlagsEPKcPjj, funcdef_no=1045, decl_uid=2771, cgraph_uid=944, symbol_order=954)

bool ImGui::CheckboxFlags(const char*, unsigned int*, unsigned int) (const char * label, unsigned int * flags, unsigned int flags_value)
{
  bool D.37219;
  bool pressed;
  bool v;
  bool D.37217;
  unsigned int D.37215;
  unsigned int D.37214;
  unsigned int D.37213;
  unsigned int D.37211;
  unsigned int D.37210;
  bool v.1289;
  bool v.1288;
  unsigned int D.37203;
  unsigned int D.37202;
  unsigned int _5;
  unsigned int _7;
  bool v.1288_8;
  bool _12;
  bool v.1289_14;
  unsigned int _15;
  unsigned int _16;
  unsigned int _18;
  unsigned int _19;
  unsigned int _20;
  bool _22;

  <bb 2>:
  _5 = *flags_4(D);
  _7 = _5 & flags_value_6(D);
  v.1288_8 = _7 == flags_value_6(D);
  v = v.1288_8;
  _12 = ImGui::Checkbox (label_10(D), &v);
  pressed_13 = _12;
  if (pressed_13 != 0)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  v.1289_14 = v;
  if (v.1289_14 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _15 = *flags_4(D);
  _16 = _15 | flags_value_6(D);
  *flags_4(D) = _16;
  goto <bb 6>;

  <bb 5>:
  _18 = *flags_4(D);
  _19 = ~flags_value_6(D);
  _20 = _18 & _19;
  *flags_4(D) = _20;

  <bb 6>:

  <bb 7>:
  _22 = pressed_13;
  v ={v} {CLOBBER};

<L7>:
  return _22;

}



;; Function bool ImGui::RadioButton(const char*, bool) (_ZN5ImGui11RadioButtonEPKcb, funcdef_no=1046, decl_uid=2774, cgraph_uid=945, symbol_order=955)

bool ImGui::RadioButton(const char*, bool) (const char * label, bool active)
{
  bool D.37321;
  bool D.37320;
  const ImGuiID D.37318;
  const float pad;
  const float check_sz;
  bool pressed;
  bool held;
  bool hovered;
  const float radius;
  struct ImVec2 center;
  const struct ImRect text_bb;
  struct ImRect total_bb;
  const struct ImRect check_bb;
  const struct ImVec2 label_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.37313;
  const char[4] * iftmp.1296;
  bool D.37305;
  struct ImDrawList * D.37303;
  unsigned int D.37302;
  float D.37301;
  struct ImDrawList * D.37300;
  struct ImVec2 D.19851;
  struct ImVec2 D.19852;
  unsigned int D.37299;
  float D.37298;
  float D.37295;
  struct ImDrawList * D.37293;
  float D.37292;
  unsigned int D.37291;
  float D.37290;
  int D.37289;
  float D.37288;
  float D.37287;
  float D.37286;
  struct ImDrawList * D.37283;
  unsigned int D.37282;
  bool hovered.1295;
  ImGuiCol iftmp.1294;
  bool D.37276;
  bool hovered.1293;
  bool D.37273;
  bool held.1292;
  ImGuiCol iftmp.1291;
  float D.37267;
  float D.37266;
  float D.37265;
  int D.37264;
  float D.37263;
  float D.37262;
  float D.37261;
  int D.37260;
  float D.37259;
  bool D.37256;
  bool retval.1290;
  float D.37253;
  float D.37252;
  struct ImVec2 D.19842;
  float D.37251;
  float D.37248;
  struct ImVec2 * D.37247;
  float D.37246;
  struct ImVec2 D.19837;
  struct ImVec2 D.19838;
  struct ImVec2 * D.37245;
  float D.37244;
  struct ImVec2 D.19839;
  struct ImVec2 D.19840;
  struct ImVec2 D.19841;
  float D.37242;
  float D.37239;
  float D.37238;
  struct ImVec2 * D.37237;
  struct ImVec2 * D.37236;
  float D.37235;
  float D.37234;
  float D.37233;
  float D.37232;
  float D.37231;
  float D.37230;
  float D.37229;
  float D.37228;
  float D.37227;
  float D.37226;
  struct ImVec2 D.19832;
  struct ImVec2 D.19833;
  bool D.37225;
  bool D.37222;
  bool _1;
  ImGuiCol iftmp.1291_2;
  ImGuiCol iftmp.1294_3;
  const char[4] * iftmp.1296_4;
  bool _16;
  bool _17;
  const ImGuiID _22;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _32;
  float _33;
  float _34;
  struct ImVec2 * _36;
  struct ImVec2 * _38;
  float _42;
  float _45;
  float _46;
  float _48;
  struct ImVec2 * _50;
  float _53;
  struct ImVec2 * _55;
  float _63;
  float _64;
  float _66;
  float _68;
  bool _75;
  bool _76;
  bool retval.1290_77;
  bool _78;
  float _80;
  int _81;
  float _82;
  float _83;
  float _85;
  int _86;
  float _87;
  float _88;
  float _91;
  bool _94;
  bool held.1292_97;
  bool _98;
  bool hovered.1293_99;
  bool _100;
  ImGuiCol iftmp.1291_101;
  bool hovered.1295_102;
  ImGuiCol iftmp.1294_103;
  ImGuiCol iftmp.1294_104;
  ImGuiCol iftmp.1291_105;
  unsigned int _107;
  struct ImDrawList * _108;
  float _112;
  float _114;
  float _117;
  int _118;
  float _119;
  unsigned int _123;
  float _124;
  struct ImDrawList * _125;
  float _127;
  float _128;
  unsigned int _130;
  struct ImDrawList * _133;
  float _137;
  unsigned int _139;
  struct ImDrawList * _140;
  bool _144;
  const char[4] * iftmp.1296_145;
  const char[4] * iftmp.1296_146;
  float _148;
  bool _150;

  <bb 2>:
  window_15 = ImGui::GetCurrentWindow ();
  _16 = window_15->SkipItems;
  if (_16 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _17 = 0;
  goto <bb 29>;

  <bb 4>:
  g_18 = GImGui;
  style_19 = &g_18->Style;
  _22 = ImGuiWindow::GetID (window_15, label_20(D), 0B);
  id_23 = _22;
  label_size = ImGui::CalcTextSize (label_20(D), 0B, 1, -1.0e+0);
  _25 = label_size.y;
  _26 = style_19->FramePadding.y;
  _27 = _26 * 2.0e+0;
  _28 = _25 + _27;
  _29 = _28 - 1.0e+0;
  _30 = label_size.y;
  _31 = style_19->FramePadding.y;
  _32 = _31 * 2.0e+0;
  _33 = _30 + _32;
  _34 = _33 - 1.0e+0;
  ImVec2::ImVec2 (&D.19832, _34, _29);
  _36 = &window_15->DC.CursorPos;
  D.19833 = operator+ (_36, &D.19832);
  _38 = &window_15->DC.CursorPos;
  ImRect::ImRect (&check_bb, _38, &D.19833);
  D.19833 ={v} {CLOBBER};
  D.19832 ={v} {CLOBBER};
  _42 = style_19->FramePadding.y;
  ImGui::ItemSize (&check_bb, _42);
  total_bb = check_bb;
  _45 = label_size.x;
  if (_45 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _46 = style_19->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _46);

  <bb 6>:
  _48 = style_19->FramePadding.y;
  ImVec2::ImVec2 (&D.19839, 0.0, _48);
  _50 = &window_15->DC.CursorPos;
  D.19840 = operator+ (_50, &D.19839);
  D.19841 = operator+ (&D.19840, &label_size);
  _53 = style_19->FramePadding.y;
  ImVec2::ImVec2 (&D.19837, 0.0, _53);
  _55 = &window_15->DC.CursorPos;
  D.19838 = operator+ (_55, &D.19837);
  ImRect::ImRect (&text_bb, &D.19838, &D.19841);
  D.19838 ={v} {CLOBBER};
  D.19837 ={v} {CLOBBER};
  D.19841 ={v} {CLOBBER};
  D.19840 ={v} {CLOBBER};
  D.19839 ={v} {CLOBBER};
  _63 = label_size.x;
  if (_63 > 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _64 = style_19->FramePadding.y;
  _66 = ImRect::GetHeight (&check_bb);
  _68 = ImRect::GetWidth (&text_bb);
  ImVec2::ImVec2 (&D.19842, _68, _66);
  ImGui::ItemSize (&D.19842, _64);
  D.19842 ={v} {CLOBBER};
  ImRect::Add (&total_bb, &text_bb);

  <bb 8>:
  _75 = ImGui::ItemAdd (&total_bb, id_23, 0B);
  _76 = _75;
  retval.1290_77 = ~_76;
  if (retval.1290_77 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _78 = 0;
  goto <bb 29>;

  <bb 10>:
  center = ImRect::GetCenter (&check_bb);
  _80 = center.x;
  _81 = (int) _80;
  _82 = (float) _81;
  _83 = _82 + 5.0e-1;
  center.x = _83;
  _85 = center.y;
  _86 = (int) _85;
  _87 = (float) _86;
  _88 = _87 + 5.0e-1;
  center.y = _88;
  _91 = ImRect::GetHeight (&check_bb);
  radius_92 = _91 * 5.0e-1;
  _94 = ImGui::ButtonBehavior (&total_bb, id_23, &hovered, &held, 0);
  pressed_95 = _94;
  ImGui::RenderNavHighlight (&total_bb, id_23, 1);
  held.1292_97 = held;
  _98 = ~held.1292_97;
  if (_98 != 0)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  hovered.1293_99 = hovered;
  _100 = ~hovered.1293_99;
  if (_100 != 0)
    goto <bb 12>;
  else
    goto <bb 16>;

  <bb 12>:
  hovered.1295_102 = hovered;
  if (hovered.1295_102 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  iftmp.1294_103 = 8;
  goto <bb 15>;

  <bb 14>:
  iftmp.1294_104 = 7;

  <bb 15>:
  # iftmp.1294_3 = PHI <iftmp.1294_103(13), iftmp.1294_104(14)>
  iftmp.1291_105 = iftmp.1294_3;
  goto <bb 17>;

  <bb 16>:
  iftmp.1291_101 = 9;

  <bb 17>:
  # iftmp.1291_2 = PHI <iftmp.1291_105(15), iftmp.1291_101(16)>
  _107 = ImGui::GetColorU32 (iftmp.1291_2, 1.0e+0);
  _108 = window_15->DrawList;
  ImDrawList::AddCircleFilled (_108, &center, radius_92, _107, 16);
  if (active_110(D) != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _112 = ImRect::GetHeight (&check_bb);
  _114 = ImRect::GetWidth (&check_bb);
  check_sz_116 = ImMin (_114, _112);
  _117 = check_sz_116 / 6.0e+0;
  _118 = (int) _117;
  _119 = (float) _118;
  pad_121 = ImMax (1.0e+0, _119);
  _123 = ImGui::GetColorU32 (18, 1.0e+0);
  _124 = radius_92 - pad_121;
  _125 = window_15->DrawList;
  ImDrawList::AddCircleFilled (_125, &center, _124, _123, 16);

  <bb 19>:
  _127 = style_19->FrameBorderSize;
  if (_127 > 0.0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _128 = style_19->FrameBorderSize;
  _130 = ImGui::GetColorU32 (6, 1.0e+0);
  ImVec2::ImVec2 (&D.19851, 1.0e+0, 1.0e+0);
  D.19852 = operator+ (&center, &D.19851);
  _133 = window_15->DrawList;
  ImDrawList::AddCircle (_133, &D.19852, radius_92, _130, 16, _128);
  D.19852 ={v} {CLOBBER};
  D.19851 ={v} {CLOBBER};
  _137 = style_19->FrameBorderSize;
  _139 = ImGui::GetColorU32 (5, 1.0e+0);
  _140 = window_15->DrawList;
  ImDrawList::AddCircle (_140, &center, radius_92, _139, 16, _137);

  <bb 21>:
  _144 = g_18->LogEnabled;
  if (_144 != 0)
    goto <bb 22>;
  else
    goto <bb 26>;

  <bb 22>:
  if (active_110(D) != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.1296_145 = "(x)";
  goto <bb 25>;

  <bb 24>:
  iftmp.1296_146 = "( )";

  <bb 25>:
  # iftmp.1296_4 = PHI <iftmp.1296_145(23), iftmp.1296_146(24)>
  LogRenderedText (&text_bb.Min, iftmp.1296_4, 0B);

  <bb 26>:
  _148 = label_size.x;
  if (_148 > 0.0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  ImGui::RenderText (text_bb.Min, label_20(D), 0B, 1);

  <bb 28>:
  _150 = pressed_95;

  <bb 29>:
  # _1 = PHI <_17(3), _78(9), _150(28)>
  label_size ={v} {CLOBBER};
  check_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  text_bb ={v} {CLOBBER};
  center ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L33>:
  return _1;

}



;; Function bool ImGui::RadioButton(const char*, int*, int) (_ZN5ImGui11RadioButtonEPKcPii, funcdef_no=1047, decl_uid=2778, cgraph_uid=946, symbol_order=956)

bool ImGui::RadioButton(const char*, int*, int) (const char * label, int * v, int v_button)
{
  const bool D.37358;
  const bool pressed;
  bool D.37356;
  int D.37352;
  bool D.37351;
  int D.37350;
  int _4;
  bool _6;
  int _7;
  const bool _10;
  bool _13;

  <bb 2>:
  _4 = *v_3(D);
  _6 = _4 == v_button_5(D);
  _7 = (int) _6;
  _10 = ImGui::RadioButton (label_8(D), _7);
  pressed_11 = _10;
  if (pressed_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  *v_3(D) = v_button_5(D);

  <bb 4>:
  _13 = pressed_11;

<L3>:
  return _13;

}



;; Function int InputTextCalcTextLenAndLineCount(const char*, const char**) (_ZL32InputTextCalcTextLenAndLineCountPKcPS0_, funcdef_no=1048, decl_uid=15081, cgraph_uid=947, symbol_order=957)

int InputTextCalcTextLenAndLineCount(const char*, const char**) (const char * text_begin, const char * * out_text_end)
{
  char c;
  const char * s;
  int line_count;
  int D.37372;
  char D.37368;
  char D.37365;
  const char * s.1297;
  const char * s.1297_8;
  char _14;
  char _15;
  int _19;

  <bb 2>:
  line_count_5 = 0;
  s_7 = text_begin_6(D);

  <bb 3>:
  # line_count_1 = PHI <line_count_5(2), line_count_2(6)>
  # s_4 = PHI <s_7(2), s_9(6)>
  s.1297_8 = s_4;
  s_9 = s.1297_8 + 1;
  c_11 = *s.1297_8;
  if (c_11 == 0)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  if (c_11 == 10)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  line_count_12 = line_count_1 + 1;

  <bb 6>:
  # line_count_2 = PHI <line_count_1(4), line_count_12(5)>
  goto <bb 3>;

  <bb 7>:
  s_13 = s_9 + 18446744073709551615;
  _14 = *s_13;
  if (_14 != 10)
    goto <bb 8>;
  else
    goto <bb 10>;

  <bb 8>:
  _15 = *s_13;
  if (_15 != 13)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  line_count_16 = line_count_1 + 1;

  <bb 10>:
  # line_count_3 = PHI <line_count_1(7), line_count_1(8), line_count_16(9)>
  *out_text_end_17(D) = s_13;
  _19 = line_count_3;

<L11>:
  return _19;

}



;; Function ImVec2 InputTextCalcTextSizeW(const ImWchar*, const ImWchar*, const ImWchar**, ImVec2*, bool) (_ZL22InputTextCalcTextSizeWPKtS0_PS0_P6ImVec2b, funcdef_no=1049, decl_uid=15087, cgraph_uid=948, symbol_order=958)

ImVec2 InputTextCalcTextSizeW(const ImWchar*, const ImWchar*, const ImWchar**, ImVec2*, bool) (const ImWchar * text_begin, const ImWchar * text_end, const ImWchar * * remaining, struct ImVec2 * out_offset, bool stop_on_new_line)
{
  float D.37414;
  const float char_width;
  unsigned int c;
  const ImWchar * s;
  float line_width;
  struct ImVec2 text_size;
  const float scale;
  const float line_height;
  struct ImFont * font;
  struct ImVec2 D.37412;
  float D.37408;
  float D.37407;
  float D.37406;
  float D.37401;
  float D.37400;
  struct ImVec2 D.19885;
  float D.37394;
  float D.37393;
  int D.37392;
  short unsigned int D.37391;
  float D.37386;
  float D.37385;
  float D.37384;
  float D.37383;
  short unsigned int D.37380;
  const ImWchar * s.1300;
  float D.37376;
  struct ImGuiContext * GImGui.1299;
  struct ImGuiContext * GImGui.1298;
  struct ImGuiContext * GImGui.1298_14;
  struct ImGuiContext * GImGui.1299_16;
  float _18;
  const ImWchar * s.1300_25;
  short unsigned int _27;
  float _29;
  float _31;
  float _33;
  float _34;
  short unsigned int _38;
  int _39;
  float _41;
  float _42;
  float _46;
  float _49;
  float _50;
  float _54;
  float _55;
  float _56;

  <bb 2>:
  GImGui.1298_14 = GImGui;
  font_15 = GImGui.1298_14->Font;
  GImGui.1299_16 = GImGui;
  line_height_17 = GImGui.1299_16->FontSize;
  _18 = font_15->FontSize;
  scale_19 = line_height_17 / _18;
  ImVec2::ImVec2 (&text_size, 0.0, 0.0);
  line_width_21 = 0.0;
  s_23 = text_begin_22(D);

  <bb 3>:
  # line_width_1 = PHI <line_width_21(2), line_width_2(11)>
  # s_4 = PHI <s_23(2), s_26(11)>
  if (s_4 >= text_end_24(D))
    goto <bb 12>;
  else
    goto <bb 4>;

  <bb 4>:
  s.1300_25 = s_4;
  s_26 = s.1300_25 + 2;
  _27 = *s.1300_25;
  c_28 = (unsigned int) _27;
  if (c_28 == 10)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _29 = text_size.x;
  _31 = ImMax (_29, line_width_1);
  text_size.x = _31;
  _33 = text_size.y;
  _34 = _33 + line_height_17;
  text_size.y = _34;
  line_width_36 = 0.0;
  if (stop_on_new_line_37(D) != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 12>;

  <bb 7>:
  goto <bb 11>;

  <bb 8>:
  if (c_28 == 13)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  goto <bb 11>;

  <bb 10>:
  _38 = (short unsigned int) c_28;
  _39 = (int) _38;
  _41 = ImFont::GetCharAdvance (font_15, _39);
  _42 = _41;
  char_width_43 = _42 * scale_19;
  line_width_44 = line_width_1 + char_width_43;

  <bb 11>:
  # line_width_2 = PHI <line_width_36(7), line_width_1(9), line_width_44(10)>
  goto <bb 3>;

  <bb 12>:
  # line_width_3 = PHI <line_width_1(3), line_width_36(6)>
  # s_5 = PHI <s_4(3), s_26(6)>
  _46 = text_size.x;
  if (_46 < line_width_3)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  text_size.x = line_width_3;

  <bb 14>:
  if (out_offset_48(D) != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _49 = text_size.y;
  _50 = _49 + line_height_17;
  ImVec2::ImVec2 (&D.19885, line_width_3, _50);
  *out_offset_48(D) = D.19885;
  D.19885 ={v} {CLOBBER};

  <bb 16>:
  if (line_width_3 > 0.0)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  _54 = text_size.y;
  if (_54 == 0.0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _55 = text_size.y;
  _56 = _55 + line_height_17;
  text_size.y = _56;

  <bb 19>:
  if (remaining_58(D) != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  *remaining_58(D) = s_5;

  <bb 21>:
  D.37412 = text_size;
  text_size ={v} {CLOBBER};

<L23>:
  return D.37412;

}



;; Function int ImGuiStb::STB_TEXTEDIT_STRINGLEN(const ImGuiTextEditState*) (_ZN8ImGuiStbL22STB_TEXTEDIT_STRINGLENEPK18ImGuiTextEditState, funcdef_no=1050, decl_uid=19890, cgraph_uid=949, symbol_order=959)

int ImGuiStb::STB_TEXTEDIT_STRINGLEN(const ImGuiTextEditState*) (const struct ImGuiTextEditState * obj)
{
  int D.37437;
  int _3;

  <bb 2>:
  _3 = obj_2(D)->CurLenW;

<L0>:
  return _3;

}



;; Function ImWchar ImGuiStb::STB_TEXTEDIT_GETCHAR(const ImGuiTextEditState*, int) (_ZN8ImGuiStbL20STB_TEXTEDIT_GETCHAREPK18ImGuiTextEditStatei, funcdef_no=1051, decl_uid=19894, cgraph_uid=950, symbol_order=960)

ImWchar ImGuiStb::STB_TEXTEDIT_GETCHAR(const ImGuiTextEditState*, int) (const struct ImGuiTextEditState * obj, int idx)
{
  const value_type & D.37441;
  const struct ImVector * D.37440;
  ImWchar D.37439;
  const struct ImVector * _2;
  const value_type & _6;
  ImWchar _7;

  <bb 2>:
  _2 = &obj_1(D)->Text;
  _6 = ImVector<short unsigned int>::operator[] (_2, idx_4(D));
  _7 = *_6;

<L0>:
  return _7;

}



;; Function float ImGuiStb::STB_TEXTEDIT_GETWIDTH(ImGuiTextEditState*, int, int) (_ZN8ImGuiStbL21STB_TEXTEDIT_GETWIDTHEP18ImGuiTextEditStateii, funcdef_no=1052, decl_uid=19899, cgraph_uid=951, symbol_order=961)

float ImGuiStb::STB_TEXTEDIT_GETWIDTH(ImGuiTextEditState*, int, int) (struct ImGuiTextEditState * obj, int line_start_idx, int char_idx)
{
  float D.37469;
  ImWchar c;
  float D.37467;
  float D.37466;
  struct ImFont * D.37465;
  struct ImGuiContext * GImGui.1304;
  float D.37463;
  struct ImGuiContext * GImGui.1303;
  float D.37461;
  struct ImFont * D.37460;
  struct ImGuiContext * GImGui.1302;
  int D.37458;
  float D.37457;
  value_type & D.37454;
  struct ImVector * D.37453;
  int D.37452;
  float _1;
  int _5;
  struct ImVector * _7;
  value_type & _10;
  float _12;
  int _13;
  struct ImGuiContext * GImGui.1302_14;
  struct ImFont * _15;
  float _17;
  float _18;
  struct ImGuiContext * GImGui.1303_19;
  float _20;
  struct ImGuiContext * GImGui.1304_21;
  struct ImFont * _22;
  float _23;
  float _24;
  float _25;

  <bb 2>:
  _5 = line_start_idx_3(D) + char_idx_4(D);
  _7 = &obj_6(D)->Text;
  _10 = ImVector<short unsigned int>::operator[] (_7, _5);
  c_11 = *_10;
  if (c_11 == 10)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = -1.0e+0;
  goto <bb 5> (<L2>);

  <bb 4>:
  _13 = (int) c_11;
  GImGui.1302_14 = GImGui;
  _15 = GImGui.1302_14->Font;
  _17 = ImFont::GetCharAdvance (_15, _13);
  _18 = _17;
  GImGui.1303_19 = GImGui;
  _20 = GImGui.1303_19->FontSize;
  GImGui.1304_21 = GImGui;
  _22 = GImGui.1304_21->Font;
  _23 = _22->FontSize;
  _24 = _20 / _23;
  _25 = _18 * _24;

  # _1 = PHI <_12(3), _25(4)>
<L2>:
  return _1;

}



;; Function int ImGuiStb::STB_TEXTEDIT_KEYTOTEXT(int) (_ZN8ImGuiStbL22STB_TEXTEDIT_KEYTOTEXTEi, funcdef_no=1053, decl_uid=19903, cgraph_uid=952, symbol_order=962)

int ImGuiStb::STB_TEXTEDIT_KEYTOTEXT(int) (int key)
{
  int iftmp.1305;
  int D.37479;
  int iftmp.1305_1;
  int iftmp.1305_3;
  int iftmp.1305_4;
  int _5;

  <bb 2>:
  if (key_2(D) <= 65535)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1305_3 = key_2(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.1305_4 = 0;

  <bb 5>:
  # iftmp.1305_1 = PHI <iftmp.1305_3(3), iftmp.1305_4(4)>
  _5 = iftmp.1305_1;

<L3>:
  return _5;

}



;; Function void ImGuiStb::STB_TEXTEDIT_LAYOUTROW(ImGuiStb::StbTexteditRow*, ImGuiTextEditState*, int) (_ZN8ImGuiStbL22STB_TEXTEDIT_LAYOUTROWEPNS_14StbTexteditRowEP18ImGuiTextEditStatei, funcdef_no=1054, decl_uid=19909, cgraph_uid=953, symbol_order=964)

void ImGuiStb::STB_TEXTEDIT_LAYOUTROW(ImGuiStb::StbTexteditRow*, ImGuiTextEditState*, int) (struct StbTexteditRow * r, struct ImGuiTextEditState * obj, int line_start_idx)
{
  const struct ImVec2 size;
  const ImWchar * text_remaining;
  const ImWchar * text;
  int D.37503;
  long int D.37502;
  long int D.37501;
  long int D.37500;
  const ImWchar * D.37499;
  long unsigned int D.37498;
  long unsigned int D.37497;
  long int text_remaining.1307;
  const ImWchar * text_remaining.1306;
  float D.37494;
  float D.37493;
  float D.37492;
  const ImWchar * D.37491;
  long unsigned int D.37490;
  long unsigned int D.37489;
  const ImWchar * D.37488;
  long unsigned int D.37487;
  long unsigned int D.37486;
  int D.37485;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  const ImWchar * _8;
  long unsigned int _10;
  long unsigned int _11;
  const ImWchar * _12;
  float _16;
  float _18;
  float _21;
  const ImWchar * text_remaining.1306_23;
  long int text_remaining.1307_24;
  long unsigned int _25;
  long unsigned int _26;
  const ImWchar * _27;
  long int _28;
  long int _29;
  long int _30;
  int _31;

  <bb 2>:
  text_3 = obj_2(D)->Text.Data;
  text_remaining = 0B;
  _5 = obj_2(D)->CurLenW;
  _6 = (long unsigned int) _5;
  _7 = _6 * 2;
  _8 = text_3 + _7;
  _10 = (long unsigned int) line_start_idx_9(D);
  _11 = _10 * 2;
  _12 = text_3 + _11;
  size = InputTextCalcTextSizeW (_12, _8, &text_remaining, 0B, 1);
  r_14(D)->x0 = 0.0;
  _16 = size.x;
  r_14(D)->x1 = _16;
  _18 = size.y;
  r_14(D)->baseline_y_delta = _18;
  r_14(D)->ymin = 0.0;
  _21 = size.y;
  r_14(D)->ymax = _21;
  text_remaining.1306_23 = text_remaining;
  text_remaining.1307_24 = (long int) text_remaining.1306_23;
  _25 = (long unsigned int) line_start_idx_9(D);
  _26 = _25 * 2;
  _27 = text_3 + _26;
  _28 = (long int) _27;
  _29 = text_remaining.1307_24 - _28;
  _30 = _29 /[ex] 2;
  _31 = (int) _30;
  r_14(D)->num_chars = _31;
  text_remaining ={v} {CLOBBER};
  size ={v} {CLOBBER};
  return;

}



;; Function bool ImGuiStb::is_separator(unsigned int) (_ZN8ImGuiStbL12is_separatorEj, funcdef_no=1055, decl_uid=19916, cgraph_uid=954, symbol_order=965)

bool ImGuiStb::is_separator(unsigned int) (unsigned int c)
{
  bool D.37510;
  bool iftmp.1308;
  bool D.37505;
  bool iftmp.1308_1;
  bool _5;
  bool iftmp.1308_6;
  bool iftmp.1308_7;
  bool _8;

  <bb 2>:
  _5 = ImCharIsSpace (c_3(D));
  if (_5 != 0)
    goto <bb 12>;
  else
    goto <bb 3>;

  <bb 3>:
  if (c_3(D) == 44)
    goto <bb 12>;
  else
    goto <bb 4>;

  <bb 4>:
  if (c_3(D) == 59)
    goto <bb 12>;
  else
    goto <bb 5>;

  <bb 5>:
  if (c_3(D) == 40)
    goto <bb 12>;
  else
    goto <bb 6>;

  <bb 6>:
  if (c_3(D) == 41)
    goto <bb 12>;
  else
    goto <bb 7>;

  <bb 7>:
  if (c_3(D) == 123)
    goto <bb 12>;
  else
    goto <bb 8>;

  <bb 8>:
  if (c_3(D) == 125)
    goto <bb 12>;
  else
    goto <bb 9>;

  <bb 9>:
  if (c_3(D) == 91)
    goto <bb 12>;
  else
    goto <bb 10>;

  <bb 10>:
  if (c_3(D) == 93)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  if (c_3(D) == 124)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.1308_7 = 1;
  goto <bb 14>;

  <bb 13>:
  iftmp.1308_6 = 0;

  <bb 14>:
  # iftmp.1308_1 = PHI <iftmp.1308_7(12), iftmp.1308_6(13)>
  _8 = iftmp.1308_1;

<L12>:
  return _8;

}



;; Function int ImGuiStb::is_word_boundary_from_right(ImGuiTextEditState*, int) (_ZN8ImGuiStbL27is_word_boundary_from_rightEP18ImGuiTextEditStatei, funcdef_no=1056, decl_uid=19920, cgraph_uid=955, symbol_order=966)

int ImGuiStb::is_word_boundary_from_right(ImGuiTextEditState*, int) (struct ImGuiTextEditState * obj, int idx)
{
  bool D.37540;
  bool D.37539;
  unsigned int D.37538;
  short unsigned int D.37537;
  value_type & D.37536;
  struct ImVector * D.37535;
  bool D.37533;
  unsigned int D.37532;
  short unsigned int D.37531;
  value_type & D.37530;
  struct ImVector * D.37529;
  int D.37528;
  bool iftmp.1310;
  int iftmp.1309;
  int D.37521;
  int iftmp.1309_1;
  bool iftmp.1310_2;
  int _7;
  struct ImVector * _9;
  value_type & _12;
  short unsigned int _13;
  unsigned int _14;
  bool _16;
  struct ImVector * _17;
  value_type & _19;
  short unsigned int _20;
  unsigned int _21;
  bool _23;
  bool _24;
  bool iftmp.1310_25;
  bool iftmp.1310_26;
  int iftmp.1309_27;
  int iftmp.1309_28;
  int _29;

  <bb 2>:
  if (idx_6(D) > 0)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  _7 = idx_6(D) + -1;
  _9 = &obj_8(D)->Text;
  _12 = ImVector<short unsigned int>::operator[] (_9, _7);
  _13 = *_12;
  _14 = (unsigned int) _13;
  _16 = ImGuiStb::is_separator (_14);
  if (_16 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _17 = &obj_8(D)->Text;
  _19 = ImVector<short unsigned int>::operator[] (_17, idx_6(D));
  _20 = *_19;
  _21 = (unsigned int) _20;
  _23 = ImGuiStb::is_separator (_21);
  _24 = ~_23;
  if (_24 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1310_25 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.1310_26 = 0;

  <bb 7>:
  # iftmp.1310_2 = PHI <iftmp.1310_25(5), iftmp.1310_26(6)>
  iftmp.1309_27 = (int) iftmp.1310_2;
  goto <bb 9>;

  <bb 8>:
  iftmp.1309_28 = 1;

  <bb 9>:
  # iftmp.1309_1 = PHI <iftmp.1309_27(7), iftmp.1309_28(8)>
  _29 = iftmp.1309_1;

<L7>:
  return _29;

}



;; Function int ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiTextEditState*, int) (_ZN8ImGuiStbL30STB_TEXTEDIT_MOVEWORDLEFT_IMPLEP18ImGuiTextEditStatei, funcdef_no=1057, decl_uid=19924, cgraph_uid=956, symbol_order=967)

int ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiTextEditState*, int) (struct ImGuiTextEditState * obj, int idx)
{
  int D.37555;
  int D.37553;
  int D.37550;
  bool iftmp.1312;
  bool retval.1311;
  bool iftmp.1312_2;
  int _11;
  int _12;
  bool iftmp.1312_13;
  bool iftmp.1312_14;
  bool retval.1311_15;
  int _17;

  <bb 2>:
  idx_7 = idx_6(D) + -1;

  <bb 3>:
  # idx_1 = PHI <idx_7(2), idx_16(8)>
  if (idx_1 >= 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _11 = ImGuiStb::is_word_boundary_from_right (obj_9(D), idx_1);
  _12 = _11;
  if (_12 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1312_13 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.1312_14 = 0;

  <bb 7>:
  # iftmp.1312_2 = PHI <iftmp.1312_13(5), iftmp.1312_14(6)>
  retval.1311_15 = iftmp.1312_2;
  if (retval.1311_15 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  idx_16 = idx_1 + -1;
  goto <bb 3>;

  <bb 9>:
  _17 = MAX_EXPR <idx_1, 0>;

<L7>:
  return _17;

}



;; Function int ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiTextEditState*, int) (_ZN8ImGuiStbL31STB_TEXTEDIT_MOVEWORDRIGHT_IMPLEP18ImGuiTextEditStatei, funcdef_no=1058, decl_uid=19930, cgraph_uid=957, symbol_order=968)

int ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(ImGuiTextEditState*, int) (struct ImGuiTextEditState * obj, int idx)
{
  int D.37571;
  int len;
  int iftmp.1315;
  int D.37565;
  int D.37562;
  bool iftmp.1314;
  bool retval.1313;
  bool iftmp.1314_2;
  int iftmp.1315_3;
  int _13;
  int _14;
  bool iftmp.1314_15;
  bool iftmp.1314_16;
  bool retval.1313_17;
  int iftmp.1315_19;
  int iftmp.1315_20;
  int _21;

  <bb 2>:
  idx_8 = idx_7(D) + 1;
  len_11 = obj_10(D)->CurLenW;

  <bb 3>:
  # idx_1 = PHI <idx_8(2), idx_18(8)>
  if (idx_1 < len_11)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _13 = ImGuiStb::is_word_boundary_from_right (obj_10(D), idx_1);
  _14 = _13;
  if (_14 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1314_15 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.1314_16 = 0;

  <bb 7>:
  # iftmp.1314_2 = PHI <iftmp.1314_15(5), iftmp.1314_16(6)>
  retval.1313_17 = iftmp.1314_2;
  if (retval.1313_17 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  idx_18 = idx_1 + 1;
  goto <bb 3>;

  <bb 9>:
  if (idx_1 > len_11)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1315_19 = len_11;
  goto <bb 12>;

  <bb 11>:
  iftmp.1315_20 = idx_1;

  <bb 12>:
  # iftmp.1315_3 = PHI <iftmp.1315_19(10), iftmp.1315_20(11)>
  _21 = iftmp.1315_3;

<L10>:
  return _21;

}



;; Function void ImGuiStb::STB_TEXTEDIT_DELETECHARS(ImGuiTextEditState*, int, int) (_ZN8ImGuiStbL24STB_TEXTEDIT_DELETECHARSEP18ImGuiTextEditStateii, funcdef_no=1059, decl_uid=19938, cgraph_uid=958, symbol_order=969)

void ImGuiStb::STB_TEXTEDIT_DELETECHARS(ImGuiTextEditState*, int, int) (struct ImGuiTextEditState * obj, int pos, int n)
{
  ImWchar c;
  const ImWchar * src;
  ImWchar * dst;
  ImWchar * dst.1317;
  const ImWchar * src.1316;
  sizetype D.37586;
  sizetype D.37585;
  sizetype D.37584;
  sizetype D.37583;
  short unsigned int * D.37582;
  int D.37581;
  int D.37580;
  int D.37579;
  int D.37578;
  ImWchar * D.37577;
  long unsigned int D.37576;
  long unsigned int D.37575;
  int D.19941;
  long unsigned int D.37574;
  long unsigned int D.37573;
  short unsigned int * D.37572;
  short unsigned int * _6;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _12;
  long unsigned int _13;
  ImWchar * _14;
  int _16;
  int _17;
  int _18;
  int _20;
  int _21;
  short unsigned int * _23;
  sizetype _24;
  sizetype _25;
  sizetype _26;
  sizetype _27;
  const ImWchar * src.1316_29;
  ImWchar * dst.1317_32;

  <bb 2>:
  _6 = obj_5(D)->Text.Data;
  _8 = (long unsigned int) pos_7(D);
  _9 = _8 * 2;
  dst_10 = _6 + _9;
  _12 = (long unsigned int) n_11(D);
  _13 = _12 * 2;
  _14 = dst_10 + _13;
  _16 = ImTextCountUtf8BytesFromStr (dst_10, _14);
  _17 = obj_5(D)->CurLenA;
  _18 = _17 - _16;
  obj_5(D)->CurLenA = _18;
  _20 = obj_5(D)->CurLenW;
  _21 = _20 - n_11(D);
  obj_5(D)->CurLenW = _21;
  _23 = obj_5(D)->Text.Data;
  _24 = (sizetype) pos_7(D);
  _25 = (sizetype) n_11(D);
  _26 = _24 + _25;
  _27 = _26 * 2;
  src_28 = _23 + _27;

  <bb 3>:
  # dst_1 = PHI <dst_10(2), dst_33(4)>
  # src_2 = PHI <src_28(2), src_30(4)>
  src.1316_29 = src_2;
  src_30 = src.1316_29 + 2;
  c_31 = *src.1316_29;
  if (c_31 == 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  dst.1317_32 = dst_1;
  dst_33 = dst.1317_32 + 2;
  *dst.1317_32 = c_31;
  goto <bb 3>;

  <bb 5>:
  *dst_1 = 0;
  return;

}



;; Function bool ImGuiStb::STB_TEXTEDIT_INSERTCHARS(ImGuiTextEditState*, int, const ImWchar*, int) (_ZN8ImGuiStbL24STB_TEXTEDIT_INSERTCHARSEP18ImGuiTextEditStateiPKti, funcdef_no=1060, decl_uid=19950, cgraph_uid=959, symbol_order=970)

bool ImGuiStb::STB_TEXTEDIT_INSERTCHARS(ImGuiTextEditState*, int, const ImWchar*, int) (struct ImGuiTextEditState * obj, int pos, const ImWchar * new_text, int new_text_len)
{
  ImWchar * text;
  const int new_text_len_utf8;
  static const char __PRETTY_FUNCTION__[87] = "bool ImGuiStb::STB_TEXTEDIT_INSERTCHARS(ImGuiTextEditState*, int, const ImWchar*, int)";
  const int text_len;
  value_type & D.37634;
  struct ImVector * D.37633;
  int D.37632;
  int D.37631;
  int D.37630;
  int D.37629;
  int D.37628;
  ImWchar * D.37627;
  long unsigned int D.37626;
  long unsigned int D.37625;
  long unsigned int D.37624;
  long unsigned int D.37623;
  ImWchar * D.37621;
  sizetype D.37620;
  sizetype D.37619;
  sizetype D.37618;
  sizetype D.37617;
  ImWchar * D.37616;
  long unsigned int D.37615;
  long unsigned int D.37614;
  long unsigned int D.37613;
  long unsigned int D.37612;
  int D.37611;
  int D.37606;
  int D.37605;
  int D.37604;
  int D.37603;
  const ImWchar * D.37602;
  long unsigned int D.37601;
  long unsigned int D.37600;
  bool D.37599;
  int D.37596;
  int D.37595;
  int D.37594;
  bool _1;
  int _9;
  int _10;
  int _11;
  bool _12;
  long unsigned int _13;
  long unsigned int _14;
  const ImWchar * _16;
  int _19;
  int _20;
  int _21;
  int _22;
  bool _23;
  int _25;
  long unsigned int _26;
  long unsigned int _27;
  long unsigned int _28;
  long unsigned int _29;
  ImWchar * _30;
  sizetype _31;
  sizetype _32;
  sizetype _33;
  sizetype _34;
  ImWchar * _35;
  long unsigned int _37;
  long unsigned int _38;
  long unsigned int _39;
  long unsigned int _40;
  ImWchar * _41;
  int _43;
  int _44;
  int _46;
  int _47;
  int _49;
  struct ImVector * _50;
  value_type & _52;
  bool _54;

  <bb 2>:
  text_len_6 = obj_5(D)->CurLenW;
  if (pos_7(D) <= text_len_6)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("pos <= text_len", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9743, &__PRETTY_FUNCTION__);

  <bb 4>:
  _9 = new_text_len_8(D) + text_len_6;
  _10 = _9 + 1;
  _11 = obj_5(D)->Text.Size;
  if (_10 > _11)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _12 = 0;
  goto <bb 11> (<L10>);

  <bb 6>:
  _13 = (long unsigned int) new_text_len_8(D);
  _14 = _13 * 2;
  _16 = new_text_15(D) + _14;
  new_text_len_utf8_18 = ImTextCountUtf8BytesFromStr (new_text_15(D), _16);
  _19 = obj_5(D)->CurLenA;
  _20 = _19 + new_text_len_utf8_18;
  _21 = _20 + 1;
  _22 = obj_5(D)->BufSizeA;
  if (_21 > _22)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _23 = 0;
  goto <bb 11> (<L10>);

  <bb 8>:
  text_24 = obj_5(D)->Text.Data;
  if (pos_7(D) != text_len_6)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _25 = text_len_6 - pos_7(D);
  _26 = (long unsigned int) _25;
  _27 = _26 * 2;
  _28 = (long unsigned int) pos_7(D);
  _29 = _28 * 2;
  _30 = text_24 + _29;
  _31 = (sizetype) pos_7(D);
  _32 = (sizetype) new_text_len_8(D);
  _33 = _31 + _32;
  _34 = _33 * 2;
  _35 = text_24 + _34;
  memmove (_35, _30, _27);

  <bb 10>:
  _37 = (long unsigned int) new_text_len_8(D);
  _38 = _37 * 2;
  _39 = (long unsigned int) pos_7(D);
  _40 = _39 * 2;
  _41 = text_24 + _40;
  memcpy (_41, new_text_15(D), _38);
  _43 = obj_5(D)->CurLenW;
  _44 = _43 + new_text_len_8(D);
  obj_5(D)->CurLenW = _44;
  _46 = obj_5(D)->CurLenA;
  _47 = _46 + new_text_len_utf8_18;
  obj_5(D)->CurLenA = _47;
  _49 = obj_5(D)->CurLenW;
  _50 = &obj_5(D)->Text;
  _52 = ImVector<short unsigned int>::operator[] (_50, _49);
  *_52 = 0;
  _54 = 1;

  # _1 = PHI <_12(5), _23(7), _54(10)>
<L10>:
  return _1;

}



;; Function int ImGuiStb::stb_text_locate_coord(ImGuiTextEditState*, float, float) (_ZN8ImGuiStbL21stb_text_locate_coordEP18ImGuiTextEditStateff, funcdef_no=1061, decl_uid=19959, cgraph_uid=960, symbol_order=971)

int ImGuiStb::stb_text_locate_coord(ImGuiTextEditState*, float, float) (struct ImGuiTextEditState * str, float x, float y)
{
  short unsigned int D.37689;
  float D.37688;
  float w;
  int k;
  int i;
  float prev_x;
  float base_y;
  int n;
  struct StbTexteditRow r;
  int D.37686;
  int D.37685;
  int D.37684;
  short unsigned int STB_TEXTEDIT_NEWLINE.1319;
  short unsigned int D.37680;
  int D.37679;
  int D.37678;
  int D.37677;
  bool retval.1318;
  int D.37674;
  float D.37671;
  float D.37670;
  float D.37667;
  int D.37665;
  float D.37661;
  float D.37658;
  float D.37655;
  int D.37654;
  float D.37651;
  float D.37650;
  float D.37647;
  float D.37646;
  int D.37643;
  int D.37640;
  float D.37637;
  float D.37636;
  int _5;
  float _19;
  float _22;
  int _26;
  float _27;
  float _28;
  int _30;
  float _31;
  float _32;
  int _33;
  float _35;
  int _37;
  int _38;
  float _39;
  int _41;
  float _42;
  int _45;
  float _47;
  float _49;
  float _52;
  float _53;
  int _54;
  int _55;
  int _56;
  int _57;
  int _58;
  int _59;
  short unsigned int _61;
  short unsigned int _62;
  short unsigned int STB_TEXTEDIT_NEWLINE.1319_63;
  bool retval.1318_64;
  int _65;
  int _66;
  int _67;
  int _68;
  int _69;

  <bb 2>:
  n_15 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_13(D));
  base_y_16 = 0.0;
  i_17 = 0;
  r.x1 = 0.0;
  _19 = r.x1;
  r.x0 = _19;
  r.ymax = 0.0;
  _22 = r.ymax;
  r.ymin = _22;
  r.num_chars = 0;

  <bb 3>:
  # base_y_1 = PHI <base_y_16(2), base_y_36(11)>
  # i_3 = PHI <i_17(2), i_34(11)>
  if (i_3 >= n_15)
    goto <bb 12>;
  else
    goto <bb 4>;

  <bb 4>:
  ImGuiStb::STB_TEXTEDIT_LAYOUTROW (&r, str_13(D), i_3);
  _26 = r.num_chars;
  if (_26 <= 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _37 = n_15;
  goto <bb 28>;

  <bb 6>:
  if (i_3 == 0)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _27 = r.ymin;
  _28 = _27 + base_y_1;
  if (_28 > y_29(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _30 = 0;
  goto <bb 28>;

  <bb 9>:
  _31 = r.ymax;
  _32 = _31 + base_y_1;
  if (_32 > y_29(D))
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 12>;

  <bb 11>:
  _33 = r.num_chars;
  i_34 = _33 + i_3;
  _35 = r.baseline_y_delta;
  base_y_36 = _35 + base_y_1;
  goto <bb 3>;

  <bb 12>:
  if (i_3 >= n_15)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _38 = n_15;
  goto <bb 28>;

  <bb 14>:
  _39 = r.x0;
  if (_39 > x_40(D))
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _41 = i_3;
  goto <bb 28>;

  <bb 16>:
  _42 = r.x1;
  if (_42 > x_40(D))
    goto <bb 17>;
  else
    goto <bb 25>;

  <bb 17>:
  prev_x_43 = r.x0;
  k_44 = 0;

  <bb 18>:
  # prev_x_2 = PHI <prev_x_43(17), prev_x_50(23)>
  # k_4 = PHI <k_44(17), k_51(23)>
  _45 = r.num_chars;
  if (_45 <= k_4)
    goto <bb 24>;
  else
    goto <bb 19>;

  <bb 19>:
  _47 = ImGuiStb::STB_TEXTEDIT_GETWIDTH (str_13(D), i_3, k_4);
  w_48 = _47;
  _49 = prev_x_2 + w_48;
  if (_49 > x_40(D))
    goto <bb 20>;
  else
    goto <bb 23>;

  <bb 20>:
  _52 = w_48 / 2.0e+0;
  _53 = _52 + prev_x_2;
  if (_53 > x_40(D))
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _54 = k_4 + i_3;
  goto <bb 28>;

  <bb 22>:
  _55 = k_4 + i_3;
  _56 = _55 + 1;
  goto <bb 28>;

  <bb 23>:
  prev_x_50 = prev_x_2 + w_48;
  k_51 = k_4 + 1;
  goto <bb 18>;

  <bb 24>:

  <bb 25>:
  _57 = r.num_chars;
  _58 = _57 + i_3;
  _59 = _58 + -1;
  _61 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_13(D), _59);
  _62 = _61;
  STB_TEXTEDIT_NEWLINE.1319_63 = STB_TEXTEDIT_NEWLINE;
  retval.1318_64 = _62 == STB_TEXTEDIT_NEWLINE.1319_63;
  if (retval.1318_64 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  _65 = r.num_chars;
  _66 = _65 + i_3;
  _67 = _66 + -1;
  goto <bb 28>;

  <bb 27>:
  _68 = r.num_chars;
  _69 = _68 + i_3;

  <bb 28>:
  # _5 = PHI <_37(5), _30(8), _38(13), _41(15), _54(21), _56(22), _67(26), _69(27)>
  r ={v} {CLOBBER};

<L28>:
  return _5;

}



;; Function void ImGuiStb::stb_textedit_click(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, float, float) (_ZN8ImGuiStbL18stb_textedit_clickEP18ImGuiTextEditStatePNS_17STB_TexteditStateEff, funcdef_no=1062, decl_uid=20009, cgraph_uid=961, symbol_order=972)

void ImGuiStb::stb_textedit_click(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, float, float) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, float x, float y)
{
  int D.37695;
  int D.37694;
  int D.37693;
  int D.37692;
  int _6;
  int _7;
  int _10;
  int _12;

  <bb 2>:
  _6 = ImGuiStb::stb_text_locate_coord (str_2(D), x_3(D), y_4(D));
  _7 = _6;
  state_8(D)->cursor = _7;
  _10 = state_8(D)->cursor;
  state_8(D)->select_start = _10;
  _12 = state_8(D)->cursor;
  state_8(D)->select_end = _12;
  state_8(D)->has_preferred_x = 0;
  return;

}



;; Function void ImGuiStb::stb_textedit_drag(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, float, float) (_ZN8ImGuiStbL17stb_textedit_dragEP18ImGuiTextEditStatePNS_17STB_TexteditStateEff, funcdef_no=1063, decl_uid=20015, cgraph_uid=962, symbol_order=973)

void ImGuiStb::stb_textedit_drag(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, float, float) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, float x, float y)
{
  int D.37703;
  int p;
  int D.37702;
  int D.37700;
  int D.37697;
  int D.37696;
  int _7;
  int _10;
  int _11;
  int _12;
  int _15;

  <bb 2>:
  _7 = ImGuiStb::stb_text_locate_coord (str_3(D), x_4(D), y_5(D));
  p_8 = _7;
  _10 = state_9(D)->select_start;
  _11 = state_9(D)->select_end;
  if (_10 == _11)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _12 = state_9(D)->cursor;
  state_9(D)->select_start = _12;

  <bb 4>:
  state_9(D)->select_end = p_8;
  _15 = state_9(D)->select_end;
  state_9(D)->cursor = _15;
  return;

}



;; Function void ImGuiStb::stb_textedit_find_charpos(ImGuiStb::StbFindState*, ImGuiTextEditState*, int, int) (_ZN8ImGuiStbL25stb_textedit_find_charposEPNS_12StbFindStateEP18ImGuiTextEditStateii, funcdef_no=1064, decl_uid=20052, cgraph_uid=963, symbol_order=974)

void ImGuiStb::stb_textedit_find_charpos(ImGuiStb::StbFindState*, ImGuiTextEditState*, int, int) (struct StbFindState * find, struct ImGuiTextEditState * str, int n, int single_line)
{
  float D.37736;
  int first;
  int i;
  int z;
  int prev_start;
  struct StbTexteditRow r;
  float D.37734;
  float D.37733;
  float D.20059;
  int D.37731;
  float D.37729;
  float D.37728;
  float D.37727;
  float D.37726;
  int D.37725;
  float D.37724;
  float D.37723;
  float D.37722;
  int D.37721;
  int D.37718;
  int D.37717;
  int D.37715;
  float D.37711;
  float D.37710;
  float D.37709;
  float D.37708;
  int _22;
  int _23;
  int _25;
  float _27;
  float _28;
  float _29;
  int _33;
  float _35;
  float _36;
  float _37;
  float _40;
  int _44;
  float _46;
  float _47;
  float _48;
  float _49;
  float _58;
  float _59;
  float _60;
  float _62;
  int _69;

  <bb 2>:
  prev_start_12 = 0;
  z_16 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_14(D));
  i_17 = 0;
  if (n_18(D) == z_16)
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 3>:
  if (single_line_53(D) != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  ImGuiStb::STB_TEXTEDIT_LAYOUTROW (&r, str_14(D), 0);
  find_19(D)->y = 0.0;
  find_19(D)->first_char = 0;
  find_19(D)->length = z_16;
  _58 = r.ymax;
  _59 = r.ymin;
  _60 = _58 - _59;
  find_19(D)->height = _60;
  _62 = r.x1;
  find_19(D)->x = _62;
  goto <bb 9>;

  <bb 5>:
  find_19(D)->y = 0.0;
  find_19(D)->x = 0.0;
  find_19(D)->height = 1.0e+0;

  <bb 6>:
  # prev_start_1 = PHI <prev_start_12(5), prev_start_68(7)>
  # i_3 = PHI <i_17(5), i_70(7)>
  if (i_3 >= z_16)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  ImGuiStb::STB_TEXTEDIT_LAYOUTROW (&r, str_14(D), i_3);
  prev_start_68 = i_3;
  _69 = r.num_chars;
  i_70 = _69 + i_3;
  goto <bb 6>;

  <bb 8>:
  find_19(D)->first_char = i_3;
  find_19(D)->length = 0;
  find_19(D)->prev_first = prev_start_1;

  <bb 9>:
  r ={v} {CLOBBER};
  goto <bb 18> (<L17>);

  <bb 10>:
  find_19(D)->y = 0.0;

  <bb 11>:
  # prev_start_2 = PHI <prev_start_12(10), prev_start_24(13)>
  # i_4 = PHI <i_17(10), i_26(13)>
  ImGuiStb::STB_TEXTEDIT_LAYOUTROW (&r, str_14(D), i_4);
  _22 = r.num_chars;
  _23 = _22 + i_4;
  if (_23 > n_18(D))
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  goto <bb 14>;

  <bb 13>:
  prev_start_24 = i_4;
  _25 = r.num_chars;
  i_26 = _25 + i_4;
  _27 = find_19(D)->y;
  _28 = r.baseline_y_delta;
  _29 = _27 + _28;
  find_19(D)->y = _29;
  goto <bb 11>;

  <bb 14>:
  first_31 = i_4;
  find_19(D)->first_char = first_31;
  _33 = r.num_chars;
  find_19(D)->length = _33;
  _35 = r.ymax;
  _36 = r.ymin;
  _37 = _35 - _36;
  find_19(D)->height = _37;
  find_19(D)->prev_first = prev_start_2;
  _40 = r.x0;
  find_19(D)->x = _40;
  i_42 = 0;
  i_43 = 0;

  <bb 15>:
  # i_5 = PHI <i_43(14), i_51(16)>
  _44 = first_31 + i_5;
  if (_44 >= n_18(D))
    goto <bb 17>;
  else
    goto <bb 16>;

  <bb 16>:
  _46 = ImGuiStb::STB_TEXTEDIT_GETWIDTH (str_14(D), first_31, i_5);
  _47 = _46;
  _48 = find_19(D)->x;
  _49 = _48 + _47;
  find_19(D)->x = _49;
  i_51 = i_5 + 1;
  goto <bb 15>;

  <bb 17>:
  r ={v} {CLOBBER};

<L17>:
  return;

}



;; Function void ImGuiStb::stb_textedit_clamp(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL18stb_textedit_clampEP18ImGuiTextEditStatePNS_17STB_TexteditStateE, funcdef_no=1065, decl_uid=20068, cgraph_uid=964, symbol_order=975)

void ImGuiStb::stb_textedit_clamp(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (struct ImGuiTextEditState * str, struct STB_TexteditState * state)
{
  int n;
  struct STB_TexteditState * state.1331;
  int D.37770;
  struct STB_TexteditState * state.1330;
  int D.37766;
  struct STB_TexteditState * state.1329;
  struct STB_TexteditState * state.1328;
  int D.37761;
  struct STB_TexteditState * state.1327;
  int D.37759;
  struct STB_TexteditState * state.1326;
  struct STB_TexteditState * state.1325;
  int D.37753;
  struct STB_TexteditState * state.1324;
  struct STB_TexteditState * state.1323;
  int D.37747;
  struct STB_TexteditState * state.1322;
  int D.37743;
  struct STB_TexteditState * state.1321;
  int D.37741;
  struct STB_TexteditState * state.1320;
  struct STB_TexteditState * state.1320_9;
  int _10;
  struct STB_TexteditState * state.1321_11;
  int _12;
  struct STB_TexteditState * state.1322_13;
  int _14;
  struct STB_TexteditState * state.1323_15;
  struct STB_TexteditState * state.1324_17;
  int _18;
  struct STB_TexteditState * state.1325_19;
  struct STB_TexteditState * state.1326_21;
  int _22;
  struct STB_TexteditState * state.1327_23;
  int _24;
  struct STB_TexteditState * state.1328_25;
  struct STB_TexteditState * state.1329_26;
  int _27;
  struct STB_TexteditState * state.1330_29;
  int _30;
  struct STB_TexteditState * state.1331_31;

  <bb 2>:
  n_8 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_6(D));
  state.1320_9 = state;
  _10 = state.1320_9->select_start;
  state.1321_11 = state;
  _12 = state.1321_11->select_end;
  if (_10 != _12)
    goto <bb 3>;
  else
    goto <bb 9>;

  <bb 3>:
  state.1322_13 = state;
  _14 = state.1322_13->select_start;
  if (_14 > n_8)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  state.1323_15 = state;
  state.1323_15->select_start = n_8;

  <bb 5>:
  state.1324_17 = state;
  _18 = state.1324_17->select_end;
  if (_18 > n_8)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  state.1325_19 = state;
  state.1325_19->select_end = n_8;

  <bb 7>:
  state.1326_21 = state;
  _22 = state.1326_21->select_start;
  state.1327_23 = state;
  _24 = state.1327_23->select_end;
  if (_22 == _24)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  state.1328_25 = state;
  state.1329_26 = state;
  _27 = state.1329_26->select_start;
  state.1328_25->cursor = _27;

  <bb 9>:
  state.1330_29 = state;
  _30 = state.1330_29->cursor;
  if (_30 > n_8)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  state.1331_31 = state;
  state.1331_31->cursor = n_8;

  <bb 11>:
  return;

}



;; Function void ImGuiStb::stb_textedit_delete(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int, int) (_ZN8ImGuiStbL19stb_textedit_deleteEP18ImGuiTextEditStatePNS_17STB_TexteditStateEii, funcdef_no=1066, decl_uid=20075, cgraph_uid=965, symbol_order=976)

void ImGuiStb::stb_textedit_delete(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int, int) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, int where, int len)
{
  <bb 2>:
  ImGuiStb::stb_text_makeundo_delete (str_2(D), state_3(D), where_4(D), len_5(D));
  ImGuiStb::STB_TEXTEDIT_DELETECHARS (str_2(D), where_4(D), len_5(D));
  state_3(D)->has_preferred_x = 0;
  return;

}



;; Function void ImGuiStb::stb_textedit_delete_selection(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL29stb_textedit_delete_selectionEP18ImGuiTextEditStatePNS_17STB_TexteditStateE, funcdef_no=1067, decl_uid=20079, cgraph_uid=966, symbol_order=977)

void ImGuiStb::stb_textedit_delete_selection(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (struct ImGuiTextEditState * str, struct STB_TexteditState * state)
{
  struct STB_TexteditState * state.1351;
  int D.37814;
  int D.37813;
  struct STB_TexteditState * state.1350;
  struct STB_TexteditState * state.1349;
  struct STB_TexteditState * state.1348;
  struct STB_TexteditState * state.1347;
  int D.37808;
  struct STB_TexteditState * state.1346;
  int D.37806;
  int D.37805;
  struct STB_TexteditState * state.1345;
  int D.37803;
  struct STB_TexteditState * state.1344;
  int D.37800;
  int D.37799;
  struct STB_TexteditState * state.1343;
  struct STB_TexteditState * state.1342;
  struct STB_TexteditState * state.1341;
  struct STB_TexteditState * state.1340;
  int D.37794;
  struct STB_TexteditState * state.1339;
  int D.37792;
  int D.37791;
  struct STB_TexteditState * state.1338;
  int D.37789;
  struct STB_TexteditState * state.1337;
  int D.37785;
  struct STB_TexteditState * state.1336;
  int D.37783;
  struct STB_TexteditState * state.1335;
  int D.37779;
  struct STB_TexteditState * state.1334;
  int D.37777;
  struct STB_TexteditState * state.1333;
  struct STB_TexteditState * state.1332;
  struct STB_TexteditState * state.1332_4;
  struct STB_TexteditState * state.1333_7;
  int _8;
  struct STB_TexteditState * state.1334_9;
  int _10;
  struct STB_TexteditState * state.1335_11;
  int _12;
  struct STB_TexteditState * state.1336_13;
  int _14;
  struct STB_TexteditState * state.1337_15;
  int _16;
  struct STB_TexteditState * state.1338_17;
  int _18;
  int _19;
  struct STB_TexteditState * state.1339_20;
  int _21;
  struct STB_TexteditState * state.1340_22;
  struct STB_TexteditState * state.1341_24;
  struct STB_TexteditState * state.1342_25;
  struct STB_TexteditState * state.1343_26;
  int _27;
  int _29;
  struct STB_TexteditState * state.1344_31;
  int _32;
  struct STB_TexteditState * state.1345_33;
  int _34;
  int _35;
  struct STB_TexteditState * state.1346_36;
  int _37;
  struct STB_TexteditState * state.1347_38;
  struct STB_TexteditState * state.1348_40;
  struct STB_TexteditState * state.1349_41;
  struct STB_TexteditState * state.1350_42;
  int _43;
  int _45;
  struct STB_TexteditState * state.1351_47;

  <bb 2>:
  state.1332_4 = state;
  ImGuiStb::stb_textedit_clamp (str_5(D), state.1332_4);
  state.1333_7 = state;
  _8 = state.1333_7->select_start;
  state.1334_9 = state;
  _10 = state.1334_9->select_end;
  if (_8 != _10)
    goto <bb 3>;
  else
    goto <bb 7>;

  <bb 3>:
  state.1335_11 = state;
  _12 = state.1335_11->select_start;
  state.1336_13 = state;
  _14 = state.1336_13->select_end;
  if (_12 < _14)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  state.1337_15 = state;
  _16 = state.1337_15->select_end;
  state.1338_17 = state;
  _18 = state.1338_17->select_start;
  _19 = _16 - _18;
  state.1339_20 = state;
  _21 = state.1339_20->select_start;
  state.1340_22 = state;
  ImGuiStb::stb_textedit_delete (str_5(D), state.1340_22, _21, _19);
  state.1341_24 = state;
  state.1342_25 = state;
  state.1343_26 = state;
  _27 = state.1343_26->select_start;
  state.1342_25->cursor = _27;
  _29 = state.1342_25->cursor;
  state.1341_24->select_end = _29;
  goto <bb 6>;

  <bb 5>:
  state.1344_31 = state;
  _32 = state.1344_31->select_start;
  state.1345_33 = state;
  _34 = state.1345_33->select_end;
  _35 = _32 - _34;
  state.1346_36 = state;
  _37 = state.1346_36->select_end;
  state.1347_38 = state;
  ImGuiStb::stb_textedit_delete (str_5(D), state.1347_38, _37, _35);
  state.1348_40 = state;
  state.1349_41 = state;
  state.1350_42 = state;
  _43 = state.1350_42->select_end;
  state.1349_41->cursor = _43;
  _45 = state.1349_41->cursor;
  state.1348_40->select_start = _45;

  <bb 6>:
  state.1351_47 = state;
  state.1351_47->has_preferred_x = 0;

  <bb 7>:
  return;

}



;; Function void ImGuiStb::stb_textedit_sortselection(ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL26stb_textedit_sortselectionEPNS_17STB_TexteditStateE, funcdef_no=1068, decl_uid=20082, cgraph_uid=967, symbol_order=978)

void ImGuiStb::stb_textedit_sortselection(ImGuiStb::STB_TexteditState*) (struct STB_TexteditState * state)
{
  int temp;
  int D.37821;
  int D.37818;
  int D.37817;
  int _4;
  int _5;
  int _7;

  <bb 2>:
  _4 = state_3(D)->select_end;
  _5 = state_3(D)->select_start;
  if (_4 < _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  temp_6 = state_3(D)->select_end;
  _7 = state_3(D)->select_start;
  state_3(D)->select_end = _7;
  state_3(D)->select_start = temp_6;

  <bb 4>:
  return;

}



;; Function void ImGuiStb::stb_textedit_move_to_first(ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL26stb_textedit_move_to_firstEPNS_17STB_TexteditStateE, funcdef_no=1069, decl_uid=20086, cgraph_uid=968, symbol_order=979)

void ImGuiStb::stb_textedit_move_to_first(ImGuiStb::STB_TexteditState*) (struct STB_TexteditState * state)
{
  struct STB_TexteditState * state.1359;
  int D.37835;
  struct STB_TexteditState * state.1358;
  struct STB_TexteditState * state.1357;
  int D.37832;
  struct STB_TexteditState * state.1356;
  struct STB_TexteditState * state.1355;
  struct STB_TexteditState * state.1354;
  int D.37826;
  struct STB_TexteditState * state.1353;
  int D.37824;
  struct STB_TexteditState * state.1352;
  struct STB_TexteditState * state.1352_3;
  int _4;
  struct STB_TexteditState * state.1353_5;
  int _6;
  struct STB_TexteditState * state.1354_7;
  struct STB_TexteditState * state.1355_9;
  struct STB_TexteditState * state.1356_10;
  int _11;
  struct STB_TexteditState * state.1357_13;
  struct STB_TexteditState * state.1358_14;
  int _15;
  struct STB_TexteditState * state.1359_17;

  <bb 2>:
  state.1352_3 = state;
  _4 = state.1352_3->select_start;
  state.1353_5 = state;
  _6 = state.1353_5->select_end;
  if (_4 != _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  state.1354_7 = state;
  ImGuiStb::stb_textedit_sortselection (state.1354_7);
  state.1355_9 = state;
  state.1356_10 = state;
  _11 = state.1356_10->select_start;
  state.1355_9->cursor = _11;
  state.1357_13 = state;
  state.1358_14 = state;
  _15 = state.1358_14->select_start;
  state.1357_13->select_end = _15;
  state.1359_17 = state;
  state.1359_17->has_preferred_x = 0;

  <bb 4>:
  return;

}



;; Function void ImGuiStb::stb_textedit_move_to_last(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL25stb_textedit_move_to_lastEP18ImGuiTextEditStatePNS_17STB_TexteditStateE, funcdef_no=1070, decl_uid=20090, cgraph_uid=969, symbol_order=980)

void ImGuiStb::stb_textedit_move_to_last(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (struct ImGuiTextEditState * str, struct STB_TexteditState * state)
{
  struct STB_TexteditState * state.1368;
  int D.37851;
  struct STB_TexteditState * state.1367;
  struct STB_TexteditState * state.1366;
  int D.37848;
  struct STB_TexteditState * state.1365;
  struct STB_TexteditState * state.1364;
  struct STB_TexteditState * state.1363;
  struct STB_TexteditState * state.1362;
  int D.37841;
  struct STB_TexteditState * state.1361;
  int D.37839;
  struct STB_TexteditState * state.1360;
  struct STB_TexteditState * state.1360_3;
  int _4;
  struct STB_TexteditState * state.1361_5;
  int _6;
  struct STB_TexteditState * state.1362_7;
  struct STB_TexteditState * state.1363_9;
  struct STB_TexteditState * state.1364_12;
  struct STB_TexteditState * state.1365_13;
  int _14;
  struct STB_TexteditState * state.1366_16;
  struct STB_TexteditState * state.1367_17;
  int _18;
  struct STB_TexteditState * state.1368_20;

  <bb 2>:
  state.1360_3 = state;
  _4 = state.1360_3->select_start;
  state.1361_5 = state;
  _6 = state.1361_5->select_end;
  if (_4 != _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  state.1362_7 = state;
  ImGuiStb::stb_textedit_sortselection (state.1362_7);
  state.1363_9 = state;
  ImGuiStb::stb_textedit_clamp (str_10(D), state.1363_9);
  state.1364_12 = state;
  state.1365_13 = state;
  _14 = state.1365_13->select_end;
  state.1364_12->cursor = _14;
  state.1366_16 = state;
  state.1367_17 = state;
  _18 = state.1367_17->select_end;
  state.1366_16->select_start = _18;
  state.1368_20 = state;
  state.1368_20->has_preferred_x = 0;

  <bb 4>:
  return;

}



;; Function void ImGuiStb::stb_textedit_prep_selection_at_cursor(ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL37stb_textedit_prep_selection_at_cursorEPNS_17STB_TexteditStateE, funcdef_no=1071, decl_uid=20093, cgraph_uid=970, symbol_order=981)

void ImGuiStb::stb_textedit_prep_selection_at_cursor(ImGuiStb::STB_TexteditState*) (struct STB_TexteditState * state)
{
  int D.37868;
  struct STB_TexteditState * state.1375;
  struct STB_TexteditState * state.1374;
  int D.37864;
  int D.37863;
  struct STB_TexteditState * state.1373;
  struct STB_TexteditState * state.1372;
  struct STB_TexteditState * state.1371;
  int D.37857;
  struct STB_TexteditState * state.1370;
  int D.37855;
  struct STB_TexteditState * state.1369;
  struct STB_TexteditState * state.1369_3;
  int _4;
  struct STB_TexteditState * state.1370_5;
  int _6;
  struct STB_TexteditState * state.1371_7;
  struct STB_TexteditState * state.1372_8;
  struct STB_TexteditState * state.1373_9;
  int _10;
  int _12;
  struct STB_TexteditState * state.1374_14;
  struct STB_TexteditState * state.1375_15;
  int _16;

  <bb 2>:
  state.1369_3 = state;
  _4 = state.1369_3->select_start;
  state.1370_5 = state;
  _6 = state.1370_5->select_end;
  if (_4 == _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  state.1371_7 = state;
  state.1372_8 = state;
  state.1373_9 = state;
  _10 = state.1373_9->cursor;
  state.1372_8->select_end = _10;
  _12 = state.1372_8->select_end;
  state.1371_7->select_start = _12;
  goto <bb 5>;

  <bb 4>:
  state.1374_14 = state;
  state.1375_15 = state;
  _16 = state.1375_15->select_end;
  state.1374_14->cursor = _16;

  <bb 5>:
  return;

}



;; Function int ImGuiStb::stb_textedit_cut(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL16stb_textedit_cutEP18ImGuiTextEditStatePNS_17STB_TexteditStateE, funcdef_no=1072, decl_uid=20097, cgraph_uid=971, symbol_order=982)

int ImGuiStb::stb_textedit_cut(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (struct ImGuiTextEditState * str, struct STB_TexteditState * state)
{
  int D.37877;
  struct STB_TexteditState * state.1379;
  struct STB_TexteditState * state.1378;
  int D.37872;
  struct STB_TexteditState * state.1377;
  int D.37870;
  struct STB_TexteditState * state.1376;
  int _1;
  struct STB_TexteditState * state.1376_4;
  int _5;
  struct STB_TexteditState * state.1377_6;
  int _7;
  struct STB_TexteditState * state.1378_8;
  struct STB_TexteditState * state.1379_11;
  int _13;
  int _14;

  <bb 2>:
  state.1376_4 = state;
  _5 = state.1376_4->select_start;
  state.1377_6 = state;
  _7 = state.1377_6->select_end;
  if (_5 != _7)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  state.1378_8 = state;
  ImGuiStb::stb_textedit_delete_selection (str_9(D), state.1378_8);
  state.1379_11 = state;
  state.1379_11->has_preferred_x = 0;
  _13 = 1;
  goto <bb 5> (<L2>);

  <bb 4>:
  _14 = 0;

  # _1 = PHI <_13(3), _14(4)>
<L2>:
  return _1;

}



;; Function int ImGuiStb::stb_textedit_paste(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, const ImWchar*, int) (_ZN8ImGuiStbL18stb_textedit_pasteEP18ImGuiTextEditStatePNS_17STB_TexteditStateEPKti, funcdef_no=1073, decl_uid=20103, cgraph_uid=972, symbol_order=983)

int ImGuiStb::stb_textedit_paste(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, const ImWchar*, int) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, const ImWchar * text, int len)
{
  bool D.37896;
  short int D.37893;
  unsigned short D.37892;
  unsigned short D.37891;
  short int D.37890;
  short int D.37887;
  int D.37886;
  int D.37885;
  int D.37884;
  int D.37883;
  int D.37880;
  bool retval.1380;
  int _1;
  int _9;
  bool _13;
  bool retval.1380_14;
  int _15;
  int _17;
  int _18;
  int _21;
  short int _22;
  short int _23;
  unsigned short _24;
  unsigned short _25;
  short int _26;
  int _28;

  <bb 2>:
  ImGuiStb::stb_textedit_clamp (str_5(D), state_6(D));
  ImGuiStb::stb_textedit_delete_selection (str_5(D), state_6(D));
  _9 = state_6(D)->cursor;
  _13 = ImGuiStb::STB_TEXTEDIT_INSERTCHARS (str_5(D), _9, text_10(D), len_11(D));
  retval.1380_14 = _13;
  if (retval.1380_14 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _15 = state_6(D)->cursor;
  ImGuiStb::stb_text_makeundo_insert (state_6(D), _15, len_11(D));
  _17 = state_6(D)->cursor;
  _18 = _17 + len_11(D);
  state_6(D)->cursor = _18;
  state_6(D)->has_preferred_x = 0;
  _21 = 1;
  goto <bb 7> (<L5>);

  <bb 4>:
  _22 = state_6(D)->undostate.undo_point;
  if (_22 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _23 = state_6(D)->undostate.undo_point;
  _24 = (unsigned short) _23;
  _25 = _24 + 65535;
  _26 = (short int) _25;
  state_6(D)->undostate.undo_point = _26;

  <bb 6>:
  _28 = 0;

  # _1 = PHI <_21(3), _28(6)>
<L5>:
  return _1;

}



;; Function void ImGuiStb::stb_textedit_key(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int) (_ZN8ImGuiStbL16stb_textedit_keyEP18ImGuiTextEditStatePNS_17STB_TexteditStateEi, funcdef_no=1074, decl_uid=20108, cgraph_uid=973, symbol_order=984)

void ImGuiStb::stb_textedit_key(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, int key)
{
  short unsigned int D.38385;
  short unsigned int D.38384;
  short unsigned int D.38383;
  short unsigned int D.38382;
  float D.38378;
  float D.38374;
  int D.38373;
  int D.38372;
  int D.38371;
  int D.38370;
  bool D.38366;
  bool D.38365;
  int n;
  int n;
  int n;
  float dx;
  float x;
  float goal_x;
  int sel;
  int i;
  struct StbTexteditRow row;
  struct StbFindState find;
  float dx;
  int start;
  float x;
  float goal_x;
  int sel;
  int i;
  struct StbTexteditRow row;
  struct StbFindState find;
  ImWchar ch;
  int c;
  struct STB_TexteditState * state.1577;
  int D.38363;
  struct STB_TexteditState * state.1576;
  struct STB_TexteditState * state.1575;
  int D.38360;
  int D.38359;
  struct STB_TexteditState * state.1574;
  short unsigned int STB_TEXTEDIT_NEWLINE.1573;
  short unsigned int D.38354;
  int D.38353;
  struct STB_TexteditState * state.1572;
  int D.38350;
  struct STB_TexteditState * state.1571;
  bool iftmp.1570;
  bool retval.1569;
  struct STB_TexteditState * state.1568;
  unsigned char D.38339;
  struct STB_TexteditState * state.1567;
  struct STB_TexteditState * state.1566;
  struct STB_TexteditState * state.1565;
  struct STB_TexteditState * state.1564;
  int D.38334;
  struct STB_TexteditState * state.1563;
  struct STB_TexteditState * state.1562;
  int D.38331;
  int D.38330;
  struct STB_TexteditState * state.1561;
  short unsigned int STB_TEXTEDIT_NEWLINE.1560;
  short unsigned int D.38325;
  int D.38324;
  int D.38323;
  struct STB_TexteditState * state.1559;
  int D.38320;
  struct STB_TexteditState * state.1558;
  bool iftmp.1557;
  bool retval.1556;
  struct STB_TexteditState * state.1555;
  unsigned char D.38309;
  struct STB_TexteditState * state.1554;
  struct STB_TexteditState * state.1553;
  struct STB_TexteditState * state.1552;
  struct STB_TexteditState * state.1551;
  int D.38304;
  int D.38303;
  struct STB_TexteditState * state.1550;
  short unsigned int STB_TEXTEDIT_NEWLINE.1549;
  short unsigned int D.38298;
  int D.38297;
  struct STB_TexteditState * state.1548;
  int D.38294;
  struct STB_TexteditState * state.1547;
  bool iftmp.1546;
  bool retval.1545;
  struct STB_TexteditState * state.1544;
  unsigned char D.38283;
  struct STB_TexteditState * state.1543;
  struct STB_TexteditState * state.1542;
  struct STB_TexteditState * state.1541;
  struct STB_TexteditState * state.1540;
  int D.38278;
  int D.38277;
  struct STB_TexteditState * state.1539;
  short unsigned int STB_TEXTEDIT_NEWLINE.1538;
  short unsigned int D.38272;
  int D.38271;
  int D.38270;
  struct STB_TexteditState * state.1537;
  int D.38267;
  struct STB_TexteditState * state.1536;
  bool iftmp.1535;
  bool retval.1534;
  struct STB_TexteditState * state.1533;
  unsigned char D.38256;
  struct STB_TexteditState * state.1532;
  struct STB_TexteditState * state.1531;
  struct STB_TexteditState * state.1530;
  struct STB_TexteditState * state.1529;
  int D.38251;
  int D.38250;
  struct STB_TexteditState * state.1528;
  struct STB_TexteditState * state.1527;
  struct STB_TexteditState * state.1526;
  struct STB_TexteditState * state.1525;
  int D.38245;
  struct STB_TexteditState * state.1524;
  struct STB_TexteditState * state.1523;
  struct STB_TexteditState * state.1522;
  struct STB_TexteditState * state.1521;
  int D.38240;
  struct STB_TexteditState * state.1520;
  struct STB_TexteditState * state.1519;
  int D.38237;
  struct STB_TexteditState * state.1518;
  struct STB_TexteditState * state.1517;
  int D.38234;
  int D.38233;
  struct STB_TexteditState * state.1516;
  struct STB_TexteditState * state.1515;
  struct STB_TexteditState * state.1514;
  struct STB_TexteditState * state.1513;
  int D.38227;
  int D.38226;
  struct STB_TexteditState * state.1512;
  struct STB_TexteditState * state.1511;
  int D.38223;
  int D.38222;
  struct STB_TexteditState * state.1510;
  int D.38218;
  struct STB_TexteditState * state.1509;
  struct STB_TexteditState * state.1508;
  struct STB_TexteditState * state.1507;
  int D.38211;
  struct STB_TexteditState * state.1506;
  int D.38209;
  struct STB_TexteditState * state.1505;
  struct STB_TexteditState * state.1504;
  struct STB_TexteditState * state.1503;
  int D.38204;
  struct STB_TexteditState * state.1502;
  int D.38200;
  struct STB_TexteditState * state.1501;
  struct STB_TexteditState * state.1500;
  int D.38194;
  struct STB_TexteditState * state.1499;
  int D.38192;
  struct STB_TexteditState * state.1498;
  int D.38188;
  struct STB_TexteditState * state.1497;
  struct STB_TexteditState * state.1496;
  struct STB_TexteditState * state.1495;
  struct STB_TexteditState * state.1494;
  struct STB_TexteditState * state.1493;
  int D.38180;
  int D.38179;
  struct STB_TexteditState * state.1492;
  int D.38173;
  int D.38171;
  int D.38169;
  struct STB_TexteditState * state.1491;
  int D.38167;
  struct STB_TexteditState * state.1490;
  struct STB_TexteditState * state.1489;
  unsigned char D.38161;
  struct STB_TexteditState * state.1488;
  float iftmp.1487;
  int D.38156;
  int D.38155;
  int D.38154;
  struct STB_TexteditState * state.1486;
  int D.38152;
  unsigned char D.38151;
  struct STB_TexteditState * state.1485;
  struct STB_TexteditState * state.1484;
  struct STB_TexteditState * state.1483;
  int D.38144;
  struct STB_TexteditState * state.1482;
  int D.38142;
  struct STB_TexteditState * state.1481;
  struct STB_TexteditState * state.1480;
  int D.38136;
  unsigned char D.38133;
  struct STB_TexteditState * state.1479;
  bool D.38131;
  int D.38130;
  int D.38127;
  struct STB_TexteditState * state.1478;
  struct STB_TexteditState * state.1477;
  struct STB_TexteditState * state.1476;
  struct STB_TexteditState * state.1475;
  struct STB_TexteditState * state.1474;
  int D.38119;
  int D.38118;
  struct STB_TexteditState * state.1473;
  int D.38111;
  int D.38109;
  struct STB_TexteditState * state.1472;
  struct STB_TexteditState * state.1471;
  int D.38106;
  int D.38105;
  struct STB_TexteditState * state.1470;
  unsigned char D.38100;
  struct STB_TexteditState * state.1469;
  float iftmp.1468;
  int D.38095;
  int D.38094;
  struct STB_TexteditState * state.1467;
  int D.38092;
  unsigned char D.38091;
  struct STB_TexteditState * state.1466;
  struct STB_TexteditState * state.1465;
  struct STB_TexteditState * state.1464;
  int D.38084;
  struct STB_TexteditState * state.1463;
  int D.38082;
  struct STB_TexteditState * state.1462;
  struct STB_TexteditState * state.1461;
  int D.38076;
  unsigned char D.38073;
  struct STB_TexteditState * state.1460;
  bool D.38071;
  int D.38070;
  struct STB_TexteditState * state.1459;
  int D.38068;
  struct STB_TexteditState * state.1458;
  struct STB_TexteditState * state.1457;
  struct STB_TexteditState * state.1456;
  int D.38064;
  int D.38063;
  struct STB_TexteditState * state.1455;
  struct STB_TexteditState * state.1454;
  struct STB_TexteditState * state.1453;
  int D.38059;
  struct STB_TexteditState * state.1452;
  struct STB_TexteditState * state.1451;
  int D.38056;
  int D.38055;
  struct STB_TexteditState * state.1450;
  struct STB_TexteditState * state.1449;
  struct STB_TexteditState * state.1448;
  int D.38048;
  struct STB_TexteditState * state.1447;
  int D.38046;
  struct STB_TexteditState * state.1446;
  struct STB_TexteditState * state.1445;
  int D.38043;
  int D.38042;
  struct STB_TexteditState * state.1444;
  struct STB_TexteditState * state.1443;
  struct STB_TexteditState * state.1442;
  int D.38035;
  struct STB_TexteditState * state.1441;
  int D.38033;
  struct STB_TexteditState * state.1440;
  struct STB_TexteditState * state.1439;
  int D.38030;
  struct STB_TexteditState * state.1438;
  struct STB_TexteditState * state.1437;
  int D.38027;
  int D.38026;
  struct STB_TexteditState * state.1436;
  struct STB_TexteditState * state.1435;
  struct STB_TexteditState * state.1434;
  int D.38019;
  struct STB_TexteditState * state.1433;
  int D.38017;
  struct STB_TexteditState * state.1432;
  struct STB_TexteditState * state.1431;
  int D.38014;
  int D.38013;
  struct STB_TexteditState * state.1430;
  struct STB_TexteditState * state.1429;
  struct STB_TexteditState * state.1428;
  int D.38006;
  struct STB_TexteditState * state.1427;
  int D.38004;
  struct STB_TexteditState * state.1426;
  struct STB_TexteditState * state.1425;
  int D.38001;
  struct STB_TexteditState * state.1424;
  struct STB_TexteditState * state.1423;
  int D.37997;
  int D.37996;
  struct STB_TexteditState * state.1422;
  int D.37992;
  struct STB_TexteditState * state.1421;
  struct STB_TexteditState * state.1420;
  struct STB_TexteditState * state.1419;
  struct STB_TexteditState * state.1418;
  struct STB_TexteditState * state.1417;
  int D.37986;
  int D.37985;
  struct STB_TexteditState * state.1416;
  struct STB_TexteditState * state.1415;
  int D.37979;
  struct STB_TexteditState * state.1414;
  int D.37977;
  struct STB_TexteditState * state.1413;
  struct STB_TexteditState * state.1412;
  int D.37973;
  int D.37972;
  struct STB_TexteditState * state.1411;
  int D.37968;
  struct STB_TexteditState * state.1410;
  struct STB_TexteditState * state.1409;
  int D.37962;
  struct STB_TexteditState * state.1408;
  int D.37960;
  struct STB_TexteditState * state.1407;
  struct STB_TexteditState * state.1406;
  struct STB_TexteditState * state.1405;
  struct STB_TexteditState * state.1404;
  struct STB_TexteditState * state.1403;
  struct STB_TexteditState * state.1402;
  int D.37951;
  int D.37950;
  struct STB_TexteditState * state.1401;
  struct STB_TexteditState * state.1400;
  int D.37947;
  struct STB_TexteditState * state.1399;
  int D.37943;
  struct STB_TexteditState * state.1398;
  bool retval.1397;
  struct STB_TexteditState * state.1396;
  struct STB_TexteditState * state.1395;
  int D.37936;
  int D.37935;
  struct STB_TexteditState * state.1394;
  int D.37931;
  struct STB_TexteditState * state.1393;
  bool retval.1392;
  int D.37928;
  struct STB_TexteditState * state.1391;
  struct STB_TexteditState * state.1390;
  int D.37925;
  struct STB_TexteditState * state.1389;
  int D.37920;
  int D.37919;
  struct STB_TexteditState * state.1388;
  int D.37916;
  struct STB_TexteditState * state.1387;
  int D.37914;
  struct STB_TexteditState * state.1386;
  unsigned char D.37911;
  struct STB_TexteditState * state.1385;
  bool iftmp.1384;
  bool retval.1383;
  unsigned char D.37903;
  struct STB_TexteditState * state.1382;
  short unsigned int ch.1381;
  bool iftmp.1384_6;
  float iftmp.1468_7;
  float iftmp.1487_8;
  bool iftmp.1535_9;
  bool iftmp.1546_10;
  bool iftmp.1557_11;
  bool iftmp.1570_12;
  int _59;
  bool _60;
  struct STB_TexteditState * state.1460_62;
  unsigned char _63;
  int _64;
  struct STB_TexteditState * state.1461_68;
  struct STB_TexteditState * state.1462_70;
  int _71;
  struct STB_TexteditState * state.1463_72;
  int _73;
  struct STB_TexteditState * state.1464_74;
  struct STB_TexteditState * state.1465_77;
  struct STB_TexteditState * state.1466_79;
  unsigned char _80;
  int _81;
  struct STB_TexteditState * state.1467_82;
  int _83;
  int _85;
  struct STB_TexteditState * state.1469_86;
  unsigned char _87;
  struct STB_TexteditState * state.1470_88;
  float iftmp.1468_89;
  float iftmp.1468_90;
  int _92;
  int _93;
  struct STB_TexteditState * state.1471_95;
  struct STB_TexteditState * state.1472_97;
  int _98;
  int _102;
  float _104;
  struct STB_TexteditState * state.1473_107;
  int _108;
  int _109;
  struct STB_TexteditState * state.1474_112;
  struct STB_TexteditState * state.1475_114;
  struct STB_TexteditState * state.1476_116;
  struct STB_TexteditState * state.1477_118;
  struct STB_TexteditState * state.1478_119;
  int _120;
  int _126;
  bool _127;
  struct STB_TexteditState * state.1479_129;
  unsigned char _130;
  int _131;
  struct STB_TexteditState * state.1480_135;
  struct STB_TexteditState * state.1481_137;
  int _138;
  struct STB_TexteditState * state.1482_139;
  int _140;
  struct STB_TexteditState * state.1483_141;
  struct STB_TexteditState * state.1484_143;
  struct STB_TexteditState * state.1485_145;
  unsigned char _146;
  int _147;
  struct STB_TexteditState * state.1486_148;
  int _149;
  int _151;
  int _152;
  struct STB_TexteditState * state.1488_153;
  unsigned char _154;
  struct STB_TexteditState * state.1489_155;
  float iftmp.1487_156;
  float iftmp.1487_157;
  struct STB_TexteditState * state.1490_159;
  int _160;
  struct STB_TexteditState * state.1491_162;
  int _163;
  int _167;
  int _168;
  float _170;
  struct STB_TexteditState * state.1492_173;
  int _174;
  int _175;
  struct STB_TexteditState * state.1493_178;
  struct STB_TexteditState * state.1494_180;
  struct STB_TexteditState * state.1495_182;
  struct STB_TexteditState * state.1496_184;
  struct STB_TexteditState * state.1497_185;
  int _186;
  short unsigned int ch.1381_194;
  struct STB_TexteditState * state.1382_196;
  unsigned char _197;
  struct STB_TexteditState * state.1385_199;
  unsigned char _200;
  struct STB_TexteditState * state.1386_201;
  int _202;
  struct STB_TexteditState * state.1387_203;
  int _204;
  struct STB_TexteditState * state.1388_205;
  int _206;
  int _208;
  bool iftmp.1384_209;
  bool iftmp.1384_210;
  bool retval.1383_211;
  struct STB_TexteditState * state.1389_212;
  int _213;
  struct STB_TexteditState * state.1390_214;
  struct STB_TexteditState * state.1391_216;
  int _217;
  struct STB_TexteditState * state.1393_219;
  int _220;
  bool _222;
  bool retval.1392_223;
  struct STB_TexteditState * state.1394_224;
  int _225;
  int _226;
  struct STB_TexteditState * state.1395_228;
  struct STB_TexteditState * state.1396_230;
  struct STB_TexteditState * state.1398_232;
  int _233;
  bool _235;
  bool retval.1397_236;
  struct STB_TexteditState * state.1399_237;
  int _238;
  struct STB_TexteditState * state.1400_239;
  struct STB_TexteditState * state.1401_241;
  int _242;
  int _243;
  struct STB_TexteditState * state.1402_245;
  struct STB_TexteditState * state.1403_249;
  struct STB_TexteditState * state.1404_251;
  struct STB_TexteditState * state.1405_253;
  struct STB_TexteditState * state.1406_255;
  struct STB_TexteditState * state.1407_257;
  int _258;
  struct STB_TexteditState * state.1408_259;
  int _260;
  struct STB_TexteditState * state.1409_261;
  struct STB_TexteditState * state.1410_263;
  int _264;
  struct STB_TexteditState * state.1411_265;
  int _266;
  int _267;
  struct STB_TexteditState * state.1412_269;
  struct STB_TexteditState * state.1413_271;
  int _272;
  struct STB_TexteditState * state.1414_273;
  int _274;
  struct STB_TexteditState * state.1415_275;
  struct STB_TexteditState * state.1416_277;
  int _278;
  int _279;
  struct STB_TexteditState * state.1417_281;
  struct STB_TexteditState * state.1418_283;
  struct STB_TexteditState * state.1419_285;
  struct STB_TexteditState * state.1420_287;
  struct STB_TexteditState * state.1421_289;
  int _290;
  struct STB_TexteditState * state.1422_291;
  int _292;
  int _293;
  struct STB_TexteditState * state.1423_295;
  struct STB_TexteditState * state.1424_296;
  int _297;
  struct STB_TexteditState * state.1425_299;
  struct STB_TexteditState * state.1426_301;
  int _302;
  struct STB_TexteditState * state.1427_303;
  int _304;
  struct STB_TexteditState * state.1428_305;
  struct STB_TexteditState * state.1429_307;
  struct STB_TexteditState * state.1430_308;
  int _309;
  int _311;
  int _312;
  struct STB_TexteditState * state.1431_314;
  struct STB_TexteditState * state.1432_316;
  int _317;
  struct STB_TexteditState * state.1433_318;
  int _319;
  struct STB_TexteditState * state.1434_320;
  struct STB_TexteditState * state.1435_322;
  struct STB_TexteditState * state.1436_323;
  int _324;
  int _326;
  int _327;
  struct STB_TexteditState * state.1437_329;
  struct STB_TexteditState * state.1438_330;
  int _331;
  struct STB_TexteditState * state.1439_333;
  struct STB_TexteditState * state.1440_335;
  int _336;
  struct STB_TexteditState * state.1441_337;
  int _338;
  struct STB_TexteditState * state.1442_339;
  struct STB_TexteditState * state.1443_341;
  struct STB_TexteditState * state.1444_342;
  int _343;
  int _345;
  int _346;
  struct STB_TexteditState * state.1445_348;
  struct STB_TexteditState * state.1446_350;
  int _351;
  struct STB_TexteditState * state.1447_352;
  int _353;
  struct STB_TexteditState * state.1448_354;
  struct STB_TexteditState * state.1449_356;
  struct STB_TexteditState * state.1450_357;
  int _358;
  int _360;
  int _361;
  struct STB_TexteditState * state.1451_363;
  struct STB_TexteditState * state.1452_364;
  int _365;
  struct STB_TexteditState * state.1453_367;
  struct STB_TexteditState * state.1454_369;
  struct STB_TexteditState * state.1455_371;
  int _372;
  int _373;
  struct STB_TexteditState * state.1456_375;
  struct STB_TexteditState * state.1457_377;
  struct STB_TexteditState * state.1458_378;
  int _379;
  struct STB_TexteditState * state.1459_381;
  struct STB_TexteditState * state.1498_383;
  int _384;
  struct STB_TexteditState * state.1499_385;
  int _386;
  struct STB_TexteditState * state.1500_387;
  struct STB_TexteditState * state.1501_391;
  int _392;
  struct STB_TexteditState * state.1502_393;
  int _394;
  struct STB_TexteditState * state.1503_395;
  struct STB_TexteditState * state.1504_397;
  struct STB_TexteditState * state.1505_399;
  int _400;
  struct STB_TexteditState * state.1506_401;
  int _402;
  struct STB_TexteditState * state.1507_403;
  struct STB_TexteditState * state.1508_405;
  struct STB_TexteditState * state.1509_407;
  int _408;
  struct STB_TexteditState * state.1510_409;
  int _410;
  int _411;
  struct STB_TexteditState * state.1511_412;
  struct STB_TexteditState * state.1512_414;
  int _415;
  int _416;
  struct STB_TexteditState * state.1513_418;
  struct STB_TexteditState * state.1514_420;
  struct STB_TexteditState * state.1515_421;
  struct STB_TexteditState * state.1516_422;
  int _424;
  int _426;
  struct STB_TexteditState * state.1517_428;
  struct STB_TexteditState * state.1518_430;
  int _432;
  struct STB_TexteditState * state.1519_434;
  struct STB_TexteditState * state.1520_435;
  int _437;
  struct STB_TexteditState * state.1521_439;
  struct STB_TexteditState * state.1522_441;
  struct STB_TexteditState * state.1523_443;
  struct STB_TexteditState * state.1524_444;
  int _446;
  struct STB_TexteditState * state.1525_448;
  struct STB_TexteditState * state.1526_450;
  struct STB_TexteditState * state.1527_452;
  struct STB_TexteditState * state.1528_453;
  int _455;
  int _457;
  struct STB_TexteditState * state.1529_459;
  struct STB_TexteditState * state.1530_461;
  struct STB_TexteditState * state.1531_463;
  struct STB_TexteditState * state.1532_465;
  unsigned char _466;
  struct STB_TexteditState * state.1533_467;
  struct STB_TexteditState * state.1536_469;
  int _470;
  struct STB_TexteditState * state.1537_471;
  int _472;
  int _473;
  short unsigned int _475;
  short unsigned int _476;
  short unsigned int STB_TEXTEDIT_NEWLINE.1538_477;
  bool iftmp.1535_478;
  bool iftmp.1535_479;
  bool retval.1534_480;
  struct STB_TexteditState * state.1539_481;
  int _482;
  int _483;
  struct STB_TexteditState * state.1540_485;
  struct STB_TexteditState * state.1541_489;
  struct STB_TexteditState * state.1542_491;
  struct STB_TexteditState * state.1543_493;
  unsigned char _494;
  struct STB_TexteditState * state.1544_495;
  struct STB_TexteditState * state.1547_497;
  int _498;
  struct STB_TexteditState * state.1548_499;
  int _500;
  short unsigned int _502;
  short unsigned int _503;
  short unsigned int STB_TEXTEDIT_NEWLINE.1549_504;
  bool iftmp.1546_505;
  bool iftmp.1546_506;
  bool retval.1545_507;
  struct STB_TexteditState * state.1550_508;
  int _509;
  int _510;
  struct STB_TexteditState * state.1551_512;
  struct STB_TexteditState * state.1552_514;
  struct STB_TexteditState * state.1553_516;
  struct STB_TexteditState * state.1554_518;
  unsigned char _519;
  struct STB_TexteditState * state.1555_520;
  struct STB_TexteditState * state.1558_522;
  int _523;
  struct STB_TexteditState * state.1559_524;
  int _525;
  int _526;
  short unsigned int _528;
  short unsigned int _529;
  short unsigned int STB_TEXTEDIT_NEWLINE.1560_530;
  bool iftmp.1557_531;
  bool iftmp.1557_532;
  bool retval.1556_533;
  struct STB_TexteditState * state.1561_534;
  int _535;
  int _536;
  struct STB_TexteditState * state.1562_538;
  struct STB_TexteditState * state.1563_539;
  int _540;
  struct STB_TexteditState * state.1564_542;
  struct STB_TexteditState * state.1565_546;
  struct STB_TexteditState * state.1566_548;
  struct STB_TexteditState * state.1567_550;
  unsigned char _551;
  struct STB_TexteditState * state.1568_552;
  struct STB_TexteditState * state.1571_554;
  int _555;
  struct STB_TexteditState * state.1572_556;
  int _557;
  short unsigned int _559;
  short unsigned int _560;
  short unsigned int STB_TEXTEDIT_NEWLINE.1573_561;
  bool iftmp.1570_562;
  bool iftmp.1570_563;
  bool retval.1569_564;
  struct STB_TexteditState * state.1574_565;
  int _566;
  int _567;
  struct STB_TexteditState * state.1575_569;
  struct STB_TexteditState * state.1576_570;
  int _571;
  struct STB_TexteditState * state.1577_573;

  # key_1 = PHI <key_57(D)(0), key_65(49), key_132(70)>
retry:
  switch (key_1) <default: <L1>, case 65536: <L27>, case 65537: <L34>, case 65538: <L87>, case 65539: <L59>, case 65540: <L135>, case 65541: <L146>, case 65542: <L131>, case 65543: <L132>, case 65544: <L115>, case 65545: <L123>, case 65546: <L25>, case 65547: <L26>, case 65548: <L42>, case 65549: <L50>, case 196608: <L38>, case 196609: <L58>, case 196610: <L87>, case 196611: <L59>, case 196612: <L157>, case 196613: <L168>, case 196614: <L133>, case 196615: <L134>, case 196616: <L115>, case 196617: <L123>, case 196620: <L46>, case 196621: <L54>>

<L1>:
  c_193 = ImGuiStb::STB_TEXTEDIT_KEYTOTEXT (key_1);
  if (c_193 > 0)
    goto <bb 4>;
  else
    goto <bb 18>;

  <bb 4>:
  ch.1381_194 = (short unsigned int) c_193;
  ch = ch.1381_194;
  if (c_193 == 10)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  state.1382_196 = state;
  _197 = state.1382_196->single_line;
  if (_197 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  ch ={v} {CLOBBER};
  goto <bb 140>;

  <bb 7>:
  state.1385_199 = state;
  _200 = state.1385_199->insert_mode;
  if (_200 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  state.1386_201 = state;
  _202 = state.1386_201->select_start;
  state.1387_203 = state;
  _204 = state.1387_203->select_end;
  if (_202 == _204)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  state.1388_205 = state;
  _206 = state.1388_205->cursor;
  _208 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_75(D));
  if (_206 < _208)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1384_209 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.1384_210 = 0;

  <bb 12>:
  # iftmp.1384_6 = PHI <iftmp.1384_209(10), iftmp.1384_210(11)>
  retval.1383_211 = iftmp.1384_6;
  if (retval.1383_211 != 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  state.1389_212 = state;
  _213 = state.1389_212->cursor;
  state.1390_214 = state;
  ImGuiStb::stb_text_makeundo_replace (str_75(D), state.1390_214, _213, 1, 1);
  state.1391_216 = state;
  _217 = state.1391_216->cursor;
  ImGuiStb::STB_TEXTEDIT_DELETECHARS (str_75(D), _217, 1);
  state.1393_219 = state;
  _220 = state.1393_219->cursor;
  _222 = ImGuiStb::STB_TEXTEDIT_INSERTCHARS (str_75(D), _220, &ch, 1);
  retval.1392_223 = _222;
  if (retval.1392_223 != 0)
    goto <bb 14>;
  else
    goto <bb 17>;

  <bb 14>:
  state.1394_224 = state;
  _225 = state.1394_224->cursor;
  _226 = _225 + 1;
  state.1394_224->cursor = _226;
  state.1395_228 = state;
  state.1395_228->has_preferred_x = 0;
  goto <bb 17>;

  <bb 15>:
  state.1396_230 = state;
  ImGuiStb::stb_textedit_delete_selection (str_75(D), state.1396_230);
  state.1398_232 = state;
  _233 = state.1398_232->cursor;
  _235 = ImGuiStb::STB_TEXTEDIT_INSERTCHARS (str_75(D), _233, &ch, 1);
  retval.1397_236 = _235;
  if (retval.1397_236 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  state.1399_237 = state;
  _238 = state.1399_237->cursor;
  state.1400_239 = state;
  ImGuiStb::stb_text_makeundo_insert (state.1400_239, _238, 1);
  state.1401_241 = state;
  _242 = state.1401_241->cursor;
  _243 = _242 + 1;
  state.1401_241->cursor = _243;
  state.1402_245 = state;
  state.1402_245->has_preferred_x = 0;

  <bb 17>:
  ch ={v} {CLOBBER};

  <bb 18>:
  goto <bb 140>;

<L25>:
  state.1403_249 = state;
  ImGuiStb::stb_text_undo (str_75(D), state.1403_249);
  state.1404_251 = state;
  state.1404_251->has_preferred_x = 0;
  goto <bb 140>;

<L26>:
  state.1405_253 = state;
  ImGuiStb::stb_text_redo (str_75(D), state.1405_253);
  state.1406_255 = state;
  state.1406_255->has_preferred_x = 0;
  goto <bb 140>;

<L27>:
  state.1407_257 = state;
  _258 = state.1407_257->select_start;
  state.1408_259 = state;
  _260 = state.1408_259->select_end;
  if (_258 != _260)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  state.1409_261 = state;
  ImGuiStb::stb_textedit_move_to_first (state.1409_261);
  goto <bb 25>;

  <bb 23>:
  state.1410_263 = state;
  _264 = state.1410_263->cursor;
  if (_264 > 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  state.1411_265 = state;
  _266 = state.1411_265->cursor;
  _267 = _266 + -1;
  state.1411_265->cursor = _267;

  <bb 25>:
  state.1412_269 = state;
  state.1412_269->has_preferred_x = 0;
  goto <bb 140>;

<L34>:
  state.1413_271 = state;
  _272 = state.1413_271->select_start;
  state.1414_273 = state;
  _274 = state.1414_273->select_end;
  if (_272 != _274)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  state.1415_275 = state;
  ImGuiStb::stb_textedit_move_to_last (str_75(D), state.1415_275);
  goto <bb 29>;

  <bb 28>:
  state.1416_277 = state;
  _278 = state.1416_277->cursor;
  _279 = _278 + 1;
  state.1416_277->cursor = _279;

  <bb 29>:
  state.1417_281 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1417_281);
  state.1418_283 = state;
  state.1418_283->has_preferred_x = 0;
  goto <bb 140>;

<L38>:
  state.1419_285 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1419_285);
  state.1420_287 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1420_287);
  state.1421_289 = state;
  _290 = state.1421_289->select_end;
  if (_290 > 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  state.1422_291 = state;
  _292 = state.1422_291->select_end;
  _293 = _292 + -1;
  state.1422_291->select_end = _293;

  <bb 32>:
  state.1423_295 = state;
  state.1424_296 = state;
  _297 = state.1424_296->select_end;
  state.1423_295->cursor = _297;
  state.1425_299 = state;
  state.1425_299->has_preferred_x = 0;
  goto <bb 140>;

<L42>:
  state.1426_301 = state;
  _302 = state.1426_301->select_start;
  state.1427_303 = state;
  _304 = state.1427_303->select_end;
  if (_302 != _304)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  state.1428_305 = state;
  ImGuiStb::stb_textedit_move_to_first (state.1428_305);
  goto <bb 36>;

  <bb 35>:
  state.1429_307 = state;
  state.1430_308 = state;
  _309 = state.1430_308->cursor;
  _311 = ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL (str_75(D), _309);
  _312 = _311;
  state.1429_307->cursor = _312;
  state.1431_314 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1431_314);

  <bb 36>:
  goto <bb 140>;

<L46>:
  state.1432_316 = state;
  _317 = state.1432_316->select_start;
  state.1433_318 = state;
  _319 = state.1433_318->select_end;
  if (_317 == _319)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  state.1434_320 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1434_320);

  <bb 39>:
  state.1435_322 = state;
  state.1436_323 = state;
  _324 = state.1436_323->cursor;
  _326 = ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL (str_75(D), _324);
  _327 = _326;
  state.1435_322->cursor = _327;
  state.1437_329 = state;
  state.1438_330 = state;
  _331 = state.1438_330->cursor;
  state.1437_329->select_end = _331;
  state.1439_333 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1439_333);
  goto <bb 140>;

<L50>:
  state.1440_335 = state;
  _336 = state.1440_335->select_start;
  state.1441_337 = state;
  _338 = state.1441_337->select_end;
  if (_336 != _338)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  state.1442_339 = state;
  ImGuiStb::stb_textedit_move_to_last (str_75(D), state.1442_339);
  goto <bb 43>;

  <bb 42>:
  state.1443_341 = state;
  state.1444_342 = state;
  _343 = state.1444_342->cursor;
  _345 = ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL (str_75(D), _343);
  _346 = _345;
  state.1443_341->cursor = _346;
  state.1445_348 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1445_348);

  <bb 43>:
  goto <bb 140>;

<L54>:
  state.1446_350 = state;
  _351 = state.1446_350->select_start;
  state.1447_352 = state;
  _353 = state.1447_352->select_end;
  if (_351 == _353)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  state.1448_354 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1448_354);

  <bb 46>:
  state.1449_356 = state;
  state.1450_357 = state;
  _358 = state.1450_357->cursor;
  _360 = ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL (str_75(D), _358);
  _361 = _360;
  state.1449_356->cursor = _361;
  state.1451_363 = state;
  state.1452_364 = state;
  _365 = state.1452_364->cursor;
  state.1451_363->select_end = _365;
  state.1453_367 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1453_367);
  goto <bb 140>;

<L58>:
  state.1454_369 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1454_369);
  state.1455_371 = state;
  _372 = state.1455_371->select_end;
  _373 = _372 + 1;
  state.1455_371->select_end = _373;
  state.1456_375 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1456_375);
  state.1457_377 = state;
  state.1458_378 = state;
  _379 = state.1458_378->select_end;
  state.1457_377->cursor = _379;
  state.1459_381 = state;
  state.1459_381->has_preferred_x = 0;
  goto <bb 140>;

<L59>:
  _59 = key_1 & 131072;
  _60 = _59 != 0;
  sel_61 = (int) _60;
  state.1460_62 = state;
  _63 = state.1460_62->single_line;
  if (_63 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  _64 = key_1 & 131072;
  key_65 = _64 | 65537;
  find ={v} {CLOBBER};
  row ={v} {CLOBBER};
  goto <bb 2> (retry);

  <bb 50>:
  if (sel_61 != 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  state.1461_68 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1461_68);
  goto <bb 54>;

  <bb 52>:
  state.1462_70 = state;
  _71 = state.1462_70->select_start;
  state.1463_72 = state;
  _73 = state.1463_72->select_end;
  if (_71 != _73)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  state.1464_74 = state;
  ImGuiStb::stb_textedit_move_to_last (str_75(D), state.1464_74);

  <bb 54>:
  state.1465_77 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1465_77);
  state.1466_79 = state;
  _80 = state.1466_79->single_line;
  _81 = (int) _80;
  state.1467_82 = state;
  _83 = state.1467_82->cursor;
  ImGuiStb::stb_textedit_find_charpos (&find, str_75(D), _83, _81);
  _85 = find.length;
  if (_85 != 0)
    goto <bb 55>;
  else
    goto <bb 68>;

  <bb 55>:
  state.1469_86 = state;
  _87 = state.1469_86->has_preferred_x;
  if (_87 != 0)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  state.1470_88 = state;
  iftmp.1468_89 = state.1470_88->preferred_x;
  goto <bb 58>;

  <bb 57>:
  iftmp.1468_90 = find.x;

  <bb 58>:
  # iftmp.1468_7 = PHI <iftmp.1468_89(56), iftmp.1468_90(57)>
  goal_x_91 = iftmp.1468_7;
  _92 = find.first_char;
  _93 = find.length;
  start_94 = _92 + _93;
  state.1471_95 = state;
  state.1471_95->cursor = start_94;
  state.1472_97 = state;
  _98 = state.1472_97->cursor;
  ImGuiStb::STB_TEXTEDIT_LAYOUTROW (&row, str_75(D), _98);
  x_100 = row.x0;
  i_101 = 0;

  <bb 59>:
  # i_2 = PHI <i_101(58), i_111(64)>
  # x_3 = PHI <x_100(58), x_106(64)>
  _102 = row.num_chars;
  if (_102 <= i_2)
    goto <bb 65>;
  else
    goto <bb 60>;

  <bb 60>:
  _104 = ImGuiStb::STB_TEXTEDIT_GETWIDTH (str_75(D), start_94, i_2);
  dx_105 = _104;
  if (dx_105 == -1.0e+0)
    goto <bb 61>;
  else
    goto <bb 62>;

  <bb 61>:
  goto <bb 65>;

  <bb 62>:
  x_106 = x_3 + dx_105;
  if (x_106 > goal_x_91)
    goto <bb 63>;
  else
    goto <bb 64>;

  <bb 63>:
  goto <bb 65>;

  <bb 64>:
  state.1473_107 = state;
  _108 = state.1473_107->cursor;
  _109 = _108 + 1;
  state.1473_107->cursor = _109;
  i_111 = i_2 + 1;
  goto <bb 59>;

  <bb 65>:
  state.1474_112 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1474_112);
  state.1475_114 = state;
  state.1475_114->has_preferred_x = 1;
  state.1476_116 = state;
  state.1476_116->preferred_x = goal_x_91;
  if (sel_61 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  state.1477_118 = state;
  state.1478_119 = state;
  _120 = state.1478_119->cursor;
  state.1477_118->select_end = _120;

  <bb 67>:

  <bb 68>:
  find ={v} {CLOBBER};
  row ={v} {CLOBBER};
  goto <bb 140>;

<L87>:
  _126 = key_1 & 131072;
  _127 = _126 != 0;
  sel_128 = (int) _127;
  state.1479_129 = state;
  _130 = state.1479_129->single_line;
  if (_130 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  _131 = key_1 & 131072;
  key_132 = _131 | 65536;
  find ={v} {CLOBBER};
  row ={v} {CLOBBER};
  goto <bb 2> (retry);

  <bb 71>:
  if (sel_128 != 0)
    goto <bb 72>;
  else
    goto <bb 73>;

  <bb 72>:
  state.1480_135 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1480_135);
  goto <bb 75>;

  <bb 73>:
  state.1481_137 = state;
  _138 = state.1481_137->select_start;
  state.1482_139 = state;
  _140 = state.1482_139->select_end;
  if (_138 != _140)
    goto <bb 74>;
  else
    goto <bb 75>;

  <bb 74>:
  state.1483_141 = state;
  ImGuiStb::stb_textedit_move_to_first (state.1483_141);

  <bb 75>:
  state.1484_143 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1484_143);
  state.1485_145 = state;
  _146 = state.1485_145->single_line;
  _147 = (int) _146;
  state.1486_148 = state;
  _149 = state.1486_148->cursor;
  ImGuiStb::stb_textedit_find_charpos (&find, str_75(D), _149, _147);
  _151 = find.prev_first;
  _152 = find.first_char;
  if (_151 != _152)
    goto <bb 76>;
  else
    goto <bb 89>;

  <bb 76>:
  state.1488_153 = state;
  _154 = state.1488_153->has_preferred_x;
  if (_154 != 0)
    goto <bb 77>;
  else
    goto <bb 78>;

  <bb 77>:
  state.1489_155 = state;
  iftmp.1487_156 = state.1489_155->preferred_x;
  goto <bb 79>;

  <bb 78>:
  iftmp.1487_157 = find.x;

  <bb 79>:
  # iftmp.1487_8 = PHI <iftmp.1487_156(77), iftmp.1487_157(78)>
  goal_x_158 = iftmp.1487_8;
  state.1490_159 = state;
  _160 = find.prev_first;
  state.1490_159->cursor = _160;
  state.1491_162 = state;
  _163 = state.1491_162->cursor;
  ImGuiStb::STB_TEXTEDIT_LAYOUTROW (&row, str_75(D), _163);
  x_165 = row.x0;
  i_166 = 0;

  <bb 80>:
  # i_4 = PHI <i_166(79), i_177(85)>
  # x_5 = PHI <x_165(79), x_172(85)>
  _167 = row.num_chars;
  if (_167 <= i_4)
    goto <bb 86>;
  else
    goto <bb 81>;

  <bb 81>:
  _168 = find.prev_first;
  _170 = ImGuiStb::STB_TEXTEDIT_GETWIDTH (str_75(D), _168, i_4);
  dx_171 = _170;
  if (dx_171 == -1.0e+0)
    goto <bb 82>;
  else
    goto <bb 83>;

  <bb 82>:
  goto <bb 86>;

  <bb 83>:
  x_172 = x_5 + dx_171;
  if (x_172 > goal_x_158)
    goto <bb 84>;
  else
    goto <bb 85>;

  <bb 84>:
  goto <bb 86>;

  <bb 85>:
  state.1492_173 = state;
  _174 = state.1492_173->cursor;
  _175 = _174 + 1;
  state.1492_173->cursor = _175;
  i_177 = i_4 + 1;
  goto <bb 80>;

  <bb 86>:
  state.1493_178 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1493_178);
  state.1494_180 = state;
  state.1494_180->has_preferred_x = 1;
  state.1495_182 = state;
  state.1495_182->preferred_x = goal_x_158;
  if (sel_128 != 0)
    goto <bb 87>;
  else
    goto <bb 88>;

  <bb 87>:
  state.1496_184 = state;
  state.1497_185 = state;
  _186 = state.1497_185->cursor;
  state.1496_184->select_end = _186;

  <bb 88>:

  <bb 89>:
  find ={v} {CLOBBER};
  row ={v} {CLOBBER};
  goto <bb 140>;

<L115>:
  state.1498_383 = state;
  _384 = state.1498_383->select_start;
  state.1499_385 = state;
  _386 = state.1499_385->select_end;
  if (_384 != _386)
    goto <bb 91>;
  else
    goto <bb 92>;

  <bb 91>:
  state.1500_387 = state;
  ImGuiStb::stb_textedit_delete_selection (str_75(D), state.1500_387);
  goto <bb 94>;

  <bb 92>:
  n_390 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_75(D));
  state.1501_391 = state;
  _392 = state.1501_391->cursor;
  if (_392 < n_390)
    goto <bb 93>;
  else
    goto <bb 94>;

  <bb 93>:
  state.1502_393 = state;
  _394 = state.1502_393->cursor;
  state.1503_395 = state;
  ImGuiStb::stb_textedit_delete (str_75(D), state.1503_395, _394, 1);

  <bb 94>:
  state.1504_397 = state;
  state.1504_397->has_preferred_x = 0;
  goto <bb 140>;

<L123>:
  state.1505_399 = state;
  _400 = state.1505_399->select_start;
  state.1506_401 = state;
  _402 = state.1506_401->select_end;
  if (_400 != _402)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  state.1507_403 = state;
  ImGuiStb::stb_textedit_delete_selection (str_75(D), state.1507_403);
  goto <bb 99>;

  <bb 97>:
  state.1508_405 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1508_405);
  state.1509_407 = state;
  _408 = state.1509_407->cursor;
  if (_408 > 0)
    goto <bb 98>;
  else
    goto <bb 99>;

  <bb 98>:
  state.1510_409 = state;
  _410 = state.1510_409->cursor;
  _411 = _410 + -1;
  state.1511_412 = state;
  ImGuiStb::stb_textedit_delete (str_75(D), state.1511_412, _411, 1);
  state.1512_414 = state;
  _415 = state.1512_414->cursor;
  _416 = _415 + -1;
  state.1512_414->cursor = _416;

  <bb 99>:
  state.1513_418 = state;
  state.1513_418->has_preferred_x = 0;
  goto <bb 140>;

<L131>:
  state.1514_420 = state;
  state.1515_421 = state;
  state.1516_422 = state;
  state.1516_422->select_end = 0;
  _424 = state.1516_422->select_end;
  state.1515_421->select_start = _424;
  _426 = state.1515_421->select_start;
  state.1514_420->cursor = _426;
  state.1517_428 = state;
  state.1517_428->has_preferred_x = 0;
  goto <bb 140>;

<L132>:
  state.1518_430 = state;
  _432 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_75(D));
  state.1518_430->cursor = _432;
  state.1519_434 = state;
  state.1520_435 = state;
  state.1520_435->select_end = 0;
  _437 = state.1520_435->select_end;
  state.1519_434->select_start = _437;
  state.1521_439 = state;
  state.1521_439->has_preferred_x = 0;
  goto <bb 140>;

<L133>:
  state.1522_441 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1522_441);
  state.1523_443 = state;
  state.1524_444 = state;
  state.1524_444->select_end = 0;
  _446 = state.1524_444->select_end;
  state.1523_443->cursor = _446;
  state.1525_448 = state;
  state.1525_448->has_preferred_x = 0;
  goto <bb 140>;

<L134>:
  state.1526_450 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1526_450);
  state.1527_452 = state;
  state.1528_453 = state;
  _455 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_75(D));
  state.1528_453->select_end = _455;
  _457 = state.1528_453->select_end;
  state.1527_452->cursor = _457;
  state.1529_459 = state;
  state.1529_459->has_preferred_x = 0;
  goto <bb 140>;

<L135>:
  state.1530_461 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1530_461);
  state.1531_463 = state;
  ImGuiStb::stb_textedit_move_to_first (state.1531_463);
  state.1532_465 = state;
  _466 = state.1532_465->single_line;
  if (_466 != 0)
    goto <bb 105>;
  else
    goto <bb 106>;

  <bb 105>:
  state.1533_467 = state;
  state.1533_467->cursor = 0;
  goto <bb 112>;

  <bb 106>:
  state.1536_469 = state;
  _470 = state.1536_469->cursor;
  if (_470 > 0)
    goto <bb 107>;
  else
    goto <bb 109>;

  <bb 107>:
  state.1537_471 = state;
  _472 = state.1537_471->cursor;
  _473 = _472 + -1;
  _475 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_75(D), _473);
  _476 = _475;
  STB_TEXTEDIT_NEWLINE.1538_477 = STB_TEXTEDIT_NEWLINE;
  if (_476 != STB_TEXTEDIT_NEWLINE.1538_477)
    goto <bb 108>;
  else
    goto <bb 109>;

  <bb 108>:
  iftmp.1535_478 = 1;
  goto <bb 110>;

  <bb 109>:
  iftmp.1535_479 = 0;

  <bb 110>:
  # iftmp.1535_9 = PHI <iftmp.1535_478(108), iftmp.1535_479(109)>
  retval.1534_480 = iftmp.1535_9;
  if (retval.1534_480 != 0)
    goto <bb 111>;
  else
    goto <bb 112>;

  <bb 111>:
  state.1539_481 = state;
  _482 = state.1539_481->cursor;
  _483 = _482 + -1;
  state.1539_481->cursor = _483;
  goto <bb 106>;

  <bb 112>:
  state.1540_485 = state;
  state.1540_485->has_preferred_x = 0;
  goto <bb 140>;

<L146>:
  n_488 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_75(D));
  state.1541_489 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1541_489);
  state.1542_491 = state;
  ImGuiStb::stb_textedit_move_to_first (state.1542_491);
  state.1543_493 = state;
  _494 = state.1543_493->single_line;
  if (_494 != 0)
    goto <bb 114>;
  else
    goto <bb 115>;

  <bb 114>:
  state.1544_495 = state;
  state.1544_495->cursor = n_488;
  goto <bb 121>;

  <bb 115>:
  state.1547_497 = state;
  _498 = state.1547_497->cursor;
  if (_498 < n_488)
    goto <bb 116>;
  else
    goto <bb 118>;

  <bb 116>:
  state.1548_499 = state;
  _500 = state.1548_499->cursor;
  _502 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_75(D), _500);
  _503 = _502;
  STB_TEXTEDIT_NEWLINE.1549_504 = STB_TEXTEDIT_NEWLINE;
  if (_503 != STB_TEXTEDIT_NEWLINE.1549_504)
    goto <bb 117>;
  else
    goto <bb 118>;

  <bb 117>:
  iftmp.1546_505 = 1;
  goto <bb 119>;

  <bb 118>:
  iftmp.1546_506 = 0;

  <bb 119>:
  # iftmp.1546_10 = PHI <iftmp.1546_505(117), iftmp.1546_506(118)>
  retval.1545_507 = iftmp.1546_10;
  if (retval.1545_507 != 0)
    goto <bb 120>;
  else
    goto <bb 121>;

  <bb 120>:
  state.1550_508 = state;
  _509 = state.1550_508->cursor;
  _510 = _509 + 1;
  state.1550_508->cursor = _510;
  goto <bb 115>;

  <bb 121>:
  state.1551_512 = state;
  state.1551_512->has_preferred_x = 0;
  goto <bb 140>;

<L157>:
  state.1552_514 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1552_514);
  state.1553_516 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1553_516);
  state.1554_518 = state;
  _519 = state.1554_518->single_line;
  if (_519 != 0)
    goto <bb 123>;
  else
    goto <bb 124>;

  <bb 123>:
  state.1555_520 = state;
  state.1555_520->cursor = 0;
  goto <bb 130>;

  <bb 124>:
  state.1558_522 = state;
  _523 = state.1558_522->cursor;
  if (_523 > 0)
    goto <bb 125>;
  else
    goto <bb 127>;

  <bb 125>:
  state.1559_524 = state;
  _525 = state.1559_524->cursor;
  _526 = _525 + -1;
  _528 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_75(D), _526);
  _529 = _528;
  STB_TEXTEDIT_NEWLINE.1560_530 = STB_TEXTEDIT_NEWLINE;
  if (_529 != STB_TEXTEDIT_NEWLINE.1560_530)
    goto <bb 126>;
  else
    goto <bb 127>;

  <bb 126>:
  iftmp.1557_531 = 1;
  goto <bb 128>;

  <bb 127>:
  iftmp.1557_532 = 0;

  <bb 128>:
  # iftmp.1557_11 = PHI <iftmp.1557_531(126), iftmp.1557_532(127)>
  retval.1556_533 = iftmp.1557_11;
  if (retval.1556_533 != 0)
    goto <bb 129>;
  else
    goto <bb 130>;

  <bb 129>:
  state.1561_534 = state;
  _535 = state.1561_534->cursor;
  _536 = _535 + -1;
  state.1561_534->cursor = _536;
  goto <bb 124>;

  <bb 130>:
  state.1562_538 = state;
  state.1563_539 = state;
  _540 = state.1563_539->cursor;
  state.1562_538->select_end = _540;
  state.1564_542 = state;
  state.1564_542->has_preferred_x = 0;
  goto <bb 140>;

<L168>:
  n_545 = ImGuiStb::STB_TEXTEDIT_STRINGLEN (str_75(D));
  state.1565_546 = state;
  ImGuiStb::stb_textedit_clamp (str_75(D), state.1565_546);
  state.1566_548 = state;
  ImGuiStb::stb_textedit_prep_selection_at_cursor (state.1566_548);
  state.1567_550 = state;
  _551 = state.1567_550->single_line;
  if (_551 != 0)
    goto <bb 132>;
  else
    goto <bb 133>;

  <bb 132>:
  state.1568_552 = state;
  state.1568_552->cursor = n_545;
  goto <bb 139>;

  <bb 133>:
  state.1571_554 = state;
  _555 = state.1571_554->cursor;
  if (_555 < n_545)
    goto <bb 134>;
  else
    goto <bb 136>;

  <bb 134>:
  state.1572_556 = state;
  _557 = state.1572_556->cursor;
  _559 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_75(D), _557);
  _560 = _559;
  STB_TEXTEDIT_NEWLINE.1573_561 = STB_TEXTEDIT_NEWLINE;
  if (_560 != STB_TEXTEDIT_NEWLINE.1573_561)
    goto <bb 135>;
  else
    goto <bb 136>;

  <bb 135>:
  iftmp.1570_562 = 1;
  goto <bb 137>;

  <bb 136>:
  iftmp.1570_563 = 0;

  <bb 137>:
  # iftmp.1570_12 = PHI <iftmp.1570_562(135), iftmp.1570_563(136)>
  retval.1569_564 = iftmp.1570_12;
  if (retval.1569_564 != 0)
    goto <bb 138>;
  else
    goto <bb 139>;

  <bb 138>:
  state.1574_565 = state;
  _566 = state.1574_565->cursor;
  _567 = _566 + 1;
  state.1574_565->cursor = _567;
  goto <bb 133>;

  <bb 139>:
  state.1575_569 = state;
  state.1576_570 = state;
  _571 = state.1576_570->cursor;
  state.1575_569->select_end = _571;
  state.1577_573 = state;
  state.1577_573->has_preferred_x = 0;

  <bb 140>:
  return;

}



;; Function void ImGuiStb::stb_textedit_flush_redo(ImGuiStb::StbUndoState*) (_ZN8ImGuiStbL23stb_textedit_flush_redoEPNS_12StbUndoStateE, funcdef_no=1075, decl_uid=20205, cgraph_uid=974, symbol_order=985)

void ImGuiStb::stb_textedit_flush_redo(ImGuiStb::StbUndoState*) (struct StbUndoState * state)
{
  <bb 2>:
  state_2(D)->redo_point = 99;
  state_2(D)->redo_char_point = 999;
  return;

}



;; Function void ImGuiStb::stb_textedit_discard_undo(ImGuiStb::StbUndoState*) (_ZN8ImGuiStbL25stb_textedit_discard_undoEPNS_12StbUndoStateE, funcdef_no=1076, decl_uid=20208, cgraph_uid=975, symbol_order=986)

void ImGuiStb::stb_textedit_discard_undo(ImGuiStb::StbUndoState*) (struct StbUndoState * state)
{
  int i;
  int n;
  struct StbUndoRecord[99] * D.38429;
  const void * D.38428;
  struct StbUndoRecord[99] * D.38427;
  long unsigned int D.38426;
  long unsigned int D.38425;
  short int D.38424;
  short int D.38423;
  unsigned short D.38422;
  unsigned short D.38421;
  short int D.38420;
  short int D.38417;
  unsigned short D.38416;
  unsigned short D.38415;
  unsigned short D.38414;
  short int D.38413;
  short int D.38410;
  int D.38408;
  short int D.38407;
  ImWchar[999] * D.38405;
  const void * D.38404;
  long unsigned int D.38403;
  long unsigned int D.38402;
  ImWchar[999] * D.38401;
  long unsigned int D.38400;
  long unsigned int D.38399;
  short int D.38398;
  short int D.38397;
  unsigned short D.38396;
  unsigned short D.38395;
  unsigned short D.38394;
  short int D.38393;
  short int D.38392;
  short int D.38389;
  short int D.38386;
  short int _8;
  short int _9;
  short int _10;
  short int _12;
  unsigned short _13;
  unsigned short _14;
  unsigned short _15;
  short int _16;
  short int _18;
  long unsigned int _19;
  long unsigned int _20;
  ImWchar[999] * _21;
  long unsigned int _22;
  long unsigned int _23;
  const void * _24;
  ImWchar[999] * _25;
  short int _28;
  int _29;
  short int _30;
  short int _31;
  unsigned short _32;
  unsigned short _33;
  unsigned short _34;
  short int _35;
  short int _38;
  unsigned short _39;
  unsigned short _40;
  short int _41;
  short int _43;
  long unsigned int _44;
  long unsigned int _45;
  struct StbUndoRecord[99] * _46;
  const void * _47;
  struct StbUndoRecord[99] * _48;

  <bb 2>:
  _8 = state_7(D)->undo_point;
  if (_8 > 0)
    goto <bb 3>;
  else
    goto <bb 11>;

  <bb 3>:
  _9 = state_7(D)->undo_rec[0].char_storage;
  if (_9 >= 0)
    goto <bb 4>;
  else
    goto <bb 10>;

  <bb 4>:
  _10 = state_7(D)->undo_rec[0].insert_length;
  n_11 = (int) _10;
  _12 = state_7(D)->undo_char_point;
  _13 = (unsigned short) _12;
  _14 = (unsigned short) n_11;
  _15 = _13 - _14;
  _16 = (short int) _15;
  state_7(D)->undo_char_point = _16;
  _18 = state_7(D)->undo_char_point;
  _19 = (long unsigned int) _18;
  _20 = _19 * 2;
  _21 = &state_7(D)->undo_char;
  _22 = (long unsigned int) n_11;
  _23 = _22 * 2;
  _24 = _21 + _23;
  _25 = &state_7(D)->undo_char;
  memmove (_25, _24, _20);
  i_27 = 0;

  <bb 5>:
  # i_1 = PHI <i_27(4), i_37(8)>
  _28 = state_7(D)->undo_point;
  _29 = (int) _28;
  if (_29 <= i_1)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 6>:
  _30 = state_7(D)->undo_rec[i_1].char_storage;
  if (_30 >= 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _31 = state_7(D)->undo_rec[i_1].char_storage;
  _32 = (unsigned short) _31;
  _33 = (unsigned short) n_11;
  _34 = _32 - _33;
  _35 = (short int) _34;
  state_7(D)->undo_rec[i_1].char_storage = _35;

  <bb 8>:
  i_37 = i_1 + 1;
  goto <bb 5>;

  <bb 9>:

  <bb 10>:
  _38 = state_7(D)->undo_point;
  _39 = (unsigned short) _38;
  _40 = _39 + 65535;
  _41 = (short int) _40;
  state_7(D)->undo_point = _41;
  _43 = state_7(D)->undo_point;
  _44 = (long unsigned int) _43;
  _45 = _44 * 12;
  _46 = &state_7(D)->undo_rec;
  _47 = _46 + 12;
  _48 = &state_7(D)->undo_rec;
  memmove (_48, _47, _45);

  <bb 11>:
  return;

}



;; Function void ImGuiStb::stb_textedit_discard_redo(ImGuiStb::StbUndoState*) (_ZN8ImGuiStbL25stb_textedit_discard_redoEPNS_12StbUndoStateE, funcdef_no=1077, decl_uid=20215, cgraph_uid=976, symbol_order=987)

void ImGuiStb::stb_textedit_discard_redo(ImGuiStb::StbUndoState*) (struct StbUndoState * state)
{
  int i;
  int n;
  int k;
  short int D.38493;
  unsigned short D.38492;
  unsigned short D.38491;
  short int D.38490;
  void * D.38489;
  long unsigned int D.38488;
  long unsigned int D.38487;
  short int D.38486;
  struct StbUndoRecord[99] * D.38485;
  const void * D.38484;
  sizetype D.38483;
  long unsigned int D.38482;
  long unsigned int D.38481;
  short int D.38480;
  struct StbUndoRecord[99] * D.38479;
  long unsigned int D.38478;
  long unsigned int D.38477;
  int D.38476;
  int D.38475;
  short int D.38474;
  short int D.38471;
  unsigned short D.38470;
  unsigned short D.38469;
  unsigned short D.38468;
  short int D.38467;
  short int D.38464;
  short int D.38461;
  void * D.38460;
  long unsigned int D.38459;
  long unsigned int D.38458;
  short int D.38457;
  ImWchar[999] * D.38456;
  const void * D.38455;
  sizetype D.38454;
  sizetype D.38453;
  sizetype D.38452;
  sizetype D.38451;
  short int D.38450;
  ImWchar[999] * D.38449;
  long unsigned int D.38448;
  long unsigned int D.38447;
  int D.38446;
  int D.38445;
  short int D.38444;
  short int D.38443;
  unsigned short D.38442;
  unsigned short D.38441;
  unsigned short D.38440;
  short int D.38439;
  short int D.38438;
  short int D.38435;
  int D.38432;
  short int D.38431;
  short int _9;
  int _10;
  short int _11;
  short int _12;
  short int _14;
  unsigned short _15;
  unsigned short _16;
  unsigned short _17;
  short int _18;
  short int _20;
  int _21;
  int _22;
  long unsigned int _23;
  long unsigned int _24;
  ImWchar[999] * _25;
  short int _26;
  sizetype _27;
  sizetype _28;
  sizetype _29;
  sizetype _30;
  const void * _31;
  ImWchar[999] * _32;
  short int _33;
  long unsigned int _34;
  long unsigned int _35;
  void * _36;
  short int _38;
  short int _40;
  short int _41;
  unsigned short _42;
  unsigned short _43;
  unsigned short _44;
  short int _45;
  short int _48;
  int _49;
  int _50;
  long unsigned int _51;
  long unsigned int _52;
  struct StbUndoRecord[99] * _53;
  short int _54;
  long unsigned int _55;
  long unsigned int _56;
  sizetype _57;
  const void * _58;
  struct StbUndoRecord[99] * _59;
  short int _60;
  long unsigned int _61;
  long unsigned int _62;
  void * _63;
  short int _65;
  unsigned short _66;
  unsigned short _67;
  short int _68;

  <bb 2>:
  k_6 = 98;
  _9 = state_8(D)->redo_point;
  _10 = (int) _9;
  if (_10 <= k_6)
    goto <bb 3>;
  else
    goto <bb 11>;

  <bb 3>:
  _11 = state_8(D)->undo_rec[k_6].char_storage;
  if (_11 >= 0)
    goto <bb 4>;
  else
    goto <bb 10>;

  <bb 4>:
  _12 = state_8(D)->undo_rec[k_6].insert_length;
  n_13 = (int) _12;
  _14 = state_8(D)->redo_char_point;
  _15 = (unsigned short) _14;
  _16 = (unsigned short) n_13;
  _17 = _15 + _16;
  _18 = (short int) _17;
  state_8(D)->redo_char_point = _18;
  _20 = state_8(D)->redo_char_point;
  _21 = (int) _20;
  _22 = 999 - _21;
  _23 = (long unsigned int) _22;
  _24 = _23 * 2;
  _25 = &state_8(D)->undo_char;
  _26 = state_8(D)->redo_char_point;
  _27 = (sizetype) _26;
  _28 = (sizetype) n_13;
  _29 = _27 - _28;
  _30 = _29 * 2;
  _31 = _25 + _30;
  _32 = &state_8(D)->undo_char;
  _33 = state_8(D)->redo_char_point;
  _34 = (long unsigned int) _33;
  _35 = _34 * 2;
  _36 = _32 + _35;
  memmove (_36, _31, _24);
  _38 = state_8(D)->redo_point;
  i_39 = (int) _38;

  <bb 5>:
  # i_1 = PHI <i_39(4), i_47(8)>
  if (i_1 >= k_6)
    goto <bb 9>;
  else
    goto <bb 6>;

  <bb 6>:
  _40 = state_8(D)->undo_rec[i_1].char_storage;
  if (_40 >= 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _41 = state_8(D)->undo_rec[i_1].char_storage;
  _42 = (unsigned short) _41;
  _43 = (unsigned short) n_13;
  _44 = _42 + _43;
  _45 = (short int) _44;
  state_8(D)->undo_rec[i_1].char_storage = _45;

  <bb 8>:
  i_47 = i_1 + 1;
  goto <bb 5>;

  <bb 9>:

  <bb 10>:
  _48 = state_8(D)->redo_point;
  _49 = (int) _48;
  _50 = 99 - _49;
  _51 = (long unsigned int) _50;
  _52 = _51 * 12;
  _53 = &state_8(D)->undo_rec;
  _54 = state_8(D)->redo_point;
  _55 = (long unsigned int) _54;
  _56 = _55 * 12;
  _57 = _56 + 18446744073709551604;
  _58 = _53 + _57;
  _59 = &state_8(D)->undo_rec;
  _60 = state_8(D)->redo_point;
  _61 = (long unsigned int) _60;
  _62 = _61 * 12;
  _63 = _59 + _62;
  memmove (_63, _58, _52);
  _65 = state_8(D)->redo_point;
  _66 = (unsigned short) _65;
  _67 = _66 + 1;
  _68 = (short int) _67;
  state_8(D)->redo_point = _68;

  <bb 11>:
  return;

}



;; Function ImGuiStb::StbUndoRecord* ImGuiStb::stb_text_create_undo_record(ImGuiStb::StbUndoState*, int) (_ZN8ImGuiStbL27stb_text_create_undo_recordEPNS_12StbUndoStateEi, funcdef_no=1078, decl_uid=20224, cgraph_uid=977, symbol_order=988)

ImGuiStb::StbUndoRecord* ImGuiStb::stb_text_create_undo_record(ImGuiStb::StbUndoState*, int) (struct StbUndoState * state, int numchars)
{
  int D.38512;
  short int D.38511;
  unsigned short D.38510;
  unsigned short D.38509;
  short int D.38508;
  short int D.38507;
  int D.38505;
  int D.38504;
  short int D.38503;
  struct StbUndoRecord * D.38501;
  short int D.38495;
  struct StbUndoRecord * _1;
  short int _8;
  struct StbUndoRecord * _13;
  short int _14;
  int _15;
  int _16;
  short int _18;
  short int _19;
  unsigned short _20;
  unsigned short _21;
  short int _22;
  int _24;
  struct StbUndoRecord * _25;

  <bb 2>:
  ImGuiStb::stb_textedit_flush_redo (state_6(D));
  _8 = state_6(D)->undo_point;
  if (_8 == 99)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImGuiStb::stb_textedit_discard_undo (state_6(D));

  <bb 4>:
  if (numchars_10(D) > 999)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  state_6(D)->undo_point = 0;
  state_6(D)->undo_char_point = 0;
  _13 = 0B;
  goto <bb 9> (<L8>);

  <bb 6>:
  _14 = state_6(D)->undo_char_point;
  _15 = (int) _14;
  _16 = _15 + numchars_10(D);
  if (_16 <= 999)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  ImGuiStb::stb_textedit_discard_undo (state_6(D));
  goto <bb 6>;

  <bb 8>:
  _18 = state_6(D)->undo_point;
  _19 = _18;
  _20 = (unsigned short) _19;
  _21 = _20 + 1;
  _22 = (short int) _21;
  state_6(D)->undo_point = _22;
  _24 = (int) _19;
  _25 = &state_6(D)->undo_rec[_24];

  # _1 = PHI <_13(5), _25(8)>
<L8>:
  return _1;

}



;; Function ImWchar* ImGuiStb::stb_text_createundo(ImGuiStb::StbUndoState*, int, int, int) (_ZN8ImGuiStbL19stb_text_createundoEPNS_12StbUndoStateEiii, funcdef_no=1079, decl_uid=20232, cgraph_uid=978, symbol_order=989)

ImWchar* ImGuiStb::stb_text_createundo(ImGuiStb::StbUndoState*, int, int, int) (struct StbUndoState * state, int pos, int insert_len, int delete_len)
{
  struct StbUndoRecord * r;
  int D.38528;
  short int D.38527;
  short int D.38526;
  unsigned short D.38525;
  unsigned short D.38524;
  unsigned short D.38523;
  short int D.38522;
  short int D.38521;
  short int D.38518;
  short int D.38517;
  ImWchar * D.38516;
  ImWchar * _1;
  ImWchar * _8;
  short int _11;
  short int _14;
  ImWchar * _17;
  short int _18;
  short int _20;
  unsigned short _21;
  unsigned short _22;
  unsigned short _23;
  short int _24;
  short int _26;
  int _27;
  ImWchar * _28;

  <bb 2>:
  r_7 = ImGuiStb::stb_text_create_undo_record (state_4(D), insert_len_5(D));
  if (r_7 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = 0B;
  goto <bb 7> (<L4>);

  <bb 4>:
  r_7->where = pos_9(D);
  _11 = (short int) insert_len_5(D);
  r_7->insert_length = _11;
  _14 = (short int) delete_len_13(D);
  r_7->delete_length = _14;
  if (insert_len_5(D) == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  r_7->char_storage = -1;
  _17 = 0B;
  goto <bb 7> (<L4>);

  <bb 6>:
  _18 = state_4(D)->undo_char_point;
  r_7->char_storage = _18;
  _20 = state_4(D)->undo_char_point;
  _21 = (unsigned short) _20;
  _22 = (unsigned short) insert_len_5(D);
  _23 = _21 + _22;
  _24 = (short int) _23;
  state_4(D)->undo_char_point = _24;
  _26 = r_7->char_storage;
  _27 = (int) _26;
  _28 = &state_4(D)->undo_char[_27];

  # _1 = PHI <_8(3), _17(5), _28(6)>
<L4>:
  return _1;

}



;; Function void ImGuiStb::stb_text_undo(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL13stb_text_undoEP18ImGuiTextEditStatePNS_17STB_TexteditStateE, funcdef_no=1080, decl_uid=20020, cgraph_uid=979, symbol_order=990)

void ImGuiStb::stb_text_undo(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (struct ImGuiTextEditState * str, struct STB_TexteditState * state)
{
  short unsigned int D.38625;
  int i;
  struct StbUndoRecord * r;
  struct StbUndoRecord u;
  struct StbUndoState * s;
  short int D.38623;
  unsigned short D.38622;
  unsigned short D.38621;
  short int D.38620;
  short int D.38619;
  short int D.38618;
  unsigned short D.38617;
  unsigned short D.38616;
  short int D.38615;
  short int D.38614;
  int D.38613;
  int D.38612;
  short int D.38611;
  int D.38610;
  short int D.38608;
  unsigned short D.38607;
  unsigned short D.38606;
  short int D.38605;
  unsigned short D.38604;
  short int D.38603;
  int D.38602;
  ImWchar * D.38601;
  int D.38600;
  short int D.38599;
  int D.38598;
  short int D.38597;
  short int D.38594;
  int D.38592;
  int D.38591;
  short int D.38590;
  short unsigned int D.38589;
  int D.38588;
  int D.38587;
  int D.38586;
  int D.38585;
  short int D.38584;
  int D.38582;
  short int D.38581;
  short int D.38579;
  unsigned short D.38578;
  unsigned short D.38577;
  short int D.38576;
  unsigned short D.38575;
  short int D.38574;
  short int D.38573;
  unsigned short D.38572;
  unsigned short D.38571;
  short int D.38570;
  unsigned short D.38569;
  short int D.38568;
  int D.38567;
  int D.38566;
  short int D.38565;
  short int D.38562;
  int D.38560;
  short int D.38559;
  int D.38558;
  int D.38557;
  short int D.38556;
  int D.38555;
  short int D.38554;
  int D.38549;
  int D.38548;
  short int D.38547;
  int D.38546;
  short int D.38545;
  short int D.38542;
  int D.38541;
  short int D.38540;
  short int D.38539;
  int D.38538;
  int D.38537;
  short int D.38536;
  int D.38535;
  int D.38534;
  short int D.38533;
  short int D.38530;
  short int _13;
  short int _14;
  int _15;
  int _16;
  short int _18;
  int _19;
  int _20;
  short int _23;
  short int _25;
  int _27;
  short int _29;
  short int _30;
  int _31;
  short int _32;
  int _33;
  int _34;
  short int _36;
  int _37;
  short int _38;
  int _39;
  int _40;
  short int _41;
  int _42;
  short int _44;
  short int _45;
  int _46;
  int _47;
  short int _49;
  unsigned short _50;
  short int _51;
  unsigned short _52;
  unsigned short _53;
  short int _54;
  short int _56;
  unsigned short _57;
  short int _58;
  unsigned short _59;
  unsigned short _60;
  short int _61;
  short int _64;
  int _65;
  short int _66;
  int _67;
  int _68;
  int _69;
  int _70;
  short unsigned int _73;
  short unsigned int _74;
  short int _77;
  int _78;
  int _79;
  short int _81;
  short int _82;
  int _83;
  short int _84;
  int _85;
  ImWchar * _86;
  int _87;
  short int _89;
  unsigned short _90;
  short int _91;
  unsigned short _92;
  unsigned short _93;
  short int _94;
  int _96;
  short int _97;
  int _98;
  int _99;
  short int _101;
  short int _102;
  unsigned short _103;
  unsigned short _104;
  short int _105;
  short int _107;
  short int _108;
  unsigned short _109;
  unsigned short _110;
  short int _111;

  <bb 2>:
  s_11 = &state_10(D)->undostate;
  _13 = s_11->undo_point;
  if (_13 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 18>;

  <bb 4>:
  _14 = s_11->undo_point;
  _15 = (int) _14;
  _16 = _15 + -1;
  u = s_11->undo_rec[_16];
  _18 = s_11->redo_point;
  _19 = (int) _18;
  _20 = _19 + -1;
  r_21 = &s_11->undo_rec[_20];
  r_21->char_storage = -1;
  _23 = u.delete_length;
  r_21->insert_length = _23;
  _25 = u.insert_length;
  r_21->delete_length = _25;
  _27 = u.where;
  r_21->where = _27;
  _29 = u.delete_length;
  if (_29 != 0)
    goto <bb 5>;
  else
    goto <bb 15>;

  <bb 5>:
  _30 = s_11->undo_char_point;
  _31 = (int) _30;
  _32 = u.delete_length;
  _33 = (int) _32;
  _34 = _31 + _33;
  if (_34 > 998)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  r_21->insert_length = 0;
  goto <bb 14>;

  <bb 7>:
  _36 = s_11->undo_char_point;
  _37 = (int) _36;
  _38 = u.delete_length;
  _39 = (int) _38;
  _40 = _37 + _39;
  _41 = s_11->redo_char_point;
  _42 = (int) _41;
  if (_40 <= _42)
    goto <bb 11>;
  else
    goto <bb 8>;

  <bb 8>:
  ImGuiStb::stb_textedit_discard_redo (s_11);
  _44 = s_11->redo_point;
  if (_44 == 99)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  goto <bb 18>;

  <bb 10>:
  goto <bb 7>;

  <bb 11>:
  _45 = s_11->redo_point;
  _46 = (int) _45;
  _47 = _46 + -1;
  r_48 = &s_11->undo_rec[_47];
  _49 = s_11->redo_char_point;
  _50 = (unsigned short) _49;
  _51 = u.delete_length;
  _52 = (unsigned short) _51;
  _53 = _50 - _52;
  _54 = (short int) _53;
  r_48->char_storage = _54;
  _56 = s_11->redo_char_point;
  _57 = (unsigned short) _56;
  _58 = u.delete_length;
  _59 = (unsigned short) _58;
  _60 = _57 - _59;
  _61 = (short int) _60;
  s_11->redo_char_point = _61;
  i_63 = 0;

  <bb 12>:
  # i_1 = PHI <i_63(11), i_76(13)>
  _64 = u.delete_length;
  _65 = (int) _64;
  if (_65 <= i_1)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  _66 = r_48->char_storage;
  _67 = (int) _66;
  _68 = _67 + i_1;
  _69 = u.where;
  _70 = _69 + i_1;
  _73 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_71(D), _70);
  _74 = _73;
  s_11->undo_char[_68] = _74;
  i_76 = i_1 + 1;
  goto <bb 12>;

  <bb 14>:
  _77 = u.delete_length;
  _78 = (int) _77;
  _79 = u.where;
  ImGuiStb::STB_TEXTEDIT_DELETECHARS (str_71(D), _79, _78);

  <bb 15>:
  _81 = u.insert_length;
  if (_81 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _82 = u.insert_length;
  _83 = (int) _82;
  _84 = u.char_storage;
  _85 = (int) _84;
  _86 = &s_11->undo_char[_85];
  _87 = u.where;
  ImGuiStb::STB_TEXTEDIT_INSERTCHARS (str_71(D), _87, _86, _83);
  _89 = s_11->undo_char_point;
  _90 = (unsigned short) _89;
  _91 = u.insert_length;
  _92 = (unsigned short) _91;
  _93 = _90 - _92;
  _94 = (short int) _93;
  s_11->undo_char_point = _94;

  <bb 17>:
  _96 = u.where;
  _97 = u.insert_length;
  _98 = (int) _97;
  _99 = _96 + _98;
  state_10(D)->cursor = _99;
  _101 = s_11->undo_point;
  _102 = _101;
  _103 = (unsigned short) _102;
  _104 = _103 + 65535;
  _105 = (short int) _104;
  s_11->undo_point = _105;
  _107 = s_11->redo_point;
  _108 = _107;
  _109 = (unsigned short) _108;
  _110 = _109 + 65535;
  _111 = (short int) _110;
  s_11->redo_point = _111;
  u ={v} {CLOBBER};
  goto <bb 19> (<L21>);

  <bb 18>:
  u ={v} {CLOBBER};

<L21>:
  return;

}



;; Function void ImGuiStb::stb_text_redo(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (_ZN8ImGuiStbL13stb_text_redoEP18ImGuiTextEditStatePNS_17STB_TexteditStateE, funcdef_no=1081, decl_uid=20023, cgraph_uid=980, symbol_order=991)

void ImGuiStb::stb_text_redo(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*) (struct ImGuiTextEditState * str, struct STB_TexteditState * state)
{
  short unsigned int D.38704;
  int i;
  struct StbUndoRecord r;
  struct StbUndoRecord * u;
  struct StbUndoState * s;
  short int D.38702;
  unsigned short D.38701;
  unsigned short D.38700;
  short int D.38699;
  short int D.38698;
  short int D.38697;
  unsigned short D.38696;
  unsigned short D.38695;
  short int D.38694;
  short int D.38693;
  int D.38692;
  int D.38691;
  short int D.38690;
  int D.38689;
  short int D.38687;
  unsigned short D.38686;
  unsigned short D.38685;
  short int D.38684;
  unsigned short D.38683;
  short int D.38682;
  int D.38681;
  ImWchar * D.38680;
  int D.38679;
  short int D.38678;
  int D.38677;
  short int D.38676;
  short int D.38673;
  int D.38671;
  int D.38670;
  short int D.38669;
  short unsigned int D.38668;
  int D.38667;
  int D.38666;
  int D.38665;
  int D.38664;
  short int D.38663;
  int D.38661;
  short int D.38660;
  short int D.38658;
  unsigned short D.38657;
  unsigned short D.38656;
  short int D.38655;
  unsigned short D.38654;
  short int D.38653;
  short int D.38652;
  int D.38648;
  short int D.38647;
  int D.38646;
  int D.38645;
  short int D.38644;
  int D.38643;
  short int D.38642;
  short int D.38639;
  int D.38638;
  short int D.38637;
  short int D.38636;
  int D.38635;
  short int D.38634;
  int D.38633;
  short int D.38632;
  short int D.38629;
  short int _11;
  short int _12;
  int _13;
  short int _15;
  int _16;
  short int _18;
  short int _20;
  int _22;
  short int _25;
  short int _26;
  int _27;
  short int _28;
  int _29;
  int _30;
  short int _31;
  int _32;
  short int _35;
  short int _37;
  unsigned short _38;
  short int _39;
  unsigned short _40;
  unsigned short _41;
  short int _42;
  short int _45;
  int _46;
  short int _47;
  int _48;
  int _49;
  int _50;
  int _51;
  short unsigned int _54;
  short unsigned int _55;
  short int _58;
  int _59;
  int _60;
  short int _62;
  short int _63;
  int _64;
  short int _65;
  int _66;
  ImWchar * _67;
  int _68;
  short int _70;
  unsigned short _71;
  short int _72;
  unsigned short _73;
  unsigned short _74;
  short int _75;
  int _77;
  short int _78;
  int _79;
  int _80;
  short int _82;
  short int _83;
  unsigned short _84;
  unsigned short _85;
  short int _86;
  short int _88;
  short int _89;
  unsigned short _90;
  unsigned short _91;
  short int _92;

  <bb 2>:
  s_9 = &state_8(D)->undostate;
  _11 = s_9->redo_point;
  if (_11 == 99)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  r ={v} {CLOBBER};
  goto <bb 14> (<L16>);

  <bb 4>:
  _12 = s_9->undo_point;
  _13 = (int) _12;
  u_14 = &s_9->undo_rec[_13];
  _15 = s_9->redo_point;
  _16 = (int) _15;
  r = s_9->undo_rec[_16];
  _18 = r.insert_length;
  u_14->delete_length = _18;
  _20 = r.delete_length;
  u_14->insert_length = _20;
  _22 = r.where;
  u_14->where = _22;
  u_14->char_storage = -1;
  _25 = r.delete_length;
  if (_25 != 0)
    goto <bb 5>;
  else
    goto <bb 11>;

  <bb 5>:
  _26 = s_9->undo_char_point;
  _27 = (int) _26;
  _28 = u_14->insert_length;
  _29 = (int) _28;
  _30 = _27 + _29;
  _31 = s_9->redo_char_point;
  _32 = (int) _31;
  if (_30 > _32)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  u_14->insert_length = 0;
  u_14->delete_length = 0;
  goto <bb 10>;

  <bb 7>:
  _35 = s_9->undo_char_point;
  u_14->char_storage = _35;
  _37 = s_9->undo_char_point;
  _38 = (unsigned short) _37;
  _39 = u_14->insert_length;
  _40 = (unsigned short) _39;
  _41 = _38 + _40;
  _42 = (short int) _41;
  s_9->undo_char_point = _42;
  i_44 = 0;

  <bb 8>:
  # i_1 = PHI <i_44(7), i_57(9)>
  _45 = u_14->insert_length;
  _46 = (int) _45;
  if (_46 <= i_1)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  _47 = u_14->char_storage;
  _48 = (int) _47;
  _49 = _48 + i_1;
  _50 = u_14->where;
  _51 = _50 + i_1;
  _54 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_52(D), _51);
  _55 = _54;
  s_9->undo_char[_49] = _55;
  i_57 = i_1 + 1;
  goto <bb 8>;

  <bb 10>:
  _58 = r.delete_length;
  _59 = (int) _58;
  _60 = r.where;
  ImGuiStb::STB_TEXTEDIT_DELETECHARS (str_52(D), _60, _59);

  <bb 11>:
  _62 = r.insert_length;
  if (_62 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _63 = r.insert_length;
  _64 = (int) _63;
  _65 = r.char_storage;
  _66 = (int) _65;
  _67 = &s_9->undo_char[_66];
  _68 = r.where;
  ImGuiStb::STB_TEXTEDIT_INSERTCHARS (str_52(D), _68, _67, _64);
  _70 = s_9->redo_char_point;
  _71 = (unsigned short) _70;
  _72 = r.insert_length;
  _73 = (unsigned short) _72;
  _74 = _71 + _73;
  _75 = (short int) _74;
  s_9->redo_char_point = _75;

  <bb 13>:
  _77 = r.where;
  _78 = r.insert_length;
  _79 = (int) _78;
  _80 = _77 + _79;
  state_8(D)->cursor = _80;
  _82 = s_9->undo_point;
  _83 = _82;
  _84 = (unsigned short) _83;
  _85 = _84 + 1;
  _86 = (short int) _85;
  s_9->undo_point = _86;
  _88 = s_9->redo_point;
  _89 = _88;
  _90 = (unsigned short) _89;
  _91 = _90 + 1;
  _92 = (short int) _91;
  s_9->redo_point = _92;
  r ={v} {CLOBBER};

<L16>:
  return;

}



;; Function void ImGuiStb::stb_text_makeundo_insert(ImGuiStb::STB_TexteditState*, int, int) (_ZN8ImGuiStbL24stb_text_makeundo_insertEPNS_17STB_TexteditStateEii, funcdef_no=1082, decl_uid=20032, cgraph_uid=981, symbol_order=992)

void ImGuiStb::stb_text_makeundo_insert(ImGuiStb::STB_TexteditState*, int, int) (struct STB_TexteditState * state, int where, int length)
{
  struct StbUndoState * D.38708;
  struct StbUndoState * _2;

  <bb 2>:
  _2 = &state_1(D)->undostate;
  ImGuiStb::stb_text_createundo (_2, where_4(D), 0, length_5(D));
  return;

}



;; Function void ImGuiStb::stb_text_makeundo_delete(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int, int) (_ZN8ImGuiStbL24stb_text_makeundo_deleteEP18ImGuiTextEditStatePNS_17STB_TexteditStateEii, funcdef_no=1083, decl_uid=20028, cgraph_uid=982, symbol_order=993)

void ImGuiStb::stb_text_makeundo_delete(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int, int) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, int where, int length)
{
  short unsigned int D.38720;
  ImWchar * p;
  int i;
  short unsigned int D.38718;
  int D.38717;
  ImWchar * D.38716;
  long unsigned int D.38715;
  long unsigned int D.38714;
  struct StbUndoState * D.38709;
  struct StbUndoState * _5;
  long unsigned int _12;
  long unsigned int _13;
  ImWchar * _14;
  int _15;
  short unsigned int _18;
  short unsigned int _19;

  <bb 2>:
  _5 = &state_4(D)->undostate;
  p_10 = ImGuiStb::stb_text_createundo (_5, where_7(D), length_8(D), 0);
  if (p_10 != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  i_11 = 0;

  <bb 4>:
  # i_1 = PHI <i_11(3), i_21(5)>
  if (i_1 >= length_8(D))
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _12 = (long unsigned int) i_1;
  _13 = _12 * 2;
  _14 = p_10 + _13;
  _15 = where_7(D) + i_1;
  _18 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_16(D), _15);
  _19 = _18;
  *_14 = _19;
  i_21 = i_1 + 1;
  goto <bb 4>;

  <bb 6>:
  return;

}



;; Function void ImGuiStb::stb_text_makeundo_replace(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int, int, int) (_ZN8ImGuiStbL25stb_text_makeundo_replaceEP18ImGuiTextEditStatePNS_17STB_TexteditStateEiii, funcdef_no=1084, decl_uid=20038, cgraph_uid=983, symbol_order=994)

void ImGuiStb::stb_text_makeundo_replace(ImGuiTextEditState*, ImGuiStb::STB_TexteditState*, int, int, int) (struct ImGuiTextEditState * str, struct STB_TexteditState * state, int where, int old_length, int new_length)
{
  short unsigned int D.38732;
  ImWchar * p;
  int i;
  short unsigned int D.38730;
  int D.38729;
  ImWchar * D.38728;
  long unsigned int D.38727;
  long unsigned int D.38726;
  struct StbUndoState * D.38721;
  struct StbUndoState * _5;
  long unsigned int _13;
  long unsigned int _14;
  ImWchar * _15;
  int _16;
  short unsigned int _19;
  short unsigned int _20;

  <bb 2>:
  _5 = &state_4(D)->undostate;
  p_11 = ImGuiStb::stb_text_createundo (_5, where_7(D), old_length_8(D), new_length_9(D));
  if (p_11 != 0B)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  i_12 = 0;

  <bb 4>:
  # i_1 = PHI <i_12(3), i_22(5)>
  if (i_1 >= old_length_8(D))
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _13 = (long unsigned int) i_1;
  _14 = _13 * 2;
  _15 = p_11 + _14;
  _16 = where_7(D) + i_1;
  _19 = ImGuiStb::STB_TEXTEDIT_GETCHAR (str_17(D), _16);
  _20 = _19;
  *_15 = _20;
  i_22 = i_1 + 1;
  goto <bb 4>;

  <bb 6>:
  return;

}



;; Function void ImGuiStb::stb_textedit_clear_state(ImGuiStb::STB_TexteditState*, int) (_ZN8ImGuiStbL24stb_textedit_clear_stateEPNS_17STB_TexteditStateEi, funcdef_no=1085, decl_uid=20291, cgraph_uid=984, symbol_order=995)

void ImGuiStb::stb_textedit_clear_state(ImGuiStb::STB_TexteditState*, int) (struct STB_TexteditState * state, int is_single_line)
{
  unsigned char D.38734;
  int D.38733;
  int _8;
  unsigned char _16;

  <bb 2>:
  state_2(D)->undostate.undo_point = 0;
  state_2(D)->undostate.undo_char_point = 0;
  state_2(D)->undostate.redo_point = 99;
  state_2(D)->undostate.redo_char_point = 999;
  state_2(D)->select_start = 0;
  _8 = state_2(D)->select_start;
  state_2(D)->select_end = _8;
  state_2(D)->cursor = 0;
  state_2(D)->has_preferred_x = 0;
  state_2(D)->preferred_x = 0.0;
  state_2(D)->cursor_at_end_of_line = 0;
  state_2(D)->initialized = 1;
  _16 = (unsigned char) is_single_line_15(D);
  state_2(D)->single_line = _16;
  state_2(D)->insert_mode = 0;
  return;

}



;; Function void ImGuiStb::stb_textedit_initialize_state(ImGuiStb::STB_TexteditState*, int) (_ZN8ImGuiStbL29stb_textedit_initialize_stateEPNS_17STB_TexteditStateEi, funcdef_no=1086, decl_uid=20295, cgraph_uid=985, symbol_order=996)

void ImGuiStb::stb_textedit_initialize_state(ImGuiStb::STB_TexteditState*, int) (struct STB_TexteditState * state, int is_single_line)
{
  <bb 2>:
  ImGuiStb::stb_textedit_clear_state (state_2(D), is_single_line_3(D));
  return;

}



;; Function void ImGuiTextEditState::OnKeyPressed(int) (_ZN18ImGuiTextEditState12OnKeyPressedEi, funcdef_no=1087, decl_uid=11132, cgraph_uid=986, symbol_order=997)

void ImGuiTextEditState::OnKeyPressed(int) (struct ImGuiTextEditState * const this, int key)
{
  struct STB_TexteditState * D.38735;
  struct STB_TexteditState * _2;

  <bb 2>:
  _2 = &this_1(D)->StbState;
  ImGuiStb::stb_textedit_key (this_1(D), _2, key_4(D));
  this_1(D)->CursorFollow = 1;
  ImGuiTextEditState::CursorAnimReset (this_1(D));
  return;

}



;; Function void ImGuiTextEditCallbackData::DeleteChars(int, int) (_ZN25ImGuiTextEditCallbackData11DeleteCharsEii, funcdef_no=1088, decl_uid=4771, cgraph_uid=987, symbol_order=998)

void ImGuiTextEditCallbackData::DeleteChars(int, int) (struct ImGuiTextEditCallbackData * const this, int pos, int bytes_count)
{
  char c;
  const char * src;
  char * dst;
  static const char __PRETTY_FUNCTION__[54] = "void ImGuiTextEditCallbackData::DeleteChars(int, int)";
  int D.38765;
  int D.38764;
  int D.38763;
  int D.38762;
  int D.38758;
  int D.38756;
  int D.38755;
  int D.38752;
  int D.38751;
  char * dst.1579;
  const char * src.1578;
  sizetype D.38746;
  sizetype D.38745;
  sizetype D.38744;
  char * D.38743;
  sizetype D.38742;
  char * D.38741;
  int D.38737;
  int D.38736;
  int _7;
  int _10;
  char * _11;
  sizetype _12;
  char * _14;
  sizetype _15;
  sizetype _16;
  sizetype _17;
  const char * src.1578_19;
  char * dst.1579_22;
  int _26;
  int _27;
  int _28;
  int _29;
  int _31;
  int _33;
  int _35;
  int _38;
  int _39;

  <bb 2>:
  _7 = pos_5(D) + bytes_count_6(D);
  _10 = this_9(D)->BufTextLen;
  if (_7 <= _10)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("pos + bytes_count <= BufTextLen", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9797, &__PRETTY_FUNCTION__);

  <bb 4>:
  _11 = this_9(D)->Buf;
  _12 = (sizetype) pos_5(D);
  dst_13 = _11 + _12;
  _14 = this_9(D)->Buf;
  _15 = (sizetype) pos_5(D);
  _16 = (sizetype) bytes_count_6(D);
  _17 = _15 + _16;
  src_18 = _14 + _17;

  <bb 5>:
  # dst_1 = PHI <dst_13(4), dst_23(6)>
  # src_2 = PHI <src_18(4), src_20(6)>
  src.1578_19 = src_2;
  src_20 = src.1578_19 + 1;
  c_21 = *src.1578_19;
  if (c_21 == 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  dst.1579_22 = dst_1;
  dst_23 = dst.1579_22 + 1;
  *dst.1579_22 = c_21;
  goto <bb 5>;

  <bb 7>:
  *dst_1 = 0;
  _26 = this_9(D)->CursorPos;
  _27 = _26 + bytes_count_6(D);
  if (_27 >= pos_5(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _28 = this_9(D)->CursorPos;
  _29 = _28 - bytes_count_6(D);
  this_9(D)->CursorPos = _29;
  goto <bb 11>;

  <bb 9>:
  _31 = this_9(D)->CursorPos;
  if (_31 >= pos_5(D))
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  this_9(D)->CursorPos = pos_5(D);

  <bb 11>:
  _33 = this_9(D)->CursorPos;
  this_9(D)->SelectionEnd = _33;
  _35 = this_9(D)->SelectionEnd;
  this_9(D)->SelectionStart = _35;
  this_9(D)->BufDirty = 1;
  _38 = this_9(D)->BufTextLen;
  _39 = _38 - bytes_count_6(D);
  this_9(D)->BufTextLen = _39;
  return;

}



;; Function void ImGuiTextEditCallbackData::InsertChars(int, const char*, const char*) (_ZN25ImGuiTextEditCallbackData11InsertCharsEiPKcS1_, funcdef_no=1089, decl_uid=4776, cgraph_uid=988, symbol_order=999)

void ImGuiTextEditCallbackData::InsertChars(int, const char*, const char*) (struct ImGuiTextEditCallbackData * const this, int pos, const char * new_text, const char * new_text_end)
{
  const int new_text_len;
  int D.38813;
  int D.38812;
  int D.38811;
  int D.38810;
  int D.38808;
  int D.38807;
  int D.38804;
  char * D.38803;
  sizetype D.38802;
  int D.38801;
  int D.38800;
  char * D.38799;
  char * D.38798;
  sizetype D.38797;
  char * D.38796;
  long unsigned int D.38795;
  char * D.38793;
  sizetype D.38792;
  sizetype D.38791;
  sizetype D.38790;
  char * D.38789;
  char * D.38788;
  sizetype D.38787;
  char * D.38786;
  long unsigned int D.38785;
  int D.38784;
  int D.38783;
  int D.38780;
  int D.38777;
  int D.38776;
  int D.38775;
  int D.38774;
  long unsigned int D.38773;
  long int D.38771;
  long int new_text.1582;
  long int new_text_end.1581;
  int iftmp.1580;
  int iftmp.1580_1;
  long int new_text_end.1581_6;
  long int new_text.1582_8;
  long int _9;
  int iftmp.1580_10;
  long unsigned int _12;
  int iftmp.1580_13;
  int _16;
  int _17;
  int _18;
  int _19;
  int _20;
  int _22;
  int _23;
  long unsigned int _24;
  char * _25;
  sizetype _26;
  char * _27;
  char * _28;
  sizetype _29;
  sizetype _30;
  sizetype _31;
  char * _32;
  long unsigned int _34;
  char * _35;
  sizetype _36;
  char * _37;
  char * _39;
  int _40;
  int _41;
  sizetype _42;
  char * _43;
  int _45;
  int _46;
  int _47;
  int _49;
  int _51;
  int _54;
  int _55;

  <bb 2>:
  if (new_text_end_5(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  new_text_end.1581_6 = (long int) new_text_end_5(D);
  new_text.1582_8 = (long int) new_text_7(D);
  _9 = new_text_end.1581_6 - new_text.1582_8;
  iftmp.1580_10 = (int) _9;
  goto <bb 5>;

  <bb 4>:
  _12 = strlen (new_text_7(D));
  iftmp.1580_13 = (int) _12;

  <bb 5>:
  # iftmp.1580_1 = PHI <iftmp.1580_10(3), iftmp.1580_13(4)>
  new_text_len_14 = iftmp.1580_1;
  _16 = this_15(D)->BufTextLen;
  _17 = _16 + new_text_len_14;
  _18 = _17 + 1;
  _19 = this_15(D)->BufSize;
  if (_18 >= _19)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 12> (<L11>);

  <bb 7>:
  _20 = this_15(D)->BufTextLen;
  if (_20 != pos_21(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _22 = this_15(D)->BufTextLen;
  _23 = _22 - pos_21(D);
  _24 = (long unsigned int) _23;
  _25 = this_15(D)->Buf;
  _26 = (sizetype) pos_21(D);
  _27 = _25 + _26;
  _28 = this_15(D)->Buf;
  _29 = (sizetype) pos_21(D);
  _30 = (sizetype) new_text_len_14;
  _31 = _29 + _30;
  _32 = _28 + _31;
  memmove (_32, _27, _24);

  <bb 9>:
  _34 = (long unsigned int) new_text_len_14;
  _35 = this_15(D)->Buf;
  _36 = (sizetype) pos_21(D);
  _37 = _35 + _36;
  memcpy (_37, new_text_7(D), _34);
  _39 = this_15(D)->Buf;
  _40 = this_15(D)->BufTextLen;
  _41 = _40 + new_text_len_14;
  _42 = (sizetype) _41;
  _43 = _39 + _42;
  *_43 = 0;
  _45 = this_15(D)->CursorPos;
  if (_45 >= pos_21(D))
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _46 = this_15(D)->CursorPos;
  _47 = _46 + new_text_len_14;
  this_15(D)->CursorPos = _47;

  <bb 11>:
  _49 = this_15(D)->CursorPos;
  this_15(D)->SelectionEnd = _49;
  _51 = this_15(D)->SelectionEnd;
  this_15(D)->SelectionStart = _51;
  this_15(D)->BufDirty = 1;
  _54 = this_15(D)->BufTextLen;
  _55 = _54 + new_text_len_14;
  this_15(D)->BufTextLen = _55;

<L11>:
  return;

}



;; Function bool InputTextFilterCharacter(unsigned int*, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (_ZL24InputTextFilterCharacterPjiPFiP25ImGuiTextEditCallbackDataEPv, funcdef_no=1090, decl_uid=15078, cgraph_uid=989, symbol_order=1000)

bool InputTextFilterCharacter(unsigned int*, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (unsigned int * p_char, ImGuiInputTextFlags flags, int (*ImGuiTextEditCallback) (struct ImGuiTextEditCallbackData *) callback, void * user_data)
{
  int D.38929;
  struct ImGuiTextEditCallbackData callback_data;
  bool pass;
  unsigned int c;
  short unsigned int D.38924;
  unsigned int D.38923;
  short unsigned int D.38922;
  int D.38919;
  bool retval.1587;
  short unsigned int D.38917;
  int D.38914;
  bool retval.1586;
  int D.38906;
  int D.38897;
  int D.38886;
  int D.38865;
  int D.38848;
  int D.38845;
  bool D.38839;
  bool D.38836;
  int D.38834;
  bool iftmp.1585;
  int D.38828;
  bool iftmp.1584;
  int D.38821;
  int D.38820;
  int c.1583;
  bool iftmp.1584_3;
  bool iftmp.1585_4;
  bool _5;
  bool _6;
  int c.1583_15;
  int _16;
  int _17;
  int _20;
  bool iftmp.1584_21;
  bool iftmp.1584_22;
  int _24;
  bool iftmp.1585_25;
  bool iftmp.1585_26;
  bool _28;
  bool _29;
  bool _30;
  int _31;
  int _32;
  bool _33;
  int _34;
  bool _35;
  int _36;
  bool _37;
  int _38;
  int _41;
  bool retval.1586_43;
  bool _44;
  int _45;
  short unsigned int _48;
  int _55;
  int _56;
  bool retval.1587_57;
  bool _58;
  short unsigned int _59;
  unsigned int _60;
  short unsigned int _62;
  bool _63;
  bool _67;

  <bb 2>:
  c_14 = *p_char_13(D);
  if (c_14 <= 127)
    goto <bb 3>;
  else
    goto <bb 16>;

  <bb 3>:
  if (c_14 != 32)
    goto <bb 4>;
  else
    goto <bb 16>;

  <bb 4>:
  c.1583_15 = (int) c_14;
  _16 = c.1583_15 & 255;
  _17 = isprint (_16);
  if (_17 == 0)
    goto <bb 5>;
  else
    goto <bb 16>;

  <bb 5>:
  pass_18 = 0;
  if (c_14 == 10)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _20 = flags_19(D) & 1048576;
  if (_20 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1584_21 = 1;
  goto <bb 9>;

  <bb 8>:
  iftmp.1584_22 = 0;

  <bb 9>:
  # iftmp.1584_3 = PHI <iftmp.1584_21(7), iftmp.1584_22(8)>
  pass_23 = iftmp.1584_3 | pass_18;
  if (c_14 == 9)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _24 = flags_19(D) & 1024;
  if (_24 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.1585_25 = 1;
  goto <bb 13>;

  <bb 12>:
  iftmp.1585_26 = 0;

  <bb 13>:
  # iftmp.1585_4 = PHI <iftmp.1585_25(11), iftmp.1585_26(12)>
  pass_27 = iftmp.1585_4 | pass_23;
  _28 = ~pass_27;
  if (_28 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _29 = 0;
  goto <bb 63> (<L92>);

  <bb 15>:

  <bb 16>:
  if (c_14 > 57343)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  if (c_14 <= 63743)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _30 = 0;
  goto <bb 63> (<L92>);

  <bb 19>:
  _31 = flags_19(D) & 131087;
  if (_31 != 0)
    goto <bb 20>;
  else
    goto <bb 55>;

  <bb 20>:
  _32 = flags_19(D) & 1;
  if (_32 != 0)
    goto <bb 21>;
  else
    goto <bb 29>;

  <bb 21>:
  if (c_14 <= 47)
    goto <bb 23>;
  else
    goto <bb 22>;

  <bb 22>:
  if (c_14 > 57)
    goto <bb 23>;
  else
    goto <bb 29>;

  <bb 23>:
  if (c_14 != 46)
    goto <bb 24>;
  else
    goto <bb 29>;

  <bb 24>:
  if (c_14 != 45)
    goto <bb 25>;
  else
    goto <bb 29>;

  <bb 25>:
  if (c_14 != 43)
    goto <bb 26>;
  else
    goto <bb 29>;

  <bb 26>:
  if (c_14 != 42)
    goto <bb 27>;
  else
    goto <bb 29>;

  <bb 27>:
  if (c_14 != 47)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  _33 = 0;
  goto <bb 63> (<L92>);

  <bb 29>:
  _34 = flags_19(D) & 131072;
  if (_34 != 0)
    goto <bb 30>;
  else
    goto <bb 40>;

  <bb 30>:
  if (c_14 <= 47)
    goto <bb 32>;
  else
    goto <bb 31>;

  <bb 31>:
  if (c_14 > 57)
    goto <bb 32>;
  else
    goto <bb 40>;

  <bb 32>:
  if (c_14 != 46)
    goto <bb 33>;
  else
    goto <bb 40>;

  <bb 33>:
  if (c_14 != 45)
    goto <bb 34>;
  else
    goto <bb 40>;

  <bb 34>:
  if (c_14 != 43)
    goto <bb 35>;
  else
    goto <bb 40>;

  <bb 35>:
  if (c_14 != 42)
    goto <bb 36>;
  else
    goto <bb 40>;

  <bb 36>:
  if (c_14 != 47)
    goto <bb 37>;
  else
    goto <bb 40>;

  <bb 37>:
  if (c_14 != 101)
    goto <bb 38>;
  else
    goto <bb 40>;

  <bb 38>:
  if (c_14 != 69)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _35 = 0;
  goto <bb 63> (<L92>);

  <bb 40>:
  _36 = flags_19(D) & 2;
  if (_36 != 0)
    goto <bb 41>;
  else
    goto <bb 48>;

  <bb 41>:
  if (c_14 <= 47)
    goto <bb 43>;
  else
    goto <bb 42>;

  <bb 42>:
  if (c_14 > 57)
    goto <bb 43>;
  else
    goto <bb 48>;

  <bb 43>:
  if (c_14 <= 96)
    goto <bb 45>;
  else
    goto <bb 44>;

  <bb 44>:
  if (c_14 > 102)
    goto <bb 45>;
  else
    goto <bb 48>;

  <bb 45>:
  if (c_14 <= 64)
    goto <bb 47>;
  else
    goto <bb 46>;

  <bb 46>:
  if (c_14 > 70)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  _37 = 0;
  goto <bb 63> (<L92>);

  <bb 48>:
  _38 = flags_19(D) & 4;
  if (_38 != 0)
    goto <bb 49>;
  else
    goto <bb 52>;

  <bb 49>:
  if (c_14 > 96)
    goto <bb 50>;
  else
    goto <bb 52>;

  <bb 50>:
  if (c_14 <= 122)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  c_39 = c_14 + 4294967264;
  *p_char_13(D) = c_39;

  <bb 52>:
  # c_1 = PHI <c_14(48), c_14(50), c_14(49), c_39(51)>
  _41 = flags_19(D) & 8;
  if (_41 != 0)
    goto <bb 53>;
  else
    goto <bb 55>;

  <bb 53>:
  retval.1586_43 = ImCharIsSpace (c_1);
  if (retval.1586_43 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  _44 = 0;
  goto <bb 63> (<L92>);

  <bb 55>:
  # c_2 = PHI <c_14(19), c_1(53), c_1(52)>
  _45 = flags_19(D) & 512;
  if (_45 != 0)
    goto <bb 56>;
  else
    goto <bb 62>;

  <bb 56>:
  memset (&callback_data, 0, 56);
  callback_data.EventFlag = 512;
  _48 = (short unsigned int) c_2;
  callback_data.EventChar = _48;
  callback_data.Flags = flags_19(D);
  callback_data.UserData = user_data_51(D);
  _55 = callback_53(D) (&callback_data);
  _56 = _55;
  retval.1587_57 = _56 != 0;
  if (retval.1587_57 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  _58 = 0;
  goto <bb 61>;

  <bb 58>:
  _59 = callback_data.EventChar;
  _60 = (unsigned int) _59;
  *p_char_13(D) = _60;
  _62 = callback_data.EventChar;
  if (_62 == 0)
    goto <bb 59>;
  else
    goto <bb 60>;

  <bb 59>:
  _63 = 0;
  goto <bb 61>;

  <bb 60>:
  callback_data ={v} {CLOBBER};
  goto <bb 62>;

  <bb 61>:
  # _5 = PHI <_58(57), _63(59)>
  callback_data ={v} {CLOBBER};
  goto <bb 63> (<L92>);

  <bb 62>:
  _67 = 1;

  # _6 = PHI <_29(14), _30(18), _33(28), _35(39), _37(47), _44(54), _5(61), _67(62)>
<L92>:
  return _6;

}



;; Function bool ImGui::InputTextEx(const char*, char*, int, const ImVec2&, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (_ZN5ImGui11InputTextExEPKcPciRK6ImVec2iPFiP25ImGuiTextEditCallbackDataEPv, funcdef_no=1091, decl_uid=14002, cgraph_uid=990, symbol_order=1001)

bool ImGui::InputTextEx(const char*, char*, int, const ImVec2&, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (const char * label, char * buf, int buf_size, const struct ImVec2 & size_arg, ImGuiInputTextFlags flags, int (*ImGuiTextEditCallback) (struct ImGuiTextEditCallbackData *) callback, void * user_data)
{
  void * D.46661;
  float D.40268;
  unsigned int D.40266;
  bool D.40264;
  bool D.40263;
  bool D.40262;
  bool D.40257;
  ImWchar * D.40256;
  const char * D.40255;
  bool D.40254;
  bool D.40253;
  bool D.40252;
  bool D.40251;
  bool D.40249;
  bool D.40248;
  bool D.40246;
  bool D.40245;
  bool D.40244;
  bool D.40243;
  bool D.40242;
  bool D.40241;
  bool D.40240;
  bool D.40239;
  bool D.40238;
  bool D.40237;
  bool D.40236;
  bool D.40235;
  bool D.40234;
  bool D.40233;
  bool D.40232;
  bool D.40231;
  bool D.40229;
  unsigned int D.40226;
  const bool D.40225;
  const struct ImFontGlyph * D.40224;
  const bool D.40223;
  bool D.40222;
  bool D.40220;
  float D.40219;
  const ImGuiID D.40218;
  const char * buf_end;
  struct ImRect rect;
  struct ImVec2 rect_size;
  const ImWchar * p;
  struct ImVec2 rect_pos;
  ImU32 bg_color;
  float bg_offy_dn;
  float bg_offy_up;
  const ImWchar * text_selected_end;
  const ImWchar * text_selected_begin;
  float scroll_y;
  const float scroll_increment_x;
  const ImWchar * s;
  int line_count;
  int searches_result_line_number[2];
  int searches_remaining;
  const ImWchar * searches_input_ptr[2];
  struct ImRect cursor_screen_rect;
  struct ImVec2 cursor_screen_pos;
  bool cursor_is_visible;
  const struct ImVec2 render_scroll;
  struct ImVec2 select_start_offset;
  struct ImVec2 cursor_offset;
  const ImWchar * text_begin;
  const int utf8_selection_end;
  const int utf8_selection_start;
  const int utf8_cursor_pos;
  ImWchar * text;
  struct ImGuiTextEditCallbackData callback_data;
  ImGuiKey event_key;
  ImGuiInputTextFlags event_flag;
  bool apply_edit_back_to_user_buffer;
  unsigned int c;
  const char * s;
  int clipboard_filtered_len;
  ImWchar * clipboard_filtered;
  const int clipboard_len;
  const char * clipboard;
  const int ie;
  const int ib;
  unsigned int c;
  unsigned int c;
  bool ctrl_enter_for_new_line;
  const bool is_paste;
  const bool is_copy;
  const bool is_cut;
  const bool is_shift_key_only;
  const bool is_ctrl_key_only;
  const bool is_startend_key_down;
  const bool is_wordmove_key_down;
  const bool is_shortcut_key_only;
  const int k_mask;
  unsigned int c;
  int n;
  const char * buf_end;
  const bool osx_double_click_selects_words;
  const float mouse_y;
  const float mouse_x;
  const bool recycle_state;
  const char * buf_end;
  const int prev_len_w;
  struct ImFont * password_font;
  const struct ImFontGlyph * glyph;
  const bool is_currently_scrolling;
  struct ImVec2 text_size;
  struct ImVec2 render_pos;
  const struct ImVec4 clip_rect;
  const char * buf_display;
  bool cancel_edit;
  bool enter_pressed;
  bool value_changed;
  bool select_all;
  bool clear_active_id;
  const bool user_nav_input_start;
  const bool user_scrolled;
  const bool user_clicked;
  const bool focus_requested_by_tab;
  const bool focus_requested_by_code;
  const bool focus_requested;
  struct ImGuiTextEditState & edit_state;
  const bool hovered;
  struct ImGuiWindow * draw_window;
  const struct ImRect total_bb;
  const struct ImRect frame_bb;
  struct ImVec2 size;
  const struct ImVec2 label_size;
  const ImGuiID id;
  const bool is_undoable;
  const bool is_password;
  const bool is_editable;
  const bool is_multiline;
  const struct ImGuiStyle & style;
  const struct ImGuiIO & io;
  struct ImGuiContext & g;
  static const char __PRETTY_FUNCTION__[115] = "bool ImGui::InputTextEx(const char*, char*, int, const ImVec2&, ImGuiInputTextFlags, ImGuiTextEditCallback, void*)";
  struct ImGuiWindow * window;
  int D.40214;
  float D.40212;
  float D.40211;
  float D.40210;
  float D.40209;
  float D.40208;
  float D.40207;
  struct ImVec2 D.20501;
  float D.40204;
  bool D.40200;
  bool D.40197;
  float D.40192;
  struct ImVec2 D.20499;
  struct ImVec2 D.20500;
  struct ImDrawList * D.40189;
  struct ImFont * D.40188;
  float D.40187;
  unsigned int D.40186;
  const char * buf_end.1694;
  const struct ImVec4 * iftmp.1693;
  float D.40179;
  float D.40178;
  float D.40177;
  float D.40176;
  int D.40175;
  struct ImVec2 text_size.1692;
  float D.40171;
  float D.40170;
  float D.40169;
  float D.40168;
  float D.40167;
  struct ImVec2 D.20496;
  struct ImDrawList * D.40163;
  struct ImVec2 D.20495;
  unsigned int D.40162;
  bool D.40158;
  const struct ImRect D.20494;
  bool iftmp.1691;
  bool retval.1690;
  float D.40152;
  float D.40151;
  float D.40150;
  float D.40149;
  float D.40148;
  float D.40147;
  float D.40146;
  float D.40145;
  float D.40144;
  struct ImVec2 D.20491;
  float D.40143;
  float D.40142;
  float D.40140;
  bool D.40138;
  bool D.40137;
  bool iftmp.1689;
  struct ImDrawList * D.40132;
  struct ImFont * D.40131;
  float D.40130;
  struct ImVec2 D.20488;
  unsigned int D.40129;
  const char * D.40128;
  sizetype D.40127;
  int D.40126;
  const struct ImVec4 * iftmp.1688;
  float D.40120;
  float D.40119;
  float D.40118;
  float D.40117;
  float D.40116;
  float D.40115;
  struct ImDrawList * D.40113;
  const struct ImRect D.20487;
  bool retval.1687;
  const struct ImRect D.20486;
  float D.40109;
  float D.40108;
  struct ImVec2 D.20482;
  struct ImVec2 D.20483;
  float D.40107;
  struct ImVec2 D.20484;
  struct ImVec2 D.20485;
  float D.40105;
  int D.40104;
  float D.40103;
  float D.40102;
  struct ImFont * D.40101;
  float D.40098;
  const ImWchar * p.1686;
  short unsigned int D.40093;
  const ImWchar * p.1685;
  const ImWchar * p.1684;
  const ImWchar * p.1683;
  bool retval.1682;
  const ImWchar * p.1681;
  float D.40083;
  float D.40082;
  float D.40079;
  float D.40078;
  float D.40077;
  float D.40076;
  const ImWchar * p.1680;
  struct ImVec2 D.20476;
  float iftmp.1679;
  float iftmp.1678;
  long unsigned int D.40064;
  long unsigned int D.40063;
  int D.40062;
  int D.40061;
  int D.40060;
  long unsigned int D.40059;
  long unsigned int D.40058;
  int D.40057;
  int D.40056;
  int D.40055;
  int D.40052;
  int D.40051;
  float D.40050;
  float D.40047;
  float D.40046;
  float D.40045;
  float D.40044;
  float D.40043;
  float D.40041;
  float D.40040;
  float D.40037;
  float D.40036;
  float D.40035;
  float D.40033;
  float D.40032;
  float D.40031;
  float D.40028;
  float D.40027;
  float D.40026;
  float D.40021;
  int D.40020;
  float D.40019;
  float D.40018;
  float D.40017;
  float D.40016;
  float D.40013;
  float D.40012;
  float D.40011;
  float D.40010;
  float D.40008;
  int D.40007;
  float D.40006;
  float D.40005;
  float D.40004;
  float D.40001;
  float D.40000;
  float D.39999;
  int D.39996;
  bool D.39993;
  float D.39991;
  float D.39990;
  float D.39989;
  float D.39988;
  struct ImVec2 text_size.1677;
  float D.39984;
  float D.39983;
  float D.39982;
  int D.39981;
  float D.39980;
  const ImWchar * D.39979;
  const ImWchar * D.39978;
  const ImWchar * D.39977;
  struct ImVec2 D.20464;
  int D.39974;
  float D.39973;
  float D.39972;
  float D.39971;
  int D.39970;
  float D.39969;
  const ImWchar * D.39968;
  const ImWchar * D.39967;
  const ImWchar * D.39966;
  struct ImVec2 D.20463;
  int D.39962;
  int D.39958;
  bool retval.1676;
  const ImWchar * D.39950;
  int D.39947;
  bool retval.1675;
  const ImWchar * D.39940;
  int D.39937;
  short unsigned int D.39934;
  short unsigned int D.39932;
  int iftmp.1674;
  const ImWchar * D.39925;
  long unsigned int D.39924;
  long unsigned int D.39923;
  int D.39922;
  int D.39921;
  int D.39920;
  int D.39917;
  int D.39916;
  const ImWchar * D.39915;
  long unsigned int D.39914;
  long unsigned int D.39913;
  int D.39912;
  float D.39911;
  float D.39910;
  float D.39909;
  unsigned int D.39907;
  unsigned int D.39902;
  unsigned int D.39901;
  unsigned int D.39898;
  bool iftmp.1673;
  const struct ImVec2 * D.39894;
  float D.39890;
  float D.39889;
  float D.39888;
  float D.39887;
  float D.39886;
  float D.39885;
  float D.39884;
  float D.39883;
  unsigned int D.39881;
  float D.39880;
  bool D.39877;
  unsigned int D.39874;
  char * iftmp.1672;
  unsigned int D.39867;
  char * D.39861;
  long unsigned int D.39860;
  int D.39857;
  char * D.39856;
  int D.39850;
  int D.39849;
  short unsigned int * D.39848;
  int D.39847;
  char * D.39846;
  int D.39842;
  long unsigned int D.39841;
  char * D.39840;
  int D.39839;
  bool D.39836;
  int D.39834;
  char * D.39833;
  char * D.39832;
  sizetype D.39831;
  int D.39830;
  char * D.39829;
  int D.39826;
  int D.39824;
  char * D.39823;
  char * D.39822;
  sizetype D.39821;
  int D.39820;
  char * D.39819;
  int D.39816;
  int D.39814;
  char * D.39813;
  char * D.39812;
  sizetype D.39811;
  int D.39810;
  char * D.39809;
  int D.39806;
  int D.39802;
  int D.39798;
  int D.39797;
  char * D.39793;
  char * D.39792;
  int D.39791;
  ImWchar * D.39790;
  long unsigned int D.39789;
  long unsigned int D.39788;
  int D.39787;
  int D.39786;
  ImWchar * D.39785;
  long unsigned int D.39784;
  long unsigned int D.39783;
  int D.39782;
  int D.39781;
  ImWchar * D.39780;
  long unsigned int D.39779;
  long unsigned int D.39778;
  int D.39777;
  int D.39776;
  int D.39775;
  char * D.39774;
  bool D.39773;
  int D.39767;
  bool D.39762;
  int D.39760;
  bool iftmp.1671;
  bool retval.1670;
  bool D.39751;
  int D.39749;
  bool iftmp.1669;
  bool retval.1668;
  bool D.39740;
  int D.39738;
  bool iftmp.1667;
  bool retval.1666;
  int D.39728;
  char * D.39726;
  int D.39725;
  short unsigned int * D.39724;
  struct ImVector * D.39723;
  int D.39722;
  int D.39721;
  int D.39716;
  bool D.39713;
  bool iftmp.1665;
  char * D.39706;
  long unsigned int D.39705;
  unsigned int D.39698;
  struct STB_TexteditState * D.39693;
  ImWchar * D.39690;
  long unsigned int D.39689;
  long unsigned int D.39688;
  short unsigned int D.39687;
  unsigned int c.1664;
  ImWchar * D.39685;
  long unsigned int D.39684;
  long unsigned int D.39683;
  int clipboard_filtered_len.1663;
  bool D.39679;
  bool D.39678;
  unsigned int c.1662;
  bool iftmp.1661;
  bool retval.1660;
  unsigned int c.1659;
  sizetype D.39667;
  int D.20436;
  char D.39665;
  long unsigned int D.39663;
  long unsigned int D.39662;
  int D.39661;
  long unsigned int D.39660;
  struct STB_TexteditState * D.39654;
  bool D.39650;
  bool retval.1658;
  char * D.39645;
  char * D.39644;
  int D.39643;
  short unsigned int * D.39642;
  long unsigned int D.39641;
  long unsigned int D.39640;
  short unsigned int * D.39639;
  short unsigned int * D.39638;
  long unsigned int D.39637;
  long unsigned int D.39636;
  short unsigned int * D.39635;
  struct ImVector * D.39634;
  int D.39633;
  int D.39632;
  int D.39631;
  int D.39629;
  int D.39628;
  bool D.39625;
  int iftmp.1657;
  int D.39622;
  int D.39621;
  bool D.39618;
  int iftmp.1656;
  void (*<T877>) (void *, const char *) D.39614;
  bool D.39605;
  bool iftmp.1655;
  bool retval.1654;
  bool D.39593;
  bool iftmp.1653;
  bool retval.1652;
  bool D.39581;
  bool iftmp.1651;
  bool retval.1650;
  bool retval.1649;
  int c.1648;
  unsigned int c.1647;
  bool retval.1646;
  bool D.39560;
  bool D.39559;
  bool D.39557;
  bool D.39556;
  bool D.39554;
  bool D.39553;
  bool D.39551;
  int D.39549;
  bool iftmp.1645;
  bool retval.1644;
  int c.1643;
  unsigned int c.1642;
  bool retval.1641;
  bool D.39534;
  bool D.39532;
  bool D.39531;
  bool D.39530;
  bool D.39527;
  int D.39522;
  bool retval.1640;
  int D.39517;
  bool D.39512;
  bool D.39511;
  bool D.39508;
  bool D.39507;
  bool D.39504;
  bool D.39501;
  bool D.39495;
  bool retval.1639;
  bool D.39489;
  bool iftmp.1638;
  bool retval.1637;
  int D.39483;
  bool D.39478;
  bool iftmp.1636;
  bool retval.1635;
  bool D.39469;
  int iftmp.1634;
  bool retval.1633;
  bool D.39460;
  int iftmp.1632;
  bool retval.1631;
  int D.39454;
  int iftmp.1630;
  float D.39448;
  float D.39447;
  float D.39446;
  float D.39445;
  float D.39444;
  bool D.39441;
  bool D.39436;
  bool iftmp.1629;
  bool retval.1628;
  int D.39430;
  int iftmp.1627;
  float D.39424;
  float D.39423;
  float D.39422;
  float D.39421;
  bool D.39418;
  bool D.39413;
  bool iftmp.1626;
  bool retval.1625;
  int D.39407;
  int iftmp.1624;
  int iftmp.1623;
  bool retval.1622;
  int D.39394;
  int iftmp.1621;
  int iftmp.1620;
  bool retval.1619;
  bool D.39381;
  bool D.39379;
  bool iftmp.1618;
  bool D.39372;
  bool D.39370;
  bool D.39368;
  bool D.39367;
  bool D.39365;
  bool iftmp.1617;
  bool D.39357;
  bool D.39355;
  bool D.39353;
  bool D.39351;
  bool D.39349;
  bool iftmp.1616;
  bool D.39340;
  bool D.39339;
  bool D.39337;
  bool D.39336;
  bool D.39334;
  bool D.39333;
  bool D.39331;
  bool iftmp.1615;
  bool D.39326;
  bool D.39325;
  bool D.39323;
  bool D.39322;
  bool D.39320;
  bool D.39319;
  bool D.39317;
  bool iftmp.1614;
  bool D.39312;
  bool D.39311;
  bool D.39309;
  bool D.39308;
  bool D.39306;
  bool D.39304;
  bool iftmp.1613;
  bool D.39297;
  bool iftmp.1612;
  bool D.39294;
  bool D.39293;
  bool D.39291;
  bool D.39290;
  bool D.39288;
  bool D.39287;
  bool D.39285;
  bool D.39282;
  bool D.39281;
  bool D.39279;
  bool D.39276;
  bool iftmp.1611;
  bool D.39269;
  int iftmp.1610;
  bool D.39265;
  bool D.39262;
  bool D.39261;
  unsigned int D.39258;
  ImWchar[17] * D.39255;
  int c.1609;
  unsigned int c.1608;
  bool retval.1607;
  unsigned int c.1606;
  short unsigned int D.39246;
  short unsigned int D.39244;
  bool D.39239;
  bool D.39236;
  bool D.39234;
  bool D.39233;
  short unsigned int D.39228;
  bool D.39224;
  bool D.39223;
  bool D.39220;
  struct STB_TexteditState * D.39219;
  float D.39218;
  float D.39216;
  bool D.39213;
  bool D.39212;
  bool D.39209;
  struct STB_TexteditState * D.39205;
  bool D.39201;
  bool D.39200;
  bool D.39198;
  bool D.39194;
  bool D.39189;
  bool D.39187;
  float D.39181;
  float D.39179;
  float D.39178;
  float D.39177;
  float D.39176;
  float iftmp.1605;
  float D.39172;
  float D.39171;
  float D.39170;
  float D.39169;
  float D.39168;
  float D.39167;
  bool D.39166;
  bool D.39165;
  int D.39163;
  long int D.39162;
  long int buf.1604;
  long int buf_end.1603;
  const char * buf_end.1602;
  int D.39158;
  short unsigned int * D.39157;
  int D.39156;
  struct ImVector * D.39155;
  int D.39154;
  bool D.39151;
  bool D.39150;
  bool D.39147;
  unsigned int D.39144;
  bool D.39140;
  int D.39138;
  int D.39137;
  int D.39134;
  bool D.39131;
  bool D.39129;
  bool D.39124;
  int D.39118;
  bool D.39112;
  struct STB_TexteditState * D.39111;
  int D.39110;
  bool D.39109;
  int D.39104;
  unsigned int D.39102;
  bool iftmp.1601;
  int D.39098;
  long int D.39097;
  long int buf.1600;
  long int buf_end.1599;
  const char * buf_end.1598;
  int D.39093;
  short unsigned int * D.39092;
  int D.39091;
  char * D.39090;
  long unsigned int D.39089;
  int D.39088;
  struct ImVector * D.39087;
  int D.39086;
  struct ImVector * D.39085;
  int D.39084;
  unsigned int D.39081;
  bool D.39073;
  int D.39071;
  unsigned int D.39069;
  bool iftmp.1597;
  ImGuiInputSource D.39064;
  unsigned int D.39062;
  unsigned int D.39060;
  unsigned int D.39058;
  bool iftmp.1596;
  unsigned int D.39052;
  unsigned int D.39051;
  unsigned int D.39049;
  unsigned int D.39047;
  bool iftmp.1595;
  bool D.39041;
  bool iftmp.1594;
  bool D.39035;
  bool iftmp.1593;
  int D.39029;
  int D.39028;
  bool iftmp.1592;
  int D.39023;
  bool D.39022;
  int D.39021;
  bool D.39018;
  struct ImVector * D.39017;
  bool D.39015;
  struct ImVector * D.39014;
  bool D.39012;
  struct ImVector * D.39011;
  float D.39008;
  struct ImFontAtlas * D.39007;
  struct ImFont * D.39006;
  float D.39005;
  struct ImFont * D.39004;
  float D.39003;
  struct ImFont * D.39002;
  struct ImFont * D.39001;
  float D.39000;
  struct ImFont * D.38999;
  float D.38998;
  struct ImFont * D.38997;
  struct ImFont * D.38996;
  bool D.38988;
  bool retval.1591;
  float D.38986;
  float D.38984;
  float D.38983;
  float D.38982;
  bool D.38979;
  struct ImVec2 D.20391;
  bool retval.1590;
  float D.38974;
  float D.38973;
  float D.38970;
  float iftmp.1589;
  struct ImVec2 D.20388;
  struct ImVec2 D.20389;
  struct ImVec2 * D.38968;
  struct ImVec2 * D.38967;
  struct ImVec2 D.20386;
  float D.38966;
  float D.38965;
  float D.38964;
  float D.38963;
  float D.38961;
  float iftmp.1588;
  int D.38954;
  int D.38953;
  int D.38952;
  int D.38951;
  int D.38947;
  int D.38944;
  int D.38940;
  int D.38937;
  bool D.38936;
  bool D.38933;
  bool _34;
  float iftmp.1588_35;
  float iftmp.1589_36;
  bool iftmp.1592_37;
  bool iftmp.1593_38;
  bool iftmp.1594_39;
  bool iftmp.1595_40;
  bool iftmp.1596_41;
  bool iftmp.1597_42;
  bool iftmp.1601_43;
  float iftmp.1605_44;
  int iftmp.1610_45;
  bool iftmp.1611_46;
  bool iftmp.1612_47;
  bool iftmp.1613_48;
  bool iftmp.1614_49;
  bool iftmp.1615_50;
  bool iftmp.1616_51;
  bool iftmp.1617_52;
  bool iftmp.1618_53;
  int iftmp.1620_54;
  int iftmp.1621_55;
  int iftmp.1623_56;
  int iftmp.1624_57;
  bool iftmp.1626_58;
  int iftmp.1627_59;
  bool iftmp.1629_60;
  int iftmp.1630_61;
  int iftmp.1632_62;
  int iftmp.1634_63;
  bool iftmp.1636_64;
  bool iftmp.1638_65;
  bool iftmp.1645_66;
  bool iftmp.1651_67;
  bool iftmp.1653_68;
  bool iftmp.1655_69;
  int iftmp.1656_70;
  int iftmp.1657_71;
  bool iftmp.1661_72;
  bool iftmp.1665_73;
  bool iftmp.1667_74;
  bool iftmp.1669_75;
  bool iftmp.1671_76;
  char * iftmp.1672_77;
  bool iftmp.1673_78;
  int iftmp.1674_79;
  float iftmp.1678_80;
  float iftmp.1679_81;
  const struct ImVec4 * iftmp.1688_82;
  bool iftmp.1689_83;
  bool iftmp.1691_84;
  const struct ImVec4 * iftmp.1693_85;
  bool _218;
  bool _219;
  int _221;
  int _222;
  int _224;
  int _225;
  int _230;
  int _232;
  int _234;
  int _236;
  const ImGuiID _241;
  float _245;
  float iftmp.1588_246;
  float iftmp.1588_247;
  float _248;
  float _249;
  float _250;
  float _252;
  float _253;
  struct ImVec2 * _256;
  struct ImVec2 * _258;
  float _261;
  float _262;
  float _263;
  float iftmp.1589_264;
  float iftmp.1589_265;
  bool _275;
  bool _276;
  bool retval.1590_277;
  bool _281;
  float _284;
  float _285;
  float _286;
  float _289;
  bool _292;
  bool _293;
  bool retval.1591_294;
  bool _295;
  const bool _297;
  struct ImFont * _300;
  const struct ImFontGlyph * _302;
  struct ImFont * _305;
  float _306;
  struct ImFont * _308;
  float _309;
  struct ImFont * _311;
  struct ImFont * _313;
  float _314;
  struct ImFont * _316;
  float _317;
  struct ImFont * _319;
  struct ImFontAtlas * _320;
  float _323;
  struct ImVector * _325;
  bool _327;
  struct ImVector * _328;
  bool _330;
  struct ImVector * _331;
  bool _333;
  int _337;
  bool _338;
  int _339;
  const bool _341;
  int _343;
  int _344;
  bool iftmp.1592_345;
  bool iftmp.1592_346;
  bool _348;
  bool iftmp.1593_349;
  bool iftmp.1593_350;
  bool _352;
  bool iftmp.1594_353;
  bool iftmp.1594_354;
  unsigned int _356;
  unsigned int _357;
  unsigned int _358;
  unsigned int _360;
  unsigned int _361;
  bool iftmp.1595_362;
  bool iftmp.1595_363;
  unsigned int _365;
  unsigned int _366;
  unsigned int _367;
  ImGuiInputSource _368;
  bool iftmp.1596_369;
  bool iftmp.1596_370;
  unsigned int _373;
  int _374;
  bool _375;
  bool iftmp.1597_376;
  bool iftmp.1597_377;
  bool _379;
  unsigned int _381;
  int _384;
  struct ImVector * _385;
  int _387;
  struct ImVector * _388;
  int _390;
  long unsigned int _391;
  char * _392;
  int _396;
  short unsigned int * _397;
  int _399;
  const char * buf_end.1598_401;
  long int buf_end.1599_402;
  long int buf.1600_403;
  long int _404;
  int _405;
  unsigned int _408;
  int _409;
  bool iftmp.1601_410;
  bool iftmp.1601_411;
  bool _416;
  int _417;
  struct STB_TexteditState * _418;
  bool _420;
  int _422;
  bool _424;
  bool _425;
  bool _432;
  int _433;
  int _434;
  int _435;
  unsigned int _439;
  bool _440;
  bool _441;
  bool _442;
  int _443;
  struct ImVector * _444;
  int _447;
  short unsigned int * _448;
  int _450;
  const char * buf_end.1602_452;
  long int buf_end.1603_453;
  long int buf.1604_454;
  long int _455;
  int _456;
  bool _462;
  bool _463;
  float _466;
  float _467;
  float _468;
  float _469;
  float _470;
  float _471;
  float _473;
  float _474;
  float _475;
  float _476;
  float iftmp.1605_477;
  float _478;
  float iftmp.1605_479;
  bool _482;
  bool _483;
  bool _484;
  bool _487;
  bool _488;
  bool _489;
  struct STB_TexteditState * _490;
  bool _493;
  bool _494;
  bool _495;
  float _496;
  float _497;
  struct STB_TexteditState * _498;
  bool _504;
  bool _505;
  bool _506;
  short unsigned int _508;
  bool _509;
  bool _510;
  bool _511;
  bool _512;
  short unsigned int _514;
  short unsigned int _515;
  unsigned int c.1606_516;
  bool _521;
  bool retval.1607_522;
  unsigned int c.1608_523;
  int c.1609_524;
  ImWchar[17] * _529;
  unsigned int _532;
  bool _533;
  bool _534;
  bool _535;
  bool _536;
  int iftmp.1610_537;
  int iftmp.1610_538;
  bool _540;
  bool _541;
  bool _542;
  bool _543;
  bool _544;
  bool _545;
  bool _546;
  bool _547;
  bool _548;
  bool _549;
  bool _550;
  bool iftmp.1611_551;
  bool iftmp.1611_552;
  bool _554;
  bool iftmp.1612_555;
  bool iftmp.1612_556;
  bool _558;
  bool _559;
  bool _560;
  bool _561;
  bool _562;
  bool _563;
  bool iftmp.1613_564;
  bool iftmp.1613_565;
  bool _567;
  bool _568;
  bool _569;
  bool _570;
  bool _571;
  bool _572;
  bool _573;
  bool iftmp.1614_574;
  bool iftmp.1614_575;
  bool _577;
  bool _578;
  bool _579;
  bool _580;
  bool _581;
  bool _582;
  bool _583;
  bool iftmp.1615_584;
  bool iftmp.1615_585;
  bool _588;
  bool _589;
  bool _591;
  bool _592;
  bool _593;
  bool _594;
  bool _596;
  bool iftmp.1616_597;
  bool iftmp.1616_598;
  bool _601;
  bool _602;
  bool _604;
  bool _605;
  bool _606;
  bool _607;
  bool _609;
  bool iftmp.1617_610;
  bool iftmp.1617_611;
  bool _614;
  bool _615;
  bool _617;
  bool _618;
  bool iftmp.1618_619;
  bool iftmp.1618_620;
  bool _623;
  bool retval.1619_624;
  int iftmp.1620_625;
  int iftmp.1621_626;
  int iftmp.1621_627;
  int iftmp.1620_628;
  int _629;
  bool _632;
  bool retval.1622_633;
  int iftmp.1623_634;
  int iftmp.1624_635;
  int iftmp.1624_636;
  int iftmp.1623_637;
  int _638;
  bool _641;
  bool _642;
  bool iftmp.1626_643;
  bool iftmp.1626_644;
  bool retval.1625_645;
  bool _646;
  float _647;
  float _648;
  float _649;
  float _651;
  int iftmp.1627_653;
  int iftmp.1627_654;
  int _655;
  bool _658;
  bool _659;
  bool iftmp.1629_660;
  bool iftmp.1629_661;
  bool retval.1628_662;
  bool _663;
  float _665;
  float _666;
  float _667;
  float _668;
  float _670;
  int iftmp.1630_672;
  int iftmp.1630_673;
  int _674;
  bool _677;
  bool retval.1631_678;
  bool _679;
  int iftmp.1632_680;
  int iftmp.1632_681;
  bool _684;
  bool retval.1633_685;
  bool _686;
  int iftmp.1634_687;
  int iftmp.1634_688;
  bool _691;
  bool _692;
  bool iftmp.1636_693;
  bool iftmp.1636_694;
  bool retval.1635_695;
  int _696;
  bool _699;
  bool _700;
  bool iftmp.1638_701;
  bool iftmp.1638_702;
  bool retval.1637_703;
  bool _705;
  bool retval.1639_706;
  bool _707;
  bool _708;
  bool _709;
  bool _710;
  bool _711;
  bool _712;
  int _715;
  bool _718;
  bool retval.1640_719;
  int _720;
  bool _722;
  bool _723;
  bool _724;
  bool _725;
  bool _726;
  bool _729;
  bool retval.1641_730;
  unsigned int c.1642_731;
  int c.1643_732;
  int _738;
  bool _740;
  bool _741;
  bool _742;
  bool _743;
  bool _744;
  bool _745;
  bool _746;
  bool _747;
  bool iftmp.1645_748;
  bool iftmp.1645_749;
  bool retval.1644_750;
  bool _753;
  bool retval.1646_754;
  unsigned int c.1647_755;
  int c.1648_756;
  bool _761;
  bool retval.1649_762;
  bool _766;
  bool _767;
  bool iftmp.1651_768;
  bool iftmp.1651_769;
  bool retval.1650_770;
  bool _774;
  bool _775;
  bool iftmp.1653_776;
  bool iftmp.1653_777;
  bool retval.1652_778;
  bool _782;
  bool _783;
  bool iftmp.1655_784;
  bool iftmp.1655_785;
  bool retval.1654_786;
  const char * _790;
  long unsigned int _792;
  int _794;
  long unsigned int _795;
  long unsigned int _796;
  ImWchar * _798;
  char _802;
  int _804;
  sizetype _805;
  unsigned int c.1659_807;
  unsigned int c.1662_808;
  bool _810;
  bool _811;
  bool _812;
  bool iftmp.1661_813;
  bool iftmp.1661_815;
  bool retval.1660_816;
  int clipboard_filtered_len.1663_817;
  long unsigned int _819;
  long unsigned int _820;
  ImWchar * _821;
  unsigned int c.1664_822;
  short unsigned int _823;
  long unsigned int _828;
  long unsigned int _829;
  ImWchar * _830;
  struct STB_TexteditState * _832;
  void (*<T877>) (void *, const char *) _836;
  bool _838;
  int _839;
  int _840;
  int iftmp.1656_842;
  int iftmp.1656_843;
  bool _846;
  int _847;
  int _848;
  int iftmp.1657_850;
  int iftmp.1657_851;
  int _853;
  int _854;
  int _855;
  struct ImVector * _856;
  short unsigned int * _858;
  long unsigned int _859;
  long unsigned int _860;
  short unsigned int * _861;
  short unsigned int * _862;
  long unsigned int _863;
  long unsigned int _864;
  short unsigned int * _865;
  int _866;
  char * _867;
  char * _869;
  bool _872;
  bool retval.1658_873;
  struct STB_TexteditState * _876;
  unsigned int _878;
  long unsigned int _879;
  char * _880;
  bool _883;
  int _884;
  bool iftmp.1665_885;
  bool iftmp.1665_886;
  int _888;
  int _889;
  struct ImVector * _890;
  short unsigned int * _892;
  int _893;
  char * _894;
  int _896;
  int _899;
  bool _901;
  bool _902;
  bool iftmp.1667_903;
  bool iftmp.1667_904;
  bool retval.1666_905;
  int _908;
  bool _910;
  bool _911;
  bool iftmp.1669_912;
  bool iftmp.1669_913;
  bool retval.1668_914;
  int _917;
  bool _919;
  bool _920;
  bool iftmp.1671_921;
  bool iftmp.1671_922;
  bool retval.1670_923;
  int _926;
  bool _932;
  char * _935;
  int _937;
  int _939;
  int _943;
  long unsigned int _944;
  long unsigned int _945;
  ImWchar * _946;
  int _948;
  int _951;
  long unsigned int _952;
  long unsigned int _953;
  ImWchar * _954;
  int _956;
  int _959;
  long unsigned int _960;
  long unsigned int _961;
  ImWchar * _962;
  int _964;
  char * _968;
  char * _969;
  int _970;
  int _971;
  int _972;
  int _973;
  char * _974;
  int _975;
  sizetype _976;
  char * _977;
  char * _978;
  int _980;
  int _982;
  char * _983;
  int _984;
  sizetype _985;
  char * _986;
  char * _987;
  int _989;
  int _991;
  char * _992;
  int _993;
  sizetype _994;
  char * _995;
  char * _996;
  int _998;
  bool _1000;
  int _1001;
  char * _1002;
  long unsigned int _1003;
  int _1004;
  char * _1005;
  int _1006;
  short unsigned int * _1007;
  int _1009;
  int _1011;
  char * _1021;
  int _1022;
  long unsigned int _1023;
  char * _1024;
  unsigned int _1027;
  unsigned int _1029;
  char * iftmp.1672_1030;
  char * iftmp.1672_1031;
  bool _1035;
  float _1036;
  unsigned int _1038;
  float _1040;
  float _1041;
  float _1042;
  float _1043;
  float _1044;
  float _1045;
  float _1046;
  float _1047;
  const struct ImVec2 * _1050;
  unsigned int _1053;
  unsigned int _1054;
  unsigned int _1056;
  unsigned int _1057;
  bool iftmp.1673_1058;
  bool iftmp.1673_1059;
  unsigned int _1061;
  int _1064;
  float _1065;
  float _1066;
  float _1067;
  float _1068;
  const struct ImVec4 * iftmp.1693_1072;
  const struct ImVec4 * iftmp.1693_1073;
  const char * buf_end.1694_1074;
  unsigned int _1076;
  float _1077;
  struct ImFont * _1078;
  struct ImDrawList * _1079;
  float _1083;
  float _1084;
  float _1085;
  int _1090;
  long unsigned int _1091;
  long unsigned int _1092;
  const ImWchar * _1093;
  int _1099;
  int _1100;
  int _1101;
  int _1102;
  int _1104;
  long unsigned int _1105;
  long unsigned int _1106;
  const ImWchar * _1107;
  int iftmp.1674_1111;
  int iftmp.1674_1112;
  short unsigned int _1116;
  short unsigned int _1117;
  int _1119;
  const ImWchar * _1120;
  bool retval.1675_1123;
  int _1124;
  const ImWchar * _1125;
  bool retval.1676_1128;
  int _1131;
  int _1133;
  const ImWchar * _1135;
  const ImWchar * _1136;
  const ImWchar * _1138;
  float _1140;
  int _1142;
  float _1143;
  float _1144;
  float _1145;
  int _1147;
  const ImWchar * _1148;
  const ImWchar * _1149;
  const ImWchar * _1151;
  float _1153;
  int _1155;
  float _1156;
  float _1157;
  float _1158;
  float _1160;
  float _1161;
  float _1162;
  float _1163;
  bool _1169;
  int _1170;
  float _1171;
  float _1173;
  float _1174;
  float _1175;
  float _1176;
  float _1178;
  int _1179;
  float _1180;
  float _1182;
  float _1183;
  float _1184;
  float _1185;
  float _1186;
  float _1187;
  float _1188;
  float _1189;
  int _1190;
  float _1191;
  float _1195;
  float _1196;
  float _1197;
  float _1198;
  float _1199;
  float _1200;
  float _1203;
  float _1204;
  float _1205;
  float _1206;
  float _1207;
  float _1209;
  float _1210;
  float _1211;
  float _1212;
  float _1215;
  float _1218;
  int _1220;
  int _1221;
  int _1222;
  int _1223;
  int _1225;
  long unsigned int _1226;
  long unsigned int _1227;
  int _1229;
  int _1230;
  int _1232;
  long unsigned int _1233;
  long unsigned int _1234;
  float iftmp.1678_1236;
  float iftmp.1678_1237;
  float iftmp.1679_1239;
  float iftmp.1679_1240;
  const ImWchar * p.1680_1248;
  float _1249;
  float _1250;
  float _1251;
  float _1252;
  float _1253;
  float _1254;
  const ImWchar * p.1681_1255;
  const ImWchar * p.1683_1256;
  const ImWchar * p.1684_1257;
  const ImWchar * p.1685_1258;
  short unsigned int _1260;
  bool retval.1682_1261;
  const ImWchar * p.1686_1262;
  float _1264;
  struct ImFont * _1265;
  float _1267;
  float _1268;
  float _1269;
  int _1270;
  float _1271;
  float _1273;
  float _1276;
  float _1277;
  bool retval.1687_1290;
  struct ImDrawList * _1292;
  float _1300;
  float _1301;
  float _1302;
  float _1304;
  float _1305;
  float _1306;
  const struct ImVec4 * iftmp.1688_1310;
  const struct ImVec4 * iftmp.1688_1311;
  int _1312;
  sizetype _1313;
  const char * _1314;
  unsigned int _1316;
  float _1318;
  struct ImFont * _1319;
  struct ImDrawList * _1320;
  bool _1323;
  bool _1324;
  float _1325;
  float _1326;
  float _1328;
  bool iftmp.1689_1329;
  bool iftmp.1689_1330;
  float _1335;
  float _1336;
  float _1337;
  float _1338;
  float _1339;
  float _1340;
  float _1341;
  float _1342;
  float _1343;
  bool _1347;
  bool iftmp.1691_1348;
  bool iftmp.1691_1349;
  bool retval.1690_1350;
  unsigned int _1353;
  struct ImDrawList * _1355;
  float _1359;
  float _1360;
  float _1361;
  float _1362;
  float _1363;
  float _1380;
  bool _1391;
  bool _1392;
  float _1394;
  float _1395;
  float _1396;
  float _1397;
  float _1398;
  float _1399;
  float _1400;
  int _1405;
  bool _1406;
  bool _1407;

  <bb 2>:
  window_217 = ImGui::GetCurrentWindow ();
  _218 = window_217->SkipItems;
  if (_218 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _219 = 0;
  goto <bb 526>;

  <bb 4>:
  _221 = flags_220(D) & 128;
  if (_221 == 0)
    goto <bb 7>;
  else
    goto <bb 5>;

  <bb 5>:
  _222 = flags_220(D) & 1048576;
  if (_222 == 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  __assert_fail ("!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9898, &__PRETTY_FUNCTION__);

  <bb 7>:
  _224 = flags_220(D) & 64;
  if (_224 == 0)
    goto <bb 10>;
  else
    goto <bb 8>;

  <bb 8>:
  _225 = flags_220(D) & 1024;
  if (_225 == 0)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  __assert_fail ("!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9899, &__PRETTY_FUNCTION__);

  <bb 10>:
  g_227 = GImGui;
  io_228 = &g_227->IO;
  style_229 = &g_227->Style;
  _230 = flags_220(D) & 1048576;
  is_multiline_231 = _230 != 0;
  _232 = flags_220(D) & 16384;
  is_editable_233 = _232 == 0;
  _234 = flags_220(D) & 32768;
  is_password_235 = _234 != 0;
  _236 = flags_220(D) & 65536;
  is_undoable_237 = _236 == 0;
  if (is_multiline_231 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  ImGui::BeginGroup ();

  <bb 12>:
  _241 = ImGuiWindow::GetID (window_217, label_239(D), 0B);
  id_242 = _241;
  label_size = ImGui::CalcTextSize (label_239(D), 0B, 1, -1.0e+0);
  if (is_multiline_231 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _245 = ImGui::GetTextLineHeight ();
  iftmp.1588_246 = _245 * 8.0e+0;
  goto <bb 15>;

  <bb 14>:
  iftmp.1588_247 = label_size.y;

  <bb 15>:
  # iftmp.1588_35 = PHI <iftmp.1588_246(13), iftmp.1588_247(14)>
  _248 = style_229->FramePadding.y;
  _249 = _248 * 2.0e+0;
  _250 = iftmp.1588_35 + _249;
  _252 = ImGui::CalcItemWidth ();
  _253 = _252;
  size = ImGui::CalcItemSize (*size_arg_254(D), _253, _250);
  _256 = &window_217->DC.CursorPos;
  D.20386 = operator+ (_256, &size);
  _258 = &window_217->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _258, &D.20386);
  D.20386 ={v} {CLOBBER};
  _261 = label_size.x;
  if (_261 > 0.0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _262 = style_229->ItemInnerSpacing.x;
  _263 = label_size.x;
  iftmp.1589_264 = _262 + _263;
  goto <bb 18>;

  <bb 17>:
  iftmp.1589_265 = 0.0;

  <bb 18>:
  # iftmp.1589_36 = PHI <iftmp.1589_264(16), iftmp.1589_265(17)>
  ImVec2::ImVec2 (&D.20388, iftmp.1589_36, 0.0);
  D.20389 = operator+ (&frame_bb.Max, &D.20388);
  ImRect::ImRect (&total_bb, &frame_bb.Min, &D.20389);
  D.20389 ={v} {CLOBBER};
  D.20388 ={v} {CLOBBER};
  draw_window_271 = window_217;
  if (is_multiline_231 != 0)
    goto <bb 19>;
  else
    goto <bb 22>;

  <bb 19>:
  ImGui::ItemAdd (&total_bb, id_242, &frame_bb);
  D.20391 = ImRect::GetSize (&frame_bb);
  _275 = ImGui::BeginChildFrame (id_242, &D.20391, 0);
  _276 = _275;
  retval.1590_277 = ~_276;
  D.20391 ={v} {CLOBBER};
  if (retval.1590_277 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  ImGui::EndChildFrame ();
  ImGui::EndGroup ();
  _281 = 0;
  goto <bb 526>;

  <bb 21>:
  draw_window_283 = ImGui::GetCurrentWindow ();
  _284 = size.x;
  _285 = draw_window_283->ScrollbarSizes.x;
  _286 = _284 - _285;
  size.x = _286;
  goto <bb 24>;

  <bb 22>:
  _289 = style_229->FramePadding.y;
  ImGui::ItemSize (&total_bb, _289);
  _292 = ImGui::ItemAdd (&total_bb, id_242, &frame_bb);
  _293 = _292;
  retval.1591_294 = ~_293;
  if (retval.1591_294 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _295 = 0;
  goto <bb 526>;

  <bb 24>:
  # draw_window_1 = PHI <draw_window_283(21), draw_window_271(22)>
  _297 = ImGui::ItemHoverable (&frame_bb, id_242);
  hovered_298 = _297;
  if (hovered_298 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  g_227->MouseCursor = 1;

  <bb 26>:
  if (is_password_235 != 0)
    goto <bb 27>;
  else
    goto <bb 33>;

  <bb 27>:
  _300 = g_227->Font;
  _302 = ImFont::FindGlyph (_300, 42);
  glyph_303 = _302;
  password_font_304 = &g_227->InputTextPasswordFont;
  _305 = g_227->Font;
  _306 = _305->FontSize;
  password_font_304->FontSize = _306;
  _308 = g_227->Font;
  _309 = _308->Scale;
  password_font_304->Scale = _309;
  _311 = g_227->Font;
  password_font_304->DisplayOffset = _311->DisplayOffset;
  _313 = g_227->Font;
  _314 = _313->Ascent;
  password_font_304->Ascent = _314;
  _316 = g_227->Font;
  _317 = _316->Descent;
  password_font_304->Descent = _317;
  _319 = g_227->Font;
  _320 = _319->ContainerAtlas;
  password_font_304->ContainerAtlas = _320;
  password_font_304->FallbackGlyph = glyph_303;
  _323 = glyph_303->AdvanceX;
  password_font_304->FallbackAdvanceX = _323;
  _325 = &password_font_304->Glyphs;
  _327 = ImVector<ImFontGlyph>::empty (_325);
  if (_327 != 0)
    goto <bb 28>;
  else
    goto <bb 31>;

  <bb 28>:
  _328 = &password_font_304->IndexAdvanceX;
  _330 = ImVector<float>::empty (_328);
  if (_330 != 0)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 29>:
  _331 = &password_font_304->IndexLookup;
  _333 = ImVector<short unsigned int>::empty (_331);
  if (_333 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  goto <bb 32>;

  <bb 31>:
  __assert_fail ("password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty()", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 9954, &__PRETTY_FUNCTION__);

  <bb 32>:
  ImGui::PushFont (password_font_304);

  <bb 33>:
  edit_state_336 = &g_227->InputTextState;
  _337 = flags_220(D) & 1088;
  _338 = _337 == 0;
  _339 = (int) _338;
  _341 = ImGui::FocusableItemRegister (window_217, id_242, _339);
  focus_requested_342 = _341;
  if (focus_requested_342 != 0)
    goto <bb 34>;
  else
    goto <bb 36>;

  <bb 34>:
  _343 = window_217->FocusIdxAllCounter;
  _344 = window_217->FocusIdxAllRequestCurrent;
  if (_343 == _344)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  iftmp.1592_345 = 1;
  goto <bb 37>;

  <bb 36>:
  iftmp.1592_346 = 0;

  <bb 37>:
  # iftmp.1592_37 = PHI <iftmp.1592_345(35), iftmp.1592_346(36)>
  focus_requested_by_code_347 = iftmp.1592_37;
  if (focus_requested_342 != 0)
    goto <bb 38>;
  else
    goto <bb 40>;

  <bb 38>:
  _348 = ~focus_requested_by_code_347;
  if (_348 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  iftmp.1593_349 = 1;
  goto <bb 41>;

  <bb 40>:
  iftmp.1593_350 = 0;

  <bb 41>:
  # iftmp.1593_38 = PHI <iftmp.1593_349(39), iftmp.1593_350(40)>
  focus_requested_by_tab_351 = iftmp.1593_38;
  if (hovered_298 != 0)
    goto <bb 42>;
  else
    goto <bb 44>;

  <bb 42>:
  _352 = io_228->MouseClicked[0];
  if (_352 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  iftmp.1594_353 = 1;
  goto <bb 45>;

  <bb 44>:
  iftmp.1594_354 = 0;

  <bb 45>:
  # iftmp.1594_39 = PHI <iftmp.1594_353(43), iftmp.1594_354(44)>
  user_clicked_355 = iftmp.1594_39;
  if (is_multiline_231 != 0)
    goto <bb 46>;
  else
    goto <bb 50>;

  <bb 46>:
  _356 = g_227->ActiveId;
  if (_356 == 0)
    goto <bb 47>;
  else
    goto <bb 50>;

  <bb 47>:
  _357 = edit_state_336->Id;
  if (_357 == id_242)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  _358 = g_227->ActiveIdPreviousFrame;
  _360 = ImGuiWindow::GetIDNoKeepAlive (draw_window_1, "#SCROLLY", 0B);
  _361 = _360;
  if (_358 == _361)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  iftmp.1595_362 = 1;
  goto <bb 51>;

  <bb 50>:
  iftmp.1595_363 = 0;

  <bb 51>:
  # iftmp.1595_40 = PHI <iftmp.1595_362(49), iftmp.1595_363(50)>
  user_scrolled_364 = iftmp.1595_40;
  _365 = g_227->ActiveId;
  if (_365 != id_242)
    goto <bb 52>;
  else
    goto <bb 56>;

  <bb 52>:
  _366 = g_227->NavInputId;
  if (_366 == id_242)
    goto <bb 55>;
  else
    goto <bb 53>;

  <bb 53>:
  _367 = g_227->NavActivateId;
  if (_367 == id_242)
    goto <bb 54>;
  else
    goto <bb 56>;

  <bb 54>:
  _368 = g_227->NavInputSource;
  if (_368 == 3)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  iftmp.1596_369 = 1;
  goto <bb 57>;

  <bb 56>:
  iftmp.1596_370 = 0;

  <bb 57>:
  # iftmp.1596_41 = PHI <iftmp.1596_369(55), iftmp.1596_370(56)>
  user_nav_input_start_371 = iftmp.1596_41;
  clear_active_id_372 = 0;
  _373 = g_227->ActiveId;
  if (_373 != id_242)
    goto <bb 58>;
  else
    goto <bb 62>;

  <bb 58>:
  _374 = flags_220(D) & 16;
  if (_374 != 0)
    goto <bb 60>;
  else
    goto <bb 59>;

  <bb 59>:
  if (user_nav_input_start_371 != 0)
    goto <bb 60>;
  else
    goto <bb 62>;

  <bb 60>:
  _375 = ~is_multiline_231;
  if (_375 != 0)
    goto <bb 61>;
  else
    goto <bb 62>;

  <bb 61>:
  iftmp.1597_376 = 1;
  goto <bb 63>;

  <bb 62>:
  iftmp.1597_377 = 0;

  <bb 63>:
  # iftmp.1597_42 = PHI <iftmp.1597_376(61), iftmp.1597_377(62)>
  select_all_378 = iftmp.1597_42;
  if (focus_requested_342 != 0)
    goto <bb 67>;
  else
    goto <bb 64>;

  <bb 64>:
  if (user_clicked_355 != 0)
    goto <bb 67>;
  else
    goto <bb 65>;

  <bb 65>:
  if (user_scrolled_364 != 0)
    goto <bb 67>;
  else
    goto <bb 66>;

  <bb 66>:
  if (user_nav_input_start_371 != 0)
    goto <bb 67>;
  else
    goto <bb 89>;

  <bb 67>:
  _381 = g_227->ActiveId;
  if (_381 != id_242)
    goto <bb 68>;
  else
    goto <bb 85>;

  <bb 68>:
  prev_len_w_382 = edit_state_336->CurLenW;
  _384 = buf_size_383(D) + 1;
  _385 = &edit_state_336->Text;
  ImVector<short unsigned int>::resize (_385, _384);
  _387 = buf_size_383(D) + 1;
  _388 = &edit_state_336->InitialText;
  ImVector<char>::resize (_388, _387);
  _390 = edit_state_336->InitialText.Size;
  _391 = (long unsigned int) _390;
  _392 = edit_state_336->InitialText.Data;
  ImStrncpy (_392, buf_393(D), _391);
  buf_end = 0B;
  _396 = edit_state_336->Text.Size;
  _397 = edit_state_336->Text.Data;
  _399 = ImTextStrFromUtf8 (_397, _396, buf_393(D), 0B, &buf_end);
  edit_state_336->CurLenW = _399;
  buf_end.1598_401 = buf_end;
  buf_end.1599_402 = (long int) buf_end.1598_401;
  buf.1600_403 = (long int) buf_393(D);
  _404 = buf_end.1599_402 - buf.1600_403;
  _405 = (int) _404;
  edit_state_336->CurLenA = _405;
  ImGuiTextEditState::CursorAnimReset (edit_state_336);
  _408 = edit_state_336->Id;
  if (_408 == id_242)
    goto <bb 69>;
  else
    goto <bb 71>;

  <bb 69>:
  _409 = edit_state_336->CurLenW;
  if (_409 == prev_len_w_382)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  iftmp.1601_410 = 1;
  goto <bb 72>;

  <bb 71>:
  iftmp.1601_411 = 0;

  <bb 72>:
  # iftmp.1601_43 = PHI <iftmp.1601_410(70), iftmp.1601_411(71)>
  recycle_state_412 = iftmp.1601_43;
  if (recycle_state_412 != 0)
    goto <bb 73>;
  else
    goto <bb 74>;

  <bb 73>:
  ImGuiTextEditState::CursorClamp (edit_state_336);
  goto <bb 77>;

  <bb 74>:
  edit_state_336->Id = id_242;
  edit_state_336->ScrollX = 0.0;
  _416 = ~is_multiline_231;
  _417 = (int) _416;
  _418 = &edit_state_336->StbState;
  ImGuiStb::stb_textedit_initialize_state (_418, _417);
  _420 = ~is_multiline_231;
  if (_420 != 0)
    goto <bb 75>;
  else
    goto <bb 77>;

  <bb 75>:
  if (focus_requested_by_code_347 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  select_all_421 = 1;

  <bb 77>:
  # select_all_6 = PHI <select_all_378(73), select_all_378(74), select_all_378(75), select_all_421(76)>
  _422 = flags_220(D) & 8192;
  if (_422 != 0)
    goto <bb 78>;
  else
    goto <bb 79>;

  <bb 78>:
  edit_state_336->StbState.insert_mode = 1;

  <bb 79>:
  _424 = ~is_multiline_231;
  if (_424 != 0)
    goto <bb 80>;
  else
    goto <bb 84>;

  <bb 80>:
  if (focus_requested_by_tab_351 != 0)
    goto <bb 83>;
  else
    goto <bb 81>;

  <bb 81>:
  if (user_clicked_355 != 0)
    goto <bb 82>;
  else
    goto <bb 84>;

  <bb 82>:
  _425 = io_228->KeyCtrl;
  if (_425 != 0)
    goto <bb 83>;
  else
    goto <bb 84>;

  <bb 83>:
  select_all_426 = 1;

  <bb 84>:
  # select_all_7 = PHI <select_all_6(79), select_all_6(81), select_all_6(82), select_all_426(83)>
  buf_end ={v} {CLOBBER};

  <bb 85>:
  # select_all_8 = PHI <select_all_378(67), select_all_7(84)>
  ImGui::SetActiveID (id_242, window_217);
  ImGui::SetFocusID (id_242, window_217);
  ImGui::FocusWindow (window_217);
  _432 = ~is_multiline_231;
  if (_432 != 0)
    goto <bb 86>;
  else
    goto <bb 88>;

  <bb 86>:
  _433 = flags_220(D) & 128;
  if (_433 == 0)
    goto <bb 87>;
  else
    goto <bb 88>;

  <bb 87>:
  _434 = g_227->ActiveIdAllowNavDirFlags;
  _435 = _434 | 12;
  g_227->ActiveIdAllowNavDirFlags = _435;

  <bb 88>:
  goto <bb 91>;

  <bb 89>:
  _379 = io_228->MouseClicked[0];
  if (_379 != 0)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  clear_active_id_380 = 1;

  <bb 91>:
  # clear_active_id_2 = PHI <clear_active_id_372(88), clear_active_id_372(89), clear_active_id_380(90)>
  # select_all_9 = PHI <select_all_8(88), select_all_378(89), select_all_378(90)>
  value_changed_437 = 0;
  enter_pressed_438 = 0;
  _439 = g_227->ActiveId;
  if (_439 == id_242)
    goto <bb 92>;
  else
    goto <bb 134>;

  <bb 92>:
  _440 = ~is_editable_233;
  if (_440 != 0)
    goto <bb 93>;
  else
    goto <bb 95>;

  <bb 93>:
  _441 = g_227->ActiveIdIsJustActivated;
  _442 = ~_441;
  if (_442 != 0)
    goto <bb 94>;
  else
    goto <bb 95>;

  <bb 94>:
  _443 = buf_size_383(D) + 1;
  _444 = &edit_state_336->Text;
  ImVector<short unsigned int>::resize (_444, _443);
  buf_end = 0B;
  _447 = edit_state_336->Text.Size;
  _448 = edit_state_336->Text.Data;
  _450 = ImTextStrFromUtf8 (_448, _447, buf_393(D), 0B, &buf_end);
  edit_state_336->CurLenW = _450;
  buf_end.1602_452 = buf_end;
  buf_end.1603_453 = (long int) buf_end.1602_452;
  buf.1604_454 = (long int) buf_393(D);
  _455 = buf_end.1603_453 - buf.1604_454;
  _456 = (int) _455;
  edit_state_336->CurLenA = _456;
  ImGuiTextEditState::CursorClamp (edit_state_336);
  buf_end ={v} {CLOBBER};

  <bb 95>:
  edit_state_336->BufSizeA = buf_size_383(D);
  _462 = io_228->MouseDown[0];
  _463 = ~_462;
  g_227->ActiveIdAllowOverlap = _463;
  g_227->WantTextInputNextFrame = 1;
  _466 = io_228->MousePos.x;
  _467 = frame_bb.Min.x;
  _468 = _466 - _467;
  _469 = style_229->FramePadding.x;
  _470 = _468 - _469;
  _471 = edit_state_336->ScrollX;
  mouse_x_472 = _470 + _471;
  if (is_multiline_231 != 0)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  _473 = io_228->MousePos.y;
  _474 = draw_window_1->DC.CursorPos.y;
  _475 = _473 - _474;
  _476 = style_229->FramePadding.y;
  iftmp.1605_477 = _475 - _476;
  goto <bb 98>;

  <bb 97>:
  _478 = g_227->FontSize;
  iftmp.1605_479 = _478 * 5.0e-1;

  <bb 98>:
  # iftmp.1605_44 = PHI <iftmp.1605_477(96), iftmp.1605_479(97)>
  mouse_y_480 = iftmp.1605_44;
  osx_double_click_selects_words_481 = io_228->OptMacOSXBehaviors;
  if (select_all_9 != 0)
    goto <bb 102>;
  else
    goto <bb 99>;

  <bb 99>:
  if (hovered_298 != 0)
    goto <bb 100>;
  else
    goto <bb 103>;

  <bb 100>:
  _482 = ~osx_double_click_selects_words_481;
  if (_482 != 0)
    goto <bb 101>;
  else
    goto <bb 103>;

  <bb 101>:
  _483 = io_228->MouseDoubleClicked[0];
  if (_483 != 0)
    goto <bb 102>;
  else
    goto <bb 103>;

  <bb 102>:
  ImGuiTextEditState::SelectAll (edit_state_336);
  edit_state_336->SelectedAllMouseLock = 1;
  goto <bb 117>;

  <bb 103>:
  if (hovered_298 != 0)
    goto <bb 104>;
  else
    goto <bb 107>;

  <bb 104>:
  if (osx_double_click_selects_words_481 != 0)
    goto <bb 105>;
  else
    goto <bb 107>;

  <bb 105>:
  _484 = io_228->MouseDoubleClicked[0];
  if (_484 != 0)
    goto <bb 106>;
  else
    goto <bb 107>;

  <bb 106>:
  ImGuiTextEditState::OnKeyPressed (edit_state_336, 65548);
  ImGuiTextEditState::OnKeyPressed (edit_state_336, 196621);
  goto <bb 117>;

  <bb 107>:
  _487 = io_228->MouseClicked[0];
  if (_487 != 0)
    goto <bb 108>;
  else
    goto <bb 112>;

  <bb 108>:
  _488 = edit_state_336->SelectedAllMouseLock;
  _489 = ~_488;
  if (_489 != 0)
    goto <bb 109>;
  else
    goto <bb 112>;

  <bb 109>:
  if (hovered_298 != 0)
    goto <bb 110>;
  else
    goto <bb 111>;

  <bb 110>:
  _490 = &edit_state_336->StbState;
  ImGuiStb::stb_textedit_click (edit_state_336, _490, mouse_x_472, mouse_y_480);
  ImGuiTextEditState::CursorAnimReset (edit_state_336);

  <bb 111>:
  goto <bb 117>;

  <bb 112>:
  _493 = io_228->MouseDown[0];
  if (_493 != 0)
    goto <bb 113>;
  else
    goto <bb 117>;

  <bb 113>:
  _494 = edit_state_336->SelectedAllMouseLock;
  _495 = ~_494;
  if (_495 != 0)
    goto <bb 114>;
  else
    goto <bb 117>;

  <bb 114>:
  _496 = io_228->MouseDelta.x;
  if (_496 != 0.0)
    goto <bb 116>;
  else
    goto <bb 115>;

  <bb 115>:
  _497 = io_228->MouseDelta.y;
  if (_497 != 0.0)
    goto <bb 116>;
  else
    goto <bb 117>;

  <bb 116>:
  _498 = &edit_state_336->StbState;
  ImGuiStb::stb_textedit_drag (edit_state_336, _498, mouse_x_472, mouse_y_480);
  ImGuiTextEditState::CursorAnimReset (edit_state_336);
  edit_state_336->CursorFollow = 1;

  <bb 117>:
  _504 = edit_state_336->SelectedAllMouseLock;
  if (_504 != 0)
    goto <bb 118>;
  else
    goto <bb 120>;

  <bb 118>:
  _505 = io_228->MouseDown[0];
  _506 = ~_505;
  if (_506 != 0)
    goto <bb 119>;
  else
    goto <bb 120>;

  <bb 119>:
  edit_state_336->SelectedAllMouseLock = 0;

  <bb 120>:
  _508 = io_228->InputCharacters[0];
  if (_508 != 0)
    goto <bb 121>;
  else
    goto <bb 133>;

  <bb 121>:
  _509 = io_228->KeyCtrl;
  _510 = ~_509;
  if (_510 != 0)
    goto <bb 123>;
  else
    goto <bb 122>;

  <bb 122>:
  _511 = io_228->KeyAlt;
  if (_511 != 0)
    goto <bb 123>;
  else
    goto <bb 132>;

  <bb 123>:
  if (is_editable_233 != 0)
    goto <bb 124>;
  else
    goto <bb 132>;

  <bb 124>:
  _512 = ~user_nav_input_start_371;
  if (_512 != 0)
    goto <bb 125>;
  else
    goto <bb 132>;

  <bb 125>:
  n_513 = 0;

  <bb 126>:
  # n_17 = PHI <n_513(125), n_527(130)>
  if (n_17 > 16)
    goto <bb 131>;
  else
    goto <bb 127>;

  <bb 127>:
  _514 = io_228->InputCharacters[n_17];
  if (_514 == 0)
    goto <bb 131>;
  else
    goto <bb 128>;

  <bb 128>:
  _515 = io_228->InputCharacters[n_17];
  c.1606_516 = (unsigned int) _515;
  c = c.1606_516;
  _521 = InputTextFilterCharacter (&c, flags_220(D), callback_518(D), user_data_519(D));
  retval.1607_522 = _521;
  if (retval.1607_522 != 0)
    goto <bb 129>;
  else
    goto <bb 130>;

  <bb 129>:
  c.1608_523 = c;
  c.1609_524 = (int) c.1608_523;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, c.1609_524);

  <bb 130>:
  c ={v} {CLOBBER};
  n_527 = n_17 + 1;
  goto <bb 126>;

  <bb 131>:

  <bb 132>:
  _529 = &g_227->IO.InputCharacters;
  memset (_529, 0, 34);

  <bb 133>:

  <bb 134>:
  cancel_edit_531 = 0;
  _532 = g_227->ActiveId;
  if (_532 == id_242)
    goto <bb 135>;
  else
    goto <bb 348>;

  <bb 135>:
  _533 = g_227->ActiveIdIsJustActivated;
  _534 = ~_533;
  if (_534 != 0)
    goto <bb 136>;
  else
    goto <bb 348>;

  <bb 136>:
  _535 = ~clear_active_id_2;
  if (_535 != 0)
    goto <bb 137>;
  else
    goto <bb 348>;

  <bb 137>:
  _536 = io_228->KeyShift;
  if (_536 != 0)
    goto <bb 138>;
  else
    goto <bb 139>;

  <bb 138>:
  iftmp.1610_537 = 131072;
  goto <bb 140>;

  <bb 139>:
  iftmp.1610_538 = 0;

  <bb 140>:
  # iftmp.1610_45 = PHI <iftmp.1610_537(138), iftmp.1610_538(139)>
  k_mask_539 = iftmp.1610_45;
  _540 = io_228->OptMacOSXBehaviors;
  if (_540 != 0)
    goto <bb 141>;
  else
    goto <bb 143>;

  <bb 141>:
  _541 = io_228->KeySuper;
  if (_541 != 0)
    goto <bb 142>;
  else
    goto <bb 148>;

  <bb 142>:
  _542 = io_228->KeyCtrl;
  _543 = ~_542;
  if (_543 != 0)
    goto <bb 145>;
  else
    goto <bb 148>;

  <bb 143>:
  _544 = io_228->KeyCtrl;
  if (_544 != 0)
    goto <bb 144>;
  else
    goto <bb 148>;

  <bb 144>:
  _545 = io_228->KeySuper;
  _546 = ~_545;
  if (_546 != 0)
    goto <bb 145>;
  else
    goto <bb 148>;

  <bb 145>:
  _547 = io_228->KeyAlt;
  _548 = ~_547;
  if (_548 != 0)
    goto <bb 146>;
  else
    goto <bb 148>;

  <bb 146>:
  _549 = io_228->KeyShift;
  _550 = ~_549;
  if (_550 != 0)
    goto <bb 147>;
  else
    goto <bb 148>;

  <bb 147>:
  iftmp.1611_551 = 1;
  goto <bb 149>;

  <bb 148>:
  iftmp.1611_552 = 0;

  <bb 149>:
  # iftmp.1611_46 = PHI <iftmp.1611_551(147), iftmp.1611_552(148)>
  is_shortcut_key_only_553 = iftmp.1611_46;
  _554 = io_228->OptMacOSXBehaviors;
  if (_554 != 0)
    goto <bb 150>;
  else
    goto <bb 151>;

  <bb 150>:
  iftmp.1612_555 = io_228->KeyAlt;
  goto <bb 152>;

  <bb 151>:
  iftmp.1612_556 = io_228->KeyCtrl;

  <bb 152>:
  # iftmp.1612_47 = PHI <iftmp.1612_555(150), iftmp.1612_556(151)>
  is_wordmove_key_down_557 = iftmp.1612_47;
  _558 = io_228->OptMacOSXBehaviors;
  if (_558 != 0)
    goto <bb 153>;
  else
    goto <bb 157>;

  <bb 153>:
  _559 = io_228->KeySuper;
  if (_559 != 0)
    goto <bb 154>;
  else
    goto <bb 157>;

  <bb 154>:
  _560 = io_228->KeyCtrl;
  _561 = ~_560;
  if (_561 != 0)
    goto <bb 155>;
  else
    goto <bb 157>;

  <bb 155>:
  _562 = io_228->KeyAlt;
  _563 = ~_562;
  if (_563 != 0)
    goto <bb 156>;
  else
    goto <bb 157>;

  <bb 156>:
  iftmp.1613_564 = 1;
  goto <bb 158>;

  <bb 157>:
  iftmp.1613_565 = 0;

  <bb 158>:
  # iftmp.1613_48 = PHI <iftmp.1613_564(156), iftmp.1613_565(157)>
  is_startend_key_down_566 = iftmp.1613_48;
  _567 = io_228->KeyCtrl;
  if (_567 != 0)
    goto <bb 159>;
  else
    goto <bb 163>;

  <bb 159>:
  _568 = io_228->KeyShift;
  _569 = ~_568;
  if (_569 != 0)
    goto <bb 160>;
  else
    goto <bb 163>;

  <bb 160>:
  _570 = io_228->KeyAlt;
  _571 = ~_570;
  if (_571 != 0)
    goto <bb 161>;
  else
    goto <bb 163>;

  <bb 161>:
  _572 = io_228->KeySuper;
  _573 = ~_572;
  if (_573 != 0)
    goto <bb 162>;
  else
    goto <bb 163>;

  <bb 162>:
  iftmp.1614_574 = 1;
  goto <bb 164>;

  <bb 163>:
  iftmp.1614_575 = 0;

  <bb 164>:
  # iftmp.1614_49 = PHI <iftmp.1614_574(162), iftmp.1614_575(163)>
  is_ctrl_key_only_576 = iftmp.1614_49;
  _577 = io_228->KeyShift;
  if (_577 != 0)
    goto <bb 165>;
  else
    goto <bb 169>;

  <bb 165>:
  _578 = io_228->KeyCtrl;
  _579 = ~_578;
  if (_579 != 0)
    goto <bb 166>;
  else
    goto <bb 169>;

  <bb 166>:
  _580 = io_228->KeyAlt;
  _581 = ~_580;
  if (_581 != 0)
    goto <bb 167>;
  else
    goto <bb 169>;

  <bb 167>:
  _582 = io_228->KeySuper;
  _583 = ~_582;
  if (_583 != 0)
    goto <bb 168>;
  else
    goto <bb 169>;

  <bb 168>:
  iftmp.1615_584 = 1;
  goto <bb 170>;

  <bb 169>:
  iftmp.1615_585 = 0;

  <bb 170>:
  # iftmp.1615_50 = PHI <iftmp.1615_584(168), iftmp.1615_585(169)>
  is_shift_key_only_586 = iftmp.1615_50;
  if (is_shortcut_key_only_553 != 0)
    goto <bb 171>;
  else
    goto <bb 172>;

  <bb 171>:
  _588 = IsKeyPressedMap (18, 1);
  _589 = _588;
  if (_589 != 0)
    goto <bb 174>;
  else
    goto <bb 172>;

  <bb 172>:
  if (is_shift_key_only_586 != 0)
    goto <bb 173>;
  else
    goto <bb 179>;

  <bb 173>:
  _591 = IsKeyPressedMap (10, 1);
  _592 = _591;
  if (_592 != 0)
    goto <bb 174>;
  else
    goto <bb 179>;

  <bb 174>:
  if (is_editable_233 != 0)
    goto <bb 175>;
  else
    goto <bb 179>;

  <bb 175>:
  _593 = ~is_password_235;
  if (_593 != 0)
    goto <bb 176>;
  else
    goto <bb 179>;

  <bb 176>:
  _594 = ~is_multiline_231;
  if (_594 != 0)
    goto <bb 178>;
  else
    goto <bb 177>;

  <bb 177>:
  _596 = ImGuiTextEditState::HasSelection (edit_state_336);
  if (_596 != 0)
    goto <bb 178>;
  else
    goto <bb 179>;

  <bb 178>:
  iftmp.1616_597 = 1;
  goto <bb 180>;

  <bb 179>:
  iftmp.1616_598 = 0;

  <bb 180>:
  # iftmp.1616_51 = PHI <iftmp.1616_597(178), iftmp.1616_598(179)>
  is_cut_599 = iftmp.1616_51;
  if (is_shortcut_key_only_553 != 0)
    goto <bb 181>;
  else
    goto <bb 182>;

  <bb 181>:
  _601 = IsKeyPressedMap (16, 1);
  _602 = _601;
  if (_602 != 0)
    goto <bb 184>;
  else
    goto <bb 182>;

  <bb 182>:
  if (is_ctrl_key_only_576 != 0)
    goto <bb 183>;
  else
    goto <bb 188>;

  <bb 183>:
  _604 = IsKeyPressedMap (9, 1);
  _605 = _604;
  if (_605 != 0)
    goto <bb 184>;
  else
    goto <bb 188>;

  <bb 184>:
  _606 = ~is_password_235;
  if (_606 != 0)
    goto <bb 185>;
  else
    goto <bb 188>;

  <bb 185>:
  _607 = ~is_multiline_231;
  if (_607 != 0)
    goto <bb 187>;
  else
    goto <bb 186>;

  <bb 186>:
  _609 = ImGuiTextEditState::HasSelection (edit_state_336);
  if (_609 != 0)
    goto <bb 187>;
  else
    goto <bb 188>;

  <bb 187>:
  iftmp.1617_610 = 1;
  goto <bb 189>;

  <bb 188>:
  iftmp.1617_611 = 0;

  <bb 189>:
  # iftmp.1617_52 = PHI <iftmp.1617_610(187), iftmp.1617_611(188)>
  is_copy_612 = iftmp.1617_52;
  if (is_shortcut_key_only_553 != 0)
    goto <bb 190>;
  else
    goto <bb 191>;

  <bb 190>:
  _614 = IsKeyPressedMap (17, 1);
  _615 = _614;
  if (_615 != 0)
    goto <bb 193>;
  else
    goto <bb 191>;

  <bb 191>:
  if (is_shift_key_only_586 != 0)
    goto <bb 192>;
  else
    goto <bb 195>;

  <bb 192>:
  _617 = IsKeyPressedMap (9, 1);
  _618 = _617;
  if (_618 != 0)
    goto <bb 193>;
  else
    goto <bb 195>;

  <bb 193>:
  if (is_editable_233 != 0)
    goto <bb 194>;
  else
    goto <bb 195>;

  <bb 194>:
  iftmp.1618_619 = 1;
  goto <bb 196>;

  <bb 195>:
  iftmp.1618_620 = 0;

  <bb 196>:
  # iftmp.1618_53 = PHI <iftmp.1618_619(194), iftmp.1618_620(195)>
  is_paste_621 = iftmp.1618_53;
  _623 = IsKeyPressedMap (1, 1);
  retval.1619_624 = _623;
  if (retval.1619_624 != 0)
    goto <bb 197>;
  else
    goto <bb 204>;

  <bb 197>:
  if (is_startend_key_down_566 != 0)
    goto <bb 198>;
  else
    goto <bb 199>;

  <bb 198>:
  iftmp.1620_625 = 65540;
  goto <bb 203>;

  <bb 199>:
  if (is_wordmove_key_down_557 != 0)
    goto <bb 200>;
  else
    goto <bb 201>;

  <bb 200>:
  iftmp.1621_626 = 65548;
  goto <bb 202>;

  <bb 201>:
  iftmp.1621_627 = 65536;

  <bb 202>:
  # iftmp.1621_55 = PHI <iftmp.1621_626(200), iftmp.1621_627(201)>
  iftmp.1620_628 = iftmp.1621_55;

  <bb 203>:
  # iftmp.1620_54 = PHI <iftmp.1620_625(198), iftmp.1620_628(202)>
  _629 = iftmp.1620_54 | k_mask_539;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, _629);
  goto <bb 347>;

  <bb 204>:
  _632 = IsKeyPressedMap (2, 1);
  retval.1622_633 = _632;
  if (retval.1622_633 != 0)
    goto <bb 205>;
  else
    goto <bb 212>;

  <bb 205>:
  if (is_startend_key_down_566 != 0)
    goto <bb 206>;
  else
    goto <bb 207>;

  <bb 206>:
  iftmp.1623_634 = 65541;
  goto <bb 211>;

  <bb 207>:
  if (is_wordmove_key_down_557 != 0)
    goto <bb 208>;
  else
    goto <bb 209>;

  <bb 208>:
  iftmp.1624_635 = 65549;
  goto <bb 210>;

  <bb 209>:
  iftmp.1624_636 = 65537;

  <bb 210>:
  # iftmp.1624_57 = PHI <iftmp.1624_635(208), iftmp.1624_636(209)>
  iftmp.1623_637 = iftmp.1624_57;

  <bb 211>:
  # iftmp.1623_56 = PHI <iftmp.1623_634(206), iftmp.1623_637(210)>
  _638 = iftmp.1623_56 | k_mask_539;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, _638);
  goto <bb 347>;

  <bb 212>:
  _641 = IsKeyPressedMap (3, 1);
  _642 = _641;
  if (_642 != 0)
    goto <bb 213>;
  else
    goto <bb 215>;

  <bb 213>:
  if (is_multiline_231 != 0)
    goto <bb 214>;
  else
    goto <bb 215>;

  <bb 214>:
  iftmp.1626_643 = 1;
  goto <bb 216>;

  <bb 215>:
  iftmp.1626_644 = 0;

  <bb 216>:
  # iftmp.1626_58 = PHI <iftmp.1626_643(214), iftmp.1626_644(215)>
  retval.1625_645 = iftmp.1626_58;
  if (retval.1625_645 != 0)
    goto <bb 217>;
  else
    goto <bb 224>;

  <bb 217>:
  _646 = io_228->KeyCtrl;
  if (_646 != 0)
    goto <bb 218>;
  else
    goto <bb 219>;

  <bb 218>:
  _647 = draw_window_1->Scroll.y;
  _648 = g_227->FontSize;
  _649 = _647 - _648;
  _651 = ImMax (_649, 0.0);
  SetWindowScrollY (draw_window_1, _651);
  goto <bb 223>;

  <bb 219>:
  if (is_startend_key_down_566 != 0)
    goto <bb 220>;
  else
    goto <bb 221>;

  <bb 220>:
  iftmp.1627_653 = 65542;
  goto <bb 222>;

  <bb 221>:
  iftmp.1627_654 = 65538;

  <bb 222>:
  # iftmp.1627_59 = PHI <iftmp.1627_653(220), iftmp.1627_654(221)>
  _655 = iftmp.1627_59 | k_mask_539;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, _655);

  <bb 223>:
  goto <bb 347>;

  <bb 224>:
  _658 = IsKeyPressedMap (4, 1);
  _659 = _658;
  if (_659 != 0)
    goto <bb 225>;
  else
    goto <bb 227>;

  <bb 225>:
  if (is_multiline_231 != 0)
    goto <bb 226>;
  else
    goto <bb 227>;

  <bb 226>:
  iftmp.1629_660 = 1;
  goto <bb 228>;

  <bb 227>:
  iftmp.1629_661 = 0;

  <bb 228>:
  # iftmp.1629_60 = PHI <iftmp.1629_660(226), iftmp.1629_661(227)>
  retval.1628_662 = iftmp.1629_60;
  if (retval.1628_662 != 0)
    goto <bb 229>;
  else
    goto <bb 236>;

  <bb 229>:
  _663 = io_228->KeyCtrl;
  if (_663 != 0)
    goto <bb 230>;
  else
    goto <bb 231>;

  <bb 230>:
  _665 = ImGui::GetScrollMaxY ();
  _666 = draw_window_1->Scroll.y;
  _667 = g_227->FontSize;
  _668 = _666 + _667;
  _670 = ImMin (_668, _665);
  SetWindowScrollY (draw_window_1, _670);
  goto <bb 235>;

  <bb 231>:
  if (is_startend_key_down_566 != 0)
    goto <bb 232>;
  else
    goto <bb 233>;

  <bb 232>:
  iftmp.1630_672 = 65543;
  goto <bb 234>;

  <bb 233>:
  iftmp.1630_673 = 65539;

  <bb 234>:
  # iftmp.1630_61 = PHI <iftmp.1630_672(232), iftmp.1630_673(233)>
  _674 = iftmp.1630_61 | k_mask_539;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, _674);

  <bb 235>:
  goto <bb 347>;

  <bb 236>:
  _677 = IsKeyPressedMap (7, 1);
  retval.1631_678 = _677;
  if (retval.1631_678 != 0)
    goto <bb 237>;
  else
    goto <bb 241>;

  <bb 237>:
  _679 = io_228->KeyCtrl;
  if (_679 != 0)
    goto <bb 238>;
  else
    goto <bb 239>;

  <bb 238>:
  iftmp.1632_680 = k_mask_539 | 65542;
  goto <bb 240>;

  <bb 239>:
  iftmp.1632_681 = k_mask_539 | 65540;

  <bb 240>:
  # iftmp.1632_62 = PHI <iftmp.1632_680(238), iftmp.1632_681(239)>
  ImGuiTextEditState::OnKeyPressed (edit_state_336, iftmp.1632_62);
  goto <bb 347>;

  <bb 241>:
  _684 = IsKeyPressedMap (8, 1);
  retval.1633_685 = _684;
  if (retval.1633_685 != 0)
    goto <bb 242>;
  else
    goto <bb 246>;

  <bb 242>:
  _686 = io_228->KeyCtrl;
  if (_686 != 0)
    goto <bb 243>;
  else
    goto <bb 244>;

  <bb 243>:
  iftmp.1634_687 = k_mask_539 | 65543;
  goto <bb 245>;

  <bb 244>:
  iftmp.1634_688 = k_mask_539 | 65541;

  <bb 245>:
  # iftmp.1634_63 = PHI <iftmp.1634_687(243), iftmp.1634_688(244)>
  ImGuiTextEditState::OnKeyPressed (edit_state_336, iftmp.1634_63);
  goto <bb 347>;

  <bb 246>:
  _691 = IsKeyPressedMap (10, 1);
  _692 = _691;
  if (_692 != 0)
    goto <bb 247>;
  else
    goto <bb 249>;

  <bb 247>:
  if (is_editable_233 != 0)
    goto <bb 248>;
  else
    goto <bb 249>;

  <bb 248>:
  iftmp.1636_693 = 1;
  goto <bb 250>;

  <bb 249>:
  iftmp.1636_694 = 0;

  <bb 250>:
  # iftmp.1636_64 = PHI <iftmp.1636_693(248), iftmp.1636_694(249)>
  retval.1635_695 = iftmp.1636_64;
  if (retval.1635_695 != 0)
    goto <bb 251>;
  else
    goto <bb 252>;

  <bb 251>:
  _696 = k_mask_539 | 65544;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, _696);
  goto <bb 347>;

  <bb 252>:
  _699 = IsKeyPressedMap (11, 1);
  _700 = _699;
  if (_700 != 0)
    goto <bb 253>;
  else
    goto <bb 255>;

  <bb 253>:
  if (is_editable_233 != 0)
    goto <bb 254>;
  else
    goto <bb 255>;

  <bb 254>:
  iftmp.1638_701 = 1;
  goto <bb 256>;

  <bb 255>:
  iftmp.1638_702 = 0;

  <bb 256>:
  # iftmp.1638_65 = PHI <iftmp.1638_701(254), iftmp.1638_702(255)>
  retval.1637_703 = iftmp.1638_65;
  if (retval.1637_703 != 0)
    goto <bb 257>;
  else
    goto <bb 266>;

  <bb 257>:
  _705 = ImGuiTextEditState::HasSelection (edit_state_336);
  retval.1639_706 = ~_705;
  if (retval.1639_706 != 0)
    goto <bb 258>;
  else
    goto <bb 265>;

  <bb 258>:
  if (is_wordmove_key_down_557 != 0)
    goto <bb 259>;
  else
    goto <bb 260>;

  <bb 259>:
  ImGuiTextEditState::OnKeyPressed (edit_state_336, 196620);
  goto <bb 265>;

  <bb 260>:
  _707 = io_228->OptMacOSXBehaviors;
  if (_707 != 0)
    goto <bb 261>;
  else
    goto <bb 265>;

  <bb 261>:
  _708 = io_228->KeySuper;
  if (_708 != 0)
    goto <bb 262>;
  else
    goto <bb 265>;

  <bb 262>:
  _709 = io_228->KeyAlt;
  _710 = ~_709;
  if (_710 != 0)
    goto <bb 263>;
  else
    goto <bb 265>;

  <bb 263>:
  _711 = io_228->KeyCtrl;
  _712 = ~_711;
  if (_712 != 0)
    goto <bb 264>;
  else
    goto <bb 265>;

  <bb 264>:
  ImGuiTextEditState::OnKeyPressed (edit_state_336, 196612);

  <bb 265>:
  _715 = k_mask_539 | 65545;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, _715);
  goto <bb 347>;

  <bb 266>:
  _718 = IsKeyPressedMap (13, 1);
  retval.1640_719 = _718;
  if (retval.1640_719 != 0)
    goto <bb 267>;
  else
    goto <bb 278>;

  <bb 267>:
  _720 = flags_220(D) & 2048;
  ctrl_enter_for_new_line_721 = _720 != 0;
  _722 = ~is_multiline_231;
  if (_722 != 0)
    goto <bb 272>;
  else
    goto <bb 268>;

  <bb 268>:
  if (ctrl_enter_for_new_line_721 != 0)
    goto <bb 269>;
  else
    goto <bb 270>;

  <bb 269>:
  _723 = io_228->KeyCtrl;
  _724 = ~_723;
  if (_724 != 0)
    goto <bb 272>;
  else
    goto <bb 270>;

  <bb 270>:
  _725 = ~ctrl_enter_for_new_line_721;
  if (_725 != 0)
    goto <bb 271>;
  else
    goto <bb 273>;

  <bb 271>:
  _726 = io_228->KeyCtrl;
  if (_726 != 0)
    goto <bb 272>;
  else
    goto <bb 273>;

  <bb 272>:
  clear_active_id_736 = 1;
  enter_pressed_737 = clear_active_id_736;
  goto <bb 277>;

  <bb 273>:
  if (is_editable_233 != 0)
    goto <bb 274>;
  else
    goto <bb 277>;

  <bb 274>:
  c = 10;
  _729 = InputTextFilterCharacter (&c, flags_220(D), callback_518(D), user_data_519(D));
  retval.1641_730 = _729;
  if (retval.1641_730 != 0)
    goto <bb 275>;
  else
    goto <bb 276>;

  <bb 275>:
  c.1642_731 = c;
  c.1643_732 = (int) c.1642_731;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, c.1643_732);

  <bb 276>:
  c ={v} {CLOBBER};

  <bb 277>:
  # clear_active_id_3 = PHI <clear_active_id_736(272), clear_active_id_2(273), clear_active_id_2(276)>
  # enter_pressed_14 = PHI <enter_pressed_737(272), enter_pressed_438(273), enter_pressed_438(276)>
  goto <bb 347>;

  <bb 278>:
  _738 = flags_220(D) & 1024;
  if (_738 != 0)
    goto <bb 279>;
  else
    goto <bb 285>;

  <bb 279>:
  _740 = IsKeyPressedMap (0, 1);
  _741 = _740;
  if (_741 != 0)
    goto <bb 280>;
  else
    goto <bb 285>;

  <bb 280>:
  _742 = io_228->KeyCtrl;
  _743 = ~_742;
  if (_743 != 0)
    goto <bb 281>;
  else
    goto <bb 285>;

  <bb 281>:
  _744 = io_228->KeyShift;
  _745 = ~_744;
  if (_745 != 0)
    goto <bb 282>;
  else
    goto <bb 285>;

  <bb 282>:
  _746 = io_228->KeyAlt;
  _747 = ~_746;
  if (_747 != 0)
    goto <bb 283>;
  else
    goto <bb 285>;

  <bb 283>:
  if (is_editable_233 != 0)
    goto <bb 284>;
  else
    goto <bb 285>;

  <bb 284>:
  iftmp.1645_748 = 1;
  goto <bb 286>;

  <bb 285>:
  iftmp.1645_749 = 0;

  <bb 286>:
  # iftmp.1645_66 = PHI <iftmp.1645_748(284), iftmp.1645_749(285)>
  retval.1644_750 = iftmp.1645_66;
  if (retval.1644_750 != 0)
    goto <bb 287>;
  else
    goto <bb 290>;

  <bb 287>:
  c = 9;
  _753 = InputTextFilterCharacter (&c, flags_220(D), callback_518(D), user_data_519(D));
  retval.1646_754 = _753;
  if (retval.1646_754 != 0)
    goto <bb 288>;
  else
    goto <bb 289>;

  <bb 288>:
  c.1647_755 = c;
  c.1648_756 = (int) c.1647_755;
  ImGuiTextEditState::OnKeyPressed (edit_state_336, c.1648_756);

  <bb 289>:
  c ={v} {CLOBBER};
  goto <bb 347>;

  <bb 290>:
  _761 = IsKeyPressedMap (14, 1);
  retval.1649_762 = _761;
  if (retval.1649_762 != 0)
    goto <bb 291>;
  else
    goto <bb 292>;

  <bb 291>:
  cancel_edit_763 = 1;
  clear_active_id_764 = cancel_edit_763;
  goto <bb 347>;

  <bb 292>:
  if (is_shortcut_key_only_553 != 0)
    goto <bb 293>;
  else
    goto <bb 297>;

  <bb 293>:
  _766 = IsKeyPressedMap (20, 1);
  _767 = _766;
  if (_767 != 0)
    goto <bb 294>;
  else
    goto <bb 297>;

  <bb 294>:
  if (is_editable_233 != 0)
    goto <bb 295>;
  else
    goto <bb 297>;

  <bb 295>:
  if (is_undoable_237 != 0)
    goto <bb 296>;
  else
    goto <bb 297>;

  <bb 296>:
  iftmp.1651_768 = 1;
  goto <bb 298>;

  <bb 297>:
  iftmp.1651_769 = 0;

  <bb 298>:
  # iftmp.1651_67 = PHI <iftmp.1651_768(296), iftmp.1651_769(297)>
  retval.1650_770 = iftmp.1651_67;
  if (retval.1650_770 != 0)
    goto <bb 299>;
  else
    goto <bb 300>;

  <bb 299>:
  ImGuiTextEditState::OnKeyPressed (edit_state_336, 65546);
  ImGuiTextEditState::ClearSelection (edit_state_336);
  goto <bb 347>;

  <bb 300>:
  if (is_shortcut_key_only_553 != 0)
    goto <bb 301>;
  else
    goto <bb 305>;

  <bb 301>:
  _774 = IsKeyPressedMap (19, 1);
  _775 = _774;
  if (_775 != 0)
    goto <bb 302>;
  else
    goto <bb 305>;

  <bb 302>:
  if (is_editable_233 != 0)
    goto <bb 303>;
  else
    goto <bb 305>;

  <bb 303>:
  if (is_undoable_237 != 0)
    goto <bb 304>;
  else
    goto <bb 305>;

  <bb 304>:
  iftmp.1653_776 = 1;
  goto <bb 306>;

  <bb 305>:
  iftmp.1653_777 = 0;

  <bb 306>:
  # iftmp.1653_68 = PHI <iftmp.1653_776(304), iftmp.1653_777(305)>
  retval.1652_778 = iftmp.1653_68;
  if (retval.1652_778 != 0)
    goto <bb 307>;
  else
    goto <bb 308>;

  <bb 307>:
  ImGuiTextEditState::OnKeyPressed (edit_state_336, 65547);
  ImGuiTextEditState::ClearSelection (edit_state_336);
  goto <bb 347>;

  <bb 308>:
  if (is_shortcut_key_only_553 != 0)
    goto <bb 309>;
  else
    goto <bb 311>;

  <bb 309>:
  _782 = IsKeyPressedMap (15, 1);
  _783 = _782;
  if (_783 != 0)
    goto <bb 310>;
  else
    goto <bb 311>;

  <bb 310>:
  iftmp.1655_784 = 1;
  goto <bb 312>;

  <bb 311>:
  iftmp.1655_785 = 0;

  <bb 312>:
  # iftmp.1655_69 = PHI <iftmp.1655_784(310), iftmp.1655_785(311)>
  retval.1654_786 = iftmp.1655_69;
  if (retval.1654_786 != 0)
    goto <bb 313>;
  else
    goto <bb 314>;

  <bb 313>:
  ImGuiTextEditState::SelectAll (edit_state_336);
  edit_state_336->CursorFollow = 1;
  goto <bb 347>;

  <bb 314>:
  if (is_cut_599 != 0)
    goto <bb 316>;
  else
    goto <bb 315>;

  <bb 315>:
  if (is_copy_612 != 0)
    goto <bb 316>;
  else
    goto <bb 329>;

  <bb 316>:
  _836 = io_228->SetClipboardTextFn;
  if (_836 != 0B)
    goto <bb 317>;
  else
    goto <bb 324>;

  <bb 317>:
  _838 = ImGuiTextEditState::HasSelection (edit_state_336);
  if (_838 != 0)
    goto <bb 318>;
  else
    goto <bb 319>;

  <bb 318>:
  _839 = edit_state_336->StbState.select_end;
  _840 = edit_state_336->StbState.select_start;
  iftmp.1656_842 = ImMin (_840, _839);
  goto <bb 320>;

  <bb 319>:
  iftmp.1656_843 = 0;

  <bb 320>:
  # iftmp.1656_70 = PHI <iftmp.1656_842(318), iftmp.1656_843(319)>
  ib_844 = iftmp.1656_70;
  _846 = ImGuiTextEditState::HasSelection (edit_state_336);
  if (_846 != 0)
    goto <bb 321>;
  else
    goto <bb 322>;

  <bb 321>:
  _847 = edit_state_336->StbState.select_end;
  _848 = edit_state_336->StbState.select_start;
  iftmp.1657_850 = ImMax (_848, _847);
  goto <bb 323>;

  <bb 322>:
  iftmp.1657_851 = edit_state_336->CurLenW;

  <bb 323>:
  # iftmp.1657_71 = PHI <iftmp.1657_850(321), iftmp.1657_851(322)>
  ie_852 = iftmp.1657_71;
  _853 = ie_852 - ib_844;
  _854 = _853 * 4;
  _855 = _854 + 1;
  _856 = &edit_state_336->TempTextBuffer;
  ImVector<char>::resize (_856, _855);
  _858 = edit_state_336->Text.Data;
  _859 = (long unsigned int) ie_852;
  _860 = _859 * 2;
  _861 = _858 + _860;
  _862 = edit_state_336->Text.Data;
  _863 = (long unsigned int) ib_844;
  _864 = _863 * 2;
  _865 = _862 + _864;
  _866 = edit_state_336->TempTextBuffer.Size;
  _867 = edit_state_336->TempTextBuffer.Data;
  ImTextStrToUtf8 (_867, _866, _865, _861);
  _869 = edit_state_336->TempTextBuffer.Data;
  ImGui::SetClipboardText (_869);

  <bb 324>:
  if (is_cut_599 != 0)
    goto <bb 325>;
  else
    goto <bb 328>;

  <bb 325>:
  _872 = ImGuiTextEditState::HasSelection (edit_state_336);
  retval.1658_873 = ~_872;
  if (retval.1658_873 != 0)
    goto <bb 326>;
  else
    goto <bb 327>;

  <bb 326>:
  ImGuiTextEditState::SelectAll (edit_state_336);

  <bb 327>:
  edit_state_336->CursorFollow = 1;
  _876 = &edit_state_336->StbState;
  ImGuiStb::stb_textedit_cut (edit_state_336, _876);

  <bb 328>:
  goto <bb 347>;

  <bb 329>:
  if (is_paste_621 != 0)
    goto <bb 330>;
  else
    goto <bb 347>;

  <bb 330>:
  _790 = ImGui::GetClipboardText ();
  clipboard_791 = _790;
  if (clipboard_791 != 0B)
    goto <bb 331>;
  else
    goto <bb 346>;

  <bb 331>:
  _792 = strlen (clipboard_791);
  clipboard_len_793 = (const int) _792;
  _794 = clipboard_len_793 + 1;
  _795 = (long unsigned int) _794;
  _796 = _795 * 2;
  _798 = ImGui::MemAlloc (_796);
  clipboard_filtered_799 = _798;
  clipboard_filtered_len_800 = 0;
  s_801 = clipboard_791;

  <bb 332>:
  # clipboard_filtered_len_20 = PHI <clipboard_filtered_len_800(331), clipboard_filtered_len_21(342)>
  # s_22 = PHI <s_801(331), s_806(342)>
  _802 = *s_22;
  if (_802 == 0)
    goto <bb 343>;
  else
    goto <bb 333>;

  <bb 333>:
  _804 = ImTextCharFromUtf8 (&c, s_22, 0B);
  _805 = (sizetype) _804;
  s_806 = s_22 + _805;
  c.1659_807 = c;
  if (c.1659_807 == 0)
    goto <bb 334>;
  else
    goto <bb 335>;

  <bb 334>:
  c ={v} {CLOBBER};
  goto <bb 343>;

  <bb 335>:
  c.1662_808 = c;
  if (c.1662_808 > 65535)
    goto <bb 337>;
  else
    goto <bb 336>;

  <bb 336>:
  _810 = InputTextFilterCharacter (&c, flags_220(D), callback_518(D), user_data_519(D));
  _811 = _810;
  _812 = ~_811;
  if (_812 != 0)
    goto <bb 337>;
  else
    goto <bb 338>;

  <bb 337>:
  iftmp.1661_815 = 1;
  goto <bb 339>;

  <bb 338>:
  iftmp.1661_813 = 0;

  <bb 339>:
  # iftmp.1661_72 = PHI <iftmp.1661_815(337), iftmp.1661_813(338)>
  retval.1660_816 = iftmp.1661_72;
  if (retval.1660_816 != 0)
    goto <bb 340>;
  else
    goto <bb 341>;

  <bb 340>:
  c ={v} {CLOBBER};
  goto <bb 342>;

  <bb 341>:
  clipboard_filtered_len.1663_817 = clipboard_filtered_len_20;
  clipboard_filtered_len_818 = clipboard_filtered_len.1663_817 + 1;
  _819 = (long unsigned int) clipboard_filtered_len.1663_817;
  _820 = _819 * 2;
  _821 = clipboard_filtered_799 + _820;
  c.1664_822 = c;
  _823 = (short unsigned int) c.1664_822;
  *_821 = _823;
  c ={v} {CLOBBER};

  <bb 342>:
  # clipboard_filtered_len_21 = PHI <clipboard_filtered_len_818(341), clipboard_filtered_len_20(340)>
  goto <bb 332>;

  <bb 343>:
  _828 = (long unsigned int) clipboard_filtered_len_20;
  _829 = _828 * 2;
  _830 = clipboard_filtered_799 + _829;
  *_830 = 0;
  if (clipboard_filtered_len_20 > 0)
    goto <bb 344>;
  else
    goto <bb 345>;

  <bb 344>:
  _832 = &edit_state_336->StbState;
  ImGuiStb::stb_textedit_paste (edit_state_336, _832, clipboard_filtered_799, clipboard_filtered_len_20);
  edit_state_336->CursorFollow = 1;

  <bb 345>:
  ImGui::MemFree (clipboard_filtered_799);

  <bb 346>:

  <bb 347>:
  # clear_active_id_4 = PHI <clear_active_id_2(203), clear_active_id_2(211), clear_active_id_2(223), clear_active_id_2(235), clear_active_id_2(240), clear_active_id_2(245), clear_active_id_2(251), clear_active_id_2(265), clear_active_id_3(277), clear_active_id_2(289), clear_active_id_764(291), clear_active_id_2(299), clear_active_id_2(307), clear_active_id_2(313), clear_active_id_2(328), clear_active_id_2(329), clear_active_id_2(346)>
  # enter_pressed_15 = PHI <enter_pressed_438(203), enter_pressed_438(211), enter_pressed_438(223), enter_pressed_438(235), enter_pressed_438(240), enter_pressed_438(245), enter_pressed_438(251), enter_pressed_438(265), enter_pressed_14(277), enter_pressed_438(289), enter_pressed_438(291), enter_pressed_438(299), enter_pressed_438(307), enter_pressed_438(313), enter_pressed_438(328), enter_pressed_438(329), enter_pressed_438(346)>
  # cancel_edit_18 = PHI <cancel_edit_531(203), cancel_edit_531(211), cancel_edit_531(223), cancel_edit_531(235), cancel_edit_531(240), cancel_edit_531(245), cancel_edit_531(251), cancel_edit_531(265), cancel_edit_531(277), cancel_edit_531(289), cancel_edit_763(291), cancel_edit_531(299), cancel_edit_531(307), cancel_edit_531(313), cancel_edit_531(328), cancel_edit_531(329), cancel_edit_531(346)>

  <bb 348>:
  # clear_active_id_5 = PHI <clear_active_id_2(134), clear_active_id_2(135), clear_active_id_2(136), clear_active_id_4(347)>
  # enter_pressed_16 = PHI <enter_pressed_438(134), enter_pressed_438(135), enter_pressed_438(136), enter_pressed_15(347)>
  # cancel_edit_19 = PHI <cancel_edit_531(134), cancel_edit_531(135), cancel_edit_531(136), cancel_edit_18(347)>
  _878 = g_227->ActiveId;
  if (_878 == id_242)
    goto <bb 349>;
  else
    goto <bb 407>;

  <bb 349>:
  if (cancel_edit_19 != 0)
    goto <bb 350>;
  else
    goto <bb 352>;

  <bb 350>:
  if (is_editable_233 != 0)
    goto <bb 351>;
  else
    goto <bb 352>;

  <bb 351>:
  _879 = (long unsigned int) buf_size_383(D);
  _880 = edit_state_336->InitialText.Data;
  ImStrncpy (buf_393(D), _880, _879);
  value_changed_882 = 1;

  <bb 352>:
  # value_changed_10 = PHI <value_changed_437(349), value_changed_882(351), value_changed_437(350)>
  _883 = ~cancel_edit_19;
  if (_883 != 0)
    goto <bb 355>;
  else
    goto <bb 353>;

  <bb 353>:
  if (enter_pressed_16 != 0)
    goto <bb 354>;
  else
    goto <bb 356>;

  <bb 354>:
  _884 = flags_220(D) & 32;
  if (_884 != 0)
    goto <bb 355>;
  else
    goto <bb 356>;

  <bb 355>:
  iftmp.1665_886 = 1;
  goto <bb 357>;

  <bb 356>:
  iftmp.1665_885 = 0;

  <bb 357>:
  # iftmp.1665_73 = PHI <iftmp.1665_886(355), iftmp.1665_885(356)>
  apply_edit_back_to_user_buffer_887 = iftmp.1665_73;
  if (apply_edit_back_to_user_buffer_887 != 0)
    goto <bb 358>;
  else
    goto <bb 406>;

  <bb 358>:
  if (is_editable_233 != 0)
    goto <bb 359>;
  else
    goto <bb 360>;

  <bb 359>:
  _888 = edit_state_336->Text.Size;
  _889 = _888 * 4;
  _890 = &edit_state_336->TempTextBuffer;
  ImVector<char>::resize (_890, _889);
  _892 = edit_state_336->Text.Data;
  _893 = edit_state_336->TempTextBuffer.Size;
  _894 = edit_state_336->TempTextBuffer.Data;
  ImTextStrToUtf8 (_894, _893, _892, 0B);

  <bb 360>:
  _896 = flags_220(D) & 448;
  if (_896 != 0)
    goto <bb 361>;
  else
    goto <bb 402>;

  <bb 361>:
  if (callback_518(D) != 0B)
    goto <bb 363>;
  else
    goto <bb 362>;

  <bb 362>:
  __assert_fail ("callback != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10230, &__PRETTY_FUNCTION__);

  <bb 363>:
  event_flag_897 = 0;
  event_key_898 = 21;
  _899 = flags_220(D) & 64;
  if (_899 != 0)
    goto <bb 364>;
  else
    goto <bb 366>;

  <bb 364>:
  _901 = IsKeyPressedMap (0, 1);
  _902 = _901;
  if (_902 != 0)
    goto <bb 365>;
  else
    goto <bb 366>;

  <bb 365>:
  iftmp.1667_903 = 1;
  goto <bb 367>;

  <bb 366>:
  iftmp.1667_904 = 0;

  <bb 367>:
  # iftmp.1667_74 = PHI <iftmp.1667_903(365), iftmp.1667_904(366)>
  retval.1666_905 = iftmp.1667_74;
  if (retval.1666_905 != 0)
    goto <bb 368>;
  else
    goto <bb 369>;

  <bb 368>:
  event_flag_906 = 64;
  event_key_907 = 0;
  goto <bb 383>;

  <bb 369>:
  _908 = flags_220(D) & 128;
  if (_908 != 0)
    goto <bb 370>;
  else
    goto <bb 372>;

  <bb 370>:
  _910 = IsKeyPressedMap (3, 1);
  _911 = _910;
  if (_911 != 0)
    goto <bb 371>;
  else
    goto <bb 372>;

  <bb 371>:
  iftmp.1669_912 = 1;
  goto <bb 373>;

  <bb 372>:
  iftmp.1669_913 = 0;

  <bb 373>:
  # iftmp.1669_75 = PHI <iftmp.1669_912(371), iftmp.1669_913(372)>
  retval.1668_914 = iftmp.1669_75;
  if (retval.1668_914 != 0)
    goto <bb 374>;
  else
    goto <bb 375>;

  <bb 374>:
  event_flag_915 = 128;
  event_key_916 = 3;
  goto <bb 383>;

  <bb 375>:
  _917 = flags_220(D) & 128;
  if (_917 != 0)
    goto <bb 376>;
  else
    goto <bb 378>;

  <bb 376>:
  _919 = IsKeyPressedMap (4, 1);
  _920 = _919;
  if (_920 != 0)
    goto <bb 377>;
  else
    goto <bb 378>;

  <bb 377>:
  iftmp.1671_921 = 1;
  goto <bb 379>;

  <bb 378>:
  iftmp.1671_922 = 0;

  <bb 379>:
  # iftmp.1671_76 = PHI <iftmp.1671_921(377), iftmp.1671_922(378)>
  retval.1670_923 = iftmp.1671_76;
  if (retval.1670_923 != 0)
    goto <bb 380>;
  else
    goto <bb 381>;

  <bb 380>:
  event_flag_924 = 128;
  event_key_925 = 4;
  goto <bb 383>;

  <bb 381>:
  _926 = flags_220(D) & 256;
  if (_926 != 0)
    goto <bb 382>;
  else
    goto <bb 383>;

  <bb 382>:
  event_flag_927 = 256;

  <bb 383>:
  # event_flag_23 = PHI <event_flag_906(368), event_flag_915(374), event_flag_924(380), event_flag_897(381), event_flag_927(382)>
  # event_key_24 = PHI <event_key_907(368), event_key_916(374), event_key_925(380), event_key_898(381), event_key_898(382)>
  if (event_flag_23 != 0)
    goto <bb 384>;
  else
    goto <bb 401>;

  <bb 384>:
  memset (&callback_data, 0, 56);
  callback_data.EventFlag = event_flag_23;
  callback_data.Flags = flags_220(D);
  callback_data.UserData = user_data_519(D);
  _932 = ~is_editable_233;
  callback_data.ReadOnly = _932;
  callback_data.EventKey = event_key_24;
  _935 = edit_state_336->TempTextBuffer.Data;
  callback_data.Buf = _935;
  _937 = edit_state_336->CurLenA;
  callback_data.BufTextLen = _937;
  _939 = edit_state_336->BufSizeA;
  callback_data.BufSize = _939;
  callback_data.BufDirty = 0;
  text_942 = edit_state_336->Text.Data;
  _943 = edit_state_336->StbState.cursor;
  _944 = (long unsigned int) _943;
  _945 = _944 * 2;
  _946 = text_942 + _945;
  _948 = ImTextCountUtf8BytesFromStr (text_942, _946);
  callback_data.CursorPos = _948;
  utf8_cursor_pos_950 = callback_data.CursorPos;
  _951 = edit_state_336->StbState.select_start;
  _952 = (long unsigned int) _951;
  _953 = _952 * 2;
  _954 = text_942 + _953;
  _956 = ImTextCountUtf8BytesFromStr (text_942, _954);
  callback_data.SelectionStart = _956;
  utf8_selection_start_958 = callback_data.SelectionStart;
  _959 = edit_state_336->StbState.select_end;
  _960 = (long unsigned int) _959;
  _961 = _960 * 2;
  _962 = text_942 + _961;
  _964 = ImTextCountUtf8BytesFromStr (text_942, _962);
  callback_data.SelectionEnd = _964;
  utf8_selection_end_966 = callback_data.SelectionEnd;
  callback_518(D) (&callback_data);
  _968 = callback_data.Buf;
  _969 = edit_state_336->TempTextBuffer.Data;
  if (_968 == _969)
    goto <bb 386>;
  else
    goto <bb 385>;

  <bb 385>:
  __assert_fail ("callback_data.Buf == edit_state.TempTextBuffer.Data", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10278, &__PRETTY_FUNCTION__);

  <bb 386>:
  _970 = callback_data.BufSize;
  _971 = edit_state_336->BufSizeA;
  if (_970 == _971)
    goto <bb 388>;
  else
    goto <bb 387>;

  <bb 387>:
  __assert_fail ("callback_data.BufSize == edit_state.BufSizeA", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10279, &__PRETTY_FUNCTION__);

  <bb 388>:
  _972 = callback_data.Flags;
  if (_972 == flags_220(D))
    goto <bb 390>;
  else
    goto <bb 389>;

  <bb 389>:
  __assert_fail ("callback_data.Flags == flags", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10280, &__PRETTY_FUNCTION__);

  <bb 390>:
  _973 = callback_data.CursorPos;
  if (_973 != utf8_cursor_pos_950)
    goto <bb 391>;
  else
    goto <bb 392>;

  <bb 391>:
  _974 = callback_data.Buf;
  _975 = callback_data.CursorPos;
  _976 = (sizetype) _975;
  _977 = _974 + _976;
  _978 = callback_data.Buf;
  _980 = ImTextCountCharsFromUtf8 (_978, _977);
  edit_state_336->StbState.cursor = _980;

  <bb 392>:
  _982 = callback_data.SelectionStart;
  if (_982 != utf8_selection_start_958)
    goto <bb 393>;
  else
    goto <bb 394>;

  <bb 393>:
  _983 = callback_data.Buf;
  _984 = callback_data.SelectionStart;
  _985 = (sizetype) _984;
  _986 = _983 + _985;
  _987 = callback_data.Buf;
  _989 = ImTextCountCharsFromUtf8 (_987, _986);
  edit_state_336->StbState.select_start = _989;

  <bb 394>:
  _991 = callback_data.SelectionEnd;
  if (_991 != utf8_selection_end_966)
    goto <bb 395>;
  else
    goto <bb 396>;

  <bb 395>:
  _992 = callback_data.Buf;
  _993 = callback_data.SelectionEnd;
  _994 = (sizetype) _993;
  _995 = _992 + _994;
  _996 = callback_data.Buf;
  _998 = ImTextCountCharsFromUtf8 (_996, _995);
  edit_state_336->StbState.select_end = _998;

  <bb 396>:
  _1000 = callback_data.BufDirty;
  if (_1000 != 0)
    goto <bb 397>;
  else
    goto <bb 400>;

  <bb 397>:
  _1001 = callback_data.BufTextLen;
  _1002 = callback_data.Buf;
  _1003 = strlen (_1002);
  _1004 = (int) _1003;
  if (_1001 == _1004)
    goto <bb 399>;
  else
    goto <bb 398>;

  <bb 398>:
  __assert_fail ("callback_data.BufTextLen == (int)strlen(callback_data.Buf)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10286, &__PRETTY_FUNCTION__);

  <bb 399>:
  _1005 = callback_data.Buf;
  _1006 = edit_state_336->Text.Size;
  _1007 = edit_state_336->Text.Data;
  _1009 = ImTextStrFromUtf8 (_1007, _1006, _1005, 0B, 0B);
  edit_state_336->CurLenW = _1009;
  _1011 = callback_data.BufTextLen;
  edit_state_336->CurLenA = _1011;
  ImGuiTextEditState::CursorAnimReset (edit_state_336);

  <bb 400>:
  callback_data ={v} {CLOBBER};

  <bb 401>:

  <bb 402>:
  if (is_editable_233 != 0)
    goto <bb 403>;
  else
    goto <bb 405>;

  <bb 403>:
  _1021 = edit_state_336->TempTextBuffer.Data;
  _1022 = strcmp (_1021, buf_393(D));
  if (_1022 != 0)
    goto <bb 404>;
  else
    goto <bb 405>;

  <bb 404>:
  _1023 = (long unsigned int) buf_size_383(D);
  _1024 = edit_state_336->TempTextBuffer.Data;
  ImStrncpy (buf_393(D), _1024, _1023);
  value_changed_1026 = 1;

  <bb 405>:
  # value_changed_11 = PHI <value_changed_10(402), value_changed_10(403), value_changed_1026(404)>

  <bb 406>:
  # value_changed_12 = PHI <value_changed_10(357), value_changed_11(405)>

  <bb 407>:
  # value_changed_13 = PHI <value_changed_437(348), value_changed_12(406)>
  if (clear_active_id_5 != 0)
    goto <bb 408>;
  else
    goto <bb 410>;

  <bb 408>:
  _1027 = g_227->ActiveId;
  if (_1027 == id_242)
    goto <bb 409>;
  else
    goto <bb 410>;

  <bb 409>:
  ImGui::ClearActiveID ();

  <bb 410>:
  _1029 = g_227->ActiveId;
  if (_1029 == id_242)
    goto <bb 411>;
  else
    goto <bb 413>;

  <bb 411>:
  if (is_editable_233 != 0)
    goto <bb 412>;
  else
    goto <bb 413>;

  <bb 412>:
  iftmp.1672_1030 = edit_state_336->TempTextBuffer.Data;
  goto <bb 414>;

  <bb 413>:
  iftmp.1672_1031 = buf_393(D);

  <bb 414>:
  # iftmp.1672_77 = PHI <iftmp.1672_1030(412), iftmp.1672_1031(413)>
  buf_display_1032 = iftmp.1672_77;
  buf_1033 = 0B;
  ImGui::RenderNavHighlight (&frame_bb, id_242, 1);
  _1035 = ~is_multiline_231;
  if (_1035 != 0)
    goto <bb 415>;
  else
    goto <bb 416>;

  <bb 415>:
  _1036 = style_229->FrameRounding;
  _1038 = ImGui::GetColorU32 (7, 1.0e+0);
  ImGui::RenderFrame (frame_bb.Min, frame_bb.Max, _1038, 1, _1036);

  <bb 416>:
  _1040 = frame_bb.Min.y;
  _1041 = size.y;
  _1042 = _1040 + _1041;
  _1043 = frame_bb.Min.x;
  _1044 = size.x;
  _1045 = _1043 + _1044;
  _1046 = frame_bb.Min.y;
  _1047 = frame_bb.Min.x;
  ImVec4::ImVec4 (&clip_rect, _1047, _1046, _1045, _1042);
  if (is_multiline_231 != 0)
    goto <bb 417>;
  else
    goto <bb 418>;

  <bb 417>:
  render_pos = draw_window_1->DC.CursorPos;
  goto <bb 419>;

  <bb 418>:
  _1050 = &style_229->FramePadding;
  render_pos = operator+ (&frame_bb.Min, _1050);

  <bb 419>:
  ImVec2::ImVec2 (&text_size, 0.0, 0.0);
  _1053 = edit_state_336->Id;
  if (_1053 == id_242)
    goto <bb 420>;
  else
    goto <bb 423>;

  <bb 420>:
  if (is_multiline_231 != 0)
    goto <bb 421>;
  else
    goto <bb 423>;

  <bb 421>:
  _1054 = g_227->ActiveId;
  _1056 = ImGuiWindow::GetIDNoKeepAlive (draw_window_1, "#SCROLLY", 0B);
  _1057 = _1056;
  if (_1054 == _1057)
    goto <bb 422>;
  else
    goto <bb 423>;

  <bb 422>:
  iftmp.1673_1058 = 1;
  goto <bb 424>;

  <bb 423>:
  iftmp.1673_1059 = 0;

  <bb 424>:
  # iftmp.1673_78 = PHI <iftmp.1673_1058(422), iftmp.1673_1059(423)>
  is_currently_scrolling_1060 = iftmp.1673_78;
  _1061 = g_227->ActiveId;
  if (_1061 == id_242)
    goto <bb 426>;
  else
    goto <bb 425>;

  <bb 425>:
  if (is_currently_scrolling_1060 != 0)
    goto <bb 426>;
  else
    goto <bb 508>;

  <bb 426>:
  _1083 = edit_state_336->CursorAnim;
  _1084 = io_228->DeltaTime;
  _1085 = _1083 + _1084;
  edit_state_336->CursorAnim = _1085;
  text_begin_1087 = edit_state_336->Text.Data;
  ImVec2::ImVec2 (&cursor_offset);
  ImVec2::ImVec2 (&select_start_offset);
  _1090 = edit_state_336->StbState.cursor;
  _1091 = (long unsigned int) _1090;
  _1092 = _1091 * 2;
  _1093 = text_begin_1087 + _1092;
  searches_input_ptr[0] = _1093;
  searches_input_ptr[1] = 0B;
  searches_remaining_1096 = 1;
  searches_result_line_number[0] = -1;
  searches_result_line_number[1] = -999;
  _1099 = edit_state_336->StbState.select_start;
  _1100 = edit_state_336->StbState.select_end;
  if (_1099 != _1100)
    goto <bb 427>;
  else
    goto <bb 428>;

  <bb 427>:
  _1101 = edit_state_336->StbState.select_end;
  _1102 = edit_state_336->StbState.select_start;
  _1104 = ImMin (_1102, _1101);
  _1105 = (long unsigned int) _1104;
  _1106 = _1105 * 2;
  _1107 = text_begin_1087 + _1106;
  searches_input_ptr[1] = _1107;
  searches_result_line_number[1] = -1;
  searches_remaining_1110 = searches_remaining_1096 + 1;

  <bb 428>:
  # searches_remaining_25 = PHI <searches_remaining_1096(426), searches_remaining_1110(427)>
  if (is_multiline_231 != 0)
    goto <bb 429>;
  else
    goto <bb 430>;

  <bb 429>:
  iftmp.1674_1111 = 1;
  goto <bb 431>;

  <bb 430>:
  iftmp.1674_1112 = 0;

  <bb 431>:
  # iftmp.1674_79 = PHI <iftmp.1674_1111(429), iftmp.1674_1112(430)>
  searches_remaining_1113 = iftmp.1674_79 + searches_remaining_25;
  line_count_1114 = 0;
  s_1115 = text_begin_1087;

  <bb 432>:
  # searches_remaining_26 = PHI <searches_remaining_1113(431), searches_remaining_28(442)>
  # line_count_29 = PHI <line_count_1114(431), line_count_30(442)>
  # s_32 = PHI <s_1115(431), s_1129(442)>
  _1116 = *s_32;
  if (_1116 == 0)
    goto <bb 443>;
  else
    goto <bb 433>;

  <bb 433>:
  _1117 = *s_32;
  if (_1117 == 10)
    goto <bb 434>;
  else
    goto <bb 442>;

  <bb 434>:
  line_count_1118 = line_count_29 + 1;
  _1119 = searches_result_line_number[0];
  if (_1119 == -1)
    goto <bb 435>;
  else
    goto <bb 438>;

  <bb 435>:
  _1120 = searches_input_ptr[0];
  if (_1120 <= s_32)
    goto <bb 436>;
  else
    goto <bb 438>;

  <bb 436>:
  searches_result_line_number[0] = line_count_1118;
  searches_remaining_1122 = searches_remaining_26 + -1;
  retval.1675_1123 = searches_remaining_1122 <= 0;
  if (retval.1675_1123 != 0)
    goto <bb 437>;
  else
    goto <bb 438>;

  <bb 437>:
  goto <bb 443>;

  <bb 438>:
  # searches_remaining_27 = PHI <searches_remaining_26(434), searches_remaining_26(435), searches_remaining_1122(436)>
  _1124 = searches_result_line_number[1];
  if (_1124 == -1)
    goto <bb 439>;
  else
    goto <bb 442>;

  <bb 439>:
  _1125 = searches_input_ptr[1];
  if (_1125 <= s_32)
    goto <bb 440>;
  else
    goto <bb 442>;

  <bb 440>:
  searches_result_line_number[1] = line_count_1118;
  searches_remaining_1127 = searches_remaining_27 + -1;
  retval.1676_1128 = searches_remaining_1127 <= 0;
  if (retval.1676_1128 != 0)
    goto <bb 441>;
  else
    goto <bb 442>;

  <bb 441>:
  goto <bb 443>;

  <bb 442>:
  # searches_remaining_28 = PHI <searches_remaining_26(433), searches_remaining_27(439), searches_remaining_27(438), searches_remaining_1127(440)>
  # line_count_30 = PHI <line_count_29(433), line_count_1118(439), line_count_1118(438), line_count_1118(440)>
  s_1129 = s_32 + 2;
  goto <bb 432>;

  <bb 443>:
  # line_count_31 = PHI <line_count_29(432), line_count_1118(437), line_count_1118(441)>
  line_count_1130 = line_count_31 + 1;
  _1131 = searches_result_line_number[0];
  if (_1131 == -1)
    goto <bb 444>;
  else
    goto <bb 445>;

  <bb 444>:
  searches_result_line_number[0] = line_count_1130;

  <bb 445>:
  _1133 = searches_result_line_number[1];
  if (_1133 == -1)
    goto <bb 446>;
  else
    goto <bb 447>;

  <bb 446>:
  searches_result_line_number[1] = line_count_1130;

  <bb 447>:
  _1135 = searches_input_ptr[0];
  _1136 = searches_input_ptr[0];
  _1138 = ImStrbolW (_1136, text_begin_1087);
  D.20463 = InputTextCalcTextSizeW (_1138, _1135, 0B, 0B, 0);
  _1140 = D.20463.x;
  cursor_offset.x = _1140;
  _1142 = searches_result_line_number[0];
  _1143 = (float) _1142;
  _1144 = g_227->FontSize;
  _1145 = _1143 * _1144;
  cursor_offset.y = _1145;
  _1147 = searches_result_line_number[1];
  if (_1147 >= 0)
    goto <bb 448>;
  else
    goto <bb 449>;

  <bb 448>:
  _1148 = searches_input_ptr[1];
  _1149 = searches_input_ptr[1];
  _1151 = ImStrbolW (_1149, text_begin_1087);
  D.20464 = InputTextCalcTextSizeW (_1151, _1148, 0B, 0B, 0);
  _1153 = D.20464.x;
  select_start_offset.x = _1153;
  _1155 = searches_result_line_number[1];
  _1156 = (float) _1155;
  _1157 = g_227->FontSize;
  _1158 = _1156 * _1157;
  select_start_offset.y = _1158;

  <bb 449>:
  if (is_multiline_231 != 0)
    goto <bb 450>;
  else
    goto <bb 451>;

  <bb 450>:
  _1160 = (float) line_count_1130;
  _1161 = g_227->FontSize;
  _1162 = _1160 * _1161;
  _1163 = size.x;
  ImVec2::ImVec2 (&text_size.1677, _1163, _1162);
  text_size = text_size.1677;
  text_size.1677 ={v} {CLOBBER};

  <bb 451>:
  searches_input_ptr ={v} {CLOBBER};
  searches_result_line_number ={v} {CLOBBER};
  _1169 = edit_state_336->CursorFollow;
  if (_1169 != 0)
    goto <bb 452>;
  else
    goto <bb 466>;

  <bb 452>:
  _1170 = flags_220(D) & 4096;
  if (_1170 == 0)
    goto <bb 453>;
  else
    goto <bb 458>;

  <bb 453>:
  _1171 = size.x;
  scroll_increment_x_1172 = _1171 * 2.5e-1;
  _1173 = cursor_offset.x;
  _1174 = edit_state_336->ScrollX;
  if (_1173 < _1174)
    goto <bb 454>;
  else
    goto <bb 455>;

  <bb 454>:
  _1175 = cursor_offset.x;
  _1176 = _1175 - scroll_increment_x_1172;
  _1178 = ImMax (0.0, _1176);
  _1179 = (int) _1178;
  _1180 = (float) _1179;
  edit_state_336->ScrollX = _1180;
  goto <bb 457>;

  <bb 455>:
  _1182 = cursor_offset.x;
  _1183 = size.x;
  _1184 = _1182 - _1183;
  _1185 = edit_state_336->ScrollX;
  if (_1184 >= _1185)
    goto <bb 456>;
  else
    goto <bb 457>;

  <bb 456>:
  _1186 = cursor_offset.x;
  _1187 = size.x;
  _1188 = _1186 - _1187;
  _1189 = _1188 + scroll_increment_x_1172;
  _1190 = (int) _1189;
  _1191 = (float) _1190;
  edit_state_336->ScrollX = _1191;

  <bb 457>:
  goto <bb 459>;

  <bb 458>:
  edit_state_336->ScrollX = 0.0;

  <bb 459>:
  if (is_multiline_231 != 0)
    goto <bb 460>;
  else
    goto <bb 465>;

  <bb 460>:
  scroll_y_1194 = draw_window_1->Scroll.y;
  _1195 = cursor_offset.y;
  _1196 = g_227->FontSize;
  _1197 = _1195 - _1196;
  if (_1197 < scroll_y_1194)
    goto <bb 461>;
  else
    goto <bb 462>;

  <bb 461>:
  _1198 = cursor_offset.y;
  _1199 = g_227->FontSize;
  _1200 = _1198 - _1199;
  scroll_y_1202 = ImMax (0.0, _1200);
  goto <bb 464>;

  <bb 462>:
  _1203 = cursor_offset.y;
  _1204 = size.y;
  _1205 = _1203 - _1204;
  if (_1205 >= scroll_y_1194)
    goto <bb 463>;
  else
    goto <bb 464>;

  <bb 463>:
  _1206 = cursor_offset.y;
  _1207 = size.y;
  scroll_y_1208 = _1206 - _1207;

  <bb 464>:
  # scroll_y_33 = PHI <scroll_y_1202(461), scroll_y_1194(462), scroll_y_1208(463)>
  _1209 = draw_window_1->DC.CursorPos.y;
  _1210 = draw_window_1->Scroll.y;
  _1211 = _1210 - scroll_y_33;
  _1212 = _1209 + _1211;
  draw_window_1->DC.CursorPos.y = _1212;
  draw_window_1->Scroll.y = scroll_y_33;
  _1215 = draw_window_1->DC.CursorPos.y;
  render_pos.y = _1215;

  <bb 465>:

  <bb 466>:
  edit_state_336->CursorFollow = 0;
  _1218 = edit_state_336->ScrollX;
  ImVec2::ImVec2 (&render_scroll, _1218, 0.0);
  _1220 = edit_state_336->StbState.select_start;
  _1221 = edit_state_336->StbState.select_end;
  if (_1220 != _1221)
    goto <bb 467>;
  else
    goto <bb 491>;

  <bb 467>:
  _1222 = edit_state_336->StbState.select_end;
  _1223 = edit_state_336->StbState.select_start;
  _1225 = ImMin (_1223, _1222);
  _1226 = (long unsigned int) _1225;
  _1227 = _1226 * 2;
  text_selected_begin_1228 = text_begin_1087 + _1227;
  _1229 = edit_state_336->StbState.select_end;
  _1230 = edit_state_336->StbState.select_start;
  _1232 = ImMax (_1230, _1229);
  _1233 = (long unsigned int) _1232;
  _1234 = _1233 * 2;
  text_selected_end_1235 = text_begin_1087 + _1234;
  if (is_multiline_231 != 0)
    goto <bb 468>;
  else
    goto <bb 469>;

  <bb 468>:
  iftmp.1678_1236 = 0.0;
  goto <bb 470>;

  <bb 469>:
  iftmp.1678_1237 = -1.0e+0;

  <bb 470>:
  # iftmp.1678_80 = PHI <iftmp.1678_1236(468), iftmp.1678_1237(469)>
  bg_offy_up_1238 = iftmp.1678_80;
  if (is_multiline_231 != 0)
    goto <bb 471>;
  else
    goto <bb 472>;

  <bb 471>:
  iftmp.1679_1239 = 0.0;
  goto <bb 473>;

  <bb 472>:
  iftmp.1679_1240 = 2.0e+0;

  <bb 473>:
  # iftmp.1679_81 = PHI <iftmp.1679_1239(471), iftmp.1679_1240(472)>
  bg_offy_dn_1241 = iftmp.1679_81;
  bg_color_1243 = ImGui::GetColorU32 (37, 1.0e+0);
  D.20476 = operator+ (&render_pos, &select_start_offset);
  rect_pos = operator- (&D.20476, &render_scroll);
  D.20476 ={v} {CLOBBER};
  p = text_selected_begin_1228;

  <bb 474>:
  p.1680_1248 = p;
  if (p.1680_1248 >= text_selected_end_1235)
    goto <bb 490>;
  else
    goto <bb 475>;

  <bb 475>:
  _1249 = rect_pos.y;
  _1250 = clip_rect.w;
  _1251 = g_227->FontSize;
  _1252 = _1250 + _1251;
  if (_1249 > _1252)
    goto <bb 476>;
  else
    goto <bb 477>;

  <bb 476>:
  goto <bb 490>;

  <bb 477>:
  _1253 = rect_pos.y;
  _1254 = clip_rect.y;
  if (_1253 < _1254)
    goto <bb 478>;
  else
    goto <bb 483>;

  <bb 478>:
  p.1681_1255 = p;
  if (p.1681_1255 >= text_selected_end_1235)
    goto <bb 482>;
  else
    goto <bb 479>;

  <bb 479>:
  p.1683_1256 = p;
  p.1684_1257 = p.1683_1256;
  p.1685_1258 = p.1684_1257 + 2;
  p = p.1685_1258;
  _1260 = *p.1684_1257;
  retval.1682_1261 = _1260 == 10;
  if (retval.1682_1261 != 0)
    goto <bb 480>;
  else
    goto <bb 481>;

  <bb 480>:
  goto <bb 482>;

  <bb 481>:
  goto <bb 478>;

  <bb 482>:
  goto <bb 489>;

  <bb 483>:
  p.1686_1262 = p;
  rect_size = InputTextCalcTextSizeW (p.1686_1262, text_selected_end_1235, &p, 0B, 1);
  _1264 = rect_size.x;
  if (_1264 <= 0.0)
    goto <bb 484>;
  else
    goto <bb 485>;

  <bb 484>:
  _1265 = g_227->Font;
  _1267 = ImFont::GetCharAdvance (_1265, 32);
  _1268 = _1267;
  _1269 = _1268 * 5.0e-1;
  _1270 = (int) _1269;
  _1271 = (float) _1270;
  rect_size.x = _1271;

  <bb 485>:
  _1273 = rect_size.x;
  ImVec2::ImVec2 (&D.20484, _1273, bg_offy_dn_1241);
  D.20485 = operator+ (&rect_pos, &D.20484);
  _1276 = g_227->FontSize;
  _1277 = bg_offy_up_1238 - _1276;
  ImVec2::ImVec2 (&D.20482, 0.0, _1277);
  D.20483 = operator+ (&rect_pos, &D.20482);
  ImRect::ImRect (&rect, &D.20483, &D.20485);
  D.20483 ={v} {CLOBBER};
  D.20482 ={v} {CLOBBER};
  D.20485 ={v} {CLOBBER};
  D.20484 ={v} {CLOBBER};
  ImRect::ImRect (&D.20486, &clip_rect);
  ImRect::ClipWith (&rect, &D.20486);
  D.20486 ={v} {CLOBBER};
  ImRect::ImRect (&D.20487, &clip_rect);
  retval.1687_1290 = ImRect::Overlaps (&rect, &D.20487);
  D.20487 ={v} {CLOBBER};
  if (retval.1687_1290 != 0)
    goto <bb 486>;
  else
    goto <bb 488>;

  <bb 486>:
  _1292 = draw_window_1->DrawList;
  ImDrawList::AddRectFilled (_1292, &rect.Min, &rect.Max, bg_color_1243, 0.0, 15);

  <bb 487>:

  <bb 488>:
  rect_size ={v} {CLOBBER};
  rect ={v} {CLOBBER};

  <bb 489>:
  _1300 = render_pos.x;
  _1301 = render_scroll.x;
  _1302 = _1300 - _1301;
  rect_pos.x = _1302;
  _1304 = rect_pos.y;
  _1305 = g_227->FontSize;
  _1306 = _1304 + _1305;
  rect_pos.y = _1306;
  goto <bb 474>;

  <bb 490>:
  p ={v} {CLOBBER};
  rect_pos ={v} {CLOBBER};

  <bb 491>:
  if (is_multiline_231 != 0)
    goto <bb 492>;
  else
    goto <bb 493>;

  <bb 492>:
  iftmp.1688_1310 = 0B;
  goto <bb 494>;

  <bb 493>:
  iftmp.1688_1311 = &clip_rect;

  <bb 494>:
  # iftmp.1688_82 = PHI <iftmp.1688_1310(492), iftmp.1688_1311(493)>
  _1312 = edit_state_336->CurLenA;
  _1313 = (sizetype) _1312;
  _1314 = buf_display_1032 + _1313;
  _1316 = ImGui::GetColorU32 (0, 1.0e+0);
  D.20488 = operator- (&render_pos, &render_scroll);
  _1318 = g_227->FontSize;
  _1319 = g_227->Font;
  _1320 = draw_window_1->DrawList;
  ImDrawList::AddText (_1320, _1319, _1318, &D.20488, _1316, buf_display_1032, _1314, 0.0, iftmp.1688_82);
  D.20488 ={v} {CLOBBER};
  _1323 = g_227->IO.OptCursorBlink;
  _1324 = ~_1323;
  if (_1324 != 0)
    goto <bb 497>;
  else
    goto <bb 495>;

  <bb 495>:
  _1325 = g_227->InputTextState.CursorAnim;
  if (_1325 <= 0.0)
    goto <bb 497>;
  else
    goto <bb 496>;

  <bb 496>:
  _1326 = g_227->InputTextState.CursorAnim;
  _1328 = fmodf (_1326, 1.2000000476837158203125e+0);
  if (_1328 <= 8.00000011920928955078125e-1)
    goto <bb 497>;
  else
    goto <bb 498>;

  <bb 497>:
  iftmp.1689_1330 = 1;
  goto <bb 499>;

  <bb 498>:
  iftmp.1689_1329 = 0;

  <bb 499>:
  # iftmp.1689_83 = PHI <iftmp.1689_1330(497), iftmp.1689_1329(498)>
  cursor_is_visible_1331 = iftmp.1689_83;
  D.20491 = operator+ (&render_pos, &cursor_offset);
  cursor_screen_pos = operator- (&D.20491, &render_scroll);
  D.20491 ={v} {CLOBBER};
  _1335 = cursor_screen_pos.y;
  _1336 = _1335 - 1.5e+0;
  _1337 = cursor_screen_pos.x;
  _1338 = _1337 + 1.0e+0;
  _1339 = cursor_screen_pos.y;
  _1340 = g_227->FontSize;
  _1341 = _1339 - _1340;
  _1342 = _1341 + 5.0e-1;
  _1343 = cursor_screen_pos.x;
  ImRect::ImRect (&cursor_screen_rect, _1343, _1342, _1338, _1336);
  if (cursor_is_visible_1331 != 0)
    goto <bb 500>;
  else
    goto <bb 502>;

  <bb 500>:
  ImRect::ImRect (&D.20494, &clip_rect);
  _1347 = ImRect::Overlaps (&cursor_screen_rect, &D.20494);
  if (_1347 != 0)
    goto <bb 501>;
  else
    goto <bb 502>;

  <bb 501>:
  iftmp.1691_1348 = 1;
  goto <bb 503>;

  <bb 502>:
  iftmp.1691_1349 = 0;

  <bb 503>:
  # iftmp.1691_84 = PHI <iftmp.1691_1348(501), iftmp.1691_1349(502)>
  retval.1690_1350 = iftmp.1691_84;
  D.20494 ={v} {CLOBBER};
  if (retval.1690_1350 != 0)
    goto <bb 504>;
  else
    goto <bb 505>;

  <bb 504>:
  _1353 = ImGui::GetColorU32 (0, 1.0e+0);
  D.20495 = ImRect::GetBL (&cursor_screen_rect);
  _1355 = draw_window_1->DrawList;
  ImDrawList::AddLine (_1355, &cursor_screen_rect.Min, &D.20495, _1353, 1.0e+0);
  D.20495 ={v} {CLOBBER};

  <bb 505>:
  if (is_editable_233 != 0)
    goto <bb 506>;
  else
    goto <bb 507>;

  <bb 506>:
  _1359 = cursor_screen_pos.y;
  _1360 = g_227->FontSize;
  _1361 = _1359 - _1360;
  _1362 = cursor_screen_pos.x;
  _1363 = _1362 - 1.0e+0;
  ImVec2::ImVec2 (&D.20496, _1363, _1361);
  g_227->OsImePosRequest = D.20496;
  D.20496 ={v} {CLOBBER};

  <bb 507>:
  cursor_offset ={v} {CLOBBER};
  select_start_offset ={v} {CLOBBER};
  render_scroll ={v} {CLOBBER};
  cursor_screen_pos ={v} {CLOBBER};
  cursor_screen_rect ={v} {CLOBBER};
  goto <bb 514>;

  <bb 508>:
  buf_end = 0B;
  if (is_multiline_231 != 0)
    goto <bb 509>;
  else
    goto <bb 510>;

  <bb 509>:
  _1064 = InputTextCalcTextLenAndLineCount (buf_display_1032, &buf_end);
  _1065 = (float) _1064;
  _1066 = g_227->FontSize;
  _1067 = _1065 * _1066;
  _1068 = size.x;
  ImVec2::ImVec2 (&text_size.1692, _1068, _1067);
  text_size = text_size.1692;
  text_size.1692 ={v} {CLOBBER};

  <bb 510>:
  if (is_multiline_231 != 0)
    goto <bb 511>;
  else
    goto <bb 512>;

  <bb 511>:
  iftmp.1693_1072 = 0B;
  goto <bb 513>;

  <bb 512>:
  iftmp.1693_1073 = &clip_rect;

  <bb 513>:
  # iftmp.1693_85 = PHI <iftmp.1693_1072(511), iftmp.1693_1073(512)>
  buf_end.1694_1074 = buf_end;
  _1076 = ImGui::GetColorU32 (0, 1.0e+0);
  _1077 = g_227->FontSize;
  _1078 = g_227->Font;
  _1079 = draw_window_1->DrawList;
  ImDrawList::AddText (_1079, _1078, _1077, &render_pos, _1076, buf_display_1032, buf_end.1694_1074, 0.0, iftmp.1693_85);
  buf_end ={v} {CLOBBER};

  <bb 514>:
  if (is_multiline_231 != 0)
    goto <bb 515>;
  else
    goto <bb 516>;

  <bb 515>:
  _1380 = g_227->FontSize;
  ImVec2::ImVec2 (&D.20499, 0.0, _1380);
  D.20500 = operator+ (&text_size, &D.20499);
  ImGui::Dummy (&D.20500);
  D.20500 ={v} {CLOBBER};
  D.20499 ={v} {CLOBBER};
  ImGui::EndChildFrame ();
  ImGui::EndGroup ();

  <bb 516>:
  if (is_password_235 != 0)
    goto <bb 517>;
  else
    goto <bb 518>;

  <bb 517>:
  ImGui::PopFont ();

  <bb 518>:
  _1391 = g_227->LogEnabled;
  if (_1391 != 0)
    goto <bb 519>;
  else
    goto <bb 521>;

  <bb 519>:
  _1392 = ~is_password_235;
  if (_1392 != 0)
    goto <bb 520>;
  else
    goto <bb 521>;

  <bb 520>:
  LogRenderedText (&render_pos, buf_display_1032, 0B);

  <bb 521>:
  _1394 = label_size.x;
  if (_1394 > 0.0)
    goto <bb 522>;
  else
    goto <bb 523>;

  <bb 522>:
  _1395 = frame_bb.Min.y;
  _1396 = style_229->FramePadding.y;
  _1397 = _1395 + _1396;
  _1398 = frame_bb.Max.x;
  _1399 = style_229->ItemInnerSpacing.x;
  _1400 = _1398 + _1399;
  ImVec2::ImVec2 (&D.20501, _1400, _1397);
  ImGui::RenderText (D.20501, label_239(D), 0B, 1);
  D.20501 ={v} {CLOBBER};

  <bb 523>:
  _1405 = flags_220(D) & 32;
  if (_1405 != 0)
    goto <bb 524>;
  else
    goto <bb 525>;

  <bb 524>:
  _1406 = enter_pressed_16;
  goto <bb 526>;

  <bb 525>:
  _1407 = value_changed_13;

  <bb 526>:
  # _34 = PHI <_219(3), _281(20), _295(23), _1406(524), _1407(525)>
  label_size ={v} {CLOBBER};
  size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  clip_rect ={v} {CLOBBER};
  render_pos ={v} {CLOBBER};
  text_size ={v} {CLOBBER};

<L654>:
  return _34;

<L664>:
  _207 = __builtin_eh_pointer (27);
  __builtin_unwind_resume (_207);

}



;; Function bool ImGui::InputText(const char*, char*, size_t, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (_ZN5ImGui9InputTextEPKcPcmiPFiP25ImGuiTextEditCallbackDataEPv, funcdef_no=1092, decl_uid=2944, cgraph_uid=991, symbol_order=1002)

bool ImGui::InputText(const char*, char*, size_t, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (const char * label, char * buf, size_t buf_size, ImGuiInputTextFlags flags, int (*ImGuiTextEditCallback) (struct ImGuiTextEditCallbackData *) callback, void * user_data)
{
  bool D.40346;
  static const char __PRETTY_FUNCTION__[101] = "bool ImGui::InputText(const char*, char*, size_t, ImGuiInputTextFlags, ImGuiTextEditCallback, void*)";
  int D.40344;
  struct ImVec2 D.20521;
  bool D.40343;
  int D.40339;
  int _2;
  int _6;
  bool _12;
  bool _13;

  <bb 2>:
  _2 = flags_1(D) & 1048576;
  if (_2 == 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("!(flags & ImGuiInputTextFlags_Multiline)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10489, &__PRETTY_FUNCTION__);

  <bb 4>:
  ImVec2::ImVec2 (&D.20521, 0.0, 0.0);
  _6 = (int) buf_size_5(D);
  _12 = ImGui::InputTextEx (label_7(D), buf_8(D), _6, &D.20521, flags_1(D), callback_9(D), user_data_10(D));
  _13 = _12;
  D.20521 ={v} {CLOBBER};

<L4>:
  return _13;

}



;; Function bool ImGui::InputTextMultiline(const char*, char*, size_t, const ImVec2&, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (_ZN5ImGui18InputTextMultilineEPKcPcmRK6ImVec2iPFiP25ImGuiTextEditCallbackDataEPv, funcdef_no=1093, decl_uid=2953, cgraph_uid=992, symbol_order=1003)

bool ImGui::InputTextMultiline(const char*, char*, size_t, const ImVec2&, ImGuiInputTextFlags, ImGuiTextEditCallback, void*) (const char * label, char * buf, size_t buf_size, const struct ImVec2 & size, ImGuiInputTextFlags flags, int (*ImGuiTextEditCallback) (struct ImGuiTextEditCallbackData *) callback, void * user_data)
{
  bool D.40353;
  int D.40351;
  int D.40350;
  bool D.40349;
  int _2;
  int _4;
  bool _12;
  bool _13;

  <bb 2>:
  _2 = flags_1(D) | 1048576;
  _4 = (int) buf_size_3(D);
  _12 = ImGui::InputTextEx (label_6(D), buf_7(D), _4, size_8(D), _2, callback_9(D), user_data_10(D));
  _13 = _12;

<L0>:
  return _13;

}



;; Function bool ImGui::InputScalarEx(const char*, ImGuiDataType, void*, void*, void*, const char*, ImGuiInputTextFlags) (_ZN5ImGui13InputScalarExEPKc13ImGuiDataTypePvS3_S3_S1_i, funcdef_no=1094, decl_uid=14021, cgraph_uid=993, symbol_order=1004)

bool ImGui::InputScalarEx(const char*, ImGuiDataType, void*, void*, void*, const char*, ImGuiInputTextFlags) (const char * label, ImGuiDataType data_type, void * data_ptr, void * step_ptr, void * step_fast_ptr, const char * scalar_format, ImGuiInputTextFlags extra_flags)
{
  bool D.40420;
  bool D.40419;
  bool D.40418;
  float D.40417;
  bool value_changed;
  char buf[64];
  const struct ImVec2 button_sz;
  const struct ImVec2 label_size;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.40414;
  float D.40413;
  float D.40412;
  float D.40411;
  float D.40410;
  struct ImVec2 D.20549;
  float D.40409;
  float D.40406;
  bool D.40401;
  void * iftmp.1702;
  bool retval.1701;
  float D.40394;
  bool D.40390;
  void * iftmp.1700;
  bool retval.1699;
  float D.40383;
  value_type * D.40379;
  struct ImVector * D.40378;
  struct ImGuiContext * GImGui.1698;
  bool retval.1697;
  int D.40370;
  float D.40368;
  float D.40367;
  float D.40366;
  float D.40365;
  float D.40364;
  float D.40363;
  float D.40362;
  float D.40359;
  float D.40358;
  bool D.40357;
  bool D.40354;
  bool _5;
  void * iftmp.1700_6;
  void * iftmp.1702_7;
  bool _18;
  bool _19;
  float _27;
  float _29;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _38;
  float _39;
  float _41;
  int _49;
  bool _53;
  bool retval.1697_54;
  struct ImGuiContext * GImGui.1698_55;
  struct ImVector * _56;
  value_type * _58;
  float _62;
  bool _65;
  bool retval.1699_66;
  bool _67;
  void * iftmp.1700_69;
  void * iftmp.1700_70;
  float _73;
  bool _76;
  bool retval.1701_77;
  bool _78;
  void * iftmp.1702_79;
  void * iftmp.1702_80;
  float _84;
  float _85;
  float _87;
  float _88;
  float _89;
  float _90;
  float _94;
  bool _98;

  <bb 2>:
  window_17 = ImGui::GetCurrentWindow ();
  _18 = window_17->SkipItems;
  if (_18 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _19 = 0;
  goto <bb 26>;

  <bb 4>:
  g_20 = GImGui;
  style_21 = &g_20->Style;
  label_size = ImGui::CalcTextSize (label_22(D), 0B, 1, -1.0e+0);
  ImGui::BeginGroup ();
  ImGui::PushID (label_22(D));
  _27 = ImGui::GetFrameHeight ();
  _29 = ImGui::GetFrameHeight ();
  ImVec2::ImVec2 (&button_sz, _29, _27);
  if (step_ptr_31(D) != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _33 = ImGui::CalcItemWidth ();
  _34 = _33;
  _35 = button_sz.x;
  _36 = style_21->ItemInnerSpacing.x;
  _37 = _35 + _36;
  _38 = _37 * 2.0e+0;
  _39 = _34 - _38;
  _41 = ImMax (1.0e+0, _39);
  ImGui::PushItemWidth (_41);

  <bb 6>:
  DataTypeFormatString (data_type_43(D), data_ptr_44(D), scalar_format_45(D), &buf, 64);
  value_changed_47 = 0;
  _49 = extra_flags_48(D) & 131074;
  if (_49 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  extra_flags_50 = extra_flags_48(D) | 1;

  <bb 8>:
  # extra_flags_1 = PHI <extra_flags_48(D)(6), extra_flags_50(7)>
  extra_flags_51 = extra_flags_1 | 16;
  _53 = ImGui::InputText ("", &buf, 64, extra_flags_51, 0B, 0B);
  retval.1697_54 = _53;
  if (retval.1697_54 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  GImGui.1698_55 = GImGui;
  _56 = &GImGui.1698_55->InputTextState.InitialText;
  _58 = ImVector<char>::begin (_56);
  value_changed_60 = DataTypeApplyOpFromText (&buf, _58, data_type_43(D), data_ptr_44(D), scalar_format_45(D));

  <bb 10>:
  # value_changed_2 = PHI <value_changed_47(8), value_changed_60(9)>
  if (step_ptr_31(D) != 0B)
    goto <bb 11>;
  else
    goto <bb 23>;

  <bb 11>:
  ImGui::PopItemWidth ();
  _62 = style_21->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _62);
  _65 = ImGui::ButtonEx ("-", &button_sz, 129);
  retval.1699_66 = _65;
  if (retval.1699_66 != 0)
    goto <bb 12>;
  else
    goto <bb 17>;

  <bb 12>:
  _67 = g_20->IO.KeyCtrl;
  if (_67 != 0)
    goto <bb 13>;
  else
    goto <bb 15>;

  <bb 13>:
  if (step_fast_ptr_68(D) != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  iftmp.1700_69 = step_fast_ptr_68(D);
  goto <bb 16>;

  <bb 15>:
  iftmp.1700_70 = step_ptr_31(D);

  <bb 16>:
  # iftmp.1700_6 = PHI <iftmp.1700_69(14), iftmp.1700_70(15)>
  DataTypeApplyOp (data_type_43(D), 45, data_ptr_44(D), data_ptr_44(D), iftmp.1700_6);
  value_changed_72 = 1;

  <bb 17>:
  # value_changed_3 = PHI <value_changed_2(11), value_changed_72(16)>
  _73 = style_21->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _73);
  _76 = ImGui::ButtonEx ("+", &button_sz, 129);
  retval.1701_77 = _76;
  if (retval.1701_77 != 0)
    goto <bb 18>;
  else
    goto <bb 23>;

  <bb 18>:
  _78 = g_20->IO.KeyCtrl;
  if (_78 != 0)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  if (step_fast_ptr_68(D) != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  iftmp.1702_79 = step_fast_ptr_68(D);
  goto <bb 22>;

  <bb 21>:
  iftmp.1702_80 = step_ptr_31(D);

  <bb 22>:
  # iftmp.1702_7 = PHI <iftmp.1702_79(20), iftmp.1702_80(21)>
  DataTypeApplyOp (data_type_43(D), 43, data_ptr_44(D), data_ptr_44(D), iftmp.1702_7);
  value_changed_82 = 1;

  <bb 23>:
  # value_changed_4 = PHI <value_changed_2(10), value_changed_82(22), value_changed_3(17)>
  ImGui::PopID ();
  _84 = label_size.x;
  if (_84 > 0.0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _85 = style_21->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _85);
  _87 = window_17->DC.CursorPos.y;
  _88 = style_21->FramePadding.y;
  _89 = _87 + _88;
  _90 = window_17->DC.CursorPos.x;
  ImVec2::ImVec2 (&D.20549, _90, _89);
  ImGui::RenderText (D.20549, label_22(D), 0B, 1);
  D.20549 ={v} {CLOBBER};
  _94 = style_21->FramePadding.y;
  ImGui::ItemSize (&label_size, _94);

  <bb 25>:
  ImGui::EndGroup ();
  _98 = value_changed_4;

  <bb 26>:
  # _5 = PHI <_19(3), _98(25)>
  label_size ={v} {CLOBBER};
  button_sz ={v} {CLOBBER};
  buf ={v} {CLOBBER};

<L32>:
  return _5;

}



;; Function bool ImGui::InputFloat(const char*, float*, float, float, int, ImGuiInputTextFlags) (_ZN5ImGui10InputFloatEPKcPfffii, funcdef_no=1095, decl_uid=2960, cgraph_uid=994, symbol_order=1005)

bool ImGui::InputFloat(const char*, float*, float, float, int, ImGuiInputTextFlags) (const char * label, float * v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
  bool D.40465;
  bool D.40464;
  char display_format[16];
  float step.1710;
  void * iftmp.1709;
  float step_fast.1708;
  void * iftmp.1707;
  float step.1706;
  void * iftmp.1705;
  float step_fast.1704;
  void * iftmp.1703;
  bool D.40442;
  bool _1;
  void * iftmp.1703_2;
  void * iftmp.1705_3;
  void * iftmp.1707_4;
  void * iftmp.1709_5;
  float step_fast.1704_11;
  void * iftmp.1703_12;
  void * iftmp.1703_13;
  float step.1706_14;
  void * iftmp.1705_15;
  void * iftmp.1705_16;
  bool _20;
  bool _21;
  float step_fast.1708_23;
  void * iftmp.1707_24;
  void * iftmp.1707_25;
  float step.1710_26;
  void * iftmp.1709_27;
  void * iftmp.1709_28;
  bool _30;
  bool _31;

  <bb 2>:
  extra_flags_8 = extra_flags_7(D) | 131072;
  if (decimal_precision_9(D) < 0)
    goto <bb 3>;
  else
    goto <bb 10>;

  <bb 3>:
  step_fast.1704_11 = step_fast;
  if (step_fast.1704_11 > 0.0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1703_12 = &step_fast;
  goto <bb 6>;

  <bb 5>:
  iftmp.1703_13 = 0B;

  <bb 6>:
  # iftmp.1703_2 = PHI <iftmp.1703_12(4), iftmp.1703_13(5)>
  step.1706_14 = step;
  if (step.1706_14 > 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1705_15 = &step;
  goto <bb 9>;

  <bb 8>:
  iftmp.1705_16 = 0B;

  <bb 9>:
  # iftmp.1705_3 = PHI <iftmp.1705_15(7), iftmp.1705_16(8)>
  _20 = ImGui::InputScalarEx (label_17(D), 1, v_18(D), iftmp.1705_3, iftmp.1703_2, "%f", extra_flags_8);
  _21 = _20;
  goto <bb 17> (<L15>);

  <bb 10>:
  ImFormatString (&display_format, 16, "%%.%df", decimal_precision_9(D));
  step_fast.1708_23 = step_fast;
  if (step_fast.1708_23 > 0.0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.1707_24 = &step_fast;
  goto <bb 13>;

  <bb 12>:
  iftmp.1707_25 = 0B;

  <bb 13>:
  # iftmp.1707_4 = PHI <iftmp.1707_24(11), iftmp.1707_25(12)>
  step.1710_26 = step;
  if (step.1710_26 > 0.0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  iftmp.1709_27 = &step;
  goto <bb 16>;

  <bb 15>:
  iftmp.1709_28 = 0B;

  <bb 16>:
  # iftmp.1709_5 = PHI <iftmp.1709_27(14), iftmp.1709_28(15)>
  _30 = ImGui::InputScalarEx (label_17(D), 1, v_18(D), iftmp.1709_5, iftmp.1707_4, &display_format, extra_flags_8);
  _31 = _30;
  display_format ={v} {CLOBBER};

  # _1 = PHI <_21(9), _31(16)>
<L15>:
  return _1;

}



;; Function bool ImGui::InputDouble(const char*, double*, double, double, const char*, ImGuiInputTextFlags) (_ZN5ImGui11InputDoubleEPKcPdddS1_i, funcdef_no=1096, decl_uid=3000, cgraph_uid=995, symbol_order=1006)

bool ImGui::InputDouble(const char*, double*, double, double, const char*, ImGuiInputTextFlags) (const char * label, double * v, double step, double step_fast, const char * display_format, ImGuiInputTextFlags extra_flags)
{
  bool D.40480;
  double step.1714;
  void * iftmp.1713;
  double step_fast.1712;
  void * iftmp.1711;
  bool D.40468;
  void * iftmp.1711_1;
  void * iftmp.1713_2;
  double step_fast.1712_6;
  void * iftmp.1711_7;
  void * iftmp.1711_8;
  double step.1714_9;
  void * iftmp.1713_10;
  void * iftmp.1713_11;
  bool _16;
  bool _17;

  <bb 2>:
  extra_flags_4 = extra_flags_3(D) | 131072;
  step_fast.1712_6 = step_fast;
  if (step_fast.1712_6 > 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1711_7 = &step_fast;
  goto <bb 5>;

  <bb 4>:
  iftmp.1711_8 = 0B;

  <bb 5>:
  # iftmp.1711_1 = PHI <iftmp.1711_7(3), iftmp.1711_8(4)>
  step.1714_9 = step;
  if (step.1714_9 > 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1713_10 = &step;
  goto <bb 8>;

  <bb 7>:
  iftmp.1713_11 = 0B;

  <bb 8>:
  # iftmp.1713_2 = PHI <iftmp.1713_10(6), iftmp.1713_11(7)>
  _16 = ImGui::InputScalarEx (label_12(D), 2, v_13(D), iftmp.1713_2, iftmp.1711_1, display_format_14(D), extra_flags_4);
  _17 = _16;

<L6>:
  return _17;

}



;; Function bool ImGui::InputInt(const char*, int*, int, int, ImGuiInputTextFlags) (_ZN5ImGui8InputIntEPKcPiiii, funcdef_no=1097, decl_uid=2981, cgraph_uid=996, symbol_order=1007)

bool ImGui::InputInt(const char*, int*, int, int, ImGuiInputTextFlags) (const char * label, int * v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
{
  bool D.40498;
  const char * scalar_format;
  int step.1719;
  void * iftmp.1718;
  int step_fast.1717;
  void * iftmp.1716;
  bool D.40486;
  int D.40482;
  const char * iftmp.1715;
  const char * iftmp.1715_1;
  void * iftmp.1716_2;
  void * iftmp.1718_3;
  int _5;
  const char * iftmp.1715_6;
  const char * iftmp.1715_7;
  int step_fast.1717_10;
  void * iftmp.1716_11;
  void * iftmp.1716_12;
  int step.1719_13;
  void * iftmp.1718_14;
  void * iftmp.1718_15;
  bool _19;
  bool _20;

  <bb 2>:
  _5 = extra_flags_4(D) & 2;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1715_6 = "%08X";
  goto <bb 5>;

  <bb 4>:
  iftmp.1715_7 = "%d";

  <bb 5>:
  # iftmp.1715_1 = PHI <iftmp.1715_6(3), iftmp.1715_7(4)>
  scalar_format_8 = iftmp.1715_1;
  step_fast.1717_10 = step_fast;
  if (step_fast.1717_10 > 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1716_11 = &step_fast;
  goto <bb 8>;

  <bb 7>:
  iftmp.1716_12 = 0B;

  <bb 8>:
  # iftmp.1716_2 = PHI <iftmp.1716_11(6), iftmp.1716_12(7)>
  step.1719_13 = step;
  if (step.1719_13 > 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1718_14 = &step;
  goto <bb 11>;

  <bb 10>:
  iftmp.1718_15 = 0B;

  <bb 11>:
  # iftmp.1718_3 = PHI <iftmp.1718_14(9), iftmp.1718_15(10)>
  _19 = ImGui::InputScalarEx (label_16(D), 0, v_17(D), iftmp.1718_3, iftmp.1716_2, scalar_format_8, extra_flags_4(D));
  _20 = _19;

<L9>:
  return _20;

}



;; Function bool ImGui::InputFloatN(const char*, float*, int, int, ImGuiInputTextFlags) (_ZN5ImGui11InputFloatNEPKcPfiii, funcdef_no=1098, decl_uid=14008, cgraph_uid=997, symbol_order=1008)

bool ImGui::InputFloatN(const char*, float*, int, int, ImGuiInputTextFlags) (const char * label, float * v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
  bool D.40511;
  int i;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.40509;
  float D.40508;
  float * D.40507;
  long unsigned int D.40506;
  long unsigned int D.40505;
  bool D.20586;
  bool D.40502;
  bool D.40499;
  bool _3;
  bool _9;
  bool _10;
  long unsigned int _20;
  long unsigned int _21;
  float * _23;
  bool _27;
  bool _28;
  float _30;
  const char * _37;
  bool _40;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 8> (<L5>);

  <bb 4>:
  g_11 = GImGui;
  value_changed_12 = 0;
  ImGui::BeginGroup ();
  ImGui::PushID (label_14(D));
  ImGui::PushMultiItemsWidths (components_16(D), 0.0);
  i_18 = 0;

  <bb 5>:
  # value_changed_1 = PHI <value_changed_12(4), value_changed_29(6)>
  # i_2 = PHI <i_18(4), i_34(6)>
  if (i_2 >= components_16(D))
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ImGui::PushID (i_2);
  _20 = (long unsigned int) i_2;
  _21 = _20 * 4;
  _23 = v_22(D) + _21;
  _27 = ImGui::InputFloat ("##v", _23, 0.0, 0.0, decimal_precision_24(D), extra_flags_25(D));
  _28 = _27;
  value_changed_29 = value_changed_1 | _28;
  _30 = g_11->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _30);
  ImGui::PopID ();
  ImGui::PopItemWidth ();
  i_34 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::PopID ();
  _37 = ImGui::FindRenderedTextEnd (label_14(D), 0B);
  ImGui::TextUnformatted (label_14(D), _37);
  ImGui::EndGroup ();
  _40 = value_changed_1;

  # _3 = PHI <_10(3), _40(7)>
<L5>:
  return _3;

}



;; Function bool ImGui::InputFloat2(const char*, float*, int, ImGuiInputTextFlags) (_ZN5ImGui11InputFloat2EPKcPfii, funcdef_no=1099, decl_uid=2965, cgraph_uid=998, symbol_order=1009)

bool ImGui::InputFloat2(const char*, float*, int, ImGuiInputTextFlags) (const char * label, float * v, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
  bool D.40514;
  bool D.40512;
  bool _7;
  bool _8;

  <bb 2>:
  _7 = ImGui::InputFloatN (label_2(D), v_3(D), 2, decimal_precision_4(D), extra_flags_5(D));
  _8 = _7;

<L0>:
  return _8;

}



;; Function bool ImGui::InputFloat3(const char*, float*, int, ImGuiInputTextFlags) (_ZN5ImGui11InputFloat3EPKcPfii, funcdef_no=1100, decl_uid=2970, cgraph_uid=999, symbol_order=1010)

bool ImGui::InputFloat3(const char*, float*, int, ImGuiInputTextFlags) (const char * label, float * v, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
  bool D.40517;
  bool D.40515;
  bool _7;
  bool _8;

  <bb 2>:
  _7 = ImGui::InputFloatN (label_2(D), v_3(D), 3, decimal_precision_4(D), extra_flags_5(D));
  _8 = _7;

<L0>:
  return _8;

}



;; Function bool ImGui::InputFloat4(const char*, float*, int, ImGuiInputTextFlags) (_ZN5ImGui11InputFloat4EPKcPfii, funcdef_no=1101, decl_uid=2975, cgraph_uid=1000, symbol_order=1011)

bool ImGui::InputFloat4(const char*, float*, int, ImGuiInputTextFlags) (const char * label, float * v, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
  bool D.40520;
  bool D.40518;
  bool _7;
  bool _8;

  <bb 2>:
  _7 = ImGui::InputFloatN (label_2(D), v_3(D), 4, decimal_precision_4(D), extra_flags_5(D));
  _8 = _7;

<L0>:
  return _8;

}



;; Function bool ImGui::InputIntN(const char*, int*, int, ImGuiInputTextFlags) (_ZN5ImGui9InputIntNEPKcPiii, funcdef_no=1102, decl_uid=14013, cgraph_uid=1001, symbol_order=1012)

bool ImGui::InputIntN(const char*, int*, int, ImGuiInputTextFlags) (const char * label, int * v, int components, ImGuiInputTextFlags extra_flags)
{
  bool D.40533;
  int i;
  bool value_changed;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const char * D.40531;
  float D.40530;
  int * D.40529;
  long unsigned int D.40528;
  long unsigned int D.40527;
  bool D.20617;
  bool D.40524;
  bool D.40521;
  bool _3;
  bool _9;
  bool _10;
  long unsigned int _20;
  long unsigned int _21;
  int * _23;
  bool _26;
  bool _27;
  float _29;
  const char * _36;
  bool _39;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 8> (<L5>);

  <bb 4>:
  g_11 = GImGui;
  value_changed_12 = 0;
  ImGui::BeginGroup ();
  ImGui::PushID (label_14(D));
  ImGui::PushMultiItemsWidths (components_16(D), 0.0);
  i_18 = 0;

  <bb 5>:
  # value_changed_1 = PHI <value_changed_12(4), value_changed_28(6)>
  # i_2 = PHI <i_18(4), i_33(6)>
  if (i_2 >= components_16(D))
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  ImGui::PushID (i_2);
  _20 = (long unsigned int) i_2;
  _21 = _20 * 4;
  _23 = v_22(D) + _21;
  _26 = ImGui::InputInt ("##v", _23, 0, 0, extra_flags_24(D));
  _27 = _26;
  value_changed_28 = value_changed_1 | _27;
  _29 = g_11->Style.ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _29);
  ImGui::PopID ();
  ImGui::PopItemWidth ();
  i_33 = i_2 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::PopID ();
  _36 = ImGui::FindRenderedTextEnd (label_14(D), 0B);
  ImGui::TextUnformatted (label_14(D), _36);
  ImGui::EndGroup ();
  _39 = value_changed_1;

  # _3 = PHI <_10(3), _39(7)>
<L5>:
  return _3;

}



;; Function bool ImGui::InputInt2(const char*, int*, ImGuiInputTextFlags) (_ZN5ImGui9InputInt2EPKcPii, funcdef_no=1103, decl_uid=2985, cgraph_uid=1002, symbol_order=1013)

bool ImGui::InputInt2(const char*, int*, ImGuiInputTextFlags) (const char * label, int * v, ImGuiInputTextFlags extra_flags)
{
  bool D.40536;
  bool D.40534;
  bool _6;
  bool _7;

  <bb 2>:
  _6 = ImGui::InputIntN (label_2(D), v_3(D), 2, extra_flags_4(D));
  _7 = _6;

<L0>:
  return _7;

}



;; Function bool ImGui::InputInt3(const char*, int*, ImGuiInputTextFlags) (_ZN5ImGui9InputInt3EPKcPii, funcdef_no=1104, decl_uid=2989, cgraph_uid=1003, symbol_order=1014)

bool ImGui::InputInt3(const char*, int*, ImGuiInputTextFlags) (const char * label, int * v, ImGuiInputTextFlags extra_flags)
{
  bool D.40539;
  bool D.40537;
  bool _6;
  bool _7;

  <bb 2>:
  _6 = ImGui::InputIntN (label_2(D), v_3(D), 3, extra_flags_4(D));
  _7 = _6;

<L0>:
  return _7;

}



;; Function bool ImGui::InputInt4(const char*, int*, ImGuiInputTextFlags) (_ZN5ImGui9InputInt4EPKcPii, funcdef_no=1105, decl_uid=2993, cgraph_uid=1004, symbol_order=1015)

bool ImGui::InputInt4(const char*, int*, ImGuiInputTextFlags) (const char * label, int * v, ImGuiInputTextFlags extra_flags)
{
  bool D.40542;
  bool D.40540;
  bool _6;
  bool _7;

  <bb 2>:
  _6 = ImGui::InputIntN (label_2(D), v_3(D), 4, extra_flags_4(D));
  _7 = _6;

<L0>:
  return _7;

}



;; Function float CalcMaxPopupHeightFromItemCount(int) (_ZL31CalcMaxPopupHeightFromItemCounti, funcdef_no=1106, decl_uid=20636, cgraph_uid=1005, symbol_order=1016)

float CalcMaxPopupHeightFromItemCount(int) (int items_count)
{
  struct ImGuiContext & g;
  float D.40554;
  float D.40553;
  float D.40552;
  float D.40551;
  float D.40550;
  float D.40549;
  float D.40548;
  float D.40547;
  float D.40546;
  float D.40545;
  float _1;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;

  <bb 2>:
  g_3 = GImGui;
  if (items_count_4(D) <= 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = 3.4028234663852885981170418348451692544e+38;
  goto <bb 5> (<L2>);

  <bb 4>:
  _6 = g_3->FontSize;
  _7 = g_3->Style.ItemSpacing.y;
  _8 = _6 + _7;
  _9 = (float) items_count_4(D);
  _10 = _8 * _9;
  _11 = g_3->Style.ItemSpacing.y;
  _12 = _10 - _11;
  _13 = g_3->Style.WindowPadding.y;
  _14 = _13 * 2.0e+0;
  _15 = _12 + _14;

  # _1 = PHI <_5(3), _15(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::BeginCombo(const char*, const char*, ImGuiComboFlags) (_ZN5ImGui10BeginComboEPKcS1_i, funcdef_no=1107, decl_uid=2836, cgraph_uid=1006, symbol_order=1017)

bool ImGui::BeginCombo(const char*, const char*, ImGuiComboFlags) (const char * label, const char * preview_value, ImGuiComboFlags flags)
{
  bool D.40736;
  struct ImGuiWindow * D.40734;
  bool D.40727;
  bool D.40726;
  bool D.40725;
  float D.40724;
  const ImGuiID D.40723;
  struct ImVec2 pos;
  struct ImVec2 size_expected;
  struct ImVec2 size_contents;
  struct ImGuiWindow * popup_window;
  int popup_max_height_in_items;
  ImGuiWindowFlags window_flags;
  char name[16];
  const ImU32 frame_col;
  const struct ImRect value_bb;
  bool popup_open;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect total_bb;
  const struct ImRect frame_bb;
  const float w;
  const struct ImVec2 label_size;
  const float arrow_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  static const char __PRETTY_FUNCTION__[66] = "bool ImGui::BeginCombo(const char*, const char*, ImGuiComboFlags)";
  struct ImGuiWindow * window;
  ImGuiCond backup_next_window_size_constraint;
  struct ImGuiContext & g;
  float D.40720;
  float D.40719;
  float D.40718;
  float D.40715;
  float D.40714;
  bool D.40708;
  bool retval.1729;
  struct ImVec2 D.20689;
  struct ImVec2 D.20687;
  ImGuiDir * D.40704;
  int D.40700;
  struct ImVec2 D.40699;
  bool D.40696;
  int D.40693;
  struct ImVec2 D.20677;
  float D.40692;
  struct ImVec2 D.20678;
  int D.40688;
  int D.40684;
  int D.40680;
  bool D.40676;
  int D.40675;
  int D.40671;
  float D.40669;
  float D.40668;
  bool D.40663;
  int D.40658;
  bool D.40655;
  unsigned int D.40654;
  float D.40649;
  float D.40648;
  float D.40647;
  float D.40646;
  float D.40645;
  float D.40644;
  struct ImVec2 D.20675;
  float D.40641;
  const struct ImVec2 * D.40639;
  struct ImVec2 D.20673;
  struct ImVec2 D.20674;
  int D.40636;
  float D.40633;
  float D.40631;
  float D.40630;
  float D.40629;
  float D.40628;
  float D.40627;
  float D.40626;
  float D.40625;
  struct ImVec2 D.20670;
  struct ImDrawList * D.40624;
  float D.40623;
  float D.40622;
  float D.40621;
  struct ImVec2 D.20669;
  unsigned int D.40620;
  bool hovered.1728;
  ImGuiCol iftmp.1727;
  float D.40613;
  int iftmp.1726;
  int D.40606;
  struct ImDrawList * D.40604;
  float D.40603;
  float D.40602;
  float D.40601;
  struct ImVec2 D.20668;
  float D.40600;
  int D.40597;
  bool hovered.1725;
  ImGuiCol iftmp.1724;
  struct ImVec2 D.20665;
  struct ImVec2 D.20666;
  bool D.40589;
  bool retval.1723;
  float D.40587;
  float D.40585;
  float D.40584;
  float D.40581;
  float iftmp.1722;
  struct ImVec2 D.20658;
  struct ImVec2 D.20659;
  struct ImVec2 * D.40579;
  struct ImVec2 * D.40578;
  float D.40577;
  float D.40576;
  float D.40575;
  float D.40574;
  struct ImVec2 D.20655;
  struct ImVec2 D.20656;
  int D.40570;
  float iftmp.1721;
  int D.40565;
  float iftmp.1720;
  int D.40560;
  bool D.40559;
  bool D.40556;
  bool _5;
  float iftmp.1720_6;
  float iftmp.1721_7;
  float iftmp.1722_8;
  ImGuiCol iftmp.1724_9;
  int iftmp.1726_10;
  ImGuiCol iftmp.1727_11;
  bool _34;
  bool _35;
  int _37;
  const ImGuiID _41;
  int _43;
  float iftmp.1720_45;
  float iftmp.1720_46;
  int _49;
  float _51;
  float iftmp.1721_52;
  float iftmp.1721_53;
  float _55;
  float _56;
  float _57;
  float _58;
  struct ImVec2 * _60;
  struct ImVec2 * _62;
  float _66;
  float _67;
  float _68;
  float iftmp.1722_69;
  float iftmp.1722_70;
  float _76;
  bool _79;
  bool _80;
  bool retval.1723_81;
  bool _82;
  bool _84;
  bool _87;
  bool hovered.1725_94;
  ImGuiCol iftmp.1724_95;
  ImGuiCol iftmp.1724_96;
  int _100;
  float _101;
  float _102;
  float _103;
  float _104;
  struct ImDrawList * _106;
  int _110;
  int iftmp.1726_111;
  int iftmp.1726_112;
  float _113;
  bool hovered.1728_114;
  ImGuiCol iftmp.1727_115;
  ImGuiCol iftmp.1727_116;
  unsigned int _118;
  float _119;
  float _120;
  float _121;
  struct ImDrawList * _123;
  float _126;
  float _127;
  float _128;
  float _129;
  float _130;
  float _131;
  float _132;
  float _138;
  int _141;
  const struct ImVec2 * _143;
  float _150;
  float _151;
  float _152;
  float _153;
  float _154;
  float _155;
  float _156;
  unsigned int _161;
  bool _162;
  int _163;
  bool _167;
  bool _168;
  float _170;
  float _172;
  int _174;
  int _176;
  bool _178;
  int _180;
  int _182;
  int _184;
  float _187;
  int _194;
  struct ImGuiWindow * _197;
  bool _199;
  int _203;
  ImGuiDir * _205;
  bool _220;
  bool _221;
  bool retval.1729_222;
  float _223;
  float _224;
  float _225;
  float _226;
  float _227;
  bool _229;

  <bb 2>:
  g_29 = GImGui;
  backup_next_window_size_constraint_30 = g_29->NextWindowData.SizeConstraintCond;
  g_29->NextWindowData.SizeConstraintCond = 0;
  window_33 = ImGui::GetCurrentWindow ();
  _34 = window_33->SkipItems;
  if (_34 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _35 = 0;
  goto <bb 69>;

  <bb 4>:
  _37 = flags_36(D) & 96;
  if (_37 != 96)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("(flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10687, &__PRETTY_FUNCTION__);

  <bb 6>:
  style_38 = &g_29->Style;
  _41 = ImGuiWindow::GetID (window_33, label_39(D), 0B);
  id_42 = _41;
  _43 = flags_36(D) & 32;
  if (_43 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1720_45 = ImGui::GetFrameHeight ();
  goto <bb 9>;

  <bb 8>:
  iftmp.1720_46 = 0.0;

  <bb 9>:
  # iftmp.1720_6 = PHI <iftmp.1720_45(7), iftmp.1720_46(8)>
  arrow_size_47 = iftmp.1720_6;
  label_size = ImGui::CalcTextSize (label_39(D), 0B, 1, -1.0e+0);
  _49 = flags_36(D) & 64;
  if (_49 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _51 = ImGui::CalcItemWidth ();
  iftmp.1721_52 = _51;
  goto <bb 12>;

  <bb 11>:
  iftmp.1721_53 = arrow_size_47;

  <bb 12>:
  # iftmp.1721_7 = PHI <iftmp.1721_52(10), iftmp.1721_53(11)>
  w_54 = iftmp.1721_7;
  _55 = label_size.y;
  _56 = style_38->FramePadding.y;
  _57 = _56 * 2.0e+0;
  _58 = _55 + _57;
  ImVec2::ImVec2 (&D.20655, w_54, _58);
  _60 = &window_33->DC.CursorPos;
  D.20656 = operator+ (_60, &D.20655);
  _62 = &window_33->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _62, &D.20656);
  D.20656 ={v} {CLOBBER};
  D.20655 ={v} {CLOBBER};
  _66 = label_size.x;
  if (_66 > 0.0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _67 = style_38->ItemInnerSpacing.x;
  _68 = label_size.x;
  iftmp.1722_69 = _67 + _68;
  goto <bb 15>;

  <bb 14>:
  iftmp.1722_70 = 0.0;

  <bb 15>:
  # iftmp.1722_8 = PHI <iftmp.1722_69(13), iftmp.1722_70(14)>
  ImVec2::ImVec2 (&D.20658, iftmp.1722_8, 0.0);
  D.20659 = operator+ (&frame_bb.Max, &D.20658);
  ImRect::ImRect (&total_bb, &frame_bb.Min, &D.20659);
  D.20659 ={v} {CLOBBER};
  D.20658 ={v} {CLOBBER};
  _76 = style_38->FramePadding.y;
  ImGui::ItemSize (&total_bb, _76);
  _79 = ImGui::ItemAdd (&total_bb, id_42, &frame_bb);
  _80 = _79;
  retval.1723_81 = ~_80;
  if (retval.1723_81 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _82 = 0;
  goto <bb 69>;

  <bb 17>:
  _84 = ImGui::ButtonBehavior (&frame_bb, id_42, &hovered, &held, 0);
  pressed_85 = _84;
  _87 = ImGui::IsPopupOpen (id_42);
  popup_open_88 = _87;
  ImVec2::ImVec2 (&D.20665, arrow_size_47, 0.0);
  D.20666 = operator- (&frame_bb.Max, &D.20665);
  ImRect::ImRect (&value_bb, &frame_bb.Min, &D.20666);
  D.20666 ={v} {CLOBBER};
  D.20665 ={v} {CLOBBER};
  hovered.1725_94 = hovered;
  if (hovered.1725_94 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  iftmp.1724_95 = 8;
  goto <bb 20>;

  <bb 19>:
  iftmp.1724_96 = 7;

  <bb 20>:
  # iftmp.1724_9 = PHI <iftmp.1724_95(18), iftmp.1724_96(19)>
  frame_col_98 = ImGui::GetColorU32 (iftmp.1724_9, 1.0e+0);
  ImGui::RenderNavHighlight (&frame_bb, id_42, 1);
  _100 = flags_36(D) & 64;
  if (_100 == 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _101 = style_38->FrameRounding;
  _102 = frame_bb.Max.y;
  _103 = frame_bb.Max.x;
  _104 = _103 - arrow_size_47;
  ImVec2::ImVec2 (&D.20668, _104, _102);
  _106 = window_33->DrawList;
  ImDrawList::AddRectFilled (_106, &frame_bb.Min, &D.20668, frame_col_98, _101, 5);
  D.20668 ={v} {CLOBBER};

  <bb 22>:
  _110 = flags_36(D) & 32;
  if (_110 == 0)
    goto <bb 23>;
  else
    goto <bb 31>;

  <bb 23>:
  if (w_54 <= arrow_size_47)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  iftmp.1726_111 = 15;
  goto <bb 26>;

  <bb 25>:
  iftmp.1726_112 = 10;

  <bb 26>:
  # iftmp.1726_10 = PHI <iftmp.1726_111(24), iftmp.1726_112(25)>
  _113 = style_38->FrameRounding;
  if (popup_open_88 != 0)
    goto <bb 28>;
  else
    goto <bb 27>;

  <bb 27>:
  hovered.1728_114 = hovered;
  if (hovered.1728_114 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  iftmp.1727_116 = 22;
  goto <bb 30>;

  <bb 29>:
  iftmp.1727_115 = 21;

  <bb 30>:
  # iftmp.1727_11 = PHI <iftmp.1727_116(28), iftmp.1727_115(29)>
  _118 = ImGui::GetColorU32 (iftmp.1727_11, 1.0e+0);
  _119 = frame_bb.Min.y;
  _120 = frame_bb.Max.x;
  _121 = _120 - arrow_size_47;
  ImVec2::ImVec2 (&D.20669, _121, _119);
  _123 = window_33->DrawList;
  ImDrawList::AddRectFilled (_123, &D.20669, &frame_bb.Max, _118, _113, iftmp.1726_10);
  D.20669 ={v} {CLOBBER};
  _126 = frame_bb.Min.y;
  _127 = style_38->FramePadding.y;
  _128 = _126 + _127;
  _129 = frame_bb.Max.x;
  _130 = _129 - arrow_size_47;
  _131 = style_38->FramePadding.y;
  _132 = _130 + _131;
  ImVec2::ImVec2 (&D.20670, _132, _128);
  ImGui::RenderArrow (D.20670, 3, 1.0e+0);
  D.20670 ={v} {CLOBBER};

  <bb 31>:
  _138 = style_38->FrameRounding;
  ImGui::RenderFrameBorder (frame_bb.Min, frame_bb.Max, _138);
  if (preview_value_140(D) != 0B)
    goto <bb 32>;
  else
    goto <bb 34>;

  <bb 32>:
  _141 = flags_36(D) & 64;
  if (_141 == 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  ImVec2::ImVec2 (&D.20674, 0.0, 0.0);
  _143 = &style_38->FramePadding;
  D.20673 = operator+ (&frame_bb.Min, _143);
  ImGui::RenderTextClipped (&D.20673, &value_bb.Max, preview_value_140(D), 0B, 0B, &D.20674, 0B);
  D.20673 ={v} {CLOBBER};
  D.20674 ={v} {CLOBBER};

  <bb 34>:
  _150 = label_size.x;
  if (_150 > 0.0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  _151 = frame_bb.Min.y;
  _152 = style_38->FramePadding.y;
  _153 = _151 + _152;
  _154 = frame_bb.Max.x;
  _155 = style_38->ItemInnerSpacing.x;
  _156 = _154 + _155;
  ImVec2::ImVec2 (&D.20675, _156, _153);
  ImGui::RenderText (D.20675, label_39(D), 0B, 1);
  D.20675 ={v} {CLOBBER};

  <bb 36>:
  if (pressed_85 != 0)
    goto <bb 38>;
  else
    goto <bb 37>;

  <bb 37>:
  _161 = g_29->NavActivateId;
  if (_161 == id_42)
    goto <bb 38>;
  else
    goto <bb 42>;

  <bb 38>:
  _162 = ~popup_open_88;
  if (_162 != 0)
    goto <bb 39>;
  else
    goto <bb 42>;

  <bb 39>:
  _163 = window_33->DC.NavLayerCurrent;
  if (_163 == 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  window_33->NavLastIds[0] = id_42;

  <bb 41>:
  ImGui::OpenPopupEx (id_42);
  popup_open_166 = 1;

  <bb 42>:
  # popup_open_3 = PHI <popup_open_88(37), popup_open_88(38), popup_open_166(41)>
  _167 = ~popup_open_3;
  if (_167 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  _168 = 0;
  goto <bb 69>;

  <bb 44>:
  if (backup_next_window_size_constraint_30 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  g_29->NextWindowData.SizeConstraintCond = backup_next_window_size_constraint_30;
  _170 = g_29->NextWindowData.SizeConstraintRect.Min.x;
  _172 = ImMax (_170, w_54);
  g_29->NextWindowData.SizeConstraintRect.Min.x = _172;
  goto <bb 57>;

  <bb 46>:
  _174 = flags_36(D) & 30;
  if (_174 == 0)
    goto <bb 47>;
  else
    goto <bb 48>;

  <bb 47>:
  flags_175 = flags_36(D) | 4;

  <bb 48>:
  # flags_1 = PHI <flags_36(D)(46), flags_175(47)>
  _176 = flags_1 & 30;
  _178 = ImIsPowerOfTwo (_176);
  if (_178 != 0)
    goto <bb 50>;
  else
    goto <bb 49>;

  <bb 49>:
  __assert_fail ("ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10741, &__PRETTY_FUNCTION__);

  <bb 50>:
  popup_max_height_in_items_179 = -1;
  _180 = flags_1 & 4;
  if (_180 != 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  popup_max_height_in_items_181 = 8;
  goto <bb 56>;

  <bb 52>:
  _182 = flags_1 & 2;
  if (_182 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  popup_max_height_in_items_183 = 4;
  goto <bb 56>;

  <bb 54>:
  _184 = flags_1 & 8;
  if (_184 != 0)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  popup_max_height_in_items_185 = 20;

  <bb 56>:
  # popup_max_height_in_items_4 = PHI <popup_max_height_in_items_181(51), popup_max_height_in_items_183(53), popup_max_height_in_items_179(54), popup_max_height_in_items_185(55)>
  _187 = CalcMaxPopupHeightFromItemCount (popup_max_height_in_items_4);
  ImVec2::ImVec2 (&D.20678, 3.4028234663852885981170418348451692544e+38, _187);
  ImVec2::ImVec2 (&D.20677, w_54, 0.0);
  ImGui::SetNextWindowSizeConstraints (&D.20677, &D.20678, 0B, 0B);
  D.20677 ={v} {CLOBBER};
  D.20678 ={v} {CLOBBER};

  <bb 57>:
  # flags_2 = PHI <flags_36(D)(45), flags_1(56)>
  _194 = g_29->CurrentPopupStack.Size;
  ImFormatString (&name, 16, "##Combo_%02d", _194);
  _197 = ImGui::FindWindowByName (&name);
  popup_window_198 = _197;
  if (popup_window_198 != 0B)
    goto <bb 58>;
  else
    goto <bb 63>;

  <bb 58>:
  _199 = popup_window_198->WasActive;
  if (_199 != 0)
    goto <bb 59>;
  else
    goto <bb 62>;

  <bb 59>:
  size_contents = CalcSizeContents (popup_window_198);
  D.40699 = CalcSizeAutoFit (popup_window_198, &size_contents);
  size_expected = CalcSizeAfterConstraint (popup_window_198, D.40699);
  _203 = flags_2 & 1;
  if (_203 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  popup_window_198->AutoPosLastDirection = 0;

  <bb 61>:
  _205 = &popup_window_198->AutoPosLastDirection;
  D.20687 = ImRect::GetBL (&frame_bb);
  pos = FindBestWindowPosForPopup (&D.20687, &size_expected, _205, &frame_bb, 1);
  D.20687 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.20689, 0.0, 0.0);
  ImGui::SetNextWindowPos (&pos, 0, &D.20689);
  D.20689 ={v} {CLOBBER};
  size_contents ={v} {CLOBBER};
  size_expected ={v} {CLOBBER};
  pos ={v} {CLOBBER};

  <bb 62>:

  <bb 63>:
  window_flags_218 = 67109187;
  _220 = ImGui::Begin (&name, 0B, window_flags_218);
  _221 = _220;
  retval.1729_222 = ~_221;
  if (retval.1729_222 != 0)
    goto <bb 64>;
  else
    goto <bb 66>;

  <bb 64>:
  ImGui::EndPopup ();

  <bb 65>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 10768, &__PRETTY_FUNCTION__);

  <bb 66>:
  _223 = style_38->FramePadding.x;
  _224 = style_38->WindowPadding.x;
  if (_223 != _224)
    goto <bb 67>;
  else
    goto <bb 68>;

  <bb 67>:
  _225 = style_38->FramePadding.x;
  _226 = style_38->WindowPadding.x;
  _227 = _225 - _226;
  ImGui::Indent (_227);

  <bb 68>:
  _229 = 1;

  <bb 69>:
  # _5 = PHI <_35(3), _82(16), _168(43), _229(68)>
  label_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  total_bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  value_bb ={v} {CLOBBER};
  name ={v} {CLOBBER};

<L87>:
  return _5;

}



;; Function void ImGui::EndCombo() (_ZN5ImGui8EndComboEv, funcdef_no=1108, decl_uid=2837, cgraph_uid=1007, symbol_order=1018)

void ImGui::EndCombo() ()
{
  const struct ImGuiStyle & style;
  float D.40746;
  float D.40745;
  float D.40744;
  float D.40741;
  float D.40740;
  struct ImGuiContext * GImGui.1730;
  struct ImGuiContext * GImGui.1730_3;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;

  <bb 2>:
  GImGui.1730_3 = GImGui;
  style_4 = &GImGui.1730_3->Style;
  _5 = style_4->FramePadding.x;
  _6 = style_4->WindowPadding.x;
  if (_5 != _6)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = style_4->FramePadding.x;
  _8 = style_4->WindowPadding.x;
  _9 = _7 - _8;
  ImGui::Unindent (_9);

  <bb 4>:
  ImGui::EndPopup ();
  return;

}



;; Function bool ImGui::Combo(const char*, int*, bool (*)(void*, int, const char**), void*, int, int) (_ZN5ImGui5ComboEPKcPiPFbPviPS1_ES3_ii, funcdef_no=1109, decl_uid=2858, cgraph_uid=1008, symbol_order=1019)

bool ImGui::Combo(const char*, int*, bool (*)(void*, int, const char**), void*, int, int) (const char * label, int * current_item, bool (*<T6ca>) (void *, int, const char * *) items_getter, void * data, int items_count, int popup_max_height_in_items)
{
  bool D.40790;
  bool D.40789;
  bool D.40788;
  const char * item_text;
  const bool item_selected;
  int i;
  float popup_max_height;
  bool value_changed;
  const char * preview_text;
  struct ImGuiContext & g;
  const char * item_text.1735;
  int D.40779;
  struct ImVec2 D.20714;
  bool retval.1734;
  bool D.40774;
  bool retval.1733;
  int D.40772;
  const void * D.40771;
  long int D.40770;
  bool D.40767;
  bool D.40764;
  const char * preview_text.1732;
  bool retval.1731;
  struct ImVec2 D.20708;
  struct ImVec2 D.20709;
  int D.40758;
  int D.40754;
  int D.40751;
  int D.40748;
  bool _4;
  int _18;
  int _19;
  int _21;
  int _26;
  const char * preview_text.1732_34;
  bool _37;
  bool _38;
  bool retval.1731_39;
  bool _40;
  long int _43;
  const void * _44;
  int _46;
  bool _49;
  bool _50;
  bool retval.1733_51;
  int _54;
  const char * item_text.1735_55;
  bool _57;
  bool retval.1734_58;
  bool _69;

  <bb 2>:
  g_15 = GImGui;
  preview_text = 0B;
  _18 = *current_item_17(D);
  if (_18 >= 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _19 = *current_item_17(D);
  if (_19 < items_count_20(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _21 = *current_item_17(D);
  items_getter_22(D) (data_23(D), _21, &preview_text);

  <bb 5>:
  if (popup_max_height_in_items_25(D) != -1)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _26 = g_15->NextWindowData.SizeConstraintCond;
  if (_26 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  popup_max_height_28 = CalcMaxPopupHeightFromItemCount (popup_max_height_in_items_25(D));
  ImVec2::ImVec2 (&D.20709, 3.4028234663852885981170418348451692544e+38, popup_max_height_28);
  ImVec2::ImVec2 (&D.20708, 0.0, 0.0);
  ImGui::SetNextWindowSizeConstraints (&D.20708, &D.20709, 0B, 0B);
  D.20708 ={v} {CLOBBER};
  D.20709 ={v} {CLOBBER};

  <bb 8>:
  preview_text.1732_34 = preview_text;
  _37 = ImGui::BeginCombo (label_35(D), preview_text.1732_34, 0);
  _38 = _37;
  retval.1731_39 = ~_38;
  if (retval.1731_39 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _40 = 0;
  goto <bb 20>;

  <bb 10>:
  value_changed_41 = 0;
  i_42 = 0;

  <bb 11>:
  # value_changed_1 = PHI <value_changed_41(10), value_changed_2(18)>
  # i_3 = PHI <i_42(10), i_65(18)>
  if (i_3 >= items_count_20(D))
    goto <bb 19>;
  else
    goto <bb 12>;

  <bb 12>:
  _43 = (long int) i_3;
  _44 = (const void *) _43;
  ImGui::PushID (_44);
  _46 = *current_item_17(D);
  item_selected_47 = _46 == i_3;
  _49 = items_getter_22(D) (data_23(D), i_3, &item_text);
  _50 = _49;
  retval.1733_51 = ~_50;
  if (retval.1733_51 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  item_text = "*Unknown item*";

  <bb 14>:
  ImVec2::ImVec2 (&D.20714, 0.0, 0.0);
  _54 = (int) item_selected_47;
  item_text.1735_55 = item_text;
  _57 = ImGui::Selectable (item_text.1735_55, _54, 0, &D.20714);
  retval.1734_58 = _57;
  D.20714 ={v} {CLOBBER};
  if (retval.1734_58 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  value_changed_60 = 1;
  *current_item_17(D) = i_3;

  <bb 16>:
  # value_changed_2 = PHI <value_changed_1(14), value_changed_60(15)>
  if (item_selected_47 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  ImGui::SetItemDefaultFocus ();

  <bb 18>:
  ImGui::PopID ();
  item_text ={v} {CLOBBER};
  i_65 = i_3 + 1;
  goto <bb 11>;

  <bb 19>:
  ImGui::EndCombo ();
  _69 = value_changed_1;

  <bb 20>:
  # _4 = PHI <_40(9), _69(19)>
  preview_text ={v} {CLOBBER};

<L25>:
  return _4;

}



;; Function bool Items_ArrayGetter(void*, int, const char**) (_ZL17Items_ArrayGetterPviPPKc, funcdef_no=1110, decl_uid=20720, cgraph_uid=1009, symbol_order=1020)

bool Items_ArrayGetter(void*, int, const char**) (void * data, int idx, const char * * out_text)
{
  const char * const * items;
  bool D.40802;
  const char * D.40800;
  const char * const * D.40799;
  long unsigned int D.40798;
  long unsigned int D.40797;
  long unsigned int _7;
  long unsigned int _8;
  const char * const * _9;
  const char * _10;
  bool _12;

  <bb 2>:
  items_3 = data_2(D);
  if (out_text_4(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = (long unsigned int) idx_6(D);
  _8 = _7 * 8;
  _9 = items_3 + _8;
  _10 = *_9;
  *out_text_4(D) = _10;

  <bb 4>:
  _12 = 1;

<L3>:
  return _12;

}



;; Function bool Items_SingleStringGetter(void*, int, const char**) (_ZL24Items_SingleStringGetterPviPPKc, funcdef_no=1111, decl_uid=20726, cgraph_uid=1010, symbol_order=1021)

bool Items_SingleStringGetter(void*, int, const char**) (void * data, int idx, const char * * out_text)
{
  const char * p;
  int items_count;
  const char * items_separated_by_zeros;
  bool D.40814;
  char D.40811;
  sizetype D.40810;
  long unsigned int D.40809;
  char D.40805;
  bool _3;
  char _11;
  long unsigned int _13;
  sizetype _14;
  char _17;
  bool _18;
  bool _21;

  <bb 2>:
  items_separated_by_zeros_7 = data_6(D);
  items_count_8 = 0;
  p_9 = items_separated_by_zeros_7;

  <bb 3>:
  # items_count_1 = PHI <items_count_8(2), items_count_16(6)>
  # p_2 = PHI <p_9(2), p_15(6)>
  _11 = *p_2;
  if (_11 == 0)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  if (idx_12(D) == items_count_1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 7>;

  <bb 6>:
  _13 = strlen (p_2);
  _14 = _13 + 1;
  p_15 = p_2 + _14;
  items_count_16 = items_count_1 + 1;
  goto <bb 3>;

  <bb 7>:
  _17 = *p_2;
  if (_17 == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _18 = 0;
  goto <bb 12> (<L10>);

  <bb 9>:
  if (out_text_19(D) != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  *out_text_19(D) = p_2;

  <bb 11>:
  _21 = 1;

  # _3 = PHI <_18(8), _21(11)>
<L10>:
  return _3;

}



;; Function bool ImGui::Combo(const char*, int*, const char* const*, int, int) (_ZN5ImGui5ComboEPKcPiPKS1_ii, funcdef_no=1112, decl_uid=2843, cgraph_uid=1011, symbol_order=1022)

bool ImGui::Combo(const char*, int*, const char* const*, int, int) (const char * label, int * current_item, const char * const * items, int items_count, int height_in_items)
{
  const bool D.40821;
  const bool value_changed;
  bool D.40819;
  const bool _8;
  bool _10;

  <bb 2>:
  _8 = ImGui::Combo (label_2(D), current_item_3(D), Items_ArrayGetter, items_4(D), items_count_5(D), height_in_items_6(D));
  value_changed_9 = _8;
  _10 = value_changed_9;

<L0>:
  return _10;

}



;; Function bool ImGui::Combo(const char*, int*, const char*, int) (_ZN5ImGui5ComboEPKcPiS1_i, funcdef_no=1113, decl_uid=2848, cgraph_uid=1012, symbol_order=1023)

bool ImGui::Combo(const char*, int*, const char*, int) (const char * label, int * current_item, const char * items_separated_by_zeros, int height_in_items)
{
  bool D.40829;
  bool value_changed;
  const char * p;
  int items_count;
  bool D.40827;
  sizetype D.40826;
  long unsigned int D.40825;
  char D.40823;
  char _7;
  long unsigned int _8;
  sizetype _9;
  bool _16;
  bool _18;

  <bb 2>:
  items_count_3 = 0;
  p_5 = items_separated_by_zeros_4(D);

  <bb 3>:
  # items_count_1 = PHI <items_count_3(2), items_count_11(4)>
  # p_2 = PHI <p_5(2), p_10(4)>
  _7 = *p_2;
  if (_7 == 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _8 = strlen (p_2);
  _9 = _8 + 1;
  p_10 = p_2 + _9;
  items_count_11 = items_count_1 + 1;
  goto <bb 3>;

  <bb 5>:
  _16 = ImGui::Combo (label_12(D), current_item_13(D), Items_SingleStringGetter, items_separated_by_zeros_4(D), items_count_1, height_in_items_14(D));
  value_changed_17 = _16;
  _18 = value_changed_17;

<L3>:
  return _18;

}



;; Function bool ImGui::Selectable(const char*, bool, ImGuiSelectableFlags, const ImVec2&) (_ZN5ImGui10SelectableEPKcbiRK6ImVec2, funcdef_no=1114, decl_uid=3157, cgraph_uid=1013, symbol_order=1024)

bool ImGui::Selectable(const char*, bool, ImGuiSelectableFlags, const ImVec2&) (const char * label, bool selected, ImGuiSelectableFlags flags, const struct ImVec2 & size_arg)
{
  bool D.41010;
  bool D.41009;
  ImGuiID D.41008;
  const ImU32 col;
  bool pressed;
  bool held;
  bool hovered;
  ImGuiButtonFlags button_flags;
  float spacing_D;
  float spacing_R;
  float spacing_U;
  float spacing_L;
  struct ImRect bb_with_spacing;
  struct ImVec2 size_draw;
  float w_draw;
  float max_x;
  struct ImVec2 window_padding;
  struct ImRect bb;
  struct ImVec2 pos;
  struct ImVec2 size;
  struct ImVec2 label_size;
  ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  int D.41003;
  int D.41002;
  int D.40999;
  int D.40996;
  int D.40995;
  int D.40989;
  struct ImVec2 D.20791;
  struct ImVec4 * D.40987;
  int D.40984;
  float D.40982;
  float D.40981;
  float D.40980;
  struct ImVec2 D.20789;
  float D.20790;
  struct ImGuiColumnsSet * D.40977;
  int D.40974;
  bool hovered.1750;
  ImGuiCol iftmp.1749;
  bool D.40968;
  bool hovered.1748;
  bool D.40965;
  bool held.1747;
  ImGuiCol iftmp.1746;
  bool hovered.1745;
  int D.40954;
  int D.40951;
  int D.40950;
  struct ImGuiWindow * D.40947;
  bool D.40944;
  bool D.40943;
  bool hovered.1744;
  int D.40935;
  int D.40931;
  int D.40927;
  int D.40923;
  int D.40919;
  struct ImGuiColumnsSet * D.40915;
  int D.40912;
  bool D.40909;
  int D.40905;
  unsigned int iftmp.1743;
  bool retval.1742;
  float D.40902;
  float D.40901;
  float D.40900;
  float D.40899;
  float D.40898;
  float D.40897;
  float D.40896;
  float D.40895;
  float D.40894;
  float D.40893;
  int D.40892;
  float D.40891;
  float D.40890;
  int D.40889;
  float D.40888;
  float D.40887;
  float D.40886;
  float D.40885;
  float D.40884;
  int D.40883;
  float D.40881;
  struct ImVec2 D.20777;
  int D.40877;
  float D.40875;
  const float iftmp.1741;
  float D.40868;
  const float iftmp.1740;
  float w_draw.1739;
  float D.40865;
  float D.40864;
  float D.40863;
  float D.40862;
  float D.40861;
  float D.40860;
  float D.40859;
  struct ImVec2 D.20773;
  struct ImVec2 D.20772;
  int D.40855;
  float iftmp.1738;
  struct ImVec2 D.20768;
  float D.40853;
  float D.40852;
  float D.40851;
  float D.40847;
  const float iftmp.1737;
  float D.40842;
  const float iftmp.1736;
  struct ImGuiColumnsSet * D.40837;
  int D.40834;
  bool D.40833;
  bool D.40830;
  bool _6;
  const float iftmp.1736_7;
  const float iftmp.1737_8;
  float iftmp.1738_9;
  const float iftmp.1740_10;
  const float iftmp.1741_11;
  unsigned int iftmp.1743_12;
  ImGuiCol iftmp.1746_13;
  ImGuiCol iftmp.1749_14;
  bool _30;
  bool _31;
  int _35;
  struct ImGuiColumnsSet * _36;
  ImGuiID _40;
  float _44;
  const float iftmp.1736_45;
  const float iftmp.1736_46;
  float _47;
  const float iftmp.1737_48;
  const float iftmp.1737_49;
  float _52;
  float _53;
  float _54;
  int _61;
  float iftmp.1738_63;
  float iftmp.1738_65;
  float _67;
  float _68;
  float _69;
  float _70;
  float _71;
  float _72;
  float _73;
  float w_draw.1739_75;
  float _77;
  const float iftmp.1740_78;
  const float iftmp.1740_79;
  float _80;
  int _81;
  const float iftmp.1741_82;
  const float iftmp.1741_83;
  float _88;
  int _89;
  float _90;
  float _91;
  float _92;
  float _94;
  float _95;
  int _96;
  float _98;
  float _99;
  int _100;
  float _102;
  float _104;
  float _106;
  float _107;
  float _109;
  float _110;
  float _112;
  float _113;
  float _115;
  float _116;
  int _118;
  unsigned int iftmp.1743_119;
  unsigned int iftmp.1743_120;
  bool _122;
  bool _123;
  bool retval.1742_124;
  int _125;
  struct ImGuiColumnsSet * _126;
  bool _128;
  int _130;
  int _132;
  int _134;
  int _136;
  bool _139;
  int _141;
  bool hovered.1744_144;
  bool _145;
  bool _146;
  struct ImGuiWindow * _147;
  int _148;
  int _149;
  int _151;
  bool hovered.1745_153;
  bool held.1747_154;
  bool _155;
  bool hovered.1748_156;
  bool _157;
  ImGuiCol iftmp.1746_158;
  bool hovered.1750_159;
  ImGuiCol iftmp.1749_160;
  ImGuiCol iftmp.1749_161;
  ImGuiCol iftmp.1746_162;
  int _167;
  struct ImGuiColumnsSet * _168;
  float _171;
  float _172;
  float _173;
  float _174;
  int _176;
  struct ImVec4 * _177;
  int _182;
  int _184;
  int _185;
  int _186;
  int _187;
  int _188;
  bool _190;

  <bb 2>:
  window_29 = ImGui::GetCurrentWindow ();
  _30 = window_29->SkipItems;
  if (_30 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _31 = 0;
  goto <bb 73>;

  <bb 4>:
  g_32 = GImGui;
  style_33 = &g_32->Style;
  _35 = flags_34(D) & 2;
  if (_35 != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

  <bb 5>:
  _36 = window_29->DC.ColumnsSet;
  if (_36 != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  ImGui::PopClipRect ();

  <bb 7>:
  _40 = ImGuiWindow::GetID (window_29, label_38(D), 0B);
  id_41 = _40;
  label_size = ImGui::CalcTextSize (label_38(D), 0B, 1, -1.0e+0);
  _44 = size_arg_43(D)->y;
  if (_44 != 0.0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1736_45 = size_arg_43(D)->y;
  goto <bb 10>;

  <bb 9>:
  iftmp.1736_46 = label_size.y;

  <bb 10>:
  # iftmp.1736_7 = PHI <iftmp.1736_45(8), iftmp.1736_46(9)>
  _47 = size_arg_43(D)->x;
  if (_47 != 0.0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.1737_48 = size_arg_43(D)->x;
  goto <bb 13>;

  <bb 12>:
  iftmp.1737_49 = label_size.x;

  <bb 13>:
  # iftmp.1737_8 = PHI <iftmp.1737_48(11), iftmp.1737_49(12)>
  ImVec2::ImVec2 (&size, iftmp.1737_8, iftmp.1736_7);
  pos = window_29->DC.CursorPos;
  _52 = pos.y;
  _53 = window_29->DC.CurrentLineTextBaseOffset;
  _54 = _52 + _53;
  pos.y = _54;
  D.20768 = operator+ (&pos, &size);
  ImRect::ImRect (&bb, &pos, &D.20768);
  D.20768 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  window_padding = window_29->WindowPadding;
  _61 = flags_34(D) & 2;
  if (_61 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  D.20772 = ImGui::GetWindowContentRegionMax ();
  iftmp.1738_63 = D.20772.x;
  goto <bb 16>;

  <bb 15>:
  D.20773 = ImGui::GetContentRegionMax ();
  iftmp.1738_65 = D.20773.x;

  <bb 16>:
  # iftmp.1738_9 = PHI <iftmp.1738_63(14), iftmp.1738_65(15)>
  max_x_66 = iftmp.1738_9;
  _67 = window_29->Pos.x;
  _68 = _67 + max_x_66;
  _69 = window_padding.x;
  _70 = _68 - _69;
  _71 = window_29->DC.CursorPos.x;
  _72 = _70 - _71;
  _73 = label_size.x;
  w_draw.1739_75 = ImMax (_73, _72);
  w_draw = w_draw.1739_75;
  _77 = size_arg_43(D)->y;
  if (_77 != 0.0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.1740_78 = size_arg_43(D)->y;
  goto <bb 19>;

  <bb 18>:
  iftmp.1740_79 = size.y;

  <bb 19>:
  # iftmp.1740_10 = PHI <iftmp.1740_78(17), iftmp.1740_79(18)>
  _80 = size_arg_43(D)->x;
  if (_80 != 0.0)
    goto <bb 20>;
  else
    goto <bb 22>;

  <bb 20>:
  _81 = flags_34(D) & 64;
  if (_81 == 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  iftmp.1741_82 = size_arg_43(D)->x;
  goto <bb 23>;

  <bb 22>:
  iftmp.1741_83 = w_draw;

  <bb 23>:
  # iftmp.1741_11 = PHI <iftmp.1741_82(21), iftmp.1741_83(22)>
  ImVec2::ImVec2 (&size_draw, iftmp.1741_11, iftmp.1740_10);
  D.20777 = operator+ (&pos, &size_draw);
  ImRect::ImRect (&bb_with_spacing, &pos, &D.20777);
  D.20777 ={v} {CLOBBER};
  _88 = size_arg_43(D)->x;
  if (_88 == 0.0)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  _89 = flags_34(D) & 64;
  if (_89 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _90 = bb_with_spacing.Max.x;
  _91 = window_padding.x;
  _92 = _90 + _91;
  bb_with_spacing.Max.x = _92;

  <bb 26>:
  _94 = style_33->ItemSpacing.x;
  _95 = _94 * 5.0e-1;
  _96 = (int) _95;
  spacing_L_97 = (float) _96;
  _98 = style_33->ItemSpacing.y;
  _99 = _98 * 5.0e-1;
  _100 = (int) _99;
  spacing_U_101 = (float) _100;
  _102 = style_33->ItemSpacing.x;
  spacing_R_103 = _102 - spacing_L_97;
  _104 = style_33->ItemSpacing.y;
  spacing_D_105 = _104 - spacing_U_101;
  _106 = bb_with_spacing.Min.x;
  _107 = _106 - spacing_L_97;
  bb_with_spacing.Min.x = _107;
  _109 = bb_with_spacing.Min.y;
  _110 = _109 - spacing_U_101;
  bb_with_spacing.Min.y = _110;
  _112 = bb_with_spacing.Max.x;
  _113 = _112 + spacing_R_103;
  bb_with_spacing.Max.x = _113;
  _115 = bb_with_spacing.Max.y;
  _116 = _115 + spacing_D_105;
  bb_with_spacing.Max.y = _116;
  _118 = flags_34(D) & 32;
  if (_118 == 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  iftmp.1743_119 = id_41;
  goto <bb 29>;

  <bb 28>:
  iftmp.1743_120 = 0;

  <bb 29>:
  # iftmp.1743_12 = PHI <iftmp.1743_119(27), iftmp.1743_120(28)>
  _122 = ImGui::ItemAdd (&bb_with_spacing, iftmp.1743_12, 0B);
  _123 = _122;
  retval.1742_124 = ~_123;
  if (retval.1742_124 != 0)
    goto <bb 30>;
  else
    goto <bb 34>;

  <bb 30>:
  _125 = flags_34(D) & 2;
  if (_125 != 0)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  _126 = window_29->DC.ColumnsSet;
  if (_126 != 0B)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  ImGui::PushColumnClipRect (-1);

  <bb 33>:
  _128 = 0;
  goto <bb 73>;

  <bb 34>:
  button_flags_129 = 0;
  _130 = flags_34(D) & 8;
  if (_130 != 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  button_flags_131 = button_flags_129 | 2052;

  <bb 36>:
  # button_flags_2 = PHI <button_flags_129(34), button_flags_131(35)>
  _132 = flags_34(D) & 16;
  if (_132 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

  <bb 37>:
  button_flags_133 = button_flags_2 | 8;

  <bb 38>:
  # button_flags_3 = PHI <button_flags_2(36), button_flags_133(37)>
  _134 = flags_34(D) & 32;
  if (_134 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  button_flags_135 = button_flags_3 | 256;

  <bb 40>:
  # button_flags_4 = PHI <button_flags_3(38), button_flags_135(39)>
  _136 = flags_34(D) & 4;
  if (_136 != 0)
    goto <bb 41>;
  else
    goto <bb 42>;

  <bb 41>:
  button_flags_137 = button_flags_4 | 18;

  <bb 42>:
  # button_flags_5 = PHI <button_flags_4(40), button_flags_137(41)>
  _139 = ImGui::ButtonBehavior (&bb_with_spacing, id_41, &hovered, &held, button_flags_5);
  pressed_140 = _139;
  _141 = flags_34(D) & 32;
  if (_141 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  selected_143 = 0;

  <bb 44>:
  # selected_1 = PHI <selected_142(D)(42), selected_143(43)>
  if (pressed_140 != 0)
    goto <bb 46>;
  else
    goto <bb 45>;

  <bb 45>:
  hovered.1744_144 = hovered;
  if (hovered.1744_144 != 0)
    goto <bb 46>;
  else
    goto <bb 50>;

  <bb 46>:
  _145 = g_32->NavDisableMouseHover;
  _146 = ~_145;
  if (_146 != 0)
    goto <bb 47>;
  else
    goto <bb 50>;

  <bb 47>:
  _147 = g_32->NavWindow;
  if (_147 == window_29)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  _148 = g_32->NavLayer;
  _149 = window_29->DC.NavLayerActiveMask;
  if (_148 == _149)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  g_32->NavDisableHighlight = 1;
  _151 = window_29->DC.NavLayerCurrent;
  SetNavID (id_41, _151);

  <bb 50>:
  hovered.1745_153 = hovered;
  if (hovered.1745_153 != 0)
    goto <bb 52>;
  else
    goto <bb 51>;

  <bb 51>:
  if (selected_1 != 0)
    goto <bb 52>;
  else
    goto <bb 60>;

  <bb 52>:
  held.1747_154 = held;
  _155 = ~held.1747_154;
  if (_155 != 0)
    goto <bb 54>;
  else
    goto <bb 53>;

  <bb 53>:
  hovered.1748_156 = hovered;
  _157 = ~hovered.1748_156;
  if (_157 != 0)
    goto <bb 54>;
  else
    goto <bb 58>;

  <bb 54>:
  hovered.1750_159 = hovered;
  if (hovered.1750_159 != 0)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  iftmp.1749_160 = 25;
  goto <bb 57>;

  <bb 56>:
  iftmp.1749_161 = 24;

  <bb 57>:
  # iftmp.1749_14 = PHI <iftmp.1749_160(55), iftmp.1749_161(56)>
  iftmp.1746_162 = iftmp.1749_14;
  goto <bb 59>;

  <bb 58>:
  iftmp.1746_158 = 26;

  <bb 59>:
  # iftmp.1746_13 = PHI <iftmp.1746_162(57), iftmp.1746_158(58)>
  col_164 = ImGui::GetColorU32 (iftmp.1746_13, 1.0e+0);
  ImGui::RenderFrame (bb_with_spacing.Min, bb_with_spacing.Max, col_164, 0, 0.0);
  ImGui::RenderNavHighlight (&bb_with_spacing, id_41, 10);

  <bb 60>:
  _167 = flags_34(D) & 2;
  if (_167 != 0)
    goto <bb 61>;
  else
    goto <bb 63>;

  <bb 61>:
  _168 = window_29->DC.ColumnsSet;
  if (_168 != 0B)
    goto <bb 62>;
  else
    goto <bb 63>;

  <bb 62>:
  ImGui::PushColumnClipRect (-1);
  D.20789 = ImGui::GetContentRegionMax ();
  _171 = D.20789.x;
  _172 = _171 - max_x_66;
  _173 = bb_with_spacing.Max.x;
  _174 = _173 - _172;
  bb_with_spacing.Max.x = _174;

  <bb 63>:
  _176 = flags_34(D) & 32;
  if (_176 != 0)
    goto <bb 64>;
  else
    goto <bb 65>;

  <bb 64>:
  _177 = &g_32->Style.Colors[1];
  ImGui::PushStyleColor (0, _177);

  <bb 65>:
  ImVec2::ImVec2 (&D.20791, 0.0, 0.0);
  ImGui::RenderTextClipped (&bb.Min, &bb_with_spacing.Max, label_38(D), 0B, &label_size, &D.20791, 0B);
  D.20791 ={v} {CLOBBER};
  _182 = flags_34(D) & 32;
  if (_182 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  ImGui::PopStyleColor (1);

  <bb 67>:
  if (pressed_140 != 0)
    goto <bb 68>;
  else
    goto <bb 72>;

  <bb 68>:
  _184 = window_29->Flags;
  _185 = _184 & 67108864;
  if (_185 != 0)
    goto <bb 69>;
  else
    goto <bb 72>;

  <bb 69>:
  _186 = flags_34(D) & 1;
  if (_186 == 0)
    goto <bb 70>;
  else
    goto <bb 72>;

  <bb 70>:
  _187 = window_29->DC.ItemFlags;
  _188 = _187 & 32;
  if (_188 == 0)
    goto <bb 71>;
  else
    goto <bb 72>;

  <bb 71>:
  ImGui::CloseCurrentPopup ();

  <bb 72>:
  _190 = pressed_140;

  <bb 73>:
  # _6 = PHI <_31(3), _128(33), _190(72)>
  label_size ={v} {CLOBBER};
  size ={v} {CLOBBER};
  pos ={v} {CLOBBER};
  bb ={v} {CLOBBER};
  window_padding ={v} {CLOBBER};
  w_draw ={v} {CLOBBER};
  size_draw ={v} {CLOBBER};
  bb_with_spacing ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

<L92>:
  return _6;

}



;; Function bool ImGui::Selectable(const char*, bool*, ImGuiSelectableFlags, const ImVec2&) (_ZN5ImGui10SelectableEPKcPbiRK6ImVec2, funcdef_no=1115, decl_uid=3163, cgraph_uid=1014, symbol_order=1025)

bool ImGui::Selectable(const char*, bool*, ImGuiSelectableFlags, const ImVec2&) (const char * label, bool * p_selected, ImGuiSelectableFlags flags, const struct ImVec2 & size_arg)
{
  bool D.41023;
  bool D.41021;
  bool D.41020;
  bool D.41019;
  int D.41016;
  bool D.41015;
  bool retval.1751;
  bool _1;
  bool _5;
  int _6;
  bool _11;
  bool retval.1751_12;
  bool _13;
  bool _14;
  bool _16;
  bool _17;

  <bb 2>:
  _5 = *p_selected_4(D);
  _6 = (int) _5;
  _11 = ImGui::Selectable (label_7(D), _6, flags_8(D), size_arg_9(D));
  retval.1751_12 = _11;
  if (retval.1751_12 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _13 = *p_selected_4(D);
  _14 = ~_13;
  *p_selected_4(D) = _14;
  _16 = 1;
  goto <bb 5> (<L2>);

  <bb 4>:
  _17 = 0;

  # _1 = PHI <_16(3), _17(4)>
<L2>:
  return _1;

}



;; Function bool ImGui::ListBoxHeader(const char*, const ImVec2&) (_ZN5ImGui13ListBoxHeaderEPKcRK6ImVec2, funcdef_no=1116, decl_uid=3183, cgraph_uid=1015, symbol_order=1026)

bool ImGui::ListBoxHeader(const char*, const ImVec2&) (const char * label, const struct ImVec2 & size_arg)
{
  float D.41058;
  const ImGuiID D.41057;
  struct ImRect bb;
  struct ImRect frame_bb;
  struct ImVec2 frame_size;
  struct ImVec2 size;
  const struct ImVec2 label_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiWindow * window;
  struct ImVec2 D.20818;
  float D.41054;
  float D.41053;
  float D.41052;
  float D.41051;
  float D.41050;
  float D.41049;
  struct ImVec2 D.20817;
  float D.41046;
  float D.41044;
  float D.41043;
  float D.41040;
  float iftmp.1752;
  struct ImVec2 D.20815;
  struct ImVec2 D.20816;
  struct ImVec2 * D.41038;
  struct ImVec2 * D.41037;
  struct ImVec2 D.20813;
  float D.41036;
  float D.41035;
  float D.41034;
  float D.41033;
  float D.41032;
  float D.41031;
  float D.41030;
  float D.41029;
  float D.41028;
  bool D.41027;
  bool D.41024;
  bool _1;
  float iftmp.1752_2;
  bool _9;
  bool _10;
  const ImGuiID _15;
  float _19;
  float _20;
  float _21;
  float _22;
  float _24;
  float _25;
  float _28;
  float _29;
  float _31;
  float _32;
  struct ImVec2 * _34;
  struct ImVec2 * _36;
  float _39;
  float _40;
  float _41;
  float iftmp.1752_42;
  float iftmp.1752_43;
  float _51;
  float _52;
  float _53;
  float _54;
  float _55;
  float _56;
  float _57;
  bool _65;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 10>;

  <bb 4>:
  style_12 = ImGui::GetStyle ();
  _15 = ImGui::GetID (label_13(D));
  id_16 = _15;
  label_size = ImGui::CalcTextSize (label_13(D), 0B, 1, -1.0e+0);
  _19 = ImGui::GetTextLineHeightWithSpacing ();
  _20 = _19 * 7.400000095367431640625e+0;
  _21 = style_12->ItemSpacing.y;
  _22 = _20 + _21;
  _24 = ImGui::CalcItemWidth ();
  _25 = _24;
  size = ImGui::CalcItemSize (*size_arg_26(D), _25, _22);
  _28 = label_size.y;
  _29 = size.y;
  _31 = ImMax (_29, _28);
  _32 = size.x;
  ImVec2::ImVec2 (&frame_size, _32, _31);
  _34 = &window_8->DC.CursorPos;
  D.20813 = operator+ (_34, &frame_size);
  _36 = &window_8->DC.CursorPos;
  ImRect::ImRect (&frame_bb, _36, &D.20813);
  D.20813 ={v} {CLOBBER};
  _39 = label_size.x;
  if (_39 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _40 = style_12->ItemInnerSpacing.x;
  _41 = label_size.x;
  iftmp.1752_42 = _40 + _41;
  goto <bb 7>;

  <bb 6>:
  iftmp.1752_43 = 0.0;

  <bb 7>:
  # iftmp.1752_2 = PHI <iftmp.1752_42(5), iftmp.1752_43(6)>
  ImVec2::ImVec2 (&D.20815, iftmp.1752_2, 0.0);
  D.20816 = operator+ (&frame_bb.Max, &D.20815);
  ImRect::ImRect (&bb, &frame_bb.Min, &D.20816);
  D.20816 ={v} {CLOBBER};
  D.20815 ={v} {CLOBBER};
  window_8->DC.LastItemRect = bb;
  ImGui::BeginGroup ();
  _51 = label_size.x;
  if (_51 > 0.0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _52 = frame_bb.Min.y;
  _53 = style_12->FramePadding.y;
  _54 = _52 + _53;
  _55 = frame_bb.Max.x;
  _56 = style_12->ItemInnerSpacing.x;
  _57 = _55 + _56;
  ImVec2::ImVec2 (&D.20817, _57, _54);
  ImGui::RenderText (D.20817, label_13(D), 0B, 1);
  D.20817 ={v} {CLOBBER};

  <bb 9>:
  D.20818 = ImRect::GetSize (&frame_bb);
  ImGui::BeginChildFrame (id_16, &D.20818, 0);
  D.20818 ={v} {CLOBBER};
  _65 = 1;

  <bb 10>:
  # _1 = PHI <_10(3), _65(9)>
  label_size ={v} {CLOBBER};
  size ={v} {CLOBBER};
  frame_size ={v} {CLOBBER};
  frame_bb ={v} {CLOBBER};
  bb ={v} {CLOBBER};

<L9>:
  return _1;

}



;; Function bool ImGui::ListBoxHeader(const char*, int, int) (_ZN5ImGui13ListBoxHeaderEPKcii, funcdef_no=1117, decl_uid=3187, cgraph_uid=1016, symbol_order=1027)

bool ImGui::ListBoxHeader(const char*, int, int) (const char * label, int items_count, int height_in_items)
{
  bool D.41079;
  struct ImVec2 size;
  float height_in_items_f;
  bool D.41077;
  float D.41076;
  float D.41075;
  struct ImGuiStyle & D.41074;
  float D.41073;
  float D.41072;
  float D.41071;
  float D.41069;
  float iftmp.1753;
  float iftmp.1753_2;
  float _9;
  float iftmp.1753_10;
  float _11;
  float iftmp.1753_12;
  float _17;
  float _18;
  struct ImGuiStyle & _20;
  float _21;
  float _22;
  bool _26;
  bool _27;

  <bb 2>:
  if (height_in_items_4(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  height_in_items_8 = ImMin (items_count_6(D), 7);

  <bb 4>:
  # height_in_items_1 = PHI <height_in_items_4(D)(2), height_in_items_8(3)>
  if (height_in_items_1 < items_count_6(D))
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _9 = (float) height_in_items_1;
  iftmp.1753_10 = _9 + 4.000000059604644775390625e-1;
  goto <bb 7>;

  <bb 6>:
  _11 = (float) height_in_items_1;
  iftmp.1753_12 = _11 + 0.0;

  <bb 7>:
  # iftmp.1753_2 = PHI <iftmp.1753_10(5), iftmp.1753_12(6)>
  height_in_items_f_13 = iftmp.1753_2;
  ImVec2::ImVec2 (&size);
  size.x = 0.0;
  _17 = ImGui::GetTextLineHeightWithSpacing ();
  _18 = _17 * height_in_items_f_13;
  _20 = ImGui::GetStyle ();
  _21 = _20->ItemSpacing.y;
  _22 = _18 + _21;
  size.y = _22;
  _26 = ImGui::ListBoxHeader (label_24(D), &size);
  _27 = _26;
  size ={v} {CLOBBER};

<L7>:
  return _27;

}



;; Function void ImGui::ListBoxFooter() (_ZN5ImGui13ListBoxFooterEv, funcdef_no=1118, decl_uid=3188, cgraph_uid=1017, symbol_order=1028)

void ImGui::ListBoxFooter() ()
{
  const struct ImGuiStyle & style;
  const struct ImRect bb;
  struct ImGuiWindow * parent_window;
  float D.41083;
  struct ImGuiWindow * D.41082;
  struct ImGuiWindow * _4;
  float _12;

  <bb 2>:
  _4 = ImGui::GetCurrentWindow ();
  parent_window_5 = _4->ParentWindow;
  bb = parent_window_5->DC.LastItemRect;
  style_8 = ImGui::GetStyle ();
  ImGui::EndChildFrame ();
  ImGui::SameLine (0.0, -1.0e+0);
  parent_window_5->DC.CursorPos = bb.Min;
  _12 = style_8->FramePadding.y;
  ImGui::ItemSize (&bb, _12);
  ImGui::EndGroup ();
  bb ={v} {CLOBBER};
  return;

}



;; Function bool ImGui::ListBox(const char*, int*, const char* const*, int, int) (_ZN5ImGui7ListBoxEPKcPiPKS1_ii, funcdef_no=1119, decl_uid=3169, cgraph_uid=1018, symbol_order=1029)

bool ImGui::ListBox(const char*, int*, const char* const*, int, int) (const char * label, int * current_item, const char * const * items, int items_count, int height_items)
{
  const bool D.41087;
  const bool value_changed;
  bool D.41085;
  const bool _8;
  bool _10;

  <bb 2>:
  _8 = ImGui::ListBox (label_2(D), current_item_3(D), Items_ArrayGetter, items_4(D), items_count_5(D), height_items_6(D));
  value_changed_9 = _8;
  _10 = value_changed_9;

<L0>:
  return _10;

}



;; Function bool ImGui::ListBox(const char*, int*, bool (*)(void*, int, const char**), void*, int, int) (_ZN5ImGui7ListBoxEPKcPiPFbPviPS1_ES3_ii, funcdef_no=1120, decl_uid=3179, cgraph_uid=1019, symbol_order=1030)

bool ImGui::ListBox(const char*, int*, bool (*)(void*, int, const char**), void*, int, int) (const char * label, int * current_item, bool (*<T6ca>) (void *, int, const char * *) items_getter, void * data, int items_count, int height_in_items)
{
  void * D.46694;
  bool D.41119;
  bool D.41118;
  bool D.41117;
  bool D.41116;
  const char * item_text;
  const bool item_selected;
  int i;
  struct ImGuiListClipper clipper;
  bool value_changed;
  const char * item_text.1758;
  int D.41107;
  struct ImVec2 D.20865;
  bool retval.1757;
  bool D.41102;
  bool retval.1756;
  int D.41100;
  int D.41098;
  bool retval.1755;
  float D.41093;
  bool D.41092;
  bool D.41089;
  bool retval.1754;
  bool _5;
  bool _20;
  bool _21;
  bool retval.1754_22;
  bool _23;
  float _26;
  bool _29;
  bool retval.1755_30;
  int _32;
  int _34;
  bool _39;
  bool _40;
  bool retval.1756_41;
  int _45;
  const char * item_text.1758_46;
  bool _48;
  bool retval.1757_49;
  bool _60;

  <bb 2>:
  _20 = ImGui::ListBoxHeader (label_16(D), items_count_17(D), height_in_items_18(D));
  _21 = _20;
  retval.1754_22 = ~_21;
  if (retval.1754_22 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _23 = 0;
  goto <bb 21>;

  <bb 4>:
  value_changed_24 = 0;
  _26 = ImGui::GetTextLineHeightWithSpacing ();
  ImGuiListClipper::ImGuiListClipper (&clipper, items_count_17(D), _26);

  <bb 5>:
  # value_changed_1 = PHI <value_changed_24(4), value_changed_2(18)>
  _29 = ImGuiListClipper::Step (&clipper);
  retval.1755_30 = _29;
  if (retval.1755_30 != 0)
    goto <bb 6>;
  else
    goto <bb 19>;

  <bb 6>:
  i_31 = clipper.DisplayStart;

  <bb 7>:
  # value_changed_2 = PHI <value_changed_1(6), value_changed_3(17)>
  # i_4 = PHI <i_31(6), i_56(17)>
  _32 = clipper.DisplayEnd;
  if (_32 <= i_4)
    goto <bb 18>;
  else
    goto <bb 8>;

  <bb 8>:
  _34 = *current_item_33(D);
  item_selected_35 = _34 == i_4;
  _39 = items_getter_36(D) (data_37(D), i_4, &item_text);

  <bb 9>:
  _40 = _39;
  retval.1756_41 = ~_40;
  if (retval.1756_41 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  item_text = "*Unknown item*";

  <bb 11>:
  ImGui::PushID (i_4);

  <bb 12>:
  ImVec2::ImVec2 (&D.20865, 0.0, 0.0);
  _45 = (int) item_selected_35;
  item_text.1758_46 = item_text;
  _48 = ImGui::Selectable (item_text.1758_46, _45, 0, &D.20865);

  <bb 13>:
  retval.1757_49 = _48;
  D.20865 ={v} {CLOBBER};
  if (retval.1757_49 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  *current_item_33(D) = i_4;
  value_changed_52 = 1;

  <bb 15>:
  # value_changed_3 = PHI <value_changed_2(13), value_changed_52(14)>
  if (item_selected_35 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  ImGui::SetItemDefaultFocus ();

  <bb 17>:
  ImGui::PopID ();
  item_text ={v} {CLOBBER};
  i_56 = i_4 + 1;
  goto <bb 7>;

  <bb 18>:
  goto <bb 5>;

  <bb 19>:
  ImGui::ListBoxFooter ();

  <bb 20>:
  _60 = value_changed_1;
  ImGuiListClipper::~ImGuiListClipper (&clipper);

  <bb 21>:
  # _5 = PHI <_23(3), _60(20)>
  clipper ={v} {CLOBBER};

<L19>:
  return _5;

<L22>:
  D.20865 ={v} {CLOBBER};
  item_text ={v} {CLOBBER};
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  _12 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_12);

}



;; Function bool ImGui::MenuItem(const char*, const char*, bool, bool) (_ZN5ImGui8MenuItemEPKcS1_bb, funcdef_no=1121, decl_uid=3221, cgraph_uid=1020, symbol_order=1031)

bool ImGui::MenuItem(const char*, const char*, bool, bool) (const char * label, const char * shortcut, bool selected, bool enabled)
{
  bool D.41199;
  bool D.41197;
  float extra_w;
  float w;
  struct ImVec2 shortcut_size;
  float w;
  bool pressed;
  ImGuiSelectableFlags flags;
  struct ImVec2 label_size;
  struct ImVec2 pos;
  struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  struct ImVec2 D.41193;
  float D.41192;
  float D.41191;
  float D.41190;
  float D.41189;
  float D.41188;
  float D.41187;
  float D.41186;
  float D.41185;
  struct ImVec2 D.20898;
  unsigned int D.41184;
  ImGuiCol iftmp.1760;
  float D.41179;
  float D.41178;
  struct ImVec2 D.41174;
  float D.41173;
  float D.41172;
  struct ImVec2 D.20896;
  struct ImVec4 * D.41171;
  float D.41168;
  int D.41167;
  struct ImVec2 D.20895;
  float D.41166;
  float D.41165;
  struct ImVec2 D.20894;
  struct ImGuiMenuColumns * D.41164;
  float D.41163;
  float D.41162;
  float D.41161;
  int D.41160;
  float D.41159;
  float D.41158;
  float D.41153;
  float D.41152;
  int D.41151;
  float D.41150;
  float D.41149;
  float D.41148;
  struct ImVec2 D.20887;
  struct ImVec2 * D.41147;
  struct ImVec2 D.20886;
  float D.41146;
  float D.41145;
  int D.41144;
  float D.41143;
  float D.41142;
  float D.41141;
  int D.41138;
  int iftmp.1759;
  bool D.41133;
  bool D.41130;
  bool _2;
  int iftmp.1759_3;
  ImGuiCol iftmp.1760_4;
  bool _15;
  bool _16;
  int iftmp.1759_23;
  int iftmp.1759_24;
  int _26;
  float _28;
  float _29;
  float _30;
  int _31;
  float _32;
  float _33;
  struct ImVec2 * _35;
  bool _41;
  float _45;
  float _46;
  float _47;
  int _48;
  float _49;
  float _50;
  float _57;
  float _58;
  int _59;
  float _60;
  float _61;
  float _62;
  struct ImGuiMenuColumns * _63;
  float _67;
  float _68;
  int _72;
  bool _74;
  float _77;
  struct ImVec4 * _78;
  float _80;
  float _81;
  float _89;
  float _90;
  ImGuiCol iftmp.1760_91;
  ImGuiCol iftmp.1760_92;
  unsigned int _94;
  float _95;
  float _96;
  float _97;
  float _98;
  float _99;
  float _100;
  float _101;
  float _102;
  bool _111;

  <bb 2>:
  window_14 = ImGui::GetCurrentWindow ();
  _15 = window_14->SkipItems;
  if (_15 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _16 = 0;
  goto <bb 21>;

  <bb 4>:
  g_17 = GImGui;
  style_18 = &g_17->Style;
  pos = window_14->DC.CursorPos;
  label_size = ImGui::CalcTextSize (label_20(D), 0B, 1, -1.0e+0);
  if (enabled_22(D) != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1759_23 = 16;
  goto <bb 7>;

  <bb 6>:
  iftmp.1759_24 = 48;

  <bb 7>:
  # iftmp.1759_3 = PHI <iftmp.1759_23(5), iftmp.1759_24(6)>
  flags_25 = iftmp.1759_3;
  _26 = window_14->DC.LayoutType;
  if (_26 == 1)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  w_27 = label_size.x;
  _28 = window_14->DC.CursorPos.x;
  _29 = style_18->ItemSpacing.x;
  _30 = _29 * 5.0e-1;
  _31 = (int) _30;
  _32 = (float) _31;
  _33 = _28 + _32;
  window_14->DC.CursorPos.x = _33;
  _35 = &style_18->ItemSpacing;
  D.20886 = operator* (_35, 2.0e+0);
  ImGui::PushStyleVar (13, &D.20886);
  D.20886 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.20887, w_27, 0.0);
  _41 = ImGui::Selectable (label_20(D), 0, flags_25, &D.20887);
  pressed_42 = _41;
  D.20887 ={v} {CLOBBER};
  ImGui::PopStyleVar (1);
  _45 = window_14->DC.CursorPos.x;
  _46 = style_18->ItemSpacing.x;
  _47 = _46 * -5.0e-1;
  _48 = (int) _47;
  _49 = (float) _48;
  _50 = _45 + _49;
  window_14->DC.CursorPos.x = _50;
  goto <bb 20>;

  <bb 9>:
  if (shortcut_54(D) != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  shortcut_size = ImGui::CalcTextSize (shortcut_54(D), 0B, 0, -1.0e+0);
  goto <bb 12>;

  <bb 11>:
  ImVec2::ImVec2 (&shortcut_size, 0.0, 0.0);

  <bb 12>:
  _57 = g_17->FontSize;
  _58 = _57 * 1.2000000476837158203125e+0;
  _59 = (int) _58;
  _60 = (float) _59;
  _61 = shortcut_size.x;
  _62 = label_size.x;
  _63 = &window_14->MenuColumns;
  w_65 = ImGuiMenuColumns::DeclColumns (_63, _62, _61, _60);
  D.20894 = ImGui::GetContentRegionAvail ();
  _67 = D.20894.x;
  _68 = _67 - w_65;
  extra_w_70 = ImMax (0.0, _68);
  ImVec2::ImVec2 (&D.20895, w_65, 0.0);
  _72 = flags_25 | 64;
  _74 = ImGui::Selectable (label_20(D), 0, _72, &D.20895);
  pressed_75 = _74;
  D.20895 ={v} {CLOBBER};
  _77 = shortcut_size.x;
  if (_77 > 0.0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _78 = &g_17->Style.Colors[1];
  ImGui::PushStyleColor (0, _78);
  _80 = window_14->MenuColumns.Pos[1];
  _81 = _80 + extra_w_70;
  ImVec2::ImVec2 (&D.20896, _81, 0.0);
  D.41174 = operator+ (&pos, &D.20896);
  ImGui::RenderText (D.41174, shortcut_54(D), 0B, 0);
  D.20896 ={v} {CLOBBER};
  ImGui::PopStyleColor (1);

  <bb 14>:
  if (selected_88(D) != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

  <bb 15>:
  _89 = g_17->FontSize;
  _90 = _89 * 8.65999996662139892578125e-1;
  if (enabled_22(D) != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.1760_91 = 0;
  goto <bb 18>;

  <bb 17>:
  iftmp.1760_92 = 1;

  <bb 18>:
  # iftmp.1760_4 = PHI <iftmp.1760_91(16), iftmp.1760_92(17)>
  _94 = ImGui::GetColorU32 (iftmp.1760_4, 1.0e+0);
  _95 = g_17->FontSize;
  _96 = _95 * 1.34000003337860107421875e-1;
  _97 = _96 * 5.0e-1;
  _98 = window_14->MenuColumns.Pos[2];
  _99 = _98 + extra_w_70;
  _100 = g_17->FontSize;
  _101 = _100 * 4.000000059604644775390625e-1;
  _102 = _99 + _101;
  ImVec2::ImVec2 (&D.20898, _102, _97);
  D.41193 = operator+ (&pos, &D.20898);
  ImGui::RenderCheckMark (D.41193, _94, _90);
  D.20898 ={v} {CLOBBER};

  <bb 19>:
  shortcut_size ={v} {CLOBBER};

  <bb 20>:
  # pressed_1 = PHI <pressed_42(8), pressed_75(19)>
  _111 = pressed_1;

  <bb 21>:
  # _2 = PHI <_16(3), _111(20)>
  pos ={v} {CLOBBER};
  label_size ={v} {CLOBBER};

<L21>:
  return _2;

}



;; Function bool ImGui::MenuItem(const char*, const char*, bool*, bool) (_ZN5ImGui8MenuItemEPKcS1_Pbb, funcdef_no=1122, decl_uid=3226, cgraph_uid=1021, symbol_order=1032)

bool ImGui::MenuItem(const char*, const char*, bool*, bool) (const char * label, const char * shortcut, bool * p_selected, bool enabled)
{
  bool D.41222;
  bool D.41220;
  bool D.41218;
  bool D.41217;
  bool D.41211;
  int iftmp.1762;
  int D.41207;
  bool retval.1761;
  int iftmp.1762_1;
  bool _2;
  int _6;
  bool _9;
  int iftmp.1762_10;
  int iftmp.1762_11;
  bool _15;
  bool retval.1761_16;
  bool _17;
  bool _18;
  bool _20;
  bool _21;

  <bb 2>:
  _6 = (int) enabled_5(D);
  if (p_selected_7(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _9 = *p_selected_7(D);
  iftmp.1762_10 = (int) _9;
  goto <bb 5>;

  <bb 4>:
  iftmp.1762_11 = 0;

  <bb 5>:
  # iftmp.1762_1 = PHI <iftmp.1762_10(3), iftmp.1762_11(4)>
  _15 = ImGui::MenuItem (label_12(D), shortcut_13(D), iftmp.1762_1, _6);
  retval.1761_16 = _15;
  if (retval.1761_16 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

  <bb 6>:
  if (p_selected_7(D) != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _17 = *p_selected_7(D);
  _18 = ~_17;
  *p_selected_7(D) = _18;

  <bb 8>:
  _20 = 1;
  goto <bb 10> (<L8>);

  <bb 9>:
  _21 = 0;

  # _2 = PHI <_20(8), _21(9)>
<L8>:
  return _2;

}



;; Function bool ImGui::BeginMainMenuBar() (_ZN5ImGui16BeginMainMenuBarEv, funcdef_no=1123, decl_uid=3209, cgraph_uid=1022, symbol_order=1033)

bool ImGui::BeginMainMenuBar() ()
{
  bool D.41249;
  bool D.41248;
  struct ImGuiContext & g;
  float D.41245;
  float D.41244;
  float D.41243;
  struct ImGuiWindow * D.41242;
  struct ImGuiWindow * D.41241;
  bool D.41240;
  bool D.41237;
  bool D.41236;
  bool D.41234;
  bool D.41233;
  bool iftmp.1764;
  bool retval.1763;
  struct ImVec2 D.20912;
  float D.41227;
  float D.41226;
  float D.41225;
  float D.41224;
  float D.41223;
  struct ImVec2 D.20911;
  struct ImVec2 D.20909;
  struct ImVec2 D.20910;
  bool iftmp.1764_1;
  bool _2;
  float _13;
  float _14;
  float _15;
  float _16;
  float _17;
  bool _26;
  bool _27;
  bool _28;
  bool _30;
  bool _31;
  bool _32;
  bool iftmp.1764_33;
  bool iftmp.1764_34;
  bool retval.1763_35;
  bool _38;
  struct ImGuiWindow * _39;
  struct ImGuiWindow * _40;
  float _41;
  float _42;
  float _43;
  bool _45;

  <bb 2>:
  g_7 = GImGui;
  ImVec2::ImVec2 (&D.20910, 0.0, 0.0);
  ImVec2::ImVec2 (&D.20909, 0.0, 0.0);
  ImGui::SetNextWindowPos (&D.20909, 0, &D.20910);
  D.20909 ={v} {CLOBBER};
  D.20910 ={v} {CLOBBER};
  _13 = g_7->FontBaseSize;
  _14 = g_7->Style.FramePadding.y;
  _15 = _14 * 2.0e+0;
  _16 = _13 + _15;
  _17 = g_7->IO.DisplaySize.x;
  ImVec2::ImVec2 (&D.20911, _17, _16);
  ImGui::SetNextWindowSize (&D.20911, 0);
  D.20911 ={v} {CLOBBER};
  ImGui::PushStyleVar (2, 0.0);
  ImVec2::ImVec2 (&D.20912, 0.0, 0.0);
  ImGui::PushStyleVar (4, &D.20912);
  D.20912 ={v} {CLOBBER};
  _26 = ImGui::Begin ("##MainMenuBar", 0B, 1295);
  _27 = _26;
  _28 = ~_27;
  if (_28 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _30 = ImGui::BeginMenuBar ();
  _31 = _30;
  _32 = ~_31;
  if (_32 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1764_34 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.1764_33 = 0;

  <bb 6>:
  # iftmp.1764_1 = PHI <iftmp.1764_34(4), iftmp.1764_33(5)>
  retval.1763_35 = iftmp.1764_1;
  if (retval.1763_35 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGui::End ();
  ImGui::PopStyleVar (2);
  _38 = 0;
  goto <bb 9> (<L6>);

  <bb 8>:
  _39 = g_7->CurrentWindow;
  _40 = g_7->CurrentWindow;
  _41 = _40->DC.MenuBarOffsetX;
  _42 = g_7->Style.DisplaySafeAreaPadding.x;
  _43 = _41 + _42;
  _39->DC.MenuBarOffsetX = _43;
  _45 = 1;

  # _2 = PHI <_38(7), _45(8)>
<L6>:
  return _2;

}



;; Function void ImGui::EndMainMenuBar() (_ZN5ImGui14EndMainMenuBarEv, funcdef_no=1124, decl_uid=3210, cgraph_uid=1023, symbol_order=1034)

void ImGui::EndMainMenuBar() ()
{
  struct ImGuiContext & g;
  struct ImGuiWindow * D.41257;
  int D.41254;
  struct ImGuiWindow * D.41251;
  struct ImGuiWindow * D.41250;
  struct ImGuiWindow * _5;
  struct ImGuiWindow * _6;
  int _7;
  struct ImGuiWindow * _8;

  <bb 2>:
  ImGui::EndMenuBar ();
  g_4 = GImGui;
  _5 = g_4->CurrentWindow;
  _6 = g_4->NavWindow;
  if (_5 == _6)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = g_4->NavLayer;
  if (_7 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _8 = g_4->NavWindow;
  ImGui::FocusFrontMostActiveWindow (_8);

  <bb 5>:
  ImGui::End ();
  ImGui::PopStyleVar (2);
  return;

}



;; Function bool ImGui::BeginMenuBar() (_ZN5ImGui12BeginMenuBarEv, funcdef_no=1125, decl_uid=3211, cgraph_uid=1024, symbol_order=1035)

bool ImGui::BeginMenuBar() ()
{
  struct ImRect clip_rect;
  struct ImRect bar_rect;
  static const char __PRETTY_FUNCTION__[27] = "bool ImGui::BeginMenuBar()";
  struct ImGuiWindow * window;
  int D.41298;
  int D.41297;
  int D.41296;
  int D.41295;
  float D.41294;
  float D.41293;
  float D.41292;
  float D.41291;
  struct ImVec2 D.20923;
  struct ImRect * D.41290;
  float D.41289;
  float D.41288;
  float D.41287;
  float D.41286;
  float D.41285;
  float D.41284;
  float D.41283;
  float D.41282;
  float D.41281;
  float D.41280;
  float D.41279;
  float D.41278;
  float D.41277;
  float D.41276;
  float D.41275;
  float D.41274;
  float D.41273;
  float D.41272;
  bool D.41268;
  bool D.41267;
  int D.41264;
  int D.41263;
  bool D.41262;
  bool D.41259;
  bool _1;
  bool _7;
  bool _8;
  int _9;
  int _10;
  bool _11;
  bool _12;
  bool _13;
  float _17;
  float _18;
  float _20;
  float _21;
  float _22;
  float _23;
  float _24;
  float _26;
  float _27;
  float _29;
  float _30;
  float _31;
  float _32;
  float _33;
  float _35;
  float _36;
  float _37;
  float _39;
  struct ImRect * _41;
  float _44;
  float _45;
  float _46;
  float _47;
  int _52;
  int _53;
  int _55;
  int _56;
  bool _60;

  <bb 2>:
  window_6 = ImGui::GetCurrentWindow ();
  _7 = window_6->SkipItems;
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = 0;
  goto <bb 9>;

  <bb 4>:
  _9 = window_6->Flags;
  _10 = _9 & 1024;
  if (_10 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _11 = 0;
  goto <bb 9>;

  <bb 6>:
  _12 = window_6->DC.MenuBarAppending;
  _13 = ~_12;
  if (_13 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("!window->DC.MenuBarAppending", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11165, &__PRETTY_FUNCTION__);

  <bb 8>:
  ImGui::BeginGroup ();
  ImGui::PushID ("##menubar");
  bar_rect = ImGuiWindow::MenuBarRect (window_6);
  _17 = bar_rect.Max.y;
  _18 = _17 + 5.0e-1;
  _20 = ImFloor (_18);
  _21 = bar_rect.Max.x;
  _22 = window_6->WindowRounding;
  _23 = _21 - _22;
  _24 = bar_rect.Min.x;
  _26 = ImMax (_24, _23);
  _27 = _26 + 5.0e-1;
  _29 = ImFloor (_27);
  _30 = bar_rect.Min.y;
  _31 = window_6->WindowBorderSize;
  _32 = _30 + _31;
  _33 = _32 + 5.0e-1;
  _35 = ImFloor (_33);
  _36 = bar_rect.Min.x;
  _37 = _36 + 5.0e-1;
  _39 = ImFloor (_37);
  ImRect::ImRect (&clip_rect, _39, _35, _29, _20);
  _41 = &window_6->WindowRectClipped;
  ImRect::ClipWith (&clip_rect, _41);
  ImGui::PushClipRect (&clip_rect.Min, &clip_rect.Max, 0);
  _44 = bar_rect.Min.y;
  _45 = bar_rect.Min.x;
  _46 = window_6->DC.MenuBarOffsetX;
  _47 = _45 + _46;
  ImVec2::ImVec2 (&D.20923, _47, _44);
  window_6->DC.CursorPos = D.20923;
  D.20923 ={v} {CLOBBER};
  window_6->DC.LayoutType = 1;
  _52 = window_6->DC.NavLayerCurrent;
  _53 = _52 + 1;
  window_6->DC.NavLayerCurrent = _53;
  _55 = window_6->DC.NavLayerCurrentMask;
  _56 = _55 << 1;
  window_6->DC.NavLayerCurrentMask = _56;
  window_6->DC.MenuBarAppending = 1;
  ImGui::AlignTextToFramePadding ();
  _60 = 1;

  <bb 9>:
  # _1 = PHI <_8(3), _11(5), _60(8)>
  bar_rect ={v} {CLOBBER};
  clip_rect ={v} {CLOBBER};

<L8>:
  return _1;

}



;; Function void ImGui::EndMenuBar() (_ZN5ImGui10EndMenuBarEv, funcdef_no=1126, decl_uid=3212, cgraph_uid=1025, symbol_order=1036)

void ImGui::EndMenuBar() ()
{
  struct ImGuiWindow * nav_earliest_child;
  static const char __PRETTY_FUNCTION__[25] = "void ImGui::EndMenuBar()";
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  int D.41363;
  int D.41362;
  int D.41361;
  int D.41360;
  struct value_type & D.41359;
  struct ImVector * D.41358;
  float D.41357;
  float D.41356;
  struct ImRect D.20930;
  float D.41355;
  bool D.41351;
  int D.41347;
  int D.41346;
  unsigned int D.41343;
  struct ImRect * D.41342;
  int D.41338;
  int D.41337;
  ImGuiNavForward D.41334;
  int D.41331;
  struct ImGuiWindow * D.41328;
  int D.41326;
  int D.41325;
  struct ImGuiWindow * D.41324;
  struct ImGuiWindow * D.41322;
  int D.41317;
  int D.41316;
  struct ImGuiWindow * D.41315;
  int D.41314;
  int D.41312;
  bool D.41310;
  bool iftmp.1766;
  bool retval.1765;
  bool D.41302;
  bool iftmp.1766_2;
  bool _9;
  bool _12;
  int _13;
  int _14;
  struct ImGuiWindow * _15;
  int _16;
  int _17;
  bool iftmp.1766_18;
  bool iftmp.1766_19;
  bool retval.1765_20;
  struct ImGuiWindow * _22;
  struct ImGuiWindow * _23;
  int _24;
  int _25;
  struct ImGuiWindow * _27;
  int _28;
  ImGuiNavForward _29;
  int _30;
  int _31;
  struct ImRect * _33;
  unsigned int _34;
  int _41;
  int _42;
  bool _43;
  float _46;
  float _48;
  float _49;
  struct ImVector * _51;
  struct value_type & _53;
  int _57;
  int _58;
  int _60;
  int _61;

  <bb 2>:
  window_8 = ImGui::GetCurrentWindow ();
  _9 = window_8->SkipItems;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 27> (<L31>);

  <bb 4>:
  g_10 = GImGui;
  _12 = NavMoveRequestButNoResultYet ();
  if (_12 != 0)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:
  _13 = g_10->NavMoveDir;
  if (_13 == 0)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _14 = g_10->NavMoveDir;
  if (_14 == 1)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _15 = g_10->NavWindow;
  _16 = _15->Flags;
  _17 = _16 & 268435456;
  if (_17 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1766_18 = 1;
  goto <bb 10>;

  <bb 9>:
  iftmp.1766_19 = 0;

  <bb 10>:
  # iftmp.1766_2 = PHI <iftmp.1766_18(8), iftmp.1766_19(9)>
  retval.1765_20 = iftmp.1766_2;
  if (retval.1765_20 != 0)
    goto <bb 11>;
  else
    goto <bb 22>;

  <bb 11>:
  nav_earliest_child_21 = g_10->NavWindow;

  <bb 12>:
  # nav_earliest_child_1 = PHI <nav_earliest_child_21(11), nav_earliest_child_26(14)>
  _22 = nav_earliest_child_1->ParentWindow;
  if (_22 == 0B)
    goto <bb 15>;
  else
    goto <bb 13>;

  <bb 13>:
  _23 = nav_earliest_child_1->ParentWindow;
  _24 = _23->Flags;
  _25 = _24 & 268435456;
  if (_25 == 0)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  nav_earliest_child_26 = nav_earliest_child_1->ParentWindow;
  goto <bb 12>;

  <bb 15>:
  _27 = nav_earliest_child_1->ParentWindow;
  if (_27 == window_8)
    goto <bb 16>;
  else
    goto <bb 21>;

  <bb 16>:
  _28 = nav_earliest_child_1->DC.ParentLayoutType;
  if (_28 == 1)
    goto <bb 17>;
  else
    goto <bb 21>;

  <bb 17>:
  _29 = g_10->NavMoveRequestForward;
  if (_29 == 0)
    goto <bb 18>;
  else
    goto <bb 21>;

  <bb 18>:
  _30 = window_8->DC.NavLayerActiveMaskNext;
  _31 = _30 & 2;
  if (_31 != 0)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  __assert_fail ("window->DC.NavLayerActiveMaskNext & 0x02", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11202, &__PRETTY_FUNCTION__);

  <bb 20>:
  ImGui::FocusWindow (window_8);
  _33 = &window_8->NavRectRel[1];
  _34 = window_8->NavLastIds[1];
  SetNavIDWithRectRel (_34, 1, _33);
  g_10->NavLayer = 1;
  g_10->NavDisableHighlight = 1;
  g_10->NavMoveRequestForward = 1;
  ImGui::NavMoveRequestCancel ();

  <bb 21>:

  <bb 22>:
  _41 = window_8->Flags;
  _42 = _41 & 1024;
  if (_42 != 0)
    goto <bb 24>;
  else
    goto <bb 23>;

  <bb 23>:
  __assert_fail ("window->Flags & ImGuiWindowFlags_MenuBar", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11212, &__PRETTY_FUNCTION__);

  <bb 24>:
  _43 = window_8->DC.MenuBarAppending;
  if (_43 != 0)
    goto <bb 26>;
  else
    goto <bb 25>;

  <bb 25>:
  __assert_fail ("window->DC.MenuBarAppending", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11213, &__PRETTY_FUNCTION__);

  <bb 26>:
  ImGui::PopClipRect ();
  ImGui::PopID ();
  _46 = window_8->DC.CursorPos.x;
  D.20930 = ImGuiWindow::MenuBarRect (window_8);
  _48 = D.20930.Min.x;
  _49 = _46 - _48;
  window_8->DC.MenuBarOffsetX = _49;
  _51 = &window_8->DC.GroupStack;
  _53 = ImVector<ImGuiGroupData>::back (_51);
  _53->AdvanceCursor = 0;
  ImGui::EndGroup ();
  window_8->DC.LayoutType = 0;
  _57 = window_8->DC.NavLayerCurrent;
  _58 = _57 + -1;
  window_8->DC.NavLayerCurrent = _58;
  _60 = window_8->DC.NavLayerCurrentMask;
  _61 = _60 >> 1;
  window_8->DC.NavLayerCurrentMask = _61;
  window_8->DC.MenuBarAppending = 0;

<L31>:
  return;

}



;; Function bool ImGui::BeginMenu(const char*, bool) (_ZN5ImGui9BeginMenuEPKcb, funcdef_no=1127, decl_uid=3215, cgraph_uid=1026, symbol_order=1037)

bool ImGui::BeginMenu(const char*, bool) (const char * label, bool enabled)
{
  bool D.41651;
  bool D.41650;
  bool D.41649;
  bool D.41646;
  bool D.41644;
  bool D.41642;
  const ImGuiID D.41641;
  ImGuiWindowFlags flags;
  float extra;
  struct ImVec2 tc;
  struct ImVec2 tb;
  struct ImVec2 ta;
  struct ImRect next_window_rect;
  struct ImGuiWindow * next_window;
  bool moving_within_opened_triangle;
  float extra_w;
  float w;
  float w;
  bool want_close;
  bool want_open;
  const bool hovered;
  struct ImVec2 pos;
  struct ImVec2 popup_pos;
  struct ImGuiWindow * backed_nav_window;
  bool menuset_is_open;
  bool menu_is_open;
  bool pressed;
  struct ImVec2 label_size;
  const ImGuiID id;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  int D.41635;
  int D.41634;
  int iftmp.1780;
  struct ImVec2 D.20979;
  int D.41625;
  int D.41624;
  bool D.41619;
  int D.41617;
  bool D.41613;
  bool iftmp.1779;
  bool retval.1778;
  bool D.41604;
  int D.41600;
  bool D.41597;
  unsigned int D.41594;
  bool D.41593;
  int D.41577;
  bool D.41574;
  unsigned int D.41571;
  unsigned int D.41567;
  bool D.41564;
  bool D.41563;
  bool D.41560;
  bool iftmp.1777;
  bool D.41553;
  unsigned int D.41551;
  unsigned int D.41549;
  struct ImGuiWindow * D.41547;
  bool D.41545;
  bool iftmp.1776;
  struct ImVec2 * D.41538;
  float D.41537;
  float D.41536;
  float D.41535;
  float D.41534;
  float D.41533;
  float D.41532;
  float D.41531;
  float D.41530;
  float D.41529;
  float D.41528;
  float D.41527;
  float D.41526;
  float D.41525;
  float D.41524;
  float D.41523;
  float D.41519;
  float D.41518;
  float iftmp.1775;
  float D.41516;
  float D.41515;
  float D.41514;
  float D.41513;
  float D.41512;
  float D.41511;
  float D.41507;
  float D.41506;
  float D.41502;
  float D.41501;
  struct ImVec2 * D.41500;
  struct ImVec2 * D.41499;
  struct value_type & D.41496;
  struct ImVector * D.41495;
  int D.41494;
  int D.41490;
  int D.41489;
  struct ImGuiWindow * D.41487;
  struct value_type & D.41486;
  struct ImVector * D.41485;
  int D.41484;
  int D.41482;
  int D.41481;
  struct ImGuiWindow * D.41479;
  bool iftmp.1774;
  bool retval.1773;
  int D.41472;
  bool D.41467;
  struct ImRect * D.41466;
  bool iftmp.1772;
  bool D.41458;
  struct ImVec2 D.41457;
  float D.41456;
  float D.41455;
  float D.41454;
  float D.41453;
  float D.41452;
  struct ImVec2 D.20959;
  struct ImVec4 * D.41450;
  bool D.41447;
  int D.41446;
  int iftmp.1771;
  struct ImVec2 D.20958;
  float D.41441;
  float D.41440;
  struct ImVec2 D.20957;
  struct ImGuiMenuColumns * D.41439;
  float D.41438;
  float D.41437;
  int D.41436;
  float D.41435;
  float D.41434;
  float D.41433;
  float D.41432;
  float D.41431;
  float D.41430;
  struct ImVec2 popup_pos.1770;
  float D.41428;
  float D.41427;
  int D.41426;
  float D.41425;
  float D.41424;
  float D.41423;
  int D.41422;
  int iftmp.1769;
  struct ImVec2 D.20953;
  const struct ImVec2 * D.41417;
  struct ImVec2 D.20951;
  float D.41416;
  float D.41415;
  int D.41414;
  float D.41413;
  float D.41412;
  float D.41411;
  float D.41410;
  float D.41409;
  float D.41408;
  float D.41407;
  float D.41406;
  float D.41405;
  float D.41404;
  float D.41403;
  struct ImVec2 popup_pos.1768;
  int D.41400;
  unsigned int D.41395;
  value_type & D.41394;
  struct ImVector * D.41393;
  unsigned int D.41392;
  struct value_type & D.41391;
  struct ImVector * D.41390;
  int D.41389;
  int D.41387;
  int D.41386;
  int D.41384;
  int D.41383;
  bool iftmp.1767;
  bool D.41379;
  bool D.41376;
  bool _12;
  bool iftmp.1767_13;
  int iftmp.1769_14;
  int iftmp.1771_15;
  bool iftmp.1772_16;
  bool iftmp.1774_17;
  float iftmp.1775_18;
  bool iftmp.1776_19;
  bool iftmp.1777_20;
  bool iftmp.1779_21;
  int iftmp.1780_22;
  bool _49;
  bool _50;
  const ImGuiID _55;
  bool _59;
  int _61;
  int _62;
  int _63;
  int _64;
  int _65;
  struct ImVector * _66;
  struct value_type & _68;
  unsigned int _69;
  struct ImVector * _70;
  value_type & _72;
  unsigned int _73;
  bool iftmp.1767_74;
  bool iftmp.1767_75;
  int _81;
  float _82;
  float _83;
  float _84;
  float _86;
  float _87;
  float _88;
  float _89;
  float _90;
  float _94;
  float _95;
  float _96;
  int _97;
  float _98;
  float _99;
  const struct ImVec2 * _101;
  int iftmp.1769_108;
  int iftmp.1769_109;
  int _110;
  bool _112;
  float _116;
  float _117;
  float _118;
  int _119;
  float _120;
  float _121;
  float _125;
  float _126;
  float _127;
  float _128;
  float _132;
  float _133;
  int _134;
  float _135;
  float _136;
  struct ImGuiMenuColumns * _137;
  float _141;
  float _142;
  int iftmp.1771_146;
  int iftmp.1771_147;
  int _148;
  bool _150;
  bool _153;
  struct ImVec4 * _154;
  float _156;
  float _157;
  float _158;
  float _159;
  float _160;
  bool _165;
  struct ImRect * _169;
  bool _171;
  bool _172;
  bool iftmp.1772_173;
  bool iftmp.1772_174;
  int _179;
  struct ImGuiWindow * _181;
  int _182;
  int _183;
  int _184;
  struct ImVector * _185;
  struct value_type & _187;
  struct ImGuiWindow * _188;
  int _189;
  int _190;
  bool iftmp.1774_191;
  bool iftmp.1774_192;
  bool retval.1773_193;
  int _194;
  struct ImVector * _195;
  struct value_type & _197;
  struct ImVec2 * _200;
  struct ImVec2 * _201;
  float _203;
  float _204;
  float _207;
  float _208;
  float _211;
  float _212;
  float _213;
  float _214;
  float _215;
  float _218;
  float _219;
  float _220;
  float iftmp.1775_221;
  float iftmp.1775_222;
  float _223;
  float _225;
  float _226;
  float _227;
  float _228;
  float _229;
  float _231;
  float _232;
  float _234;
  float _235;
  float _236;
  float _237;
  float _238;
  float _240;
  float _241;
  struct ImVec2 * _243;
  bool _250;
  struct ImGuiWindow * _251;
  unsigned int _252;
  unsigned int _253;
  bool _254;
  bool iftmp.1776_255;
  bool iftmp.1776_256;
  bool _258;
  bool _259;
  bool _260;
  bool iftmp.1777_261;
  bool iftmp.1777_262;
  unsigned int _264;
  unsigned int _267;
  bool _268;
  int _269;
  bool _275;
  unsigned int _276;
  bool _277;
  int _278;
  bool _282;
  bool _285;
  bool _286;
  bool iftmp.1779_287;
  bool iftmp.1779_288;
  bool retval.1778_289;
  int _290;
  bool _292;
  int _293;
  int _294;
  bool _296;
  int _302;
  int _303;
  int iftmp.1780_304;
  int iftmp.1780_305;
  bool _308;
  bool _310;

  <bb 2>:
  window_48 = ImGui::GetCurrentWindow ();
  _49 = window_48->SkipItems;
  if (_49 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _50 = 0;
  goto <bb 105>;

  <bb 4>:
  g_51 = GImGui;
  style_52 = &g_51->Style;
  _55 = ImGuiWindow::GetID (window_48, label_53(D), 0B);
  id_56 = _55;
  label_size = ImGui::CalcTextSize (label_53(D), 0B, 1, -1.0e+0);
  _59 = ImGui::IsPopupOpen (id_56);
  menu_is_open_60 = _59;
  _61 = window_48->Flags;
  _62 = _61 & 67108864;
  if (_62 == 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _63 = g_51->OpenPopupStack.Size;
  _64 = g_51->CurrentPopupStack.Size;
  if (_63 > _64)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _65 = g_51->CurrentPopupStack.Size;
  _66 = &g_51->OpenPopupStack;
  _68 = ImVector<ImGuiPopupRef>::operator[] (_66, _65);
  _69 = _68->OpenParentId;
  _70 = &window_48->IDStack;
  _72 = ImVector<unsigned int>::back (_70);
  _73 = *_72;
  if (_69 == _73)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1767_74 = 1;
  goto <bb 9>;

  <bb 8>:
  iftmp.1767_75 = 0;

  <bb 9>:
  # iftmp.1767_13 = PHI <iftmp.1767_74(7), iftmp.1767_75(8)>
  menuset_is_open_76 = iftmp.1767_13;
  backed_nav_window_77 = g_51->NavWindow;
  if (menuset_is_open_76 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  g_51->NavWindow = window_48;

  <bb 11>:
  ImVec2::ImVec2 (&popup_pos);
  pos = window_48->DC.CursorPos;
  _81 = window_48->DC.LayoutType;
  if (_81 == 1)
    goto <bb 12>;
  else
    goto <bb 16>;

  <bb 12>:
  _82 = pos.y;
  _83 = style_52->FramePadding.y;
  _84 = _82 - _83;
  _86 = ImGuiWindow::MenuBarHeight (window_48);
  _87 = _84 + _86;
  _88 = pos.x;
  _89 = window_48->WindowPadding.x;
  _90 = _88 - _89;
  ImVec2::ImVec2 (&popup_pos.1768, _90, _87);
  popup_pos = popup_pos.1768;
  popup_pos.1768 ={v} {CLOBBER};
  _94 = window_48->DC.CursorPos.x;
  _95 = style_52->ItemSpacing.x;
  _96 = _95 * 5.0e-1;
  _97 = (int) _96;
  _98 = (float) _97;
  _99 = _94 + _98;
  window_48->DC.CursorPos.x = _99;
  _101 = &style_52->ItemSpacing;
  D.20951 = operator* (_101, 2.0e+0);
  ImGui::PushStyleVar (13, &D.20951);
  D.20951 ={v} {CLOBBER};
  w_105 = label_size.x;
  ImVec2::ImVec2 (&D.20953, w_105, 0.0);
  if (enabled_107(D) != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  iftmp.1769_108 = 9;
  goto <bb 15>;

  <bb 14>:
  iftmp.1769_109 = 41;

  <bb 15>:
  # iftmp.1769_14 = PHI <iftmp.1769_108(13), iftmp.1769_109(14)>
  _110 = (int) menu_is_open_60;
  _112 = ImGui::Selectable (label_53(D), _110, iftmp.1769_14, &D.20953);
  pressed_113 = _112;
  D.20953 ={v} {CLOBBER};
  ImGui::PopStyleVar (1);
  _116 = window_48->DC.CursorPos.x;
  _117 = style_52->ItemSpacing.x;
  _118 = _117 * -5.0e-1;
  _119 = (int) _118;
  _120 = (float) _119;
  _121 = _116 + _120;
  window_48->DC.CursorPos.x = _121;
  goto <bb 23>;

  <bb 16>:
  _125 = pos.y;
  _126 = style_52->WindowPadding.y;
  _127 = _125 - _126;
  _128 = pos.x;
  ImVec2::ImVec2 (&popup_pos.1770, _128, _127);
  popup_pos = popup_pos.1770;
  popup_pos.1770 ={v} {CLOBBER};
  _132 = g_51->FontSize;
  _133 = _132 * 1.2000000476837158203125e+0;
  _134 = (int) _133;
  _135 = (float) _134;
  _136 = label_size.x;
  _137 = &window_48->MenuColumns;
  w_139 = ImGuiMenuColumns::DeclColumns (_137, _136, 0.0, _135);
  D.20957 = ImGui::GetContentRegionAvail ();
  _141 = D.20957.x;
  _142 = _141 - w_139;
  extra_w_144 = ImMax (0.0, _142);
  ImVec2::ImVec2 (&D.20958, w_139, 0.0);
  if (enabled_107(D) != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.1771_146 = 73;
  goto <bb 19>;

  <bb 18>:
  iftmp.1771_147 = 105;

  <bb 19>:
  # iftmp.1771_15 = PHI <iftmp.1771_146(17), iftmp.1771_147(18)>
  _148 = (int) menu_is_open_60;
  _150 = ImGui::Selectable (label_53(D), _148, iftmp.1771_15, &D.20958);
  pressed_151 = _150;
  D.20958 ={v} {CLOBBER};
  _153 = ~enabled_107(D);
  if (_153 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _154 = &g_51->Style.Colors[1];
  ImGui::PushStyleColor (0, _154);

  <bb 21>:
  _156 = window_48->MenuColumns.Pos[2];
  _157 = _156 + extra_w_144;
  _158 = g_51->FontSize;
  _159 = _158 * 3.00000011920928955078125e-1;
  _160 = _157 + _159;
  ImVec2::ImVec2 (&D.20959, _160, 0.0);
  D.41457 = operator+ (&pos, &D.20959);
  ImGui::RenderArrow (D.41457, 1, 1.0e+0);
  D.20959 ={v} {CLOBBER};
  _165 = ~enabled_107(D);
  if (_165 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  ImGui::PopStyleColor (1);

  <bb 23>:
  # pressed_1 = PHI <pressed_113(15), pressed_151(21), pressed_151(22)>
  if (enabled_107(D) != 0)
    goto <bb 24>;
  else
    goto <bb 26>;

  <bb 24>:
  _169 = &window_48->DC.LastItemRect;
  _171 = ImGui::ItemHoverable (_169, id_56);
  _172 = _171;
  if (_172 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  iftmp.1772_173 = 1;
  goto <bb 27>;

  <bb 26>:
  iftmp.1772_174 = 0;

  <bb 27>:
  # iftmp.1772_16 = PHI <iftmp.1772_173(25), iftmp.1772_174(26)>
  hovered_175 = iftmp.1772_16;
  if (menuset_is_open_76 != 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  g_51->NavWindow = backed_nav_window_77;

  <bb 29>:
  want_open_177 = 0;
  want_close_178 = 0;
  _179 = window_48->DC.LayoutType;
  if (_179 == 0)
    goto <bb 30>;
  else
    goto <bb 72>;

  <bb 30>:
  moving_within_opened_triangle_180 = 0;
  _181 = g_51->HoveredWindow;
  if (_181 == window_48)
    goto <bb 31>;
  else
    goto <bb 35>;

  <bb 31>:
  _182 = g_51->OpenPopupStack.Size;
  _183 = g_51->CurrentPopupStack.Size;
  if (_182 > _183)
    goto <bb 32>;
  else
    goto <bb 35>;

  <bb 32>:
  _184 = g_51->CurrentPopupStack.Size;
  _185 = &g_51->OpenPopupStack;
  _187 = ImVector<ImGuiPopupRef>::operator[] (_185, _184);
  _188 = _187->ParentWindow;
  if (_188 == window_48)
    goto <bb 33>;
  else
    goto <bb 35>;

  <bb 33>:
  _189 = window_48->Flags;
  _190 = _189 & 1024;
  if (_190 == 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  iftmp.1774_191 = 1;
  goto <bb 36>;

  <bb 35>:
  iftmp.1774_192 = 0;

  <bb 36>:
  # iftmp.1774_17 = PHI <iftmp.1774_191(34), iftmp.1774_192(35)>
  retval.1773_193 = iftmp.1774_17;
  if (retval.1773_193 != 0)
    goto <bb 37>;
  else
    goto <bb 49>;

  <bb 37>:
  _194 = g_51->CurrentPopupStack.Size;
  _195 = &g_51->OpenPopupStack;
  _197 = ImVector<ImGuiPopupRef>::operator[] (_195, _194);
  next_window_198 = _197->Window;
  if (next_window_198 != 0B)
    goto <bb 38>;
  else
    goto <bb 48>;

  <bb 38>:
  next_window_rect = ImGuiWindow::Rect (next_window_198);
  _200 = &g_51->IO.MouseDelta;
  _201 = &g_51->IO.MousePos;
  ta = operator- (_201, _200);
  _203 = window_48->Pos.x;
  _204 = next_window_198->Pos.x;
  if (_203 < _204)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  tb = ImRect::GetTL (&next_window_rect);
  goto <bb 41>;

  <bb 40>:
  tb = ImRect::GetTR (&next_window_rect);

  <bb 41>:
  _207 = window_48->Pos.x;
  _208 = next_window_198->Pos.x;
  if (_207 < _208)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  tc = ImRect::GetBL (&next_window_rect);
  goto <bb 44>;

  <bb 43>:
  tc = ImRect::GetBR (&next_window_rect);

  <bb 44>:
  _211 = ta.x;
  _212 = tb.x;
  _213 = _211 - _212;
  _214 = ABS_EXPR <_213>;
  _215 = _214 * 3.00000011920928955078125e-1;
  extra_217 = ImClamp (_215, 5.0e+0, 3.0e+1);
  _218 = ta.x;
  _219 = window_48->Pos.x;
  _220 = next_window_198->Pos.x;
  if (_219 < _220)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  iftmp.1775_221 = -5.0e-1;
  goto <bb 47>;

  <bb 46>:
  iftmp.1775_222 = 5.0e-1;

  <bb 47>:
  # iftmp.1775_18 = PHI <iftmp.1775_221(45), iftmp.1775_222(46)>
  _223 = _218 + iftmp.1775_18;
  ta.x = _223;
  _225 = ta.y;
  _226 = tb.y;
  _227 = _226 - extra_217;
  _228 = ta.y;
  _229 = _227 - _228;
  _231 = ImMax (_229, -1.0e+2);
  _232 = _225 + _231;
  tb.y = _232;
  _234 = ta.y;
  _235 = tc.y;
  _236 = _235 + extra_217;
  _237 = ta.y;
  _238 = _236 - _237;
  _240 = ImMin (_238, 1.0e+2);
  _241 = _234 + _240;
  tc.y = _241;
  _243 = &g_51->IO.MousePos;
  moving_within_opened_triangle_245 = ImTriangleContainsPoint (&ta, &tb, &tc, _243);
  next_window_rect ={v} {CLOBBER};
  ta ={v} {CLOBBER};
  tb ={v} {CLOBBER};
  tc ={v} {CLOBBER};

  <bb 48>:
  # moving_within_opened_triangle_10 = PHI <moving_within_opened_triangle_180(37), moving_within_opened_triangle_245(47)>

  <bb 49>:
  # moving_within_opened_triangle_11 = PHI <moving_within_opened_triangle_180(36), moving_within_opened_triangle_10(48)>
  if (menu_is_open_60 != 0)
    goto <bb 50>;
  else
    goto <bb 56>;

  <bb 50>:
  _250 = ~hovered_175;
  if (_250 != 0)
    goto <bb 51>;
  else
    goto <bb 56>;

  <bb 51>:
  _251 = g_51->HoveredWindow;
  if (_251 == window_48)
    goto <bb 52>;
  else
    goto <bb 56>;

  <bb 52>:
  _252 = g_51->HoveredIdPreviousFrame;
  if (_252 != 0)
    goto <bb 53>;
  else
    goto <bb 56>;

  <bb 53>:
  _253 = g_51->HoveredIdPreviousFrame;
  if (_253 != id_56)
    goto <bb 54>;
  else
    goto <bb 56>;

  <bb 54>:
  _254 = ~moving_within_opened_triangle_11;
  if (_254 != 0)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  iftmp.1776_255 = 1;
  goto <bb 57>;

  <bb 56>:
  iftmp.1776_256 = 0;

  <bb 57>:
  # iftmp.1776_19 = PHI <iftmp.1776_255(55), iftmp.1776_256(56)>
  want_close_257 = iftmp.1776_19;
  _258 = ~menu_is_open_60;
  if (_258 != 0)
    goto <bb 58>;
  else
    goto <bb 60>;

  <bb 58>:
  if (hovered_175 != 0)
    goto <bb 59>;
  else
    goto <bb 60>;

  <bb 59>:
  _259 = ~moving_within_opened_triangle_11;
  if (_259 != 0)
    goto <bb 63>;
  else
    goto <bb 60>;

  <bb 60>:
  _260 = ~menu_is_open_60;
  if (_260 != 0)
    goto <bb 61>;
  else
    goto <bb 64>;

  <bb 61>:
  if (hovered_175 != 0)
    goto <bb 62>;
  else
    goto <bb 64>;

  <bb 62>:
  if (pressed_1 != 0)
    goto <bb 63>;
  else
    goto <bb 64>;

  <bb 63>:
  iftmp.1777_262 = 1;
  goto <bb 65>;

  <bb 64>:
  iftmp.1777_261 = 0;

  <bb 65>:
  # iftmp.1777_20 = PHI <iftmp.1777_262(63), iftmp.1777_261(64)>
  want_open_263 = iftmp.1777_20;
  _264 = g_51->NavActivateId;
  if (_264 == id_56)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  want_close_265 = menu_is_open_60;
  want_open_266 = ~menu_is_open_60;

  <bb 67>:
  # want_open_4 = PHI <want_open_263(65), want_open_266(66)>
  # want_close_7 = PHI <want_close_257(65), want_close_265(66)>
  _267 = g_51->NavId;
  if (_267 == id_56)
    goto <bb 68>;
  else
    goto <bb 71>;

  <bb 68>:
  _268 = g_51->NavMoveRequest;
  if (_268 != 0)
    goto <bb 69>;
  else
    goto <bb 71>;

  <bb 69>:
  _269 = g_51->NavMoveDir;
  if (_269 == 1)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  want_open_270 = 1;
  ImGui::NavMoveRequestCancel ();

  <bb 71>:
  # want_open_5 = PHI <want_open_4(67), want_open_4(68), want_open_4(69), want_open_270(70)>
  goto <bb 85>;

  <bb 72>:
  if (menu_is_open_60 != 0)
    goto <bb 73>;
  else
    goto <bb 76>;

  <bb 73>:
  if (pressed_1 != 0)
    goto <bb 74>;
  else
    goto <bb 76>;

  <bb 74>:
  if (menuset_is_open_76 != 0)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 75>:
  want_close_272 = 1;
  menu_is_open_273 = 0;
  want_open_274 = menu_is_open_273;
  goto <bb 85>;

  <bb 76>:
  if (pressed_1 != 0)
    goto <bb 80>;
  else
    goto <bb 77>;

  <bb 77>:
  if (hovered_175 != 0)
    goto <bb 78>;
  else
    goto <bb 81>;

  <bb 78>:
  if (menuset_is_open_76 != 0)
    goto <bb 79>;
  else
    goto <bb 81>;

  <bb 79>:
  _275 = ~menu_is_open_60;
  if (_275 != 0)
    goto <bb 80>;
  else
    goto <bb 81>;

  <bb 80>:
  want_open_281 = 1;
  goto <bb 85>;

  <bb 81>:
  _276 = g_51->NavId;
  if (_276 == id_56)
    goto <bb 82>;
  else
    goto <bb 85>;

  <bb 82>:
  _277 = g_51->NavMoveRequest;
  if (_277 != 0)
    goto <bb 83>;
  else
    goto <bb 85>;

  <bb 83>:
  _278 = g_51->NavMoveDir;
  if (_278 == 3)
    goto <bb 84>;
  else
    goto <bb 85>;

  <bb 84>:
  want_open_279 = 1;
  ImGui::NavMoveRequestCancel ();

  <bb 85>:
  # menu_is_open_2 = PHI <menu_is_open_60(71), menu_is_open_273(75), menu_is_open_60(80), menu_is_open_60(81), menu_is_open_60(82), menu_is_open_60(83), menu_is_open_60(84)>
  # want_open_6 = PHI <want_open_5(71), want_open_274(75), want_open_281(80), want_open_177(81), want_open_177(82), want_open_177(83), want_open_279(84)>
  # want_close_8 = PHI <want_close_7(71), want_close_272(75), want_close_178(80), want_close_178(81), want_close_178(82), want_close_178(83), want_close_178(84)>
  _282 = ~enabled_107(D);
  if (_282 != 0)
    goto <bb 86>;
  else
    goto <bb 87>;

  <bb 86>:
  want_close_283 = 1;

  <bb 87>:
  # want_close_9 = PHI <want_close_8(85), want_close_283(86)>
  if (want_close_9 != 0)
    goto <bb 88>;
  else
    goto <bb 90>;

  <bb 88>:
  _285 = ImGui::IsPopupOpen (id_56);
  _286 = _285;
  if (_286 != 0)
    goto <bb 89>;
  else
    goto <bb 90>;

  <bb 89>:
  iftmp.1779_287 = 1;
  goto <bb 91>;

  <bb 90>:
  iftmp.1779_288 = 0;

  <bb 91>:
  # iftmp.1779_21 = PHI <iftmp.1779_287(89), iftmp.1779_288(90)>
  retval.1778_289 = iftmp.1779_21;
  if (retval.1778_289 != 0)
    goto <bb 92>;
  else
    goto <bb 93>;

  <bb 92>:
  _290 = g_51->CurrentPopupStack.Size;
  ClosePopupToLevel (_290);

  <bb 93>:
  _292 = ~menu_is_open_2;
  if (_292 != 0)
    goto <bb 94>;
  else
    goto <bb 97>;

  <bb 94>:
  if (want_open_6 != 0)
    goto <bb 95>;
  else
    goto <bb 97>;

  <bb 95>:
  _293 = g_51->OpenPopupStack.Size;
  _294 = g_51->CurrentPopupStack.Size;
  if (_293 > _294)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  ImGui::OpenPopup (label_53(D));
  _296 = 0;
  goto <bb 105>;

  <bb 97>:
  menu_is_open_297 = menu_is_open_2 | want_open_6;
  if (want_open_6 != 0)
    goto <bb 98>;
  else
    goto <bb 99>;

  <bb 98>:
  ImGui::OpenPopup (label_53(D));

  <bb 99>:
  if (menu_is_open_297 != 0)
    goto <bb 100>;
  else
    goto <bb 104>;

  <bb 100>:
  ImVec2::ImVec2 (&D.20979, 0.0, 0.0);
  ImGui::SetNextWindowPos (&popup_pos, 1, &D.20979);
  D.20979 ={v} {CLOBBER};
  _302 = window_48->Flags;
  _303 = _302 & 335544320;
  if (_303 != 0)
    goto <bb 101>;
  else
    goto <bb 102>;

  <bb 101>:
  iftmp.1780_304 = 285212993;
  goto <bb 103>;

  <bb 102>:
  iftmp.1780_305 = 268435777;

  <bb 103>:
  # iftmp.1780_22 = PHI <iftmp.1780_304(101), iftmp.1780_305(102)>
  flags_306 = iftmp.1780_22;
  _308 = ImGui::BeginPopupEx (id_56, flags_306);
  menu_is_open_309 = _308;

  <bb 104>:
  # menu_is_open_3 = PHI <menu_is_open_297(99), menu_is_open_309(103)>
  _310 = menu_is_open_3;

  <bb 105>:
  # _12 = PHI <_50(3), _296(96), _310(104)>
  label_size ={v} {CLOBBER};
  popup_pos ={v} {CLOBBER};
  pos ={v} {CLOBBER};

<L126>:
  return _12;

}



;; Function void ImGui::EndMenu() (_ZN5ImGui7EndMenuEv, funcdef_no=1128, decl_uid=3216, cgraph_uid=1027, symbol_order=1038)

void ImGui::EndMenu() ()
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.41674;
  int D.41673;
  int D.41669;
  bool D.41667;
  int D.41665;
  struct ImGuiWindow * D.41663;
  struct ImGuiWindow * D.41662;
  struct ImGuiWindow * D.41660;
  bool iftmp.1782;
  bool retval.1781;
  bool iftmp.1782_1;
  struct ImGuiWindow * _8;
  struct ImGuiWindow * _9;
  struct ImGuiWindow * _10;
  int _11;
  bool _13;
  int _14;
  bool iftmp.1782_15;
  bool iftmp.1782_16;
  bool retval.1781_17;
  int _18;
  int _19;

  <bb 2>:
  g_6 = GImGui;
  window_7 = g_6->CurrentWindow;
  _8 = g_6->NavWindow;
  if (_8 != 0B)
    goto <bb 3>;
  else
    goto <bb 8>;

  <bb 3>:
  _9 = g_6->NavWindow;
  _10 = _9->ParentWindow;
  if (_10 == window_7)
    goto <bb 4>;
  else
    goto <bb 8>;

  <bb 4>:
  _11 = g_6->NavMoveDir;
  if (_11 == 0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  _13 = NavMoveRequestButNoResultYet ();
  if (_13 != 0)
    goto <bb 6>;
  else
    goto <bb 8>;

  <bb 6>:
  _14 = window_7->DC.LayoutType;
  if (_14 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1782_15 = 1;
  goto <bb 9>;

  <bb 8>:
  iftmp.1782_16 = 0;

  <bb 9>:
  # iftmp.1782_1 = PHI <iftmp.1782_15(7), iftmp.1782_16(8)>
  retval.1781_17 = iftmp.1782_1;
  if (retval.1781_17 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _18 = g_6->OpenPopupStack.Size;
  _19 = _18 + -1;
  ClosePopupToLevel (_19);
  ImGui::NavMoveRequestCancel ();

  <bb 11>:
  ImGui::EndPopup ();
  return;

}



;; Function void ImGui::ColorTooltip(const char*, const float*, ImGuiColorEditFlags) (_ZN5ImGui12ColorTooltipEPKcPKfi, funcdef_no=1129, decl_uid=14032, cgraph_uid=1028, symbol_order=1039)

void ImGui::ColorTooltip(const char*, const float*, ImGuiColorEditFlags) (const char * text, const float * col, ImGuiColorEditFlags flags)
{
  struct ImVec2 sz;
  const char * text_end;
  int ca;
  int cb;
  int cg;
  int cr;
  struct ImGuiContext & g;
  double D.41748;
  float D.41747;
  double D.41746;
  float D.41745;
  const float * D.41744;
  double D.41743;
  float D.41742;
  const float * D.41741;
  double D.41740;
  float D.41739;
  const float * D.41738;
  double D.41736;
  float D.41735;
  double D.41734;
  float D.41733;
  const float * D.41732;
  double D.41731;
  float D.41730;
  const float * D.41729;
  int D.41726;
  float D.41725;
  float D.41724;
  const float * D.41723;
  float D.41722;
  const float * D.41721;
  float D.41720;
  const float * D.41719;
  struct ImVec4 D.20997;
  int D.41718;
  int D.41717;
  float D.41716;
  float D.41715;
  float D.41714;
  float D.41713;
  float D.41712;
  float D.41711;
  float D.41710;
  float D.41709;
  float D.41708;
  float D.41707;
  const char * iftmp.1784;
  float D.41698;
  float D.41697;
  float D.41696;
  float D.41695;
  const float * D.41694;
  int D.41691;
  int iftmp.1783;
  float D.41689;
  float D.41688;
  float D.41687;
  float D.41686;
  const float * D.41685;
  float D.41684;
  float D.41683;
  float D.41682;
  float D.41681;
  const float * D.41680;
  float D.41679;
  float D.41678;
  float D.41677;
  float D.41676;
  int iftmp.1783_1;
  const char * iftmp.1784_2;
  float _11;
  float _13;
  float _14;
  float _15;
  const float * _17;
  float _18;
  float _20;
  float _21;
  float _22;
  const float * _24;
  float _25;
  float _27;
  float _28;
  float _29;
  int _32;
  const float * _33;
  float _34;
  float _36;
  float _37;
  float _38;
  int iftmp.1783_39;
  int iftmp.1783_40;
  const char * iftmp.1784_45;
  const char * iftmp.1784_46;
  float _50;
  float _51;
  float _52;
  float _53;
  float _54;
  float _55;
  float _56;
  float _57;
  float _58;
  float _59;
  int _61;
  int _62;
  const float * _63;
  float _64;
  const float * _65;
  float _66;
  const float * _67;
  float _68;
  float _69;
  int _74;
  const float * _75;
  float _76;
  double _77;
  const float * _78;
  float _79;
  double _80;
  float _81;
  double _82;
  const float * _84;
  float _85;
  double _86;
  const float * _87;
  float _88;
  double _89;
  const float * _90;
  float _91;
  double _92;
  float _93;
  double _94;

  <bb 2>:
  g_9 = GImGui;
  _11 = *col_10(D);
  _13 = ImSaturate (_11);
  _14 = _13 * 2.55e+2;
  _15 = _14 + 5.0e-1;
  cr_16 = (int) _15;
  _17 = col_10(D) + 4;
  _18 = *_17;
  _20 = ImSaturate (_18);
  _21 = _20 * 2.55e+2;
  _22 = _21 + 5.0e-1;
  cg_23 = (int) _22;
  _24 = col_10(D) + 8;
  _25 = *_24;
  _27 = ImSaturate (_25);
  _28 = _27 * 2.55e+2;
  _29 = _28 + 5.0e-1;
  cb_30 = (int) _29;
  _32 = flags_31(D) & 2;
  if (_32 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _33 = col_10(D) + 12;
  _34 = *_33;
  _36 = ImSaturate (_34);
  _37 = _36 * 2.55e+2;
  _38 = _37 + 5.0e-1;
  iftmp.1783_39 = (int) _38;
  goto <bb 5>;

  <bb 4>:
  iftmp.1783_40 = 255;

  <bb 5>:
  # iftmp.1783_1 = PHI <iftmp.1783_39(3), iftmp.1783_40(4)>
  ca_41 = iftmp.1783_1;
  ImGui::BeginTooltipEx (0, 1);
  if (text_43(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1784_45 = ImGui::FindRenderedTextEnd (text_43(D), 0B);
  goto <bb 8>;

  <bb 7>:
  iftmp.1784_46 = text_43(D);

  <bb 8>:
  # iftmp.1784_2 = PHI <iftmp.1784_45(6), iftmp.1784_46(7)>
  text_end_47 = iftmp.1784_2;
  if (text_end_47 > text_43(D))
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  ImGui::TextUnformatted (text_43(D), text_end_47);
  ImGui::Separator ();

  <bb 10>:
  _50 = g_9->FontSize;
  _51 = _50 * 3.0e+0;
  _52 = g_9->Style.FramePadding.y;
  _53 = _52 * 2.0e+0;
  _54 = _51 + _53;
  _55 = g_9->FontSize;
  _56 = _55 * 3.0e+0;
  _57 = g_9->Style.FramePadding.y;
  _58 = _57 * 2.0e+0;
  _59 = _56 + _58;
  ImVec2::ImVec2 (&sz, _59, _54);
  _61 = flags_31(D) & 3074;
  _62 = _61 | 64;
  _63 = col_10(D) + 12;
  _64 = *_63;
  _65 = col_10(D) + 8;
  _66 = *_65;
  _67 = col_10(D) + 4;
  _68 = *_67;
  _69 = *col_10(D);
  ImVec4::ImVec4 (&D.20997, _69, _68, _66, _64);
  ImGui::ColorButton ("##preview", &D.20997, _62, sz);
  D.20997 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  _74 = flags_31(D) & 2;
  if (_74 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _75 = col_10(D) + 8;
  _76 = *_75;
  _77 = (double) _76;
  _78 = col_10(D) + 4;
  _79 = *_78;
  _80 = (double) _79;
  _81 = *col_10(D);
  _82 = (double) _81;
  ImGui::Text ("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr_16, cg_23, cb_30, cr_16, cg_23, cb_30, _82, _80, _77);
  goto <bb 13>;

  <bb 12>:
  _84 = col_10(D) + 12;
  _85 = *_84;
  _86 = (double) _85;
  _87 = col_10(D) + 8;
  _88 = *_87;
  _89 = (double) _88;
  _90 = col_10(D) + 4;
  _91 = *_90;
  _92 = (double) _91;
  _93 = *col_10(D);
  _94 = (double) _93;
  ImGui::Text ("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr_16, cg_23, cb_30, ca_41, cr_16, cg_23, cb_30, ca_41, _94, _92, _89, _86);

  <bb 13>:
  ImGui::EndTooltip ();
  sz ={v} {CLOBBER};
  return;

}



;; Function ImU32 ImAlphaBlendColor(ImU32, ImU32) (_ZL17ImAlphaBlendColorjj, funcdef_no=1130, decl_uid=21001, cgraph_uid=1029, symbol_order=1040)

ImU32 ImAlphaBlendColor(ImU32, ImU32) (ImU32 col_a, ImU32 col_b)
{
  int b;
  int g;
  int r;
  float t;
  unsigned int D.41848;
  unsigned int r.1796;
  int r.1795;
  unsigned int D.41845;
  unsigned int D.41844;
  unsigned int g.1794;
  int g.1793;
  unsigned int D.41841;
  unsigned int b.1792;
  int b.1791;
  ImU32 D.41838;
  int b.1790;
  int D.41836;
  int D.41835;
  unsigned int D.41834;
  int D.41833;
  int D.41832;
  unsigned int D.41831;
  int g.1789;
  int D.41829;
  int D.41828;
  unsigned int D.41827;
  int D.41826;
  int D.41825;
  unsigned int D.41824;
  int r.1788;
  int D.41822;
  int col_a.1787;
  int D.41820;
  int col_b.1786;
  float D.41818;
  unsigned int D.41817;
  unsigned int _2;
  float _3;
  int col_b.1786_5;
  int _6;
  int col_a.1787_8;
  int _9;
  int r.1788_12;
  unsigned int _14;
  int _15;
  int _16;
  unsigned int _17;
  int _18;
  int _19;
  int g.1789_21;
  unsigned int _23;
  int _24;
  int _25;
  unsigned int _26;
  int _27;
  int _28;
  int b.1790_30;
  int b.1791_32;
  unsigned int b.1792_33;
  unsigned int _34;
  int g.1793_35;
  unsigned int g.1794_36;
  unsigned int _37;
  unsigned int _38;
  int r.1795_39;
  unsigned int r.1796_40;
  unsigned int _41;
  ImU32 _42;

  <bb 2>:
  _2 = col_b_1(D) >> 24;
  _3 = (float) _2;
  t_4 = _3 / 2.55e+2;
  col_b.1786_5 = (int) col_b_1(D);
  _6 = col_b.1786_5 & 255;
  col_a.1787_8 = (int) col_a_7(D);
  _9 = col_a.1787_8 & 255;
  r.1788_12 = ImLerp (_9, _6, t_4);
  r = r.1788_12;
  _14 = col_b_1(D) >> 8;
  _15 = (int) _14;
  _16 = _15 & 255;
  _17 = col_a_7(D) >> 8;
  _18 = (int) _17;
  _19 = _18 & 255;
  g.1789_21 = ImLerp (_19, _16, t_4);
  g = g.1789_21;
  _23 = col_b_1(D) >> 16;
  _24 = (int) _23;
  _25 = _24 & 255;
  _26 = col_a_7(D) >> 16;
  _27 = (int) _26;
  _28 = _27 & 255;
  b.1790_30 = ImLerp (_28, _25, t_4);
  b = b.1790_30;
  b.1791_32 = b;
  b.1792_33 = (unsigned int) b.1791_32;
  _34 = b.1792_33 << 16;
  g.1793_35 = g;
  g.1794_36 = (unsigned int) g.1793_35;
  _37 = g.1794_36 << 8;
  _38 = _34 | _37;
  r.1795_39 = r;
  r.1796_40 = (unsigned int) r.1795_39;
  _41 = _38 | r.1796_40;
  _42 = _41 | 4278190080;
  r ={v} {CLOBBER};
  g ={v} {CLOBBER};
  b ={v} {CLOBBER};

<L1>:
  return _42;

}



;; Function void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2, ImVec2, ImU32, float, ImVec2, float, int) (_ZN5ImGui36RenderColorRectWithAlphaCheckerboardE6ImVec2S0_jfS0_fi, funcdef_no=1131, decl_uid=13905, cgraph_uid=1030, symbol_order=1041)

void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2, ImVec2, ImU32, float, ImVec2, float, int) (struct ImVec2 p_min, struct ImVec2 p_max, ImU32 col, float grid_step, struct ImVec2 grid_off, float rounding, int rounding_corners_flags)
{
  int rounding_corners_flags_cell;
  float x2;
  float x1;
  float x;
  float y2;
  float y1;
  float y;
  int yi;
  ImU32 col_bg2;
  ImU32 col_bg1;
  struct ImGuiWindow * window;
  struct ImDrawList * D.41814;
  float D.41812;
  struct ImDrawList * D.41811;
  struct ImVec2 D.21027;
  struct ImVec2 D.21028;
  float iftmp.1785;
  float D.41802;
  float D.41798;
  float D.41795;
  float D.41790;
  float D.41786;
  float D.41783;
  float D.41780;
  float D.41779;
  float D.41778;
  float D.41777;
  float D.41775;
  float D.41773;
  float D.41772;
  int D.41771;
  float D.41770;
  float D.41769;
  float D.41768;
  float D.41765;
  float D.41764;
  float D.41763;
  float D.41762;
  float D.41760;
  float D.41758;
  float D.41757;
  struct ImDrawList * D.41756;
  unsigned int D.41755;
  unsigned int D.41754;
  unsigned int D.41751;
  float iftmp.1785_8;
  unsigned int _18;
  unsigned int _20;
  unsigned int _24;
  struct ImDrawList * _27;
  float _32;
  float _33;
  float _35;
  float _36;
  float _37;
  float _40;
  float _42;
  float _45;
  float _46;
  float _47;
  int _48;
  float _49;
  float _50;
  float _52;
  float _53;
  float _54;
  float _57;
  float _58;
  float _62;
  float _63;
  float _65;
  float _67;
  float _68;
  float _70;
  float iftmp.1785_73;
  float iftmp.1785_74;
  struct ImDrawList * _77;
  float _83;
  struct ImDrawList * _87;

  <bb 2>:
  window_16 = ImGui::GetCurrentWindow ();
  _18 = col_17(D) >> 24;
  if (_18 <= 254)
    goto <bb 3>;
  else
    goto <bb 28>;

  <bb 3>:
  _20 = ImAlphaBlendColor (4291611852, col_17(D));
  col_bg1_22 = ImGui::GetColorU32 (_20);
  _24 = ImAlphaBlendColor (4286611584, col_17(D));
  col_bg2_26 = ImGui::GetColorU32 (_24);
  _27 = window_16->DrawList;
  ImDrawList::AddRectFilled (_27, &p_min, &p_max, col_bg1_22, rounding_28(D), rounding_corners_flags_29(D));
  yi_31 = 0;
  _32 = p_min.y;
  _33 = grid_off.y;
  y_34 = _32 + _33;

  <bb 4>:
  # yi_1 = PHI <yi_31(3), yi_86(26)>
  # y_2 = PHI <y_34(3), y_85(26)>
  _35 = p_max.y;
  if (_35 > y_2)
    goto <bb 5>;
  else
    goto <bb 27>;

  <bb 5>:
  _36 = p_max.y;
  _37 = p_min.y;
  y1_39 = ImClamp (y_2, _37, _36);
  _40 = p_max.y;
  _42 = y_2 + grid_step_41(D);
  y2_44 = ImMin (_42, _40);
  if (y2_44 <= y1_39)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  goto <bb 26>;

  <bb 7>:
  _45 = p_min.x;
  _46 = grid_off.x;
  _47 = _45 + _46;
  _48 = yi_1 & 1;
  _49 = (float) _48;
  _50 = _49 * grid_step_41(D);
  x_51 = _47 + _50;

  <bb 8>:
  # x_3 = PHI <x_51(7), x_84(25)>
  _52 = p_max.x;
  if (_52 > x_3)
    goto <bb 9>;
  else
    goto <bb 26>;

  <bb 9>:
  _53 = p_max.x;
  _54 = p_min.x;
  x1_56 = ImClamp (x_3, _54, _53);
  _57 = p_max.x;
  _58 = x_3 + grid_step_41(D);
  x2_60 = ImMin (_58, _57);
  if (x2_60 <= x1_56)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 25>;

  <bb 11>:
  rounding_corners_flags_cell_61 = 0;
  _62 = p_min.y;
  if (_62 >= y1_39)
    goto <bb 12>;
  else
    goto <bb 16>;

  <bb 12>:
  _63 = p_min.x;
  if (_63 >= x1_56)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  rounding_corners_flags_cell_64 = rounding_corners_flags_cell_61 | 1;

  <bb 14>:
  # rounding_corners_flags_cell_4 = PHI <rounding_corners_flags_cell_61(12), rounding_corners_flags_cell_64(13)>
  _65 = p_max.x;
  if (_65 <= x2_60)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  rounding_corners_flags_cell_66 = rounding_corners_flags_cell_4 | 2;

  <bb 16>:
  # rounding_corners_flags_cell_5 = PHI <rounding_corners_flags_cell_61(11), rounding_corners_flags_cell_66(15), rounding_corners_flags_cell_4(14)>
  _67 = p_max.y;
  if (_67 <= y2_44)
    goto <bb 17>;
  else
    goto <bb 21>;

  <bb 17>:
  _68 = p_min.x;
  if (_68 >= x1_56)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  rounding_corners_flags_cell_69 = rounding_corners_flags_cell_5 | 4;

  <bb 19>:
  # rounding_corners_flags_cell_6 = PHI <rounding_corners_flags_cell_5(17), rounding_corners_flags_cell_69(18)>
  _70 = p_max.x;
  if (_70 <= x2_60)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  rounding_corners_flags_cell_71 = rounding_corners_flags_cell_6 | 8;

  <bb 21>:
  # rounding_corners_flags_cell_7 = PHI <rounding_corners_flags_cell_5(16), rounding_corners_flags_cell_71(20), rounding_corners_flags_cell_6(19)>
  rounding_corners_flags_cell_72 = rounding_corners_flags_cell_7 & rounding_corners_flags_29(D);
  if (rounding_corners_flags_cell_72 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  iftmp.1785_73 = rounding_28(D);
  goto <bb 24>;

  <bb 23>:
  iftmp.1785_74 = 0.0;

  <bb 24>:
  # iftmp.1785_8 = PHI <iftmp.1785_73(22), iftmp.1785_74(23)>
  ImVec2::ImVec2 (&D.21028, x2_60, y2_44);
  ImVec2::ImVec2 (&D.21027, x1_56, y1_39);
  _77 = window_16->DrawList;
  ImDrawList::AddRectFilled (_77, &D.21027, &D.21028, col_bg2_26, iftmp.1785_8, rounding_corners_flags_cell_72);
  D.21027 ={v} {CLOBBER};
  D.21028 ={v} {CLOBBER};

  <bb 25>:
  _83 = grid_step_41(D) * 2.0e+0;
  x_84 = _83 + x_3;
  goto <bb 8>;

  <bb 26>:
  y_85 = y_2 + grid_step_41(D);
  yi_86 = yi_1 + 1;
  goto <bb 4>;

  <bb 27>:
  goto <bb 29>;

  <bb 28>:
  _87 = window_16->DrawList;
  ImDrawList::AddRectFilled (_87, &p_min, &p_max, col_17(D), rounding_28(D), rounding_corners_flags_29(D));

  <bb 29>:
  return;

}



;; Function void ImGui::SetColorEditOptions(ImGuiColorEditFlags) (_ZN5ImGui19SetColorEditOptionsEi, funcdef_no=1132, decl_uid=3097, cgraph_uid=1031, symbol_order=1042)

void ImGui::SetColorEditOptions(ImGuiColorEditFlags) (ImGuiColorEditFlags flags)
{
  static const char __PRETTY_FUNCTION__[53] = "void ImGui::SetColorEditOptions(ImGuiColorEditFlags)";
  struct ImGuiContext & g;
  bool D.41881;
  int D.41880;
  bool D.41876;
  int D.41875;
  bool D.41871;
  int D.41870;
  int D.41866;
  int D.41862;
  int D.41858;
  int _7;
  int _9;
  int _11;
  int _13;
  bool _15;
  int _16;
  bool _18;
  int _19;
  bool _21;

  <bb 2>:
  g_5 = GImGui;
  _7 = flags_6(D) & 57344;
  if (_7 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  flags_8 = flags_6(D) | 8192;

  <bb 4>:
  # flags_1 = PHI <flags_6(D)(2), flags_8(3)>
  _9 = flags_1 & 196608;
  if (_9 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  flags_10 = flags_1 | 65536;

  <bb 6>:
  # flags_2 = PHI <flags_1(4), flags_10(5)>
  _11 = flags_2 & 786432;
  if (_11 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  flags_12 = flags_2 | 262144;

  <bb 8>:
  # flags_3 = PHI <flags_2(6), flags_12(7)>
  _13 = flags_3 & 57344;
  _15 = ImIsPowerOfTwo (_13);
  if (_15 != 0)
    goto <bb 10>;
  else
    goto <bb 9>;

  <bb 9>:
  __assert_fail ("ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11451, &__PRETTY_FUNCTION__);

  <bb 10>:
  _16 = flags_3 & 196608;
  _18 = ImIsPowerOfTwo (_16);
  if (_18 != 0)
    goto <bb 12>;
  else
    goto <bb 11>;

  <bb 11>:
  __assert_fail ("ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11452, &__PRETTY_FUNCTION__);

  <bb 12>:
  _19 = flags_3 & 786432;
  _21 = ImIsPowerOfTwo (_19);
  if (_21 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  __assert_fail ("ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11453, &__PRETTY_FUNCTION__);

  <bb 14>:
  g_5->ColorEditOptions = flags_3;
  return;

}



;; Function bool ImGui::ColorButton(const char*, const ImVec4&, ImGuiColorEditFlags, ImVec2) (_ZN5ImGui11ColorButtonEPKcRK6ImVec4i6ImVec2, funcdef_no=1133, decl_uid=3095, cgraph_uid=1032, symbol_order=1043)

bool ImGui::ColorButton(const char*, const ImVec4&, ImGuiColorEditFlags, ImVec2) (const char * desc_id, const struct ImVec4 & col, ImGuiColorEditFlags flags, struct ImVec2 size)
{
  bool D.41991;
  bool D.41985;
  bool D.41984;
  const ImGuiID D.41983;
  struct ImVec4 col_source;
  float mid_x;
  float off;
  struct ImRect bb_inner;
  float rounding;
  float grid_step;
  struct ImVec4 col_without_alpha;
  bool pressed;
  bool held;
  bool hovered;
  const struct ImRect bb;
  float default_size;
  const ImGuiID id;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  const float * D.41980;
  int D.41979;
  bool hovered.1802;
  int D.41973;
  struct ImVec2 D.21071;
  int D.41968;
  bool D.41964;
  unsigned int D.41962;
  bool iftmp.1801;
  bool retval.1800;
  struct ImDrawList * D.41957;
  unsigned int D.41956;
  float D.41952;
  struct ImDrawList * D.41951;
  unsigned int D.41950;
  unsigned int D.41948;
  struct ImVec2 D.21066;
  float D.41945;
  int D.41941;
  const struct ImVec4 & iftmp.1799;
  struct ImDrawList * D.41939;
  float D.41938;
  struct ImVec2 D.21063;
  unsigned int D.41937;
  float D.41936;
  float D.41935;
  float D.41934;
  struct ImVec2 D.21060;
  unsigned int D.41933;
  float D.41932;
  struct ImVec2 D.21061;
  int D.41931;
  float D.41930;
  float D.41929;
  float D.41928;
  float D.41927;
  float D.41926;
  float D.41924;
  int D.41922;
  float D.41919;
  float D.41918;
  float D.41917;
  float D.41916;
  float D.41915;
  float D.41914;
  float D.41913;
  float D.41912;
  int D.41908;
  bool D.41905;
  bool retval.1798;
  float D.41900;
  float iftmp.1797;
  struct ImVec2 * D.41898;
  struct ImVec2 * D.41897;
  struct ImVec2 D.21049;
  float D.41893;
  float D.41889;
  bool D.41888;
  bool D.41885;
  bool _2;
  float iftmp.1797_3;
  const struct ImVec4 & iftmp.1799_4;
  bool iftmp.1801_5;
  bool _22;
  bool _23;
  const ImGuiID _27;
  float _31;
  float _33;
  struct ImVec2 * _35;
  struct ImVec2 * _37;
  float _40;
  float iftmp.1797_41;
  float iftmp.1797_42;
  bool _45;
  bool _46;
  bool retval.1798_47;
  bool _48;
  bool _50;
  int _53;
  float _56;
  float _57;
  float _58;
  float _60;
  float _61;
  float _63;
  float _65;
  float _66;
  int _72;
  float _73;
  float _74;
  float _75;
  float _76;
  float _77;
  float _78;
  int _79;
  float _81;
  unsigned int _84;
  float _85;
  float _86;
  float _87;
  unsigned int _93;
  float _94;
  struct ImDrawList * _96;
  int _102;
  const struct ImVec4 & iftmp.1799_103;
  const struct ImVec4 & iftmp.1799_104;
  float _106;
  unsigned int _109;
  unsigned int _114;
  struct ImDrawList * _115;
  float _120;
  unsigned int _123;
  struct ImDrawList * _124;
  unsigned int _126;
  bool _128;
  bool _129;
  bool iftmp.1801_130;
  bool iftmp.1801_131;
  bool retval.1800_132;
  int _133;
  int _144;
  bool hovered.1802_145;
  int _146;
  const float * _147;
  bool _149;

  <bb 2>:
  window_21 = ImGui::GetCurrentWindow ();
  _22 = window_21->SkipItems;
  if (_22 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _23 = 0;
  goto <bb 41>;

  <bb 4>:
  g_24 = GImGui;
  _27 = ImGuiWindow::GetID (window_21, desc_id_25(D), 0B);
  id_28 = _27;
  default_size_30 = ImGui::GetFrameHeight ();
  _31 = size.x;
  if (_31 == 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  size.x = default_size_30;

  <bb 6>:
  _33 = size.y;
  if (_33 == 0.0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  size.y = default_size_30;

  <bb 8>:
  _35 = &window_21->DC.CursorPos;
  D.21049 = operator+ (_35, &size);
  _37 = &window_21->DC.CursorPos;
  ImRect::ImRect (&bb, _37, &D.21049);
  D.21049 ={v} {CLOBBER};
  _40 = size.y;
  if (_40 >= default_size_30)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1797_41 = g_24->Style.FramePadding.y;
  goto <bb 11>;

  <bb 10>:
  iftmp.1797_42 = 0.0;

  <bb 11>:
  # iftmp.1797_3 = PHI <iftmp.1797_41(9), iftmp.1797_42(10)>
  ImGui::ItemSize (&bb, iftmp.1797_3);
  _45 = ImGui::ItemAdd (&bb, id_28, 0B);
  _46 = _45;
  retval.1798_47 = ~_46;
  if (retval.1798_47 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  _48 = 0;
  goto <bb 41>;

  <bb 13>:
  _50 = ImGui::ButtonBehavior (&bb, id_28, &hovered, &held, 0);
  pressed_51 = _50;
  _53 = flags_52(D) & 2;
  if (_53 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  flags_54 = flags_52(D) & -3073;

  <bb 15>:
  # flags_1 = PHI <flags_52(D)(13), flags_54(14)>
  _56 = col_55(D)->z;
  _57 = col_55(D)->y;
  _58 = col_55(D)->x;
  ImVec4::ImVec4 (&col_without_alpha, _58, _57, _56, 1.0e+0);
  _60 = size.y;
  _61 = size.x;
  _63 = ImMin (_61, _60);
  grid_step_64 = _63 / 2.9900000095367431640625e+0;
  _65 = grid_step_64 * 5.0e-1;
  _66 = g_24->Style.FrameRounding;
  rounding_68 = ImMin (_66, _65);
  bb_inner = bb;
  off_70 = -7.5e-1;
  ImRect::Expand (&bb_inner, off_70);
  _72 = flags_1 & 2048;
  if (_72 != 0)
    goto <bb 16>;
  else
    goto <bb 18>;

  <bb 16>:
  _73 = col_55(D)->w;
  if (_73 < 1.0e+0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _74 = bb_inner.Min.x;
  _75 = bb_inner.Max.x;
  _76 = _74 + _75;
  _77 = _76 * 5.0e-1;
  _78 = _77 + 5.0e-1;
  _79 = (int) _78;
  mid_x_80 = (float) _79;
  _81 = off_70 - grid_step_64;
  ImVec2::ImVec2 (&D.21061, _81, off_70);
  _84 = ImGui::GetColorU32 (col_55(D));
  _85 = bb_inner.Min.y;
  _86 = bb_inner.Min.x;
  _87 = _86 + grid_step_64;
  ImVec2::ImVec2 (&D.21060, _87, _85);
  ImGui::RenderColorRectWithAlphaCheckerboard (D.21060, bb_inner.Max, _84, grid_step_64, D.21061, rounding_68, 10);
  D.21060 ={v} {CLOBBER};
  D.21061 ={v} {CLOBBER};
  _93 = ImGui::GetColorU32 (&col_without_alpha);
  _94 = bb_inner.Max.y;
  ImVec2::ImVec2 (&D.21063, mid_x_80, _94);
  _96 = window_21->DrawList;
  ImDrawList::AddRectFilled (_96, &bb_inner.Min, &D.21063, _93, rounding_68, 5);
  D.21063 ={v} {CLOBBER};
  goto <bb 25>;

  <bb 18>:
  _102 = flags_1 & 1024;
  if (_102 == 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  iftmp.1799_103 = &col_without_alpha;
  goto <bb 21>;

  <bb 20>:
  iftmp.1799_104 = col_55(D);

  <bb 21>:
  # iftmp.1799_4 = PHI <iftmp.1799_103(19), iftmp.1799_104(20)>
  col_source = *iftmp.1799_4;
  _106 = col_source.w;
  if (_106 < 1.0e+0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  ImVec2::ImVec2 (&D.21066, off_70, off_70);
  _109 = ImGui::GetColorU32 (&col_source);
  ImGui::RenderColorRectWithAlphaCheckerboard (bb_inner.Min, bb_inner.Max, _109, grid_step_64, D.21066, rounding_68, -1);
  D.21066 ={v} {CLOBBER};
  goto <bb 24>;

  <bb 23>:
  _114 = ImGui::GetColorU32 (&col_source);
  _115 = window_21->DrawList;
  ImDrawList::AddRectFilled (_115, &bb_inner.Min, &bb_inner.Max, _114, rounding_68, 15);

  <bb 24>:
  col_source ={v} {CLOBBER};

  <bb 25>:
  ImGui::RenderNavHighlight (&bb, id_28, 1);
  _120 = g_24->Style.FrameBorderSize;
  if (_120 > 0.0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  ImGui::RenderFrameBorder (bb.Min, bb.Max, rounding_68);
  goto <bb 28>;

  <bb 27>:
  _123 = ImGui::GetColorU32 (7, 1.0e+0);
  _124 = window_21->DrawList;
  ImDrawList::AddRect (_124, &bb.Min, &bb.Max, _123, rounding_68, 15, 1.0e+0);

  <bb 28>:
  _126 = g_24->ActiveId;
  if (_126 == id_28)
    goto <bb 29>;
  else
    goto <bb 31>;

  <bb 29>:
  _128 = ImGui::BeginDragDropSource (0);
  _129 = _128;
  if (_129 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  iftmp.1801_130 = 1;
  goto <bb 32>;

  <bb 31>:
  iftmp.1801_131 = 0;

  <bb 32>:
  # iftmp.1801_5 = PHI <iftmp.1801_130(30), iftmp.1801_131(31)>
  retval.1800_132 = iftmp.1801_5;
  if (retval.1800_132 != 0)
    goto <bb 33>;
  else
    goto <bb 37>;

  <bb 33>:
  _133 = flags_1 & 2;
  if (_133 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  ImGui::SetDragDropPayload ("_COL3F", col_55(D), 12, 2);
  goto <bb 36>;

  <bb 35>:
  ImGui::SetDragDropPayload ("_COL4F", col_55(D), 16, 2);

  <bb 36>:
  ImVec2::ImVec2 (&D.21071, 0.0, 0.0);
  ImGui::ColorButton (desc_id_25(D), col_55(D), flags_1, D.21071);
  D.21071 ={v} {CLOBBER};
  ImGui::SameLine (0.0, -1.0e+0);
  ImGui::TextUnformatted ("Color", 0B);
  ImGui::EndDragDropSource ();
  hovered = 0;

  <bb 37>:
  _144 = flags_1 & 64;
  if (_144 == 0)
    goto <bb 38>;
  else
    goto <bb 40>;

  <bb 38>:
  hovered.1802_145 = hovered;
  if (hovered.1802_145 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _146 = flags_1 & 3074;
  _147 = &col_55(D)->x;
  ImGui::ColorTooltip (desc_id_25(D), _147, _146);

  <bb 40>:
  _149 = pressed_51;

  <bb 41>:
  # _2 = PHI <_23(3), _48(12), _149(40)>
  bb ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  col_without_alpha ={v} {CLOBBER};
  bb_inner ={v} {CLOBBER};

<L45>:
  return _2;

}



;; Function bool ImGui::ColorEdit3(const char*, float*, ImGuiColorEditFlags) (_ZN5ImGui10ColorEdit3EPKcPfi, funcdef_no=1134, decl_uid=3076, cgraph_uid=1033, symbol_order=1044)

bool ImGui::ColorEdit3(const char*, float*, ImGuiColorEditFlags) (const char * label, float * col, ImGuiColorEditFlags flags)
{
  bool D.41998;
  int D.41996;
  bool D.41995;
  int _2;
  bool _7;
  bool _8;

  <bb 2>:
  _2 = flags_1(D) | 2;
  _7 = ImGui::ColorEdit4 (label_4(D), col_5(D), _2);
  _8 = _7;

<L0>:
  return _8;

}



;; Function void ImGui::ColorEditOptionsPopup(const float*, ImGuiColorEditFlags) (_ZN5ImGui21ColorEditOptionsPopupEPKfi, funcdef_no=1135, decl_uid=14035, cgraph_uid=1034, symbol_order=1045)

void ImGui::ColorEditOptionsPopup(const float*, ImGuiColorEditFlags) (const float * col, ImGuiColorEditFlags flags)
{
  bool D.42143;
  bool D.42141;
  bool D.42139;
  bool D.42138;
  bool D.42136;
  bool D.42135;
  bool D.42134;
  bool D.42133;
  bool D.42132;
  bool D.42131;
  bool D.42130;
  char buf[64];
  int ca;
  int cb;
  int cg;
  int cr;
  ImGuiColorEditFlags opts;
  struct ImGuiContext & g;
  bool allow_opt_datatype;
  bool allow_opt_inputs;
  struct ImVec2 D.21093;
  bool retval.1816;
  int D.42120;
  struct ImVec2 D.21092;
  bool retval.1815;
  struct ImVec2 D.21091;
  bool retval.1814;
  double D.42111;
  float D.42110;
  double D.42109;
  float D.42108;
  const float * D.42107;
  double D.42106;
  float D.42105;
  const float * D.42104;
  float D.42102;
  const float * D.42101;
  int D.42098;
  double iftmp.1813;
  float D.42095;
  float D.42094;
  float D.42093;
  float D.42092;
  const float * D.42091;
  int D.42088;
  int iftmp.1812;
  float D.42086;
  float D.42085;
  float D.42084;
  float D.42083;
  const float * D.42082;
  float D.42081;
  float D.42080;
  float D.42079;
  float D.42078;
  const float * D.42077;
  float D.42076;
  float D.42075;
  float D.42074;
  float D.42073;
  bool retval.1811;
  struct ImVec2 D.21085;
  bool retval.1810;
  int D.42060;
  int D.42057;
  bool D.42056;
  int D.42055;
  bool retval.1809;
  int D.42052;
  int D.42049;
  bool D.42048;
  int D.42047;
  bool retval.1808;
  int D.42038;
  int D.42035;
  bool D.42034;
  int D.42033;
  bool retval.1807;
  int D.42030;
  int D.42027;
  bool D.42026;
  int D.42025;
  bool retval.1806;
  int D.42022;
  int D.42019;
  bool D.42018;
  int D.42017;
  bool retval.1805;
  bool D.42011;
  bool D.42010;
  bool D.42009;
  bool D.42007;
  bool iftmp.1804;
  bool retval.1803;
  int D.42000;
  int D.41999;
  bool iftmp.1804_6;
  int iftmp.1812_7;
  double iftmp.1813_8;
  int _25;
  int _27;
  bool _29;
  bool _30;
  bool _33;
  bool _34;
  bool _35;
  bool iftmp.1804_36;
  bool iftmp.1804_37;
  bool retval.1803_38;
  int _41;
  bool _42;
  int _43;
  bool _45;
  bool retval.1805_46;
  int _47;
  int _49;
  bool _50;
  int _51;
  bool _53;
  bool retval.1806_54;
  int _55;
  int _57;
  bool _58;
  int _59;
  bool _61;
  bool retval.1807_62;
  int _63;
  int _66;
  bool _67;
  int _68;
  bool _70;
  bool retval.1808_71;
  int _72;
  int _74;
  bool _75;
  int _76;
  bool _78;
  bool retval.1809_79;
  int _80;
  bool _85;
  bool retval.1810_86;
  bool _90;
  bool retval.1811_91;
  float _93;
  float _95;
  float _96;
  float _97;
  const float * _99;
  float _100;
  float _102;
  float _103;
  float _104;
  const float * _106;
  float _107;
  float _109;
  float _110;
  float _111;
  int _113;
  const float * _114;
  float _115;
  float _117;
  float _118;
  float _119;
  int iftmp.1812_120;
  int iftmp.1812_121;
  int _123;
  const float * _124;
  float _125;
  double iftmp.1813_126;
  double iftmp.1813_127;
  const float * _128;
  float _129;
  double _130;
  const float * _131;
  float _132;
  double _133;
  float _134;
  double _135;
  bool _139;
  bool retval.1814_140;
  bool _146;
  bool retval.1815_147;
  int _150;
  bool _155;
  bool retval.1816_156;

  <bb 2>:
  _25 = flags_24(D) & 57344;
  allow_opt_inputs_26 = _25 == 0;
  _27 = flags_24(D) & 196608;
  allow_opt_datatype_28 = _27 == 0;
  _29 = ~allow_opt_inputs_26;
  if (_29 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _30 = ~allow_opt_datatype_28;
  if (_30 != 0)
    goto <bb 5>;
  else
    goto <bb 4>;

  <bb 4>:
  _33 = ImGui::BeginPopup ("context", 0);
  _34 = _33;
  _35 = ~_34;
  if (_35 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1804_37 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.1804_36 = 0;

  <bb 7>:
  # iftmp.1804_6 = PHI <iftmp.1804_37(5), iftmp.1804_36(6)>
  retval.1803_38 = iftmp.1804_6;
  if (retval.1803_38 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  goto <bb 46> (<L58>);

  <bb 9>:
  g_39 = GImGui;
  opts_40 = g_39->ColorEditOptions;
  if (allow_opt_inputs_26 != 0)
    goto <bb 10>;
  else
    goto <bb 16>;

  <bb 10>:
  _41 = opts_40 & 8192;
  _42 = _41 != 0;
  _43 = (int) _42;
  _45 = ImGui::RadioButton ("RGB", _43);
  retval.1805_46 = _45;
  if (retval.1805_46 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _47 = opts_40 & -57345;
  opts_48 = _47 | 8192;

  <bb 12>:
  # opts_1 = PHI <opts_40(10), opts_48(11)>
  _49 = opts_1 & 16384;
  _50 = _49 != 0;
  _51 = (int) _50;
  _53 = ImGui::RadioButton ("HSV", _51);
  retval.1806_54 = _53;
  if (retval.1806_54 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _55 = opts_1 & -57345;
  opts_56 = _55 | 16384;

  <bb 14>:
  # opts_2 = PHI <opts_1(12), opts_56(13)>
  _57 = opts_2 & 32768;
  _58 = _57 != 0;
  _59 = (int) _58;
  _61 = ImGui::RadioButton ("HEX", _59);
  retval.1807_62 = _61;
  if (retval.1807_62 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _63 = opts_2 & -57345;
  opts_64 = _63 | 32768;

  <bb 16>:
  # opts_3 = PHI <opts_40(9), opts_64(15), opts_2(14)>
  if (allow_opt_datatype_28 != 0)
    goto <bb 17>;
  else
    goto <bb 23>;

  <bb 17>:
  if (allow_opt_inputs_26 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  ImGui::Separator ();

  <bb 19>:
  _66 = opts_3 & 65536;
  _67 = _66 != 0;
  _68 = (int) _67;
  _70 = ImGui::RadioButton ("0..255", _68);
  retval.1808_71 = _70;
  if (retval.1808_71 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  _72 = opts_3 & -196609;
  opts_73 = _72 | 65536;

  <bb 21>:
  # opts_4 = PHI <opts_3(19), opts_73(20)>
  _74 = opts_4 & 131072;
  _75 = _74 != 0;
  _76 = (int) _75;
  _78 = ImGui::RadioButton ("0.00..1.00", _76);
  retval.1809_79 = _78;
  if (retval.1809_79 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  _80 = opts_4 & -196609;
  opts_81 = _80 | 131072;

  <bb 23>:
  # opts_5 = PHI <opts_3(16), opts_81(22), opts_4(21)>
  if (allow_opt_inputs_26 != 0)
    goto <bb 25>;
  else
    goto <bb 24>;

  <bb 24>:
  if (allow_opt_datatype_28 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  ImGui::Separator ();

  <bb 26>:
  ImVec2::ImVec2 (&D.21085, -1.0e+0, 0.0);
  _85 = ImGui::Button ("Copy as..", &D.21085);
  retval.1810_86 = _85;
  D.21085 ={v} {CLOBBER};
  if (retval.1810_86 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  ImGui::OpenPopup ("Copy");

  <bb 28>:
  _90 = ImGui::BeginPopup ("Copy", 0);
  retval.1811_91 = _90;
  if (retval.1811_91 != 0)
    goto <bb 29>;
  else
    goto <bb 45>;

  <bb 29>:
  _93 = *col_92(D);
  _95 = ImSaturate (_93);
  _96 = _95 * 2.55e+2;
  _97 = _96 + 5.0e-1;
  cr_98 = (int) _97;
  _99 = col_92(D) + 4;
  _100 = *_99;
  _102 = ImSaturate (_100);
  _103 = _102 * 2.55e+2;
  _104 = _103 + 5.0e-1;
  cg_105 = (int) _104;
  _106 = col_92(D) + 8;
  _107 = *_106;
  _109 = ImSaturate (_107);
  _110 = _109 * 2.55e+2;
  _111 = _110 + 5.0e-1;
  cb_112 = (int) _111;
  _113 = flags_24(D) & 2;
  if (_113 == 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _114 = col_92(D) + 12;
  _115 = *_114;
  _117 = ImSaturate (_115);
  _118 = _117 * 2.55e+2;
  _119 = _118 + 5.0e-1;
  iftmp.1812_120 = (int) _119;
  goto <bb 32>;

  <bb 31>:
  iftmp.1812_121 = 255;

  <bb 32>:
  # iftmp.1812_7 = PHI <iftmp.1812_120(30), iftmp.1812_121(31)>
  ca_122 = iftmp.1812_7;
  _123 = flags_24(D) & 2;
  if (_123 == 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _124 = col_92(D) + 12;
  _125 = *_124;
  iftmp.1813_126 = (double) _125;
  goto <bb 35>;

  <bb 34>:
  iftmp.1813_127 = 1.0e+0;

  <bb 35>:
  # iftmp.1813_8 = PHI <iftmp.1813_126(33), iftmp.1813_127(34)>
  _128 = col_92(D) + 8;
  _129 = *_128;
  _130 = (double) _129;
  _131 = col_92(D) + 4;
  _132 = *_131;
  _133 = (double) _132;
  _134 = *col_92(D);
  _135 = (double) _134;
  ImFormatString (&buf, 64, "(%.3ff, %.3ff, %.3ff, %.3ff)", _135, _133, _130, iftmp.1813_8);
  ImVec2::ImVec2 (&D.21091, 0.0, 0.0);
  _139 = ImGui::Selectable (&buf, 0, 0, &D.21091);
  retval.1814_140 = _139;
  D.21091 ={v} {CLOBBER};
  if (retval.1814_140 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  ImGui::SetClipboardText (&buf);

  <bb 37>:
  ImFormatString (&buf, 64, "(%d,%d,%d,%d)", cr_98, cg_105, cb_112, ca_122);
  ImVec2::ImVec2 (&D.21092, 0.0, 0.0);
  _146 = ImGui::Selectable (&buf, 0, 0, &D.21092);
  retval.1815_147 = _146;
  D.21092 ={v} {CLOBBER};
  if (retval.1815_147 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  ImGui::SetClipboardText (&buf);

  <bb 39>:
  _150 = flags_24(D) & 2;
  if (_150 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  ImFormatString (&buf, 64, "0x%02X%02X%02X", cr_98, cg_105, cb_112);
  goto <bb 42>;

  <bb 41>:
  ImFormatString (&buf, 64, "0x%02X%02X%02X%02X", cr_98, cg_105, cb_112, ca_122);

  <bb 42>:
  ImVec2::ImVec2 (&D.21093, 0.0, 0.0);
  _155 = ImGui::Selectable (&buf, 0, 0, &D.21093);
  retval.1816_156 = _155;
  D.21093 ={v} {CLOBBER};
  if (retval.1816_156 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  ImGui::SetClipboardText (&buf);

  <bb 44>:
  ImGui::EndPopup ();
  buf ={v} {CLOBBER};

  <bb 45>:
  g_39->ColorEditOptions = opts_5;
  ImGui::EndPopup ();

<L58>:
  return;

}



;; Function void ColorPickerOptionsPopup(ImGuiColorEditFlags, const float*) (_ZL23ColorPickerOptionsPopupiPKf, funcdef_no=1136, decl_uid=21096, cgraph_uid=1035, symbol_order=1046)

void ColorPickerOptionsPopup(ImGuiColorEditFlags, const float*) (ImGuiColorEditFlags flags, const float * ref_col)
{
  bool D.42214;
  bool D.42213;
  struct ImVec4 dummy_ref_col;
  struct ImVec2 backup_pos;
  ImGuiColorEditFlags picker_flags;
  int picker_type;
  struct ImVec2 picker_size;
  struct ImGuiContext & g;
  bool allow_opt_alpha_bar;
  bool allow_opt_picker;
  ImGuiColorEditFlags * D.42210;
  int D.42200;
  long unsigned int iftmp.1821;
  int D.42197;
  int D.42196;
  int D.42195;
  int D.42194;
  bool retval.1820;
  int D.42184;
  float D.42178;
  float D.42177;
  float D.42176;
  float D.42175;
  float D.42174;
  float D.42173;
  float D.42172;
  float D.42171;
  float D.42170;
  float D.42169;
  bool D.42164;
  bool D.42163;
  bool D.42162;
  bool D.42160;
  bool iftmp.1819;
  bool retval.1818;
  int D.42152;
  int D.42150;
  bool iftmp.1817;
  int D.42146;
  bool iftmp.1817_4;
  bool iftmp.1819_5;
  long unsigned int iftmp.1821_6;
  int _19;
  int _21;
  int _22;
  bool iftmp.1817_23;
  bool iftmp.1817_24;
  bool _26;
  bool _27;
  bool _30;
  bool _31;
  bool _32;
  bool iftmp.1819_33;
  bool iftmp.1819_34;
  bool retval.1818_35;
  float _37;
  float _38;
  float _40;
  float _41;
  float _42;
  float _43;
  float _45;
  float _46;
  float _47;
  float _49;
  int _54;
  bool _60;
  bool retval.1820_61;
  int _62;
  int _63;
  int _64;
  int _65;
  int _69;
  long unsigned int iftmp.1821_70;
  long unsigned int iftmp.1821_71;
  ImGuiColorEditFlags * _85;

  <bb 2>:
  _19 = flags_18(D) & 786432;
  allow_opt_picker_20 = _19 == 0;
  _21 = flags_18(D) & 2;
  if (_21 == 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _22 = flags_18(D) & 512;
  if (_22 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1817_23 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.1817_24 = 0;

  <bb 6>:
  # iftmp.1817_4 = PHI <iftmp.1817_23(4), iftmp.1817_24(5)>
  allow_opt_alpha_bar_25 = iftmp.1817_4;
  _26 = ~allow_opt_picker_20;
  if (_26 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _27 = ~allow_opt_alpha_bar_25;
  if (_27 != 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  _30 = ImGui::BeginPopup ("context", 0);
  _31 = _30;
  _32 = ~_31;
  if (_32 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1819_34 = 1;
  goto <bb 11>;

  <bb 10>:
  iftmp.1819_33 = 0;

  <bb 11>:
  # iftmp.1819_5 = PHI <iftmp.1819_34(9), iftmp.1819_33(10)>
  retval.1818_35 = iftmp.1819_5;
  if (retval.1818_35 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  goto <bb 34> (<L38>);

  <bb 13>:
  g_36 = GImGui;
  if (allow_opt_picker_20 != 0)
    goto <bb 14>;
  else
    goto <bb 29>;

  <bb 14>:
  _37 = g_36->FontSize;
  _38 = _37 * 8.0e+0;
  _40 = ImGui::GetFrameHeight ();
  _41 = g_36->Style.ItemInnerSpacing.x;
  _42 = _40 + _41;
  _43 = _38 - _42;
  _45 = ImMax (_43, 1.0e+0);
  _46 = g_36->FontSize;
  _47 = _46 * 8.0e+0;
  ImVec2::ImVec2 (&picker_size, _47, _45);
  _49 = picker_size.x;
  ImGui::PushItemWidth (_49);
  picker_type_51 = 0;

  <bb 15>:
  # picker_type_1 = PHI <picker_type_51(14), picker_type_78(27)>
  if (picker_type_1 > 1)
    goto <bb 28>;
  else
    goto <bb 16>;

  <bb 16>:
  if (picker_type_1 > 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  ImGui::Separator ();

  <bb 18>:
  ImGui::PushID (picker_type_1);
  _54 = flags_18(D) & 2;
  picker_flags_55 = _54 | 424;
  if (picker_type_1 == 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  picker_flags_56 = picker_flags_55 | 262144;

  <bb 20>:
  # picker_flags_2 = PHI <picker_flags_55(18), picker_flags_56(19)>
  if (picker_type_1 == 1)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  picker_flags_57 = picker_flags_2 | 524288;

  <bb 22>:
  # picker_flags_3 = PHI <picker_flags_2(20), picker_flags_57(21)>
  backup_pos = ImGui::GetCursorScreenPos ();
  _60 = ImGui::Selectable ("##selectable", 0, 0, &picker_size);
  retval.1820_61 = _60;
  if (retval.1820_61 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _62 = g_36->ColorEditOptions;
  _63 = _62 & -786433;
  _64 = picker_flags_3 & 786432;
  _65 = _63 | _64;
  g_36->ColorEditOptions = _65;

  <bb 24>:
  ImGui::SetCursorScreenPos (&backup_pos);
  ImVec4::ImVec4 (&dummy_ref_col);
  _69 = picker_flags_3 & 2;
  if (_69 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  iftmp.1821_70 = 12;
  goto <bb 27>;

  <bb 26>:
  iftmp.1821_71 = 16;

  <bb 27>:
  # iftmp.1821_6 = PHI <iftmp.1821_70(25), iftmp.1821_71(26)>
  memcpy (&dummy_ref_col.x, ref_col_72(D), iftmp.1821_6);
  ImGui::ColorPicker4 ("##dummypicker", &dummy_ref_col.x, picker_flags_3, 0B);
  ImGui::PopID ();
  backup_pos ={v} {CLOBBER};
  dummy_ref_col ={v} {CLOBBER};
  picker_type_78 = picker_type_1 + 1;
  goto <bb 15>;

  <bb 28>:
  ImGui::PopItemWidth ();
  picker_size ={v} {CLOBBER};

  <bb 29>:
  if (allow_opt_alpha_bar_25 != 0)
    goto <bb 30>;
  else
    goto <bb 33>;

  <bb 30>:
  if (allow_opt_picker_20 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  ImGui::Separator ();

  <bb 32>:
  _85 = &g_36->ColorEditOptions;
  ImGui::CheckboxFlags ("Alpha Bar", _85, 512);

  <bb 33>:
  ImGui::EndPopup ();

<L38>:
  return;

}



;; Function bool ImGui::ColorEdit4(const char*, float*, ImGuiColorEditFlags) (_ZN5ImGui10ColorEdit4EPKcPfi, funcdef_no=1137, decl_uid=3080, cgraph_uid=1036, symbol_order=1047)

bool ImGui::ColorEdit4(const char*, float*, ImGuiColorEditFlags) (const char * label, float * col, ImGuiColorEditFlags flags)
{
  const struct ImGuiPayload * D.42561;
  const struct ImGuiPayload * D.42560;
  bool D.42559;
  bool D.42557;
  bool D.42556;
  bool D.42554;
  bool D.42552;
  bool D.42550;
  bool D.42549;
  float D.42548;
  const struct ImGuiPayload * payload;
  const struct ImGuiPayload * payload;
  int n;
  ImGuiColorEditFlags picker_flags;
  ImGuiColorEditFlags picker_flags_to_forward;
  const struct ImVec4 col_v4;
  char * p;
  char buf[64];
  int n;
  const int fmt_idx;
  const char * fmt_table_float[3][4];
  const char * fmt_table_int[3][4];
  const char * ids[4];
  const bool hide_prefix;
  const float w_item_last;
  const float w_item_one;
  struct ImGuiWindow * picker_active_window;
  bool value_changed_as_float;
  bool value_changed;
  int i[4];
  float f[4];
  const ImGuiColorEditFlags flags_untouched;
  const int components;
  const bool hdr;
  const bool alpha;
  const char * label_display_end;
  const float w_items_all;
  const float w_extra;
  const float square_sz;
  const struct ImGuiStyle & style;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  unsigned int D.42545;
  struct ImGuiWindow * D.42542;
  unsigned int D.42539;
  const void * D.42534;
  long unsigned int D.42533;
  long unsigned int D.42532;
  const void * D.42528;
  bool D.42522;
  int D.42520;
  int D.42519;
  bool iftmp.1841;
  bool retval.1840;
  float D.42511;
  float * D.42510;
  float D.42507;
  float * D.42506;
  float D.42505;
  float * D.42504;
  float D.42503;
  float D.42499;
  float D.42498;
  float D.42497;
  int D.42494;
  float D.42492;
  float D.42491;
  int D.42490;
  bool D.42485;
  float D.42481;
  int D.42478;
  float * D.42473;
  bool D.21150;
  float D.42472;
  int D.42471;
  bool retval.1839;
  int D.42461;
  struct ImRect * D.42458;
  struct ImVec2 D.21144;
  float D.42457;
  struct ImVec2 D.21145;
  struct ImVec2 D.21146;
  struct ImVec2 D.21147;
  int D.42454;
  struct ImVec2 D.21143;
  bool retval.1838;
  float D.42450;
  float D.42449;
  float * D.42448;
  float D.42447;
  float * D.42446;
  float iftmp.1837;
  float D.42440;
  int D.42437;
  int D.42434;
  int D.42429;
  int D.42424;
  int D.42423;
  int D.42422;
  bool D.42420;
  unsigned int D.42419;
  char D.42418;
  char D.42416;
  bool iftmp.1836;
  bool retval.1835;
  bool retval.1834;
  int D.42406;
  int D.42405;
  int D.42404;
  int D.42403;
  int D.42402;
  int D.42401;
  int D.42399;
  int D.42398;
  int D.42397;
  int D.42396;
  int D.42395;
  int D.42394;
  int D.42393;
  int D.42392;
  int D.42387;
  int D.42384;
  int D.42380;
  const char * D.42379;
  int * D.42378;
  int iftmp.1833;
  const char * D.42373;
  bool D.21138;
  bool D.42371;
  const char * D.42370;
  float * D.42369;
  float iftmp.1832;
  const char * D.42364;
  int D.42361;
  int D.42357;
  float D.42355;
  int D.42347;
  int iftmp.1831;
  int iftmp.1830;
  float D.42341;
  int D.42337;
  const char * iftmp.1829;
  struct ImVec2 D.21132;
  float D.42335;
  int D.42334;
  float D.42333;
  float D.42332;
  float D.42331;
  int D.42330;
  float D.42329;
  float D.42328;
  float D.42327;
  int D.42326;
  float D.42325;
  float D.42324;
  float D.42323;
  float D.42322;
  float D.42321;
  int D.42320;
  float D.42319;
  int D.42317;
  int D.42315;
  int D.42312;
  float D.42311;
  float D.42307;
  float iftmp.1828;
  float D.42305;
  float D.42304;
  int D.42303;
  float D.42302;
  float D.42298;
  float iftmp.1827;
  float D.42296;
  float D.42295;
  int D.42294;
  float D.42293;
  float D.42289;
  float iftmp.1826;
  float D.42287;
  float D.42286;
  int D.42285;
  float D.42284;
  float D.42280;
  float iftmp.1825;
  float D.42278;
  float D.42277;
  float D.42275;
  float D.42274;
  float D.42273;
  int D.42270;
  float iftmp.1824;
  float D.42265;
  float D.42264;
  float D.42263;
  int D.42262;
  int D.42261;
  int D.42259;
  int D.42258;
  int D.42255;
  int D.42253;
  int D.42252;
  int D.42249;
  int D.42247;
  int D.42246;
  int D.42243;
  int D.42239;
  int D.42237;
  int D.42234;
  int iftmp.1823;
  int D.42229;
  int D.42228;
  float D.42227;
  float D.42225;
  int D.42222;
  float iftmp.1822;
  bool D.42220;
  bool D.42217;
  bool _22;
  float iftmp.1822_23;
  int iftmp.1823_24;
  float iftmp.1824_25;
  float iftmp.1825_26;
  float iftmp.1826_27;
  float iftmp.1827_28;
  float iftmp.1828_29;
  const char * iftmp.1829_30;
  int iftmp.1830_31;
  int iftmp.1831_32;
  float iftmp.1832_33;
  int iftmp.1833_34;
  bool iftmp.1836_35;
  float iftmp.1837_36;
  bool iftmp.1841_37;
  bool _79;
  bool _80;
  int _86;
  float _87;
  float iftmp.1822_88;
  float iftmp.1822_89;
  float _92;
  float _93;
  int _98;
  int _100;
  int iftmp.1823_102;
  int iftmp.1823_103;
  int _108;
  int _109;
  int _111;
  int _114;
  int _115;
  int _116;
  int _118;
  int _119;
  int _120;
  int _122;
  int _123;
  int _124;
  int _126;
  int _127;
  float _129;
  float _131;
  float _133;
  float iftmp.1824_135;
  float iftmp.1824_136;
  int _138;
  float _139;
  float _140;
  float _141;
  float _143;
  float _144;
  float _145;
  float iftmp.1825_146;
  float iftmp.1825_147;
  float _148;
  int _149;
  float _151;
  float _152;
  float _153;
  float iftmp.1826_154;
  float iftmp.1826_155;
  float _156;
  int _157;
  float _159;
  float _160;
  float _161;
  float iftmp.1827_162;
  float iftmp.1827_163;
  float _164;
  int _165;
  float _167;
  float _168;
  float _169;
  float iftmp.1828_170;
  float iftmp.1828_171;
  float _172;
  int _173;
  int _177;
  int _178;
  float _179;
  int _180;
  float _181;
  float _182;
  float _183;
  float _184;
  float _185;
  int _186;
  float _187;
  float _190;
  float _191;
  int _192;
  float _193;
  float _194;
  float _195;
  int _196;
  float _197;
  int _200;
  const char * iftmp.1829_201;
  const char * iftmp.1829_202;
  float _204;
  int iftmp.1830_234;
  int _235;
  int iftmp.1831_236;
  int iftmp.1831_237;
  int iftmp.1830_238;
  float _242;
  int _244;
  int _246;
  const char * _247;
  float iftmp.1832_248;
  float iftmp.1832_249;
  float * _250;
  const char * _251;
  bool _253;
  bool _254;
  const char * _257;
  int iftmp.1833_258;
  int iftmp.1833_259;
  int * _260;
  const char * _261;
  bool _263;
  bool _264;
  int _266;
  int _277;
  int _278;
  int _279;
  int _281;
  int _282;
  int _284;
  int _285;
  int _287;
  int _288;
  int _290;
  int _292;
  int _294;
  int _295;
  int _297;
  int _298;
  int _300;
  bool _304;
  bool retval.1834_305;
  char _308;
  char _309;
  unsigned int _310;
  bool _312;
  bool iftmp.1836_313;
  bool iftmp.1836_314;
  bool retval.1835_315;
  int _318;
  int _320;
  int _322;
  int _326;
  int _332;
  int _333;
  float _334;
  float iftmp.1837_336;
  float iftmp.1837_337;
  float * _338;
  float _339;
  float * _340;
  float _341;
  float _342;
  bool _346;
  bool retval.1838_347;
  int _349;
  float _353;
  struct ImRect * _355;
  int _363;
  bool _366;
  bool retval.1839_367;
  int _372;
  float _374;
  float * _376;
  bool _378;
  bool _379;
  int _386;
  float _387;
  bool _390;
  int _392;
  float _393;
  float _394;
  int _397;
  float _398;
  float _399;
  float _400;
  float _402;
  float * _404;
  float _405;
  float * _407;
  float _408;
  float * _410;
  float _411;
  int _415;
  int _416;
  bool _418;
  bool _419;
  bool iftmp.1841_420;
  bool iftmp.1841_421;
  bool retval.1840_422;
  const struct ImGuiPayload * _424;
  const void * _426;
  const struct ImGuiPayload * _430;
  long unsigned int _432;
  long unsigned int _433;
  const void * _434;
  unsigned int _438;
  struct ImGuiWindow * _439;
  unsigned int _440;
  bool _442;

  <bb 2>:
  window_78 = ImGui::GetCurrentWindow ();
  _79 = window_78->SkipItems;
  if (_79 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _80 = 0;
  goto <bb 133>;

  <bb 4>:
  g_81 = GImGui;
  style_82 = &g_81->Style;
  square_sz_84 = ImGui::GetFrameHeight ();
  _86 = flags_85(D) & 16;
  if (_86 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _87 = style_82->ItemInnerSpacing.x;
  iftmp.1822_88 = _87 + square_sz_84;
  goto <bb 7>;

  <bb 6>:
  iftmp.1822_89 = 0.0;

  <bb 7>:
  # iftmp.1822_23 = PHI <iftmp.1822_88(5), iftmp.1822_89(6)>
  w_extra_90 = iftmp.1822_23;
  _92 = ImGui::CalcItemWidth ();
  _93 = _92;
  w_items_all_94 = _93 - w_extra_90;
  label_display_end_97 = ImGui::FindRenderedTextEnd (label_95(D), 0B);
  _98 = flags_85(D) & 2;
  alpha_99 = _98 == 0;
  _100 = flags_85(D) & 4096;
  hdr_101 = _100 != 0;
  if (alpha_99 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1823_102 = 4;
  goto <bb 10>;

  <bb 9>:
  iftmp.1823_103 = 3;

  <bb 10>:
  # iftmp.1823_24 = PHI <iftmp.1823_102(8), iftmp.1823_103(9)>
  components_104 = iftmp.1823_24;
  flags_untouched_105 = flags_85(D);
  ImGui::BeginGroup ();
  ImGui::PushID (label_95(D));
  _108 = flags_85(D) & 32;
  if (_108 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _109 = flags_85(D) & -57353;
  flags_110 = _109 | 8200;

  <bb 12>:
  # flags_1 = PHI <flags_85(D)(10), flags_110(11)>
  _111 = flags_1 & 8;
  if (_111 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  ImGui::ColorEditOptionsPopup (col_112(D), flags_1);

  <bb 14>:
  _114 = flags_1 & 57344;
  if (_114 == 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _115 = g_81->ColorEditOptions;
  _116 = _115 & 57344;
  flags_117 = _116 | flags_1;

  <bb 16>:
  # flags_2 = PHI <flags_1(14), flags_117(15)>
  _118 = flags_2 & 196608;
  if (_118 == 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _119 = g_81->ColorEditOptions;
  _120 = _119 & 196608;
  flags_121 = _120 | flags_2;

  <bb 18>:
  # flags_3 = PHI <flags_2(16), flags_121(17)>
  _122 = flags_3 & 786432;
  if (_122 == 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _123 = g_81->ColorEditOptions;
  _124 = _123 & 786432;
  flags_125 = _124 | flags_3;

  <bb 20>:
  # flags_4 = PHI <flags_3(18), flags_125(19)>
  _126 = g_81->ColorEditOptions;
  _127 = _126 & -1040385;
  flags_128 = _127 | flags_4;
  _129 = *col_112(D);
  f[0] = _129;
  _131 = MEM[(float *)col_112(D) + 4B];
  f[1] = _131;
  _133 = MEM[(float *)col_112(D) + 8B];
  f[2] = _133;
  if (alpha_99 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  iftmp.1824_135 = MEM[(float *)col_112(D) + 12B];
  goto <bb 23>;

  <bb 22>:
  iftmp.1824_136 = 1.0e+0;

  <bb 23>:
  # iftmp.1824_25 = PHI <iftmp.1824_135(21), iftmp.1824_136(22)>
  f[3] = iftmp.1824_25;
  _138 = flags_128 & 16384;
  if (_138 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _139 = f[2];
  _140 = f[1];
  _141 = f[0];
  ImGui::ColorConvertRGBtoHSV (_141, _140, _139, &f[0], &f[1], &f[2]);

  <bb 25>:
  _143 = f[0];
  _144 = _143 * 2.55e+2;
  _145 = f[0];
  if (_145 >= 0.0)
    goto <bb 26>;
  else
    goto <bb 27>;

  <bb 26>:
  iftmp.1825_146 = 5.0e-1;
  goto <bb 28>;

  <bb 27>:
  iftmp.1825_147 = -5.0e-1;

  <bb 28>:
  # iftmp.1825_26 = PHI <iftmp.1825_146(26), iftmp.1825_147(27)>
  _148 = _144 + iftmp.1825_26;
  _149 = (int) _148;
  i[0] = _149;
  _151 = f[1];
  _152 = _151 * 2.55e+2;
  _153 = f[1];
  if (_153 >= 0.0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  iftmp.1826_154 = 5.0e-1;
  goto <bb 31>;

  <bb 30>:
  iftmp.1826_155 = -5.0e-1;

  <bb 31>:
  # iftmp.1826_27 = PHI <iftmp.1826_154(29), iftmp.1826_155(30)>
  _156 = _152 + iftmp.1826_27;
  _157 = (int) _156;
  i[1] = _157;
  _159 = f[2];
  _160 = _159 * 2.55e+2;
  _161 = f[2];
  if (_161 >= 0.0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  iftmp.1827_162 = 5.0e-1;
  goto <bb 34>;

  <bb 33>:
  iftmp.1827_163 = -5.0e-1;

  <bb 34>:
  # iftmp.1827_28 = PHI <iftmp.1827_162(32), iftmp.1827_163(33)>
  _164 = _160 + iftmp.1827_28;
  _165 = (int) _164;
  i[2] = _165;
  _167 = f[3];
  _168 = _167 * 2.55e+2;
  _169 = f[3];
  if (_169 >= 0.0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  iftmp.1828_170 = 5.0e-1;
  goto <bb 37>;

  <bb 36>:
  iftmp.1828_171 = -5.0e-1;

  <bb 37>:
  # iftmp.1828_29 = PHI <iftmp.1828_170(35), iftmp.1828_171(36)>
  _172 = _168 + iftmp.1828_29;
  _173 = (int) _172;
  i[3] = _173;
  value_changed_175 = 0;
  value_changed_as_float_176 = 0;
  _177 = flags_128 & 24576;
  if (_177 != 0)
    goto <bb 38>;
  else
    goto <bb 67>;

  <bb 38>:
  _178 = flags_128 & 32;
  if (_178 == 0)
    goto <bb 39>;
  else
    goto <bb 67>;

  <bb 39>:
  _179 = style_82->ItemInnerSpacing.x;
  _180 = components_104 + -1;
  _181 = (float) _180;
  _182 = _179 * _181;
  _183 = w_items_all_94 - _182;
  _184 = (float) components_104;
  _185 = _183 / _184;
  _186 = (int) _185;
  _187 = (float) _186;
  w_item_one_189 = ImMax (1.0e+0, _187);
  _190 = style_82->ItemInnerSpacing.x;
  _191 = _190 + w_item_one_189;
  _192 = components_104 + -1;
  _193 = (float) _192;
  _194 = _191 * _193;
  _195 = w_items_all_94 - _194;
  _196 = (int) _195;
  _197 = (float) _196;
  w_item_last_199 = ImMax (1.0e+0, _197);
  _200 = flags_128 & 131072;
  if (_200 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

  <bb 40>:
  iftmp.1829_201 = "M:0.000";
  goto <bb 42>;

  <bb 41>:
  iftmp.1829_202 = "M:000";

  <bb 42>:
  # iftmp.1829_30 = PHI <iftmp.1829_201(40), iftmp.1829_202(41)>
  D.21132 = ImGui::CalcTextSize (iftmp.1829_30, 0B, 0, -1.0e+0);
  _204 = D.21132.x;
  hide_prefix_205 = _204 >= w_item_one_189;
  ids[0] = "##X";
  ids[1] = "##Y";
  ids[2] = "##Z";
  ids[3] = "##W";
  fmt_table_int[0][0] = "%3.0f";
  fmt_table_int[0][1] = "%3.0f";
  fmt_table_int[0][2] = "%3.0f";
  fmt_table_int[0][3] = "%3.0f";
  fmt_table_int[1][0] = "R:%3.0f";
  fmt_table_int[1][1] = "G:%3.0f";
  fmt_table_int[1][2] = "B:%3.0f";
  fmt_table_int[1][3] = "A:%3.0f";
  fmt_table_int[2][0] = "H:%3.0f";
  fmt_table_int[2][1] = "S:%3.0f";
  fmt_table_int[2][2] = "V:%3.0f";
  fmt_table_int[2][3] = "A:%3.0f";
  fmt_table_float[0][0] = "%0.3f";
  fmt_table_float[0][1] = "%0.3f";
  fmt_table_float[0][2] = "%0.3f";
  fmt_table_float[0][3] = "%0.3f";
  fmt_table_float[1][0] = "R:%0.3f";
  fmt_table_float[1][1] = "G:%0.3f";
  fmt_table_float[1][2] = "B:%0.3f";
  fmt_table_float[1][3] = "A:%0.3f";
  fmt_table_float[2][0] = "H:%0.3f";
  fmt_table_float[2][1] = "S:%0.3f";
  fmt_table_float[2][2] = "V:%0.3f";
  fmt_table_float[2][3] = "A:%0.3f";
  if (hide_prefix_205 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  iftmp.1830_234 = 0;
  goto <bb 48>;

  <bb 44>:
  _235 = flags_128 & 16384;
  if (_235 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

  <bb 45>:
  iftmp.1831_236 = 2;
  goto <bb 47>;

  <bb 46>:
  iftmp.1831_237 = 1;

  <bb 47>:
  # iftmp.1831_32 = PHI <iftmp.1831_236(45), iftmp.1831_237(46)>
  iftmp.1830_238 = iftmp.1831_32;

  <bb 48>:
  # iftmp.1830_31 = PHI <iftmp.1830_234(43), iftmp.1830_238(47)>
  fmt_idx_239 = iftmp.1830_31;
  ImGui::PushItemWidth (w_item_one_189);
  n_241 = 0;

  <bb 49>:
  # value_changed_5 = PHI <value_changed_175(48), value_changed_6(65)>
  # value_changed_as_float_14 = PHI <value_changed_as_float_176(48), value_changed_as_float_15(65)>
  # n_17 = PHI <n_241(48), n_268(65)>
  if (n_17 >= components_104)
    goto <bb 66>;
  else
    goto <bb 50>;

  <bb 50>:
  if (n_17 > 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  _242 = style_82->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _242);

  <bb 52>:
  _244 = n_17 + 1;
  if (_244 == components_104)
    goto <bb 53>;
  else
    goto <bb 54>;

  <bb 53>:
  ImGui::PushItemWidth (w_item_last_199);

  <bb 54>:
  _246 = flags_128 & 131072;
  if (_246 != 0)
    goto <bb 55>;
  else
    goto <bb 59>;

  <bb 55>:
  _247 = fmt_table_float[fmt_idx_239][n_17];
  if (hdr_101 != 0)
    goto <bb 56>;
  else
    goto <bb 57>;

  <bb 56>:
  iftmp.1832_248 = 0.0;
  goto <bb 58>;

  <bb 57>:
  iftmp.1832_249 = 1.0e+0;

  <bb 58>:
  # iftmp.1832_33 = PHI <iftmp.1832_248(56), iftmp.1832_249(57)>
  _250 = &f[n_17];
  _251 = ids[n_17];
  _253 = ImGui::DragFloat (_251, _250, 3.9215688593685626983642578125e-3, 0.0, iftmp.1832_33, _247, 1.0e+0);
  _254 = _253;
  value_changed_as_float_255 = _254 | value_changed_5;
  value_changed_256 = value_changed_as_float_255;
  goto <bb 63>;

  <bb 59>:
  _257 = fmt_table_int[fmt_idx_239][n_17];
  if (hdr_101 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  iftmp.1833_258 = 0;
  goto <bb 62>;

  <bb 61>:
  iftmp.1833_259 = 255;

  <bb 62>:
  # iftmp.1833_34 = PHI <iftmp.1833_258(60), iftmp.1833_259(61)>
  _260 = &i[n_17];
  _261 = ids[n_17];
  _263 = ImGui::DragInt (_261, _260, 1.0e+0, 0, iftmp.1833_34, _257);
  _264 = _263;
  value_changed_265 = value_changed_5 | _264;

  <bb 63>:
  # value_changed_6 = PHI <value_changed_256(58), value_changed_265(62)>
  # value_changed_as_float_15 = PHI <value_changed_as_float_255(58), value_changed_as_float_14(62)>
  _266 = flags_128 & 8;
  if (_266 == 0)
    goto <bb 64>;
  else
    goto <bb 65>;

  <bb 64>:
  ImGui::OpenPopupOnItemClick ("context", 1);

  <bb 65>:
  n_268 = n_17 + 1;
  goto <bb 49>;

  <bb 66>:
  ImGui::PopItemWidth ();
  ImGui::PopItemWidth ();
  ids ={v} {CLOBBER};
  fmt_table_int ={v} {CLOBBER};
  fmt_table_float ={v} {CLOBBER};
  goto <bb 87>;

  <bb 67>:
  _277 = flags_128 & 32768;
  if (_277 != 0)
    goto <bb 68>;
  else
    goto <bb 87>;

  <bb 68>:
  _278 = flags_128 & 32;
  if (_278 == 0)
    goto <bb 69>;
  else
    goto <bb 87>;

  <bb 69>:
  if (alpha_99 != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

  <bb 70>:
  _279 = i[3];
  _281 = ImClamp (_279, 0, 255);
  _282 = i[2];
  _284 = ImClamp (_282, 0, 255);
  _285 = i[1];
  _287 = ImClamp (_285, 0, 255);
  _288 = i[0];
  _290 = ImClamp (_288, 0, 255);
  ImFormatString (&buf, 64, "#%02X%02X%02X%02X", _290, _287, _284, _281);
  goto <bb 72>;

  <bb 71>:
  _292 = i[2];
  _294 = ImClamp (_292, 0, 255);
  _295 = i[1];
  _297 = ImClamp (_295, 0, 255);
  _298 = i[0];
  _300 = ImClamp (_298, 0, 255);
  ImFormatString (&buf, 64, "#%02X%02X%02X", _300, _297, _294);

  <bb 72>:
  ImGui::PushItemWidth (w_items_all_94);
  _304 = ImGui::InputText ("##Text", &buf, 64, 6, 0B, 0B);
  retval.1834_305 = _304;
  if (retval.1834_305 != 0)
    goto <bb 73>;
  else
    goto <bb 84>;

  <bb 73>:
  value_changed_306 = 1;
  p_307 = &buf;

  <bb 74>:
  # p_18 = PHI <p_307(73), p_316(79)>
  _308 = *p_18;
  if (_308 == 35)
    goto <bb 76>;
  else
    goto <bb 75>;

  <bb 75>:
  _309 = *p_18;
  _310 = (unsigned int) _309;
  _312 = ImCharIsSpace (_310);
  if (_312 != 0)
    goto <bb 76>;
  else
    goto <bb 77>;

  <bb 76>:
  iftmp.1836_314 = 1;
  goto <bb 78>;

  <bb 77>:
  iftmp.1836_313 = 0;

  <bb 78>:
  # iftmp.1836_35 = PHI <iftmp.1836_314(76), iftmp.1836_313(77)>
  retval.1835_315 = iftmp.1836_35;
  if (retval.1835_315 != 0)
    goto <bb 79>;
  else
    goto <bb 80>;

  <bb 79>:
  p_316 = p_18 + 1;
  goto <bb 74>;

  <bb 80>:
  i[3] = 0;
  _318 = i[3];
  i[2] = _318;
  _320 = i[2];
  i[1] = _320;
  _322 = i[1];
  i[0] = _322;
  if (alpha_99 != 0)
    goto <bb 81>;
  else
    goto <bb 82>;

  <bb 81>:
  sscanf (p_18, "%02X%02X%02X%02X", &i[0], &i[1], &i[2], &i[3]);
  goto <bb 83>;

  <bb 82>:
  sscanf (p_18, "%02X%02X%02X", &i[0], &i[1], &i[2]);

  <bb 83>:

  <bb 84>:
  # value_changed_7 = PHI <value_changed_175(72), value_changed_306(83)>
  _326 = flags_128 & 8;
  if (_326 == 0)
    goto <bb 85>;
  else
    goto <bb 86>;

  <bb 85>:
  ImGui::OpenPopupOnItemClick ("context", 1);

  <bb 86>:
  ImGui::PopItemWidth ();
  buf ={v} {CLOBBER};

  <bb 87>:
  # value_changed_8 = PHI <value_changed_5(66), value_changed_175(67), value_changed_175(68), value_changed_7(86)>
  # value_changed_as_float_16 = PHI <value_changed_as_float_14(66), value_changed_as_float_176(67), value_changed_as_float_176(68), value_changed_as_float_176(86)>
  picker_active_window_331 = 0B;
  _332 = flags_128 & 16;
  if (_332 == 0)
    goto <bb 88>;
  else
    goto <bb 103>;

  <bb 88>:
  _333 = flags_128 & 32;
  if (_333 == 0)
    goto <bb 89>;
  else
    goto <bb 90>;

  <bb 89>:
  _334 = style_82->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _334);

  <bb 90>:
  if (alpha_99 != 0)
    goto <bb 91>;
  else
    goto <bb 92>;

  <bb 91>:
  iftmp.1837_336 = MEM[(float *)col_112(D) + 12B];
  goto <bb 93>;

  <bb 92>:
  iftmp.1837_337 = 1.0e+0;

  <bb 93>:
  # iftmp.1837_36 = PHI <iftmp.1837_336(91), iftmp.1837_337(92)>
  _338 = col_112(D) + 8;
  _339 = *_338;
  _340 = col_112(D) + 4;
  _341 = *_340;
  _342 = *col_112(D);
  ImVec4::ImVec4 (&col_v4, _342, _341, _339, iftmp.1837_36);
  ImVec2::ImVec2 (&D.21143, 0.0, 0.0);
  _346 = ImGui::ColorButton ("##ColorButton", &col_v4, flags_128, D.21143);
  retval.1838_347 = _346;
  D.21143 ={v} {CLOBBER};
  if (retval.1838_347 != 0)
    goto <bb 94>;
  else
    goto <bb 96>;

  <bb 94>:
  _349 = flags_128 & 4;
  if (_349 == 0)
    goto <bb 95>;
  else
    goto <bb 96>;

  <bb 95>:
  g_81->ColorPickerRef = col_v4;
  ImGui::OpenPopup ("picker");
  ImVec2::ImVec2 (&D.21147, 0.0, 0.0);
  _353 = style_82->ItemSpacing.y;
  ImVec2::ImVec2 (&D.21145, -1.0e+0, _353);
  _355 = &window_78->DC.LastItemRect;
  D.21144 = ImRect::GetBL (_355);
  D.21146 = operator+ (&D.21144, &D.21145);
  ImGui::SetNextWindowPos (&D.21146, 0, &D.21147);
  D.21146 ={v} {CLOBBER};
  D.21144 ={v} {CLOBBER};
  D.21145 ={v} {CLOBBER};
  D.21147 ={v} {CLOBBER};

  <bb 96>:
  _363 = flags_128 & 8;
  if (_363 == 0)
    goto <bb 97>;
  else
    goto <bb 98>;

  <bb 97>:
  ImGui::OpenPopupOnItemClick ("context", 1);

  <bb 98>:
  _366 = ImGui::BeginPopup ("picker", 0);
  retval.1839_367 = _366;
  if (retval.1839_367 != 0)
    goto <bb 99>;
  else
    goto <bb 102>;

  <bb 99>:
  picker_active_window_368 = g_81->CurrentWindow;
  if (label_95(D) != label_display_end_97)
    goto <bb 100>;
  else
    goto <bb 101>;

  <bb 100>:
  ImGui::TextUnformatted (label_95(D), label_display_end_97);
  ImGui::Separator ();

  <bb 101>:
  picker_flags_to_forward_371 = 987650;
  _372 = flags_untouched_105 & picker_flags_to_forward_371;
  picker_flags_373 = _372 | 59520;
  _374 = square_sz_84 * 1.2e+1;
  ImGui::PushItemWidth (_374);
  _376 = &g_81->ColorPickerRef.x;
  _378 = ImGui::ColorPicker4 ("##picker", col_112(D), picker_flags_373, _376);
  _379 = _378;
  value_changed_380 = value_changed_8 | _379;
  ImGui::PopItemWidth ();
  ImGui::EndPopup ();

  <bb 102>:
  # value_changed_9 = PHI <value_changed_8(98), value_changed_380(101)>
  # picker_active_window_19 = PHI <picker_active_window_331(98), picker_active_window_368(101)>
  col_v4 ={v} {CLOBBER};

  <bb 103>:
  # value_changed_10 = PHI <value_changed_8(87), value_changed_9(102)>
  # picker_active_window_20 = PHI <picker_active_window_331(87), picker_active_window_19(102)>
  if (label_95(D) != label_display_end_97)
    goto <bb 104>;
  else
    goto <bb 106>;

  <bb 104>:
  _386 = flags_128 & 128;
  if (_386 == 0)
    goto <bb 105>;
  else
    goto <bb 106>;

  <bb 105>:
  _387 = style_82->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _387);
  ImGui::TextUnformatted (label_95(D), label_display_end_97);

  <bb 106>:
  if (picker_active_window_20 == 0B)
    goto <bb 107>;
  else
    goto <bb 118>;

  <bb 107>:
  _390 = ~value_changed_as_float_16;
  if (_390 != 0)
    goto <bb 108>;
  else
    goto <bb 112>;

  <bb 108>:
  n_391 = 0;

  <bb 109>:
  # n_21 = PHI <n_391(108), n_396(110)>
  if (n_21 > 3)
    goto <bb 111>;
  else
    goto <bb 110>;

  <bb 110>:
  _392 = i[n_21];
  _393 = (float) _392;
  _394 = _393 / 2.55e+2;
  f[n_21] = _394;
  n_396 = n_21 + 1;
  goto <bb 109>;

  <bb 111>:

  <bb 112>:
  _397 = flags_128 & 16384;
  if (_397 != 0)
    goto <bb 113>;
  else
    goto <bb 114>;

  <bb 113>:
  _398 = f[2];
  _399 = f[1];
  _400 = f[0];
  ImGui::ColorConvertHSVtoRGB (_400, _399, _398, &f[0], &f[1], &f[2]);

  <bb 114>:
  if (value_changed_10 != 0)
    goto <bb 115>;
  else
    goto <bb 117>;

  <bb 115>:
  _402 = f[0];
  *col_112(D) = _402;
  _404 = col_112(D) + 4;
  _405 = f[1];
  *_404 = _405;
  _407 = col_112(D) + 8;
  _408 = f[2];
  *_407 = _408;
  if (alpha_99 != 0)
    goto <bb 116>;
  else
    goto <bb 117>;

  <bb 116>:
  _410 = col_112(D) + 12;
  _411 = f[3];
  *_410 = _411;

  <bb 117>:

  <bb 118>:
  ImGui::PopID ();
  ImGui::EndGroup ();
  _415 = window_78->DC.LastItemStatusFlags;
  _416 = _415 & 1;
  if (_416 != 0)
    goto <bb 119>;
  else
    goto <bb 121>;

  <bb 119>:
  _418 = ImGui::BeginDragDropTarget ();
  _419 = _418;
  if (_419 != 0)
    goto <bb 120>;
  else
    goto <bb 121>;

  <bb 120>:
  iftmp.1841_420 = 1;
  goto <bb 122>;

  <bb 121>:
  iftmp.1841_421 = 0;

  <bb 122>:
  # iftmp.1841_37 = PHI <iftmp.1841_420(120), iftmp.1841_421(121)>
  retval.1840_422 = iftmp.1841_37;
  if (retval.1840_422 != 0)
    goto <bb 123>;
  else
    goto <bb 128>;

  <bb 123>:
  _424 = ImGui::AcceptDragDropPayload ("_COL3F", 0);
  payload_425 = _424;
  if (payload_425 != 0B)
    goto <bb 124>;
  else
    goto <bb 125>;

  <bb 124>:
  _426 = payload_425->Data;
  memcpy (col_112(D), _426, 12);
  value_changed_428 = 1;

  <bb 125>:
  # value_changed_11 = PHI <value_changed_10(123), value_changed_428(124)>
  _430 = ImGui::AcceptDragDropPayload ("_COL4F", 0);
  payload_431 = _430;
  if (payload_431 != 0B)
    goto <bb 126>;
  else
    goto <bb 127>;

  <bb 126>:
  _432 = (long unsigned int) components_104;
  _433 = _432 * 4;
  _434 = payload_431->Data;
  memcpy (col_112(D), _434, _433);
  value_changed_436 = 1;

  <bb 127>:
  # value_changed_12 = PHI <value_changed_11(125), value_changed_436(126)>
  ImGui::EndDragDropTarget ();

  <bb 128>:
  # value_changed_13 = PHI <value_changed_10(122), value_changed_12(127)>
  if (picker_active_window_20 != 0B)
    goto <bb 129>;
  else
    goto <bb 132>;

  <bb 129>:
  _438 = g_81->ActiveId;
  if (_438 != 0)
    goto <bb 130>;
  else
    goto <bb 132>;

  <bb 130>:
  _439 = g_81->ActiveIdWindow;
  if (_439 == picker_active_window_20)
    goto <bb 131>;
  else
    goto <bb 132>;

  <bb 131>:
  _440 = g_81->ActiveId;
  window_78->DC.LastItemId = _440;

  <bb 132>:
  _442 = value_changed_13;

  <bb 133>:
  # _22 = PHI <_80(3), _442(132)>
  f ={v} {CLOBBER};
  i ={v} {CLOBBER};

<L167>:
  return _22;

}



;; Function bool ImGui::ColorPicker3(const char*, float*, ImGuiColorEditFlags) (_ZN5ImGui12ColorPicker3EPKcPfi, funcdef_no=1138, decl_uid=3084, cgraph_uid=1037, symbol_order=1048)

bool ImGui::ColorPicker3(const char*, float*, ImGuiColorEditFlags) (const char * label, float * col, ImGuiColorEditFlags flags)
{
  bool D.42579;
  float col4[4];
  float D.42577;
  float * D.42576;
  float D.42575;
  float * D.42574;
  float D.42573;
  bool D.42572;
  bool D.42569;
  int D.42568;
  bool retval.1842;
  float D.42566;
  float D.42565;
  float D.42564;
  bool _1;
  float _7;
  float _9;
  float _11;
  int _14;
  bool _17;
  bool _18;
  bool retval.1842_19;
  bool _20;
  float _21;
  float * _23;
  float _24;
  float * _26;
  float _27;
  bool _29;

  <bb 2>:
  col4 = {};
  col4[3] = 1.0e+0;
  _7 = *col_6(D);
  col4[0] = _7;
  _9 = MEM[(float *)col_6(D) + 4B];
  col4[1] = _9;
  _11 = MEM[(float *)col_6(D) + 8B];
  col4[2] = _11;
  _14 = flags_13(D) | 2;
  _17 = ImGui::ColorPicker4 (label_15(D), &col4, _14, 0B);
  _18 = _17;
  retval.1842_19 = ~_18;
  if (retval.1842_19 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _20 = 0;
  goto <bb 5>;

  <bb 4>:
  _21 = col4[0];
  *col_6(D) = _21;
  _23 = col_6(D) + 4;
  _24 = col4[1];
  *_23 = _24;
  _26 = col_6(D) + 8;
  _27 = col4[2];
  *_26 = _27;
  _29 = 1;

  <bb 5>:
  # _1 = PHI <_20(3), _29(4)>
  col4 ={v} {CLOBBER};

<L3>:
  return _1;

}



;; Function void RenderArrow(ImDrawList*, ImVec2, ImVec2, ImGuiDir, ImU32) (_ZL11RenderArrowP10ImDrawList6ImVec2S1_ij, funcdef_no=1139, decl_uid=21171, cgraph_uid=1038, symbol_order=1049)

void RenderArrow(ImDrawList*, ImVec2, ImVec2, ImGuiDir, ImU32) (struct ImDrawList * draw_list, struct ImVec2 pos, struct ImVec2 half_sz, ImGuiDir direction, ImU32 col)
{
  float D.42629;
  float D.42628;
  float D.42627;
  float D.42626;
  float D.42625;
  float D.42624;
  struct ImVec2 D.21183;
  float D.42623;
  float D.42622;
  float D.42621;
  float D.42620;
  float D.42619;
  float D.42618;
  struct ImVec2 D.21184;
  float D.42617;
  float D.42616;
  float D.42615;
  float D.42614;
  float D.42613;
  float D.42612;
  struct ImVec2 D.21180;
  float D.42611;
  float D.42610;
  float D.42609;
  float D.42608;
  float D.42607;
  float D.42606;
  struct ImVec2 D.21181;
  float D.42605;
  float D.42604;
  float D.42603;
  float D.42602;
  float D.42601;
  float D.42600;
  struct ImVec2 D.21177;
  float D.42599;
  float D.42598;
  float D.42597;
  float D.42596;
  float D.42595;
  float D.42594;
  struct ImVec2 D.21178;
  float D.42593;
  float D.42592;
  float D.42591;
  float D.42590;
  float D.42589;
  float D.42588;
  struct ImVec2 D.21174;
  float D.42587;
  float D.42586;
  float D.42585;
  float D.42584;
  float D.42583;
  float D.42582;
  struct ImVec2 D.21175;
  float _4;
  float _5;
  float _6;
  float _7;
  float _8;
  float _9;
  float _11;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  float _32;
  float _33;
  float _34;
  float _35;
  float _36;
  float _37;
  float _44;
  float _45;
  float _46;
  float _47;
  float _48;
  float _49;
  float _51;
  float _52;
  float _53;
  float _54;
  float _55;
  float _56;
  float _63;
  float _64;
  float _65;
  float _66;
  float _67;
  float _68;
  float _70;
  float _71;
  float _72;
  float _73;
  float _74;
  float _75;

  <bb 2>:
  switch (direction_2(D)) <default: <L8>, case -1: <L4>, case 0: <L0>, case 1: <L1>, case 2: <L2>, case 3: <L3>, case 4: <L4>>

<L0>:
  _4 = pos.y;
  _5 = half_sz.y;
  _6 = _4 + _5;
  _7 = pos.x;
  _8 = half_sz.x;
  _9 = _7 + _8;
  ImVec2::ImVec2 (&D.21175, _9, _6);
  _11 = pos.y;
  _12 = half_sz.y;
  _13 = _11 - _12;
  _14 = pos.x;
  _15 = half_sz.x;
  _16 = _14 + _15;
  ImVec2::ImVec2 (&D.21174, _16, _13);
  ImDrawList::AddTriangleFilled (draw_list_18(D), &D.21174, &D.21175, &pos, col_19(D));
  D.21174 ={v} {CLOBBER};
  D.21175 ={v} {CLOBBER};
  goto <bb 8> (<L8>);

<L1>:
  _25 = pos.y;
  _26 = half_sz.y;
  _27 = _25 - _26;
  _28 = pos.x;
  _29 = half_sz.x;
  _30 = _28 - _29;
  ImVec2::ImVec2 (&D.21178, _30, _27);
  _32 = pos.y;
  _33 = half_sz.y;
  _34 = _32 + _33;
  _35 = pos.x;
  _36 = half_sz.x;
  _37 = _35 - _36;
  ImVec2::ImVec2 (&D.21177, _37, _34);
  ImDrawList::AddTriangleFilled (draw_list_18(D), &D.21177, &D.21178, &pos, col_19(D));
  D.21177 ={v} {CLOBBER};
  D.21178 ={v} {CLOBBER};
  goto <bb 8> (<L8>);

<L2>:
  _44 = pos.y;
  _45 = half_sz.y;
  _46 = _44 + _45;
  _47 = pos.x;
  _48 = half_sz.x;
  _49 = _47 - _48;
  ImVec2::ImVec2 (&D.21181, _49, _46);
  _51 = pos.y;
  _52 = half_sz.y;
  _53 = _51 + _52;
  _54 = pos.x;
  _55 = half_sz.x;
  _56 = _54 + _55;
  ImVec2::ImVec2 (&D.21180, _56, _53);
  ImDrawList::AddTriangleFilled (draw_list_18(D), &D.21180, &D.21181, &pos, col_19(D));
  D.21180 ={v} {CLOBBER};
  D.21181 ={v} {CLOBBER};
  goto <bb 8> (<L8>);

<L3>:
  _63 = pos.y;
  _64 = half_sz.y;
  _65 = _63 - _64;
  _66 = pos.x;
  _67 = half_sz.x;
  _68 = _66 + _67;
  ImVec2::ImVec2 (&D.21184, _68, _65);
  _70 = pos.y;
  _71 = half_sz.y;
  _72 = _70 - _71;
  _73 = pos.x;
  _74 = half_sz.x;
  _75 = _73 - _74;
  ImVec2::ImVec2 (&D.21183, _75, _72);
  ImDrawList::AddTriangleFilled (draw_list_18(D), &D.21183, &D.21184, &pos, col_19(D));
  D.21183 ={v} {CLOBBER};
  D.21184 ={v} {CLOBBER};
  goto <bb 8> (<L8>);

<L4>:

<L8>:
  return;

}



;; Function void RenderArrowsForVerticalBar(ImDrawList*, ImVec2, ImVec2, float) (_ZL26RenderArrowsForVerticalBarP10ImDrawList6ImVec2S1_f, funcdef_no=1140, decl_uid=21192, cgraph_uid=1039, symbol_order=1050)

void RenderArrowsForVerticalBar(ImDrawList*, ImVec2, ImVec2, float) (struct ImDrawList * draw_list, struct ImVec2 pos, struct ImVec2 half_sz, float bar_w)
{
  float D.42667;
  float D.42666;
  float D.42665;
  float D.42664;
  float D.42663;
  struct ImVec2 D.21200;
  float D.42662;
  float D.42661;
  float D.42660;
  float D.42659;
  float D.42658;
  float D.42657;
  struct ImVec2 D.21198;
  float D.42656;
  float D.42655;
  float D.42654;
  float D.42653;
  struct ImVec2 D.21199;
  float D.42652;
  float D.42651;
  float D.42650;
  float D.42649;
  struct ImVec2 D.21196;
  float D.42648;
  float D.42647;
  float D.42646;
  float D.42645;
  float D.42644;
  struct ImVec2 D.21194;
  float D.42643;
  float D.42642;
  float D.42641;
  float D.42640;
  struct ImVec2 D.21195;
  float _2;
  float _3;
  float _4;
  float _5;
  float _7;
  float _8;
  float _9;
  float _10;
  float _11;
  float _17;
  float _18;
  float _19;
  float _20;
  float _24;
  float _25;
  float _26;
  float _27;
  float _29;
  float _30;
  float _32;
  float _33;
  float _34;
  float _35;
  float _40;
  float _41;
  float _42;
  float _43;
  float _44;

  <bb 2>:
  _2 = half_sz.y;
  _3 = _2 + 1.0e+0;
  _4 = half_sz.x;
  _5 = _4 + 2.0e+0;
  ImVec2::ImVec2 (&D.21195, _5, _3);
  _7 = pos.y;
  _8 = pos.x;
  _9 = half_sz.x;
  _10 = _8 + _9;
  _11 = _10 + 1.0e+0;
  ImVec2::ImVec2 (&D.21194, _11, _7);
  RenderArrow (draw_list_13(D), D.21194, D.21195, 1, 4278190080);
  D.21194 ={v} {CLOBBER};
  D.21195 ={v} {CLOBBER};
  _17 = pos.y;
  _18 = pos.x;
  _19 = half_sz.x;
  _20 = _18 + _19;
  ImVec2::ImVec2 (&D.21196, _20, _17);
  RenderArrow (draw_list_13(D), D.21196, half_sz, 1, 4294967295);
  D.21196 ={v} {CLOBBER};
  _24 = half_sz.y;
  _25 = _24 + 1.0e+0;
  _26 = half_sz.x;
  _27 = _26 + 2.0e+0;
  ImVec2::ImVec2 (&D.21199, _27, _25);
  _29 = pos.y;
  _30 = pos.x;
  _32 = _30 + bar_w_31(D);
  _33 = half_sz.x;
  _34 = _32 - _33;
  _35 = _34 - 1.0e+0;
  ImVec2::ImVec2 (&D.21198, _35, _29);
  RenderArrow (draw_list_13(D), D.21198, D.21199, 0, 4278190080);
  D.21198 ={v} {CLOBBER};
  D.21199 ={v} {CLOBBER};
  _40 = pos.y;
  _41 = pos.x;
  _42 = _41 + bar_w_31(D);
  _43 = half_sz.x;
  _44 = _42 - _43;
  ImVec2::ImVec2 (&D.21200, _44, _40);
  RenderArrow (draw_list_13(D), D.21200, half_sz, 0, 4294967295);
  D.21200 ={v} {CLOBBER};
  return;

}



;; Function bool ImGui::ColorPicker4(const char*, float*, ImGuiColorEditFlags, const float*) (_ZN5ImGui12ColorPicker4EPKcPfiPKf, funcdef_no=1141, decl_uid=3089, cgraph_uid=1040, symbol_order=1051)

bool ImGui::ColorPicker4(const char*, float*, ImGuiColorEditFlags, const float*) (const char * label, float * col, ImGuiColorEditFlags flags, const float * ref_col)
{
  void * D.46778;
  bool D.43229;
  bool D.43228;
  bool D.43227;
  bool D.43223;
  float D.43217;
  float bar1_line_y;
  struct ImRect bar1_bb;
  float alpha;
  int i;
  float bar0_line_y;
  struct ImVec2 gradient_p1;
  struct ImVec2 gradient_p0;
  const int vert_end_idx;
  const int vert_start_idx;
  const float a1;
  const float a0;
  int n;
  struct ImVec2 uv_white;
  struct ImVec2 trc;
  struct ImVec2 trb;
  struct ImVec2 tra;
  int hue_cursor_segments;
  float hue_cursor_rad;
  struct ImVec2 hue_cursor_pos;
  float sin_hue_angle;
  float cos_hue_angle;
  const int segment_per_arc;
  const float aeps;
  float new_V;
  float new_S;
  float new_H;
  ImGuiColorEditFlags sub_flags;
  ImGuiColorEditFlags sub_flags_to_forward;
  struct ImVec4 ref_col_v4;
  struct ImVec4 col_v4;
  const char * label_display_end;
  float ww;
  float vv;
  float uu;
  struct ImVec2 current_off_unrotated;
  float sin_hue_angle;
  float cos_hue_angle;
  float initial_dist2;
  struct ImVec2 current_off;
  struct ImVec2 initial_off;
  float sv_cursor_rad;
  struct ImVec2 sv_cursor_pos;
  const ImU32 hue_colors[7];
  ImU32 col32_no_alpha;
  ImU32 hue_color32;
  struct ImVec4 hue_color_f;
  bool value_changed_sv;
  bool value_changed_h;
  bool value_changed;
  float V;
  float S;
  float H;
  struct ImVec2 triangle_pc;
  struct ImVec2 triangle_pb;
  struct ImVec2 triangle_pa;
  float triangle_r;
  struct ImVec2 wheel_center;
  float wheel_r_inner;
  float wheel_r_outer;
  float wheel_thickness;
  float backup_initial_col[4];
  float bars_triangles_half_sz;
  float bar1_pos_x;
  float bar0_pos_x;
  float sv_picker_size;
  float bars_width;
  float square_sz;
  struct ImVec2 picker_pos;
  bool alpha_bar;
  int components;
  static const char __PRETTY_FUNCTION__[81] = "bool ImGui::ColorPicker4(const char*, float*, ImGuiColorEditFlags, const float*)";
  struct ImGuiIO & io;
  struct ImGuiStyle & style;
  struct ImDrawList * draw_list;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.43214;
  long unsigned int D.43213;
  long unsigned int D.43212;
  bool iftmp.1911;
  bool D.43207;
  float D.43205;
  struct ImVec2 D.21334;
  float D.43204;
  struct ImVec2 D.21335;
  float D.43203;
  int D.43202;
  float D.43201;
  float D.43200;
  float D.43199;
  float D.43198;
  float D.43197;
  unsigned int D.43196;
  unsigned int D.43195;
  float D.43194;
  float D.43193;
  struct ImVec2 D.21328;
  float D.43192;
  float D.43191;
  float D.43190;
  float D.43189;
  float D.43188;
  float * D.43187;
  float D.43184;
  float iftmp.1910;
  float D.43178;
  struct ImVec2 D.21323;
  float D.43177;
  struct ImVec2 D.21324;
  float D.43176;
  float D.43175;
  struct ImVec2 D.21321;
  float D.43174;
  float D.43173;
  float D.43172;
  struct ImVec2 D.21322;
  int D.43171;
  float D.43170;
  float D.43169;
  float D.43168;
  float H.1909;
  float D.43166;
  float D.43165;
  float D.43164;
  float D.43163;
  float D.43162;
  float D.43161;
  struct ImVec2 D.21318;
  float D.43160;
  float D.43159;
  float D.43158;
  float D.43157;
  float D.43156;
  int D.43155;
  float D.43154;
  struct ImVec2 D.21319;
  unsigned int D.43153;
  unsigned int D.43152;
  unsigned int D.43151;
  int D.43150;
  unsigned int D.43149;
  int D.43148;
  float D.43145;
  float D.43144;
  int D.43143;
  float D.43142;
  float D.43141;
  float D.43140;
  float D.43139;
  float D.43138;
  float V.1908;
  float D.43136;
  float D.43135;
  float D.43134;
  float D.43133;
  float D.43132;
  float D.43131;
  float D.43130;
  float D.43129;
  int D.43128;
  float D.43127;
  float D.43126;
  float D.43125;
  float D.43124;
  float S.1907;
  float D.43122;
  float D.43121;
  float D.43120;
  float D.43119;
  float D.43118;
  float D.43117;
  struct ImVec2 D.43116;
  struct ImVec2 D.21314;
  struct ImVec2 D.21312;
  struct ImVec2 D.21313;
  struct ImVec2 D.21310;
  struct ImVec2 D.21311;
  int D.43113;
  float D.43111;
  float S.1906;
  struct ImVec2 D.21308;
  float D.43109;
  float D.43108;
  float V.1905;
  struct ImVec2 D.21304;
  struct ImVec2 D.21301;
  struct ImVec2 D.21298;
  float D.43106;
  int D.43105;
  float D.43104;
  float iftmp.1904;
  float D.43099;
  float D.43098;
  float D.43097;
  float D.43096;
  float D.43095;
  float D.43094;
  float D.43093;
  float D.43092;
  float D.43091;
  float D.43090;
  float D.43089;
  float D.43088;
  float H.1903;
  float D.43086;
  float D.43085;
  float H.1902;
  int n.1901;
  int n.1900;
  struct ImDrawVert * D.43081;
  long unsigned int D.43080;
  long unsigned int D.43079;
  struct ImDrawVert * D.43078;
  struct ImDrawVert * D.43077;
  long unsigned int D.43076;
  long unsigned int D.43075;
  struct ImDrawVert * D.43074;
  unsigned int D.43073;
  int n.1899;
  unsigned int D.43071;
  int D.43070;
  int n.1898;
  float D.43068;
  float D.43067;
  float D.43066;
  float D.43065;
  float D.43064;
  float D.43063;
  float D.43062;
  float D.43061;
  float D.43060;
  float D.43059;
  float D.43058;
  float D.43057;
  float D.43056;
  float D.43055;
  float D.43054;
  float D.43053;
  float D.43052;
  float D.43051;
  float D.43050;
  float D.43049;
  float D.43048;
  float D.43047;
  float D.43046;
  int n.1897;
  float D.43044;
  float D.43043;
  float D.43042;
  float D.43041;
  int n.1896;
  int n.1895;
  int D.43036;
  int D.43035;
  int D.43032;
  float D.43031;
  float D.43030;
  float * D.43029;
  float D.43028;
  float * D.43027;
  struct ImVec4 D.21278;
  float H.1894;
  float H.1893;
  float S.1892;
  float new_S.1891;
  float iftmp.1890;
  float new_V.1889;
  float * D.43014;
  float * D.43013;
  float new_S.1888;
  float H.1887;
  float S.1886;
  float V.1885;
  float new_V.1884;
  float iftmp.1883;
  float * D.43001;
  float * D.43000;
  float new_V.1882;
  float V.1881;
  float new_V.1880;
  float H.1879;
  float new_H.1878;
  float D.42986;
  float D.42985;
  float * D.42984;
  float D.42983;
  float * D.42982;
  int D.42978;
  bool D.21271;
  int D.42977;
  int D.42975;
  int D.42972;
  bool D.21270;
  int D.42971;
  int D.42969;
  int D.42966;
  bool D.21269;
  int D.42965;
  int D.42963;
  int D.42960;
  float D.42959;
  float D.42958;
  float D.42957;
  float iftmp.1877;
  int D.42950;
  float H.1876;
  float H.1875;
  float iftmp.1874;
  float S.1873;
  float iftmp.1872;
  float V.1871;
  float iftmp.1870;
  float * D.42933;
  float * D.42932;
  long unsigned int D.42925;
  long unsigned int D.42924;
  int D.42921;
  float D.42920;
  float D.42919;
  struct ImVec2 D.21266;
  bool retval.1869;
  float D.42917;
  float D.42916;
  const float * D.42915;
  float D.42914;
  const float * D.42913;
  const float * D.42911;
  int D.42908;
  float iftmp.1868;
  int D.42904;
  float D.42903;
  float D.42902;
  struct ImVec2 D.21264;
  int D.42898;
  float D.42897;
  float D.42896;
  float * D.42895;
  float D.42894;
  float * D.42893;
  int D.42889;
  float iftmp.1867;
  int D.42885;
  float D.42881;
  int D.42878;
  int D.42873;
  float D.42871;
  int D.42868;
  float D.42865;
  float D.42864;
  float D.42863;
  float D.42862;
  float D.42861;
  float D.42860;
  float D.42859;
  float * D.42858;
  bool retval.1866;
  struct ImVec2 D.21261;
  float D.42854;
  struct ImVec2 D.21260;
  float H.1865;
  float D.42848;
  float D.42847;
  float D.42846;
  float D.42845;
  float D.42844;
  bool retval.1864;
  struct ImVec2 D.21259;
  float D.42840;
  struct ImVec2 D.21258;
  int D.42836;
  float V.1863;
  float D.42833;
  float D.42832;
  float D.42831;
  float D.42830;
  float D.42829;
  float D.42828;
  float S.1862;
  float D.42826;
  float D.42825;
  float D.42824;
  float D.42823;
  float D.42822;
  bool retval.1861;
  struct ImVec2 D.21257;
  int D.42816;
  int D.42811;
  float S.1860;
  float D.42807;
  float V.1859;
  float uu.1858;
  float V.1857;
  float D.42803;
  float vv.1856;
  bool D.42798;
  bool retval.1855;
  struct ImVec2 D.21250;
  bool retval.1854;
  float D.42793;
  float D.42792;
  float D.42791;
  float H.1853;
  float D.42789;
  float D.42788;
  float D.42787;
  float H.1852;
  float H.1851;
  float H.1850;
  float H.1849;
  float H.1848;
  float D.42777;
  float D.42776;
  float D.42775;
  float D.42774;
  float D.42771;
  float D.42770;
  float D.42769;
  float D.42766;
  float D.42765;
  float D.42764;
  struct ImVec2 * D.42763;
  struct ImVec2 * D.42762;
  bool retval.1847;
  float D.42758;
  float D.42757;
  float D.42756;
  struct ImVec2 D.21242;
  int D.42753;
  float D.42752;
  float D.42751;
  float * D.42750;
  float D.42749;
  float * D.42748;
  float D.42747;
  float D.42746;
  float D.42745;
  float D.42744;
  float D.42743;
  int D.42742;
  float D.42741;
  float D.42740;
  float D.42739;
  float D.42738;
  float D.42737;
  float D.42736;
  float D.42735;
  float D.42734;
  long unsigned int D.42733;
  long unsigned int D.42732;
  int D.42731;
  float D.42730;
  float D.42729;
  float D.42728;
  float D.42727;
  float D.42726;
  float D.42725;
  float D.42724;
  float D.42723;
  float D.42722;
  float D.42721;
  float iftmp.1846;
  float D.42716;
  int D.42714;
  int D.42712;
  bool iftmp.1845;
  int D.42705;
  int iftmp.1844;
  int D.42702;
  int D.42701;
  int D.42698;
  bool D.42694;
  int D.42693;
  int D.42690;
  int D.42687;
  int D.42686;
  int iftmp.1843;
  int D.42682;
  int D.42678;
  int D.42674;
  int iftmp.1843_25;
  int iftmp.1844_26;
  bool iftmp.1845_27;
  float iftmp.1846_28;
  float iftmp.1867_29;
  float iftmp.1868_30;
  float iftmp.1870_31;
  float iftmp.1872_32;
  float iftmp.1874_33;
  float iftmp.1877_34;
  float iftmp.1883_35;
  float iftmp.1890_36;
  float iftmp.1904_37;
  float iftmp.1910_38;
  bool iftmp.1911_39;
  int _88;
  int _90;
  int _93;
  int _94;
  int _95;
  int _96;
  int iftmp.1843_97;
  int iftmp.1843_98;
  int _100;
  bool _102;
  int _103;
  int _104;
  int _105;
  int _107;
  int iftmp.1844_108;
  int iftmp.1844_109;
  int _111;
  int _112;
  bool iftmp.1845_113;
  bool iftmp.1845_114;
  float _121;
  float _122;
  float iftmp.1846_123;
  float iftmp.1846_124;
  float _125;
  float _126;
  float _127;
  float _128;
  float _131;
  float _132;
  float _133;
  float _135;
  float _136;
  float _138;
  int _139;
  long unsigned int _141;
  long unsigned int _142;
  float _147;
  float _148;
  float _149;
  float _150;
  float _151;
  float _152;
  float _153;
  float _155;
  int _156;
  float _157;
  float _160;
  float _161;
  float _163;
  float _164;
  float * _166;
  float _167;
  float * _168;
  float _169;
  float _170;
  int _176;
  float _177;
  float _178;
  float _179;
  bool retval.1847_184;
  struct ImVec2 * _185;
  struct ImVec2 * _187;
  float _191;
  float _192;
  float _193;
  float _194;
  float _195;
  float _196;
  float _197;
  float _198;
  float _200;
  float _201;
  float H.1848_202;
  float H.1849_204;
  float H.1850_205;
  float H.1851_206;
  float H.1852_210;
  float _211;
  float _212;
  float _213;
  float H.1853_215;
  float _216;
  float _217;
  float _218;
  bool retval.1854_222;
  bool _226;
  bool retval.1855_227;
  float vv.1856_230;
  float _231;
  float V.1857_233;
  float uu.1858_235;
  float V.1859_236;
  float _237;
  float S.1860_239;
  int _249;
  int _252;
  bool retval.1861_257;
  float _258;
  float _259;
  float _260;
  float _261;
  float _262;
  float S.1862_264;
  float _266;
  float _267;
  float _268;
  float _269;
  float _270;
  float _272;
  float V.1863_273;
  int _277;
  float _279;
  bool retval.1864_287;
  float _288;
  float _289;
  float _290;
  float _291;
  float _292;
  float H.1865_294;
  float _300;
  bool retval.1866_308;
  float * _309;
  float _310;
  float _311;
  float _312;
  float _313;
  float _314;
  float _316;
  float _317;
  int _322;
  float _323;
  int _326;
  int _329;
  float _330;
  int _333;
  int _335;
  float iftmp.1867_336;
  float iftmp.1867_337;
  float * _338;
  float _339;
  float * _340;
  float _341;
  float _342;
  int _344;
  float _346;
  float _347;
  int _349;
  int _354;
  const float * _355;
  float iftmp.1868_356;
  float iftmp.1868_357;
  const float * _358;
  float _359;
  const float * _360;
  float _361;
  float _362;
  float _364;
  float _365;
  int _367;
  bool _369;
  bool retval.1869_370;
  long unsigned int _372;
  long unsigned int _373;
  float * _384;
  float * _385;
  float V.1871_386;
  float iftmp.1870_387;
  float iftmp.1870_388;
  float S.1873_389;
  float iftmp.1872_390;
  float iftmp.1872_391;
  float H.1875_392;
  float H.1876_393;
  float iftmp.1874_394;
  float iftmp.1874_395;
  int _397;
  float iftmp.1877_398;
  float iftmp.1877_399;
  float _400;
  float _401;
  float _402;
  int _405;
  int _407;
  int _408;
  int _409;
  bool _411;
  bool _412;
  int _414;
  int _415;
  int _416;
  bool _418;
  bool _419;
  int _421;
  int _422;
  int _423;
  bool _425;
  bool _426;
  float * _429;
  float _430;
  float * _431;
  float _432;
  float _433;
  float new_H.1878_435;
  float H.1879_436;
  float new_V.1880_437;
  float V.1881_438;
  float new_V.1882_439;
  float * _440;
  float * _441;
  float new_V.1884_442;
  float V.1885_443;
  float iftmp.1883_444;
  float iftmp.1883_445;
  float S.1886_446;
  float H.1887_447;
  float new_S.1888_449;
  float * _450;
  float * _451;
  float new_V.1889_452;
  float new_S.1891_453;
  float S.1892_454;
  float iftmp.1890_455;
  float iftmp.1890_456;
  float H.1893_457;
  float H.1894_463;
  float * _467;
  float _468;
  float * _469;
  float _470;
  float _471;
  int _484;
  int _486;
  int _487;
  int n.1895_491;
  int n.1896_492;
  float _493;
  float _494;
  float _495;
  float _496;
  int n.1897_498;
  float _499;
  float _500;
  float _501;
  float _502;
  float _503;
  float _506;
  float _507;
  float _511;
  float _512;
  float _513;
  float _514;
  float _515;
  float _516;
  float _517;
  float _518;
  float _520;
  float _521;
  float _522;
  float _523;
  float _524;
  float _525;
  float _526;
  float _527;
  int n.1898_529;
  int _530;
  unsigned int _531;
  int n.1899_532;
  unsigned int _533;
  struct ImDrawVert * _534;
  long unsigned int _535;
  long unsigned int _536;
  struct ImDrawVert * _537;
  struct ImDrawVert * _538;
  long unsigned int _539;
  long unsigned int _540;
  struct ImDrawVert * _541;
  int n.1900_545;
  int n.1901_546;
  float H.1902_552;
  float _553;
  float _554;
  float H.1903_556;
  float _557;
  float _558;
  float _560;
  float _561;
  float _562;
  float _563;
  float _564;
  float _565;
  float _566;
  float _567;
  float _568;
  float _569;
  float iftmp.1904_571;
  float iftmp.1904_572;
  float _574;
  int _575;
  float _579;
  float V.1905_600;
  float _601;
  float _603;
  float S.1906_604;
  float _606;
  int _620;
  float _635;
  float _636;
  float _637;
  float _638;
  float _639;
  float _640;
  float S.1907_641;
  float _643;
  float _644;
  float _645;
  float _646;
  int _647;
  float _648;
  float _650;
  float _652;
  float _653;
  float _654;
  float _655;
  float _656;
  float _657;
  float V.1908_658;
  float _659;
  float _661;
  float _662;
  float _663;
  float _664;
  int _665;
  float _666;
  float _668;
  int _671;
  unsigned int _672;
  int _673;
  unsigned int _674;
  unsigned int _675;
  unsigned int _676;
  float _677;
  int _678;
  float _679;
  float _680;
  float _681;
  float _682;
  float _683;
  float _685;
  float _686;
  float _687;
  float _688;
  float _689;
  float _697;
  float H.1909_698;
  float _699;
  float _700;
  float _701;
  int _702;
  float _704;
  float _705;
  float _706;
  float _708;
  float _713;
  float _714;
  float _716;
  float iftmp.1910_730;
  float iftmp.1910_731;
  float _734;
  float * _737;
  float _738;
  float _741;
  float _742;
  float _743;
  float _744;
  float _748;
  float _749;
  unsigned int _752;
  unsigned int _753;
  float _755;
  float _756;
  float _757;
  float _758;
  float _759;
  int _760;
  float _763;
  float _764;
  float _766;
  long unsigned int _778;
  long unsigned int _779;
  int _780;
  bool iftmp.1911_781;
  bool iftmp.1911_782;
  bool _783;

  <bb 2>:
  g_78 = GImGui;
  window_80 = ImGui::GetCurrentWindow ();
  draw_list_81 = window_80->DrawList;
  style_82 = &g_78->Style;
  io_83 = &g_78->IO;
  ImGui::PushID (label_84(D));
  ImGui::BeginGroup ();
  _88 = flags_87(D) & 256;
  if (_88 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  flags_89 = flags_87(D) | 16;

  <bb 4>:
  # flags_1 = PHI <flags_87(D)(2), flags_89(3)>
  _90 = flags_1 & 8;
  if (_90 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ColorPickerOptionsPopup (flags_1, col_91(D));

  <bb 6>:
  _93 = flags_1 & 786432;
  if (_93 == 0)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  _94 = g_78->ColorEditOptions;
  _95 = _94 & 786432;
  if (_95 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _96 = g_78->ColorEditOptions;
  iftmp.1843_97 = _96 & 786432;
  goto <bb 10>;

  <bb 9>:
  iftmp.1843_98 = 262144;

  <bb 10>:
  # iftmp.1843_25 = PHI <iftmp.1843_97(8), iftmp.1843_98(9)>
  flags_99 = iftmp.1843_25 | flags_1;

  <bb 11>:
  # flags_2 = PHI <flags_1(6), flags_99(10)>
  _100 = flags_2 & 786432;
  _102 = ImIsPowerOfTwo (_100);
  if (_102 != 0)
    goto <bb 13>;
  else
    goto <bb 12>;

  <bb 12>:
  __assert_fail ("ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 11880, &__PRETTY_FUNCTION__);

  <bb 13>:
  _103 = flags_2 & 8;
  if (_103 == 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _104 = g_78->ColorEditOptions;
  _105 = _104 & 512;
  flags_106 = _105 | flags_2;

  <bb 15>:
  # flags_3 = PHI <flags_2(13), flags_106(14)>
  _107 = flags_3 & 2;
  if (_107 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  iftmp.1844_108 = 3;
  goto <bb 18>;

  <bb 17>:
  iftmp.1844_109 = 4;

  <bb 18>:
  # iftmp.1844_26 = PHI <iftmp.1844_108(16), iftmp.1844_109(17)>
  components_110 = iftmp.1844_26;
  _111 = flags_3 & 512;
  if (_111 != 0)
    goto <bb 19>;
  else
    goto <bb 21>;

  <bb 19>:
  _112 = flags_3 & 2;
  if (_112 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  iftmp.1845_113 = 1;
  goto <bb 22>;

  <bb 21>:
  iftmp.1845_114 = 0;

  <bb 22>:
  # iftmp.1845_27 = PHI <iftmp.1845_113(20), iftmp.1845_114(21)>
  alpha_bar_115 = iftmp.1845_27;
  picker_pos = window_80->DC.CursorPos;
  square_sz_118 = ImGui::GetFrameHeight ();
  bars_width_119 = square_sz_118;
  _121 = ImGui::CalcItemWidth ();
  _122 = _121;
  if (alpha_bar_115 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.1846_123 = 2.0e+0;
  goto <bb 25>;

  <bb 24>:
  iftmp.1846_124 = 1.0e+0;

  <bb 25>:
  # iftmp.1846_28 = PHI <iftmp.1846_123(23), iftmp.1846_124(24)>
  _125 = style_82->ItemInnerSpacing.x;
  _126 = _125 + bars_width_119;
  _127 = iftmp.1846_28 * _126;
  _128 = _122 - _127;
  sv_picker_size_130 = ImMax (bars_width_119, _128);
  _131 = picker_pos.x;
  _132 = _131 + sv_picker_size_130;
  _133 = style_82->ItemInnerSpacing.x;
  bar0_pos_x_134 = _132 + _133;
  _135 = bar0_pos_x_134 + bars_width_119;
  _136 = style_82->ItemInnerSpacing.x;
  bar1_pos_x_137 = _135 + _136;
  _138 = bars_width_119 * 2.0000000298023223876953125e-1;
  _139 = (int) _138;
  bars_triangles_half_sz_140 = (float) _139;
  _141 = (long unsigned int) components_110;
  _142 = _141 * 4;
  memcpy (&backup_initial_col, col_91(D), _142);
  wheel_thickness_144 = sv_picker_size_130 * 7.999999821186065673828125e-2;
  wheel_r_outer_145 = sv_picker_size_130 * 5.0e-1;
  wheel_r_inner_146 = wheel_r_outer_145 - wheel_thickness_144;
  _147 = picker_pos.y;
  _148 = sv_picker_size_130 * 5.0e-1;
  _149 = _147 + _148;
  _150 = picker_pos.x;
  _151 = sv_picker_size_130 + bars_width_119;
  _152 = _151 * 5.0e-1;
  _153 = _150 + _152;
  ImVec2::ImVec2 (&wheel_center, _153, _149);
  _155 = sv_picker_size_130 * 2.700000070035457611083984375e-2;
  _156 = (int) _155;
  _157 = (float) _156;
  triangle_r_158 = wheel_r_inner_146 - _157;
  ImVec2::ImVec2 (&triangle_pa, triangle_r_158, 0.0);
  _160 = triangle_r_158 * -8.6602497100830078125e-1;
  _161 = triangle_r_158 * -5.0e-1;
  ImVec2::ImVec2 (&triangle_pb, _161, _160);
  _163 = triangle_r_158 * 8.6602497100830078125e-1;
  _164 = triangle_r_158 * -5.0e-1;
  ImVec2::ImVec2 (&triangle_pc, _164, _163);
  _166 = col_91(D) + 8;
  _167 = *_166;
  _168 = col_91(D) + 4;
  _169 = *_168;
  _170 = *col_91(D);
  ImGui::ColorConvertRGBtoHSV (_170, _169, _167, &H, &S, &V);
  value_changed_172 = 0;
  value_changed_h_173 = 0;
  value_changed_sv_174 = 0;
  ImGui::PushItemFlag (8, 1);
  _176 = flags_3 & 524288;
  if (_176 != 0)
    goto <bb 26>;
  else
    goto <bb 40>;

  <bb 26>:
  _177 = style_82->ItemInnerSpacing.x;
  _178 = _177 + sv_picker_size_130;
  _179 = _178 + bars_width_119;
  ImVec2::ImVec2 (&D.21242, _179, sv_picker_size_130);
  ImGui::InvisibleButton ("hsv", &D.21242);
  D.21242 ={v} {CLOBBER};
  retval.1847_184 = ImGui::IsItemActive ();
  if (retval.1847_184 != 0)
    goto <bb 27>;
  else
    goto <bb 37>;

  <bb 27>:
  _185 = &g_78->IO.MouseClickedPos[0];
  initial_off = operator- (_185, &wheel_center);
  _187 = &g_78->IO.MousePos;
  current_off = operator- (_187, &wheel_center);
  initial_dist2_190 = ImLengthSqr (&initial_off);
  _191 = wheel_r_inner_146 - 1.0e+0;
  _192 = wheel_r_inner_146 - 1.0e+0;
  _193 = _191 * _192;
  if (_193 <= initial_dist2_190)
    goto <bb 28>;
  else
    goto <bb 32>;

  <bb 28>:
  _194 = wheel_r_outer_145 + 1.0e+0;
  _195 = wheel_r_outer_145 + 1.0e+0;
  _196 = _194 * _195;
  if (_196 >= initial_dist2_190)
    goto <bb 29>;
  else
    goto <bb 32>;

  <bb 29>:
  _197 = current_off.x;
  _198 = current_off.y;
  _200 = atan2f (_198, _197);
  _201 = _200 / 3.1415927410125732421875e+0;
  H.1848_202 = _201 * 5.0e-1;
  H = H.1848_202;
  H.1849_204 = H;
  if (H.1849_204 < 0.0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  H.1850_205 = H;
  H.1851_206 = H.1850_205 + 1.0e+0;
  H = H.1851_206;

  <bb 31>:
  value_changed_h_208 = 1;
  value_changed_209 = value_changed_h_208;

  <bb 32>:
  # value_changed_4 = PHI <value_changed_172(27), value_changed_172(28), value_changed_209(31)>
  # value_changed_h_17 = PHI <value_changed_h_173(27), value_changed_h_173(28), value_changed_h_208(31)>
  H.1852_210 = H;
  _211 = -H.1852_210;
  _212 = _211 * 2.0e+0;
  _213 = _212 * 3.1415927410125732421875e+0;
  cos_hue_angle_214 = cosf (_213);
  H.1853_215 = H;
  _216 = -H.1853_215;
  _217 = _216 * 2.0e+0;
  _218 = _217 * 3.1415927410125732421875e+0;
  sin_hue_angle_219 = sinf (_218);
  D.21250 = ImRotate (&initial_off, cos_hue_angle_214, sin_hue_angle_219);
  retval.1854_222 = ImTriangleContainsPoint (&triangle_pa, &triangle_pb, &triangle_pc, &D.21250);
  D.21250 ={v} {CLOBBER};
  if (retval.1854_222 != 0)
    goto <bb 33>;
  else
    goto <bb 36>;

  <bb 33>:
  current_off_unrotated = ImRotate (&current_off, cos_hue_angle_214, sin_hue_angle_219);
  _226 = ImTriangleContainsPoint (&triangle_pa, &triangle_pb, &triangle_pc, &current_off_unrotated);
  retval.1855_227 = ~_226;
  if (retval.1855_227 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

  <bb 34>:
  current_off_unrotated = ImTriangleClosestPoint (&triangle_pa, &triangle_pb, &triangle_pc, &current_off_unrotated);

  <bb 35>:
  ImTriangleBarycentricCoords (&triangle_pa, &triangle_pb, &triangle_pc, &current_off_unrotated, &uu, &vv, &ww);
  vv.1856_230 = vv;
  _231 = 1.0e+0 - vv.1856_230;
  V.1857_233 = ImClamp (_231, 9.99999974737875163555145263671875e-5, 1.0e+0);
  V = V.1857_233;
  uu.1858_235 = uu;
  V.1859_236 = V;
  _237 = uu.1858_235 / V.1859_236;
  S.1860_239 = ImClamp (_237, 9.99999974737875163555145263671875e-5, 1.0e+0);
  S = S.1860_239;
  value_changed_sv_241 = 1;
  value_changed_242 = value_changed_sv_241;
  current_off_unrotated ={v} {CLOBBER};
  uu ={v} {CLOBBER};
  vv ={v} {CLOBBER};
  ww ={v} {CLOBBER};

  <bb 36>:
  # value_changed_5 = PHI <value_changed_4(32), value_changed_242(35)>
  # value_changed_sv_20 = PHI <value_changed_sv_174(32), value_changed_sv_241(35)>
  initial_off ={v} {CLOBBER};
  current_off ={v} {CLOBBER};

  <bb 37>:
  # value_changed_6 = PHI <value_changed_172(26), value_changed_5(36)>
  # value_changed_h_18 = PHI <value_changed_h_173(26), value_changed_h_17(36)>
  # value_changed_sv_21 = PHI <value_changed_sv_174(26), value_changed_sv_20(36)>
  _249 = flags_3 & 8;
  if (_249 == 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  ImGui::OpenPopupOnItemClick ("context", 1);

  <bb 39>:
  goto <bb 47>;

  <bb 40>:
  _252 = flags_3 & 262144;
  if (_252 != 0)
    goto <bb 41>;
  else
    goto <bb 47>;

  <bb 41>:
  ImVec2::ImVec2 (&D.21257, sv_picker_size_130, sv_picker_size_130);
  ImGui::InvisibleButton ("sv", &D.21257);
  D.21257 ={v} {CLOBBER};
  retval.1861_257 = ImGui::IsItemActive ();
  if (retval.1861_257 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

  <bb 42>:
  _258 = io_83->MousePos.x;
  _259 = picker_pos.x;
  _260 = _258 - _259;
  _261 = sv_picker_size_130 - 1.0e+0;
  _262 = _260 / _261;
  S.1862_264 = ImSaturate (_262);
  S = S.1862_264;
  _266 = io_83->MousePos.y;
  _267 = picker_pos.y;
  _268 = _266 - _267;
  _269 = sv_picker_size_130 - 1.0e+0;
  _270 = _268 / _269;
  _272 = ImSaturate (_270);
  V.1863_273 = 1.0e+0 - _272;
  V = V.1863_273;
  value_changed_sv_275 = 1;
  value_changed_276 = value_changed_sv_275;

  <bb 43>:
  # value_changed_7 = PHI <value_changed_172(41), value_changed_276(42)>
  # value_changed_sv_22 = PHI <value_changed_sv_174(41), value_changed_sv_275(42)>
  _277 = flags_3 & 8;
  if (_277 == 0)
    goto <bb 44>;
  else
    goto <bb 45>;

  <bb 44>:
  ImGui::OpenPopupOnItemClick ("context", 1);

  <bb 45>:
  _279 = picker_pos.y;
  ImVec2::ImVec2 (&D.21258, bar0_pos_x_134, _279);
  ImGui::SetCursorScreenPos (&D.21258);
  D.21258 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.21259, bars_width_119, sv_picker_size_130);
  ImGui::InvisibleButton ("hue", &D.21259);
  D.21259 ={v} {CLOBBER};
  retval.1864_287 = ImGui::IsItemActive ();
  if (retval.1864_287 != 0)
    goto <bb 46>;
  else
    goto <bb 47>;

  <bb 46>:
  _288 = io_83->MousePos.y;
  _289 = picker_pos.y;
  _290 = _288 - _289;
  _291 = sv_picker_size_130 - 1.0e+0;
  _292 = _290 / _291;
  H.1865_294 = ImSaturate (_292);
  H = H.1865_294;
  value_changed_h_296 = 1;
  value_changed_297 = value_changed_h_296;

  <bb 47>:
  # value_changed_8 = PHI <value_changed_6(39), value_changed_172(40), value_changed_297(46), value_changed_7(45)>
  # value_changed_h_19 = PHI <value_changed_h_18(39), value_changed_h_173(40), value_changed_h_296(46), value_changed_h_173(45)>
  # value_changed_sv_23 = PHI <value_changed_sv_21(39), value_changed_sv_174(40), value_changed_sv_22(46), value_changed_sv_22(45)>
  if (alpha_bar_115 != 0)
    goto <bb 48>;
  else
    goto <bb 50>;

  <bb 48>:
  _300 = picker_pos.y;
  ImVec2::ImVec2 (&D.21260, bar1_pos_x_137, _300);
  ImGui::SetCursorScreenPos (&D.21260);
  D.21260 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.21261, bars_width_119, sv_picker_size_130);
  ImGui::InvisibleButton ("alpha", &D.21261);
  D.21261 ={v} {CLOBBER};
  retval.1866_308 = ImGui::IsItemActive ();
  if (retval.1866_308 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

  <bb 49>:
  _309 = col_91(D) + 12;
  _310 = io_83->MousePos.y;
  _311 = picker_pos.y;
  _312 = _310 - _311;
  _313 = sv_picker_size_130 - 1.0e+0;
  _314 = _312 / _313;
  _316 = ImSaturate (_314);
  _317 = 1.0e+0 - _316;
  *_309 = _317;
  value_changed_319 = 1;

  <bb 50>:
  # value_changed_9 = PHI <value_changed_8(47), value_changed_319(49), value_changed_8(48)>
  ImGui::PopItemFlag ();
  _322 = flags_3 & 256;
  if (_322 == 0)
    goto <bb 51>;
  else
    goto <bb 52>;

  <bb 51>:
  _323 = style_82->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _323);
  ImGui::BeginGroup ();

  <bb 52>:
  _326 = flags_3 & 128;
  if (_326 == 0)
    goto <bb 53>;
  else
    goto <bb 58>;

  <bb 53>:
  label_display_end_328 = ImGui::FindRenderedTextEnd (label_84(D), 0B);
  if (label_84(D) != label_display_end_328)
    goto <bb 54>;
  else
    goto <bb 57>;

  <bb 54>:
  _329 = flags_3 & 256;
  if (_329 != 0)
    goto <bb 55>;
  else
    goto <bb 56>;

  <bb 55>:
  _330 = style_82->ItemInnerSpacing.x;
  ImGui::SameLine (0.0, _330);

  <bb 56>:
  ImGui::TextUnformatted (label_84(D), label_display_end_328);

  <bb 57>:

  <bb 58>:
  _333 = flags_3 & 256;
  if (_333 == 0)
    goto <bb 59>;
  else
    goto <bb 72>;

  <bb 59>:
  ImGui::PushItemFlag (16, 1);
  _335 = flags_3 & 2;
  if (_335 == 0)
    goto <bb 60>;
  else
    goto <bb 61>;

  <bb 60>:
  iftmp.1867_336 = MEM[(float *)col_91(D) + 12B];
  goto <bb 62>;

  <bb 61>:
  iftmp.1867_337 = 1.0e+0;

  <bb 62>:
  # iftmp.1867_29 = PHI <iftmp.1867_336(60), iftmp.1867_337(61)>
  _338 = col_91(D) + 8;
  _339 = *_338;
  _340 = col_91(D) + 4;
  _341 = *_340;
  _342 = *col_91(D);
  ImVec4::ImVec4 (&col_v4, _342, _341, _339, iftmp.1867_29);
  _344 = flags_3 & 128;
  if (_344 != 0)
    goto <bb 63>;
  else
    goto <bb 64>;

  <bb 63>:
  ImGui::Text ("Current");

  <bb 64>:
  _346 = square_sz_118 * 2.0e+0;
  _347 = square_sz_118 * 3.0e+0;
  ImVec2::ImVec2 (&D.21264, _347, _346);
  _349 = flags_3 & 7232;
  ImGui::ColorButton ("##current", &col_v4, _349, D.21264);
  D.21264 ={v} {CLOBBER};
  if (ref_col_352(D) != 0B)
    goto <bb 65>;
  else
    goto <bb 71>;

  <bb 65>:
  ImGui::Text ("Original");
  _354 = flags_3 & 2;
  if (_354 == 0)
    goto <bb 66>;
  else
    goto <bb 67>;

  <bb 66>:
  _355 = ref_col_352(D) + 12;
  iftmp.1868_356 = *_355;
  goto <bb 68>;

  <bb 67>:
  iftmp.1868_357 = 1.0e+0;

  <bb 68>:
  # iftmp.1868_30 = PHI <iftmp.1868_356(66), iftmp.1868_357(67)>
  _358 = ref_col_352(D) + 8;
  _359 = *_358;
  _360 = ref_col_352(D) + 4;
  _361 = *_360;
  _362 = *ref_col_352(D);
  ImVec4::ImVec4 (&ref_col_v4, _362, _361, _359, iftmp.1868_30);
  _364 = square_sz_118 * 2.0e+0;
  _365 = square_sz_118 * 3.0e+0;
  ImVec2::ImVec2 (&D.21266, _365, _364);
  _367 = flags_3 & 7232;
  _369 = ImGui::ColorButton ("##original", &ref_col_v4, _367, D.21266);
  retval.1869_370 = _369;
  D.21266 ={v} {CLOBBER};
  if (retval.1869_370 != 0)
    goto <bb 69>;
  else
    goto <bb 70>;

  <bb 69>:
  _372 = (long unsigned int) components_110;
  _373 = _372 * 4;
  memcpy (col_91(D), ref_col_352(D), _373);
  value_changed_375 = 1;

  <bb 70>:
  # value_changed_10 = PHI <value_changed_9(68), value_changed_375(69)>
  ref_col_v4 ={v} {CLOBBER};

  <bb 71>:
  # value_changed_11 = PHI <value_changed_9(64), value_changed_10(70)>
  ImGui::PopItemFlag ();
  ImGui::EndGroup ();
  col_v4 ={v} {CLOBBER};

  <bb 72>:
  # value_changed_12 = PHI <value_changed_9(58), value_changed_11(71)>
  if (value_changed_h_19 != 0)
    goto <bb 74>;
  else
    goto <bb 73>;

  <bb 73>:
  if (value_changed_sv_23 != 0)
    goto <bb 74>;
  else
    goto <bb 84>;

  <bb 74>:
  _384 = col_91(D) + 8;
  _385 = col_91(D) + 4;
  V.1871_386 = V;
  if (V.1871_386 > 0.0)
    goto <bb 75>;
  else
    goto <bb 76>;

  <bb 75>:
  iftmp.1870_387 = V;
  goto <bb 77>;

  <bb 76>:
  iftmp.1870_388 = 9.999999974752427078783512115478515625e-7;

  <bb 77>:
  # iftmp.1870_31 = PHI <iftmp.1870_387(75), iftmp.1870_388(76)>
  S.1873_389 = S;
  if (S.1873_389 > 0.0)
    goto <bb 78>;
  else
    goto <bb 79>;

  <bb 78>:
  iftmp.1872_390 = S;
  goto <bb 80>;

  <bb 79>:
  iftmp.1872_391 = 9.99999974737875163555145263671875e-6;

  <bb 80>:
  # iftmp.1872_32 = PHI <iftmp.1872_390(78), iftmp.1872_391(79)>
  H.1875_392 = H;
  if (H.1875_392 >= 1.0e+0)
    goto <bb 81>;
  else
    goto <bb 82>;

  <bb 81>:
  H.1876_393 = H;
  iftmp.1874_394 = H.1876_393 - 9.99999974737875163555145263671875e-6;
  goto <bb 83>;

  <bb 82>:
  iftmp.1874_395 = H;

  <bb 83>:
  # iftmp.1874_33 = PHI <iftmp.1874_394(81), iftmp.1874_395(82)>
  ImGui::ColorConvertHSVtoRGB (iftmp.1874_33, iftmp.1872_32, iftmp.1870_31, col_91(D), _385, _384);

  <bb 84>:
  _397 = flags_3 & 32;
  if (_397 == 0)
    goto <bb 85>;
  else
    goto <bb 98>;

  <bb 85>:
  if (alpha_bar_115 != 0)
    goto <bb 86>;
  else
    goto <bb 87>;

  <bb 86>:
  iftmp.1877_398 = bar1_pos_x_137;
  goto <bb 88>;

  <bb 87>:
  iftmp.1877_399 = bar0_pos_x_134;

  <bb 88>:
  # iftmp.1877_34 = PHI <iftmp.1877_398(86), iftmp.1877_399(87)>
  _400 = iftmp.1877_34 + bars_width_119;
  _401 = picker_pos.x;
  _402 = _400 - _401;
  ImGui::PushItemWidth (_402);
  sub_flags_to_forward_404 = 203802;
  _405 = flags_3 & sub_flags_to_forward_404;
  sub_flags_406 = _405 | 4;
  _407 = flags_3 & 8192;
  if (_407 != 0)
    goto <bb 90>;
  else
    goto <bb 89>;

  <bb 89>:
  _408 = flags_3 & 57344;
  if (_408 == 0)
    goto <bb 90>;
  else
    goto <bb 91>;

  <bb 90>:
  _409 = sub_flags_406 | 8192;
  _411 = ImGui::ColorEdit4 ("##rgb", col_91(D), _409);
  _412 = _411;
  value_changed_413 = value_changed_12 | _412;

  <bb 91>:
  # value_changed_13 = PHI <value_changed_12(89), value_changed_413(90)>
  _414 = flags_3 & 16384;
  if (_414 != 0)
    goto <bb 93>;
  else
    goto <bb 92>;

  <bb 92>:
  _415 = flags_3 & 57344;
  if (_415 == 0)
    goto <bb 93>;
  else
    goto <bb 94>;

  <bb 93>:
  _416 = sub_flags_406 | 16384;
  _418 = ImGui::ColorEdit4 ("##hsv", col_91(D), _416);
  _419 = _418;
  value_changed_420 = value_changed_13 | _419;

  <bb 94>:
  # value_changed_14 = PHI <value_changed_13(92), value_changed_420(93)>
  _421 = flags_3 & 32768;
  if (_421 != 0)
    goto <bb 96>;
  else
    goto <bb 95>;

  <bb 95>:
  _422 = flags_3 & 57344;
  if (_422 == 0)
    goto <bb 96>;
  else
    goto <bb 97>;

  <bb 96>:
  _423 = sub_flags_406 | 32768;
  _425 = ImGui::ColorEdit4 ("##hex", col_91(D), _423);
  _426 = _425;
  value_changed_427 = value_changed_14 | _426;

  <bb 97>:
  # value_changed_15 = PHI <value_changed_14(95), value_changed_427(96)>
  ImGui::PopItemWidth ();

  <bb 98>:
  # value_changed_16 = PHI <value_changed_12(84), value_changed_15(97)>
  if (value_changed_16 != 0)
    goto <bb 99>;
  else
    goto <bb 114>;

  <bb 99>:
  _429 = col_91(D) + 8;
  _430 = *_429;
  _431 = col_91(D) + 4;
  _432 = *_431;
  _433 = *col_91(D);
  ImGui::ColorConvertRGBtoHSV (_433, _432, _430, &new_H, &new_S, &new_V);
  new_H.1878_435 = new_H;
  if (new_H.1878_435 <= 0.0)
    goto <bb 100>;
  else
    goto <bb 113>;

  <bb 100>:
  H.1879_436 = H;
  if (H.1879_436 > 0.0)
    goto <bb 101>;
  else
    goto <bb 113>;

  <bb 101>:
  new_V.1880_437 = new_V;
  if (new_V.1880_437 <= 0.0)
    goto <bb 102>;
  else
    goto <bb 107>;

  <bb 102>:
  V.1881_438 = V;
  new_V.1882_439 = new_V;
  if (V.1881_438 != new_V.1882_439)
    goto <bb 103>;
  else
    goto <bb 107>;

  <bb 103>:
  _440 = col_91(D) + 8;
  _441 = col_91(D) + 4;
  new_V.1884_442 = new_V;
  if (new_V.1884_442 <= 0.0)
    goto <bb 104>;
  else
    goto <bb 105>;

  <bb 104>:
  V.1885_443 = V;
  iftmp.1883_444 = V.1885_443 * 5.0e-1;
  goto <bb 106>;

  <bb 105>:
  iftmp.1883_445 = new_V;

  <bb 106>:
  # iftmp.1883_35 = PHI <iftmp.1883_444(104), iftmp.1883_445(105)>
  S.1886_446 = S;
  H.1887_447 = H;
  ImGui::ColorConvertHSVtoRGB (H.1887_447, S.1886_446, iftmp.1883_35, col_91(D), _441, _440);
  goto <bb 112>;

  <bb 107>:
  new_S.1888_449 = new_S;
  if (new_S.1888_449 <= 0.0)
    goto <bb 108>;
  else
    goto <bb 112>;

  <bb 108>:
  _450 = col_91(D) + 8;
  _451 = col_91(D) + 4;
  new_V.1889_452 = new_V;
  new_S.1891_453 = new_S;
  if (new_S.1891_453 <= 0.0)
    goto <bb 109>;
  else
    goto <bb 110>;

  <bb 109>:
  S.1892_454 = S;
  iftmp.1890_455 = S.1892_454 * 5.0e-1;
  goto <bb 111>;

  <bb 110>:
  iftmp.1890_456 = new_S;

  <bb 111>:
  # iftmp.1890_36 = PHI <iftmp.1890_455(109), iftmp.1890_456(110)>
  H.1893_457 = H;
  ImGui::ColorConvertHSVtoRGB (H.1893_457, iftmp.1890_36, new_V.1889_452, col_91(D), _451, _450);

  <bb 112>:

  <bb 113>:
  new_H ={v} {CLOBBER};
  new_S ={v} {CLOBBER};
  new_V ={v} {CLOBBER};

  <bb 114>:
  ImVec4::ImVec4 (&hue_color_f, 1.0e+0, 1.0e+0, 1.0e+0, 1.0e+0);
  H.1894_463 = H;
  ImGui::ColorConvertHSVtoRGB (H.1894_463, 1.0e+0, 1.0e+0, &hue_color_f.x, &hue_color_f.y, &hue_color_f.z);
  hue_color32_466 = ImGui::ColorConvertFloat4ToU32 (&hue_color_f);
  _467 = col_91(D) + 8;
  _468 = *_467;
  _469 = col_91(D) + 4;
  _470 = *_469;
  _471 = *col_91(D);
  ImVec4::ImVec4 (&D.21278, _471, _470, _468, 1.0e+0);
  col32_no_alpha_474 = ImGui::ColorConvertFloat4ToU32 (&D.21278);
  D.21278 ={v} {CLOBBER};
  hue_colors[0] = 4278190335;
  hue_colors[1] = 4278255615;
  hue_colors[2] = 4278255360;
  hue_colors[3] = 4294967040;
  hue_colors[4] = 4294901760;
  hue_colors[5] = 4294902015;
  hue_colors[6] = 4278190335;
  ImVec2::ImVec2 (&sv_cursor_pos);
  _484 = flags_3 & 524288;
  if (_484 != 0)
    goto <bb 115>;
  else
    goto <bb 125>;

  <bb 115>:
  aeps_485 = 1.5e+0 / wheel_r_outer_145;
  _486 = (int) wheel_r_outer_145;
  _487 = _486 / 12;
  segment_per_arc_489 = ImMax (4, _487);
  n = 0;

  <bb 116>:
  n.1895_491 = n;
  if (n.1895_491 > 5)
    goto <bb 121>;
  else
    goto <bb 117>;

  <bb 117>:
  n.1896_492 = n;
  _493 = (float) n.1896_492;
  _494 = _493 / 6.0e+0;
  _495 = _494 * 2.0e+0;
  _496 = _495 * 3.1415927410125732421875e+0;
  a0_497 = _496 - aeps_485;
  n.1897_498 = n;
  _499 = (float) n.1897_498;
  _500 = _499 + 1.0e+0;
  _501 = _500 / 6.0e+0;
  _502 = _501 * 2.0e+0;
  _503 = _502 * 3.1415927410125732421875e+0;
  a1_504 = _503 + aeps_485;
  vert_start_idx_505 = draw_list_81->VtxBuffer.Size;
  _506 = wheel_r_inner_146 + wheel_r_outer_145;
  _507 = _506 * 5.0e-1;
  ImDrawList::PathArcTo (draw_list_81, &wheel_center, _507, a0_497, a1_504, segment_per_arc_489);

  <bb 118>:
  ImDrawList::PathStroke (draw_list_81, 4294967295, 0, wheel_thickness_144);

  <bb 119>:
  vert_end_idx_510 = draw_list_81->VtxBuffer.Size;
  _511 = wheel_center.y;
  _512 = sinf (a0_497);
  _513 = _512 * wheel_r_inner_146;
  _514 = _511 + _513;
  _515 = wheel_center.x;
  _516 = cosf (a0_497);
  _517 = _516 * wheel_r_inner_146;
  _518 = _515 + _517;
  ImVec2::ImVec2 (&gradient_p0, _518, _514);
  _520 = wheel_center.y;
  _521 = sinf (a1_504);
  _522 = _521 * wheel_r_inner_146;
  _523 = _520 + _522;
  _524 = wheel_center.x;
  _525 = cosf (a1_504);
  _526 = _525 * wheel_r_inner_146;
  _527 = _524 + _526;
  ImVec2::ImVec2 (&gradient_p1, _527, _523);
  n.1898_529 = n;
  _530 = n.1898_529 + 1;
  _531 = hue_colors[_530];
  n.1899_532 = n;
  _533 = hue_colors[n.1899_532];
  _534 = draw_list_81->VtxBuffer.Data;
  _535 = (long unsigned int) vert_end_idx_510;
  _536 = _535 * 20;
  _537 = _534 + _536;
  _538 = draw_list_81->VtxBuffer.Data;
  _539 = (long unsigned int) vert_start_idx_505;
  _540 = _539 * 20;
  _541 = _538 + _540;
  ImGui::ShadeVertsLinearColorGradientKeepAlpha (_541, _537, gradient_p0, gradient_p1, _533, _531);

  <bb 120>:
  gradient_p0 ={v} {CLOBBER};
  gradient_p1 ={v} {CLOBBER};
  n.1900_545 = n;
  n.1901_546 = n.1900_545 + 1;
  n = n.1901_546;
  goto <bb 116>;

  <bb 121>:
  n ={v} {CLOBBER};
  H.1902_552 = H;
  _553 = H.1902_552 * 2.0e+0;
  _554 = _553 * 3.1415927410125732421875e+0;
  cos_hue_angle_555 = cosf (_554);
  H.1903_556 = H;
  _557 = H.1903_556 * 2.0e+0;
  _558 = _557 * 3.1415927410125732421875e+0;
  sin_hue_angle_559 = sinf (_558);
  _560 = wheel_center.y;
  _561 = wheel_r_inner_146 + wheel_r_outer_145;
  _562 = _561 * sin_hue_angle_559;
  _563 = _562 * 5.0e-1;
  _564 = _560 + _563;
  _565 = wheel_center.x;
  _566 = wheel_r_inner_146 + wheel_r_outer_145;
  _567 = _566 * cos_hue_angle_555;
  _568 = _567 * 5.0e-1;
  _569 = _565 + _568;
  ImVec2::ImVec2 (&hue_cursor_pos, _569, _564);
  if (value_changed_h_19 != 0)
    goto <bb 122>;
  else
    goto <bb 123>;

  <bb 122>:
  iftmp.1904_571 = wheel_thickness_144 * 6.4999997615814208984375e-1;
  goto <bb 124>;

  <bb 123>:
  iftmp.1904_572 = wheel_thickness_144 * 5.50000011920928955078125e-1;

  <bb 124>:
  # iftmp.1904_37 = PHI <iftmp.1904_571(122), iftmp.1904_572(123)>
  hue_cursor_rad_573 = iftmp.1904_37;
  _574 = hue_cursor_rad_573 / 1.39999997615814208984375e+0;
  _575 = (int) _574;
  hue_cursor_segments_577 = ImClamp (_575, 9, 32);
  ImDrawList::AddCircleFilled (draw_list_81, &hue_cursor_pos, hue_cursor_rad_573, hue_color32_466, hue_cursor_segments_577);
  _579 = hue_cursor_rad_573 + 1.0e+0;
  ImDrawList::AddCircle (draw_list_81, &hue_cursor_pos, _579, 4286611584, hue_cursor_segments_577, 1.0e+0);
  ImDrawList::AddCircle (draw_list_81, &hue_cursor_pos, hue_cursor_rad_573, 4294967295, hue_cursor_segments_577, 1.0e+0);
  D.21298 = ImRotate (&triangle_pa, cos_hue_angle_555, sin_hue_angle_559);
  tra = operator+ (&wheel_center, &D.21298);
  D.21298 ={v} {CLOBBER};
  D.21301 = ImRotate (&triangle_pb, cos_hue_angle_555, sin_hue_angle_559);
  trb = operator+ (&wheel_center, &D.21301);
  D.21301 ={v} {CLOBBER};
  D.21304 = ImRotate (&triangle_pc, cos_hue_angle_555, sin_hue_angle_559);
  trc = operator+ (&wheel_center, &D.21304);
  D.21304 ={v} {CLOBBER};
  uv_white = ImGui::GetFontTexUvWhitePixel ();
  ImDrawList::PrimReserve (draw_list_81, 6, 6);
  ImDrawList::PrimVtx (draw_list_81, &tra, &uv_white, hue_color32_466);
  ImDrawList::PrimVtx (draw_list_81, &trb, &uv_white, hue_color32_466);
  ImDrawList::PrimVtx (draw_list_81, &trc, &uv_white, 4294967295);
  ImDrawList::PrimVtx (draw_list_81, &tra, &uv_white, 0);
  ImDrawList::PrimVtx (draw_list_81, &trb, &uv_white, 4278190080);
  ImDrawList::PrimVtx (draw_list_81, &trc, &uv_white, 0);
  ImDrawList::AddTriangle (draw_list_81, &tra, &trb, &trc, 4286611584, 1.5e+0);
  V.1905_600 = V;
  _601 = 1.0e+0 - V.1905_600;
  _603 = ImSaturate (_601);
  S.1906_604 = S;
  _606 = ImSaturate (S.1906_604);
  D.21308 = ImLerp (&trc, &tra, _606);
  sv_cursor_pos = ImLerp (&D.21308, &trb, _603);
  D.21308 ={v} {CLOBBER};
  hue_cursor_pos ={v} {CLOBBER};
  tra ={v} {CLOBBER};
  trb ={v} {CLOBBER};
  trc ={v} {CLOBBER};
  uv_white ={v} {CLOBBER};
  goto <bb 130>;

  <bb 125>:
  _620 = flags_3 & 262144;
  if (_620 != 0)
    goto <bb 126>;
  else
    goto <bb 130>;

  <bb 126>:
  ImVec2::ImVec2 (&D.21310, sv_picker_size_130, sv_picker_size_130);
  D.21311 = operator+ (&picker_pos, &D.21310);
  ImDrawList::AddRectFilledMultiColor (draw_list_81, &picker_pos, &D.21311, 4294967295, hue_color32_466, hue_color32_466, 4294967295);
  D.21311 ={v} {CLOBBER};
  D.21310 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.21312, sv_picker_size_130, sv_picker_size_130);
  D.21313 = operator+ (&picker_pos, &D.21312);
  ImDrawList::AddRectFilledMultiColor (draw_list_81, &picker_pos, &D.21313, 0, 0, 4278190080, 4278190080);
  D.21313 ={v} {CLOBBER};
  D.21312 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.21314, sv_picker_size_130, sv_picker_size_130);
  D.43116 = operator+ (&picker_pos, &D.21314);
  ImGui::RenderFrameBorder (picker_pos, D.43116, 0.0);
  D.21314 ={v} {CLOBBER};
  _635 = picker_pos.x;
  _636 = _635 + sv_picker_size_130;
  _637 = _636 - 2.0e+0;
  _638 = picker_pos.x;
  _639 = _638 + 2.0e+0;
  _640 = picker_pos.x;
  S.1907_641 = S;
  _643 = ImSaturate (S.1907_641);
  _644 = _643 * sv_picker_size_130;
  _645 = _640 + _644;
  _646 = _645 + 5.0e-1;
  _647 = (int) _646;
  _648 = (float) _647;
  _650 = ImClamp (_648, _639, _637);
  sv_cursor_pos.x = _650;
  _652 = picker_pos.y;
  _653 = _652 + sv_picker_size_130;
  _654 = _653 - 2.0e+0;
  _655 = picker_pos.y;
  _656 = _655 + 2.0e+0;
  _657 = picker_pos.y;
  V.1908_658 = V;
  _659 = 1.0e+0 - V.1908_658;
  _661 = ImSaturate (_659);
  _662 = _661 * sv_picker_size_130;
  _663 = _657 + _662;
  _664 = _663 + 5.0e-1;
  _665 = (int) _664;
  _666 = (float) _665;
  _668 = ImClamp (_666, _656, _654);
  sv_cursor_pos.y = _668;
  i_670 = 0;

  <bb 127>:
  # i_24 = PHI <i_670(126), i_694(128)>
  if (i_24 > 5)
    goto <bb 129>;
  else
    goto <bb 128>;

  <bb 128>:
  _671 = i_24 + 1;
  _672 = hue_colors[_671];
  _673 = i_24 + 1;
  _674 = hue_colors[_673];
  _675 = hue_colors[i_24];
  _676 = hue_colors[i_24];
  _677 = picker_pos.y;
  _678 = i_24 + 1;
  _679 = (float) _678;
  _680 = sv_picker_size_130 / 6.0e+0;
  _681 = _679 * _680;
  _682 = _677 + _681;
  _683 = bar0_pos_x_134 + bars_width_119;
  ImVec2::ImVec2 (&D.21319, _683, _682);
  _685 = picker_pos.y;
  _686 = (float) i_24;
  _687 = sv_picker_size_130 / 6.0e+0;
  _688 = _686 * _687;
  _689 = _685 + _688;
  ImVec2::ImVec2 (&D.21318, bar0_pos_x_134, _689);
  ImDrawList::AddRectFilledMultiColor (draw_list_81, &D.21318, &D.21319, _676, _675, _674, _672);
  D.21318 ={v} {CLOBBER};
  D.21319 ={v} {CLOBBER};
  i_694 = i_24 + 1;
  goto <bb 127>;

  <bb 129>:
  _697 = picker_pos.y;
  H.1909_698 = H;
  _699 = H.1909_698 * sv_picker_size_130;
  _700 = _697 + _699;
  _701 = _700 + 5.0e-1;
  _702 = (int) _701;
  bar0_line_y_703 = (float) _702;
  _704 = picker_pos.y;
  _705 = _704 + sv_picker_size_130;
  _706 = bar0_pos_x_134 + bars_width_119;
  ImVec2::ImVec2 (&D.21322, _706, _705);
  _708 = picker_pos.y;
  ImVec2::ImVec2 (&D.21321, bar0_pos_x_134, _708);
  ImGui::RenderFrameBorder (D.21321, D.21322, 0.0);
  D.21321 ={v} {CLOBBER};
  D.21322 ={v} {CLOBBER};
  _713 = bars_width_119 + 2.0e+0;
  _714 = bars_triangles_half_sz_140 + 1.0e+0;
  ImVec2::ImVec2 (&D.21324, _714, bars_triangles_half_sz_140);
  _716 = bar0_pos_x_134 - 1.0e+0;
  ImVec2::ImVec2 (&D.21323, _716, bar0_line_y_703);
  RenderArrowsForVerticalBar (draw_list_81, D.21323, D.21324, _713);
  D.21323 ={v} {CLOBBER};
  D.21324 ={v} {CLOBBER};

  <bb 130>:
  if (value_changed_sv_23 != 0)
    goto <bb 131>;
  else
    goto <bb 132>;

  <bb 131>:
  iftmp.1910_730 = 1.0e+1;
  goto <bb 133>;

  <bb 132>:
  iftmp.1910_731 = 6.0e+0;

  <bb 133>:
  # iftmp.1910_38 = PHI <iftmp.1910_730(131), iftmp.1910_731(132)>
  sv_cursor_rad_732 = iftmp.1910_38;
  ImDrawList::AddCircleFilled (draw_list_81, &sv_cursor_pos, sv_cursor_rad_732, col32_no_alpha_474, 12);
  _734 = sv_cursor_rad_732 + 1.0e+0;
  ImDrawList::AddCircle (draw_list_81, &sv_cursor_pos, _734, 4286611584, 12, 1.0e+0);
  ImDrawList::AddCircle (draw_list_81, &sv_cursor_pos, sv_cursor_rad_732, 4294967295, 12, 1.0e+0);
  if (alpha_bar_115 != 0)
    goto <bb 134>;
  else
    goto <bb 135>;

  <bb 134>:
  _737 = col_91(D) + 12;
  _738 = *_737;
  alpha_740 = ImSaturate (_738);
  _741 = picker_pos.y;
  _742 = _741 + sv_picker_size_130;
  _743 = bar1_pos_x_137 + bars_width_119;
  _744 = picker_pos.y;
  ImRect::ImRect (&bar1_bb, bar1_pos_x_137, _744, _743, _742);
  ImVec2::ImVec2 (&D.21328, 0.0, 0.0);
  _748 = ImRect::GetWidth (&bar1_bb);
  _749 = _748 / 2.0e+0;
  ImGui::RenderColorRectWithAlphaCheckerboard (bar1_bb.Min, bar1_bb.Max, 0, _749, D.21328, 0.0, -1);
  D.21328 ={v} {CLOBBER};
  _752 = col32_no_alpha_474 & 16777215;
  _753 = col32_no_alpha_474 & 16777215;
  ImDrawList::AddRectFilledMultiColor (draw_list_81, &bar1_bb.Min, &bar1_bb.Max, col32_no_alpha_474, col32_no_alpha_474, _753, _752);
  _755 = picker_pos.y;
  _756 = 1.0e+0 - alpha_740;
  _757 = _756 * sv_picker_size_130;
  _758 = _755 + _757;
  _759 = _758 + 5.0e-1;
  _760 = (int) _759;
  bar1_line_y_761 = (float) _760;
  ImGui::RenderFrameBorder (bar1_bb.Min, bar1_bb.Max, 0.0);
  _763 = bars_width_119 + 2.0e+0;
  _764 = bars_triangles_half_sz_140 + 1.0e+0;
  ImVec2::ImVec2 (&D.21335, _764, bars_triangles_half_sz_140);
  _766 = bar1_pos_x_137 - 1.0e+0;
  ImVec2::ImVec2 (&D.21334, _766, bar1_line_y_761);
  RenderArrowsForVerticalBar (draw_list_81, D.21334, D.21335, _763);
  D.21334 ={v} {CLOBBER};
  D.21335 ={v} {CLOBBER};
  bar1_bb ={v} {CLOBBER};

  <bb 135>:
  ImGui::EndGroup ();
  ImGui::PopID ();
  if (value_changed_16 != 0)
    goto <bb 136>;
  else
    goto <bb 138>;

  <bb 136>:
  _778 = (long unsigned int) components_110;
  _779 = _778 * 4;
  _780 = memcmp (&backup_initial_col, col_91(D), _779);
  if (_780 != 0)
    goto <bb 137>;
  else
    goto <bb 138>;

  <bb 137>:
  iftmp.1911_781 = 1;
  goto <bb 139>;

  <bb 138>:
  iftmp.1911_782 = 0;

  <bb 139>:
  # iftmp.1911_39 = PHI <iftmp.1911_781(137), iftmp.1911_782(138)>
  _783 = iftmp.1911_39;
  picker_pos ={v} {CLOBBER};
  backup_initial_col ={v} {CLOBBER};
  wheel_center ={v} {CLOBBER};
  triangle_pa ={v} {CLOBBER};
  triangle_pb ={v} {CLOBBER};
  triangle_pc ={v} {CLOBBER};
  H ={v} {CLOBBER};
  S ={v} {CLOBBER};
  V ={v} {CLOBBER};
  hue_color_f ={v} {CLOBBER};
  hue_colors ={v} {CLOBBER};
  sv_cursor_pos ={v} {CLOBBER};

<L173>:
  return _783;

<L182>:
  _71 = __builtin_eh_pointer (26);
  __builtin_unwind_resume (_71);

}



;; Function void ImGui::Separator() (_ZN5ImGui9SeparatorEv, funcdef_no=1142, decl_uid=2617, cgraph_uid=1041, symbol_order=1052)

void ImGui::Separator() ()
{
  bool D.43351;
  const struct ImRect bb;
  float x2;
  float x1;
  static const char __PRETTY_FUNCTION__[24] = "void ImGui::Separator()";
  ImGuiSeparatorFlags flags;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.43347;
  struct ImGuiColumnsSet * D.43346;
  struct ImGuiColumnsSet * D.43343;
  bool D.43339;
  struct ImDrawList * D.43338;
  float D.43337;
  float D.43336;
  struct ImVec2 D.21352;
  unsigned int D.43335;
  struct ImGuiColumnsSet * D.43331;
  bool D.43328;
  bool retval.1914;
  struct ImVec2 D.21351;
  float D.43326;
  struct ImVec2 D.21349;
  float D.43325;
  float D.43324;
  struct ImVec2 D.21350;
  float D.43322;
  bool D.43319;
  struct ImVector * D.43318;
  bool retval.1913;
  float D.43316;
  float D.43315;
  struct ImGuiColumnsSet * D.43311;
  int D.43308;
  bool D.43304;
  int D.43303;
  int D.43298;
  int iftmp.1912;
  int D.43294;
  bool D.43291;
  int iftmp.1912_3;
  bool _14;
  int _17;
  int _18;
  int iftmp.1912_19;
  int iftmp.1912_20;
  int _22;
  bool _24;
  int _25;
  struct ImGuiColumnsSet * _26;
  float _29;
  float _30;
  struct ImVector * _32;
  bool _34;
  bool retval.1913_35;
  float _36;
  float _38;
  float _39;
  float _41;
  bool _50;
  bool _51;
  bool retval.1914_52;
  unsigned int _54;
  float _55;
  float _56;
  struct ImDrawList * _58;
  bool _61;
  struct ImGuiColumnsSet * _63;
  struct ImGuiColumnsSet * _65;
  float _66;
  struct ImGuiColumnsSet * _70;

  <bb 2>:
  window_13 = ImGui::GetCurrentWindow ();
  _14 = window_13->SkipItems;
  if (_14 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 26>;

  <bb 4>:
  g_15 = GImGui;
  flags_16 = 0;
  _17 = flags_16 & 3;
  if (_17 == 0)
    goto <bb 5>;
  else
    goto <bb 9>;

  <bb 5>:
  _18 = window_13->DC.LayoutType;
  if (_18 == 1)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1912_19 = 2;
  goto <bb 8>;

  <bb 7>:
  iftmp.1912_20 = 1;

  <bb 8>:
  # iftmp.1912_3 = PHI <iftmp.1912_19(6), iftmp.1912_20(7)>
  flags_21 = iftmp.1912_3 | flags_16;

  <bb 9>:
  # flags_1 = PHI <flags_16(4), flags_21(8)>
  _22 = flags_1 & 3;
  _24 = ImIsPowerOfTwo (_22);
  if (_24 != 0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  __assert_fail ("ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)))", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12161, &__PRETTY_FUNCTION__);

  <bb 11>:
  _25 = flags_1 & 2;
  if (_25 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  ImGui::VerticalSeparator ();
  goto <bb 26>;

  <bb 13>:
  _26 = window_13->DC.ColumnsSet;
  if (_26 != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  ImGui::PopClipRect ();

  <bb 15>:
  x1_28 = window_13->Pos.x;
  _29 = window_13->Pos.x;
  _30 = window_13->Size.x;
  x2_31 = _29 + _30;
  _32 = &window_13->DC.GroupStack;
  _34 = ImVector<ImGuiGroupData>::empty (_32);
  retval.1913_35 = ~_34;
  if (retval.1913_35 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _36 = window_13->DC.IndentX;
  x1_37 = _36 + x1_28;

  <bb 17>:
  # x1_2 = PHI <x1_28(15), x1_37(16)>
  _38 = window_13->DC.CursorPos.y;
  _39 = _38 + 1.0e+0;
  ImVec2::ImVec2 (&D.21350, x2_31, _39);
  _41 = window_13->DC.CursorPos.y;
  ImVec2::ImVec2 (&D.21349, x1_2, _41);
  ImRect::ImRect (&bb, &D.21349, &D.21350);
  D.21349 ={v} {CLOBBER};
  D.21350 ={v} {CLOBBER};
  ImVec2::ImVec2 (&D.21351, 0.0, 0.0);
  ImGui::ItemSize (&D.21351, 0.0);
  D.21351 ={v} {CLOBBER};
  _50 = ImGui::ItemAdd (&bb, 0, 0B);
  _51 = _50;
  retval.1914_52 = ~_51;
  if (retval.1914_52 != 0)
    goto <bb 18>;
  else
    goto <bb 21>;

  <bb 18>:
  _70 = window_13->DC.ColumnsSet;
  if (_70 != 0B)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  ImGui::PushColumnClipRect (-1);

  <bb 20>:
  goto <bb 26>;

  <bb 21>:
  _54 = ImGui::GetColorU32 (27, 1.0e+0);
  _55 = bb.Min.y;
  _56 = bb.Max.x;
  ImVec2::ImVec2 (&D.21352, _56, _55);
  _58 = window_13->DrawList;
  ImDrawList::AddLine (_58, &bb.Min, &D.21352, _54, 1.0e+0);
  D.21352 ={v} {CLOBBER};
  _61 = g_15->LogEnabled;
  if (_61 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

  <bb 22>:
  LogRenderedText (0B, "\n--------------------------------", 0B);

  <bb 23>:
  _63 = window_13->DC.ColumnsSet;
  if (_63 != 0B)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  ImGui::PushColumnClipRect (-1);
  _65 = window_13->DC.ColumnsSet;
  _66 = window_13->DC.CursorPos.y;
  _65->LineMinY = _66;

  <bb 25>:
  bb ={v} {CLOBBER};
  goto <bb 27> (<L32>);

  <bb 26>:
  bb ={v} {CLOBBER};

<L32>:
  return;

}



;; Function void ImGui::VerticalSeparator() (_ZN5ImGui17VerticalSeparatorEv, funcdef_no=1143, decl_uid=13847, cgraph_uid=1042, symbol_order=1053)

void ImGui::VerticalSeparator() ()
{
  bool D.43384;
  const struct ImRect bb;
  float y2;
  float y1;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  bool D.43378;
  struct ImDrawList * D.43377;
  float D.43376;
  float D.43375;
  struct ImVec2 D.21363;
  float D.43374;
  float D.43373;
  struct ImVec2 D.21364;
  unsigned int D.43372;
  bool D.43369;
  bool retval.1915;
  float D.43367;
  struct ImVec2 D.21362;
  float D.43366;
  struct ImVec2 D.21360;
  float D.43365;
  float D.43364;
  struct ImVec2 D.21361;
  float D.43363;
  float D.43362;
  bool D.43359;
  bool _8;
  float _11;
  float _12;
  float _14;
  float _15;
  float _17;
  float _23;
  bool _28;
  bool _29;
  bool retval.1915_30;
  unsigned int _32;
  float _33;
  float _34;
  float _36;
  float _37;
  struct ImDrawList * _39;
  bool _43;

  <bb 2>:
  window_7 = ImGui::GetCurrentWindow ();
  _8 = window_7->SkipItems;
  if (_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 9>;

  <bb 4>:
  g_9 = GImGui;
  y1_10 = window_7->DC.CursorPos.y;
  _11 = window_7->DC.CursorPos.y;
  _12 = window_7->DC.CurrentLineHeight;
  y2_13 = _11 + _12;
  _14 = window_7->DC.CursorPos.x;
  _15 = _14 + 1.0e+0;
  ImVec2::ImVec2 (&D.21361, _15, y2_13);
  _17 = window_7->DC.CursorPos.x;
  ImVec2::ImVec2 (&D.21360, _17, y1_10);
  ImRect::ImRect (&bb, &D.21360, &D.21361);
  D.21360 ={v} {CLOBBER};
  D.21361 ={v} {CLOBBER};
  _23 = ImRect::GetWidth (&bb);
  ImVec2::ImVec2 (&D.21362, _23, 0.0);
  ImGui::ItemSize (&D.21362, 0.0);
  D.21362 ={v} {CLOBBER};
  _28 = ImGui::ItemAdd (&bb, 0, 0B);
  _29 = _28;
  retval.1915_30 = ~_29;
  if (retval.1915_30 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  goto <bb 9>;

  <bb 6>:
  _32 = ImGui::GetColorU32 (27, 1.0e+0);
  _33 = bb.Max.y;
  _34 = bb.Min.x;
  ImVec2::ImVec2 (&D.21364, _34, _33);
  _36 = bb.Min.y;
  _37 = bb.Min.x;
  ImVec2::ImVec2 (&D.21363, _37, _36);
  _39 = window_7->DrawList;
  ImDrawList::AddLine (_39, &D.21363, &D.21364, _32, 1.0e+0);
  D.21363 ={v} {CLOBBER};
  D.21364 ={v} {CLOBBER};
  _43 = g_9->LogEnabled;
  if (_43 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGui::LogText (" |");

  <bb 8>:
  bb ={v} {CLOBBER};
  goto <bb 10> (<L9>);

  <bb 9>:
  bb ={v} {CLOBBER};

<L9>:
  return;

}



;; Function bool ImGui::SplitterBehavior(ImGuiID, const ImRect&, ImGuiAxis, float*, float*, float, float, float) (_ZN5ImGui16SplitterBehaviorEjRK6ImRect9ImGuiAxisPfS4_fff, funcdef_no=1144, decl_uid=13856, cgraph_uid=1043, symbol_order=1054)

bool ImGui::SplitterBehavior(ImGuiID, const ImRect&, ImGuiAxis, float*, float*, float, float, float) (ImGuiID id, const struct ImRect & bb, ImGuiAxis axis, float * size1, float * size2, float min_size1, float min_size2, float hover_extend)
{
  bool D.43456;
  float mouse_delta;
  struct ImVec2 mouse_delta_2d;
  const ImU32 col;
  struct ImRect bb_render;
  struct ImRect bb_interact;
  bool held;
  bool hovered;
  bool item_add;
  const ImGuiItemFlags item_flags_backup;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImDrawList * D.43454;
  float D.43453;
  bool hovered.1923;
  ImGuiCol iftmp.1922;
  bool held.1921;
  ImGuiCol iftmp.1920;
  struct ImVec2 D.21394;
  float D.43438;
  float D.43437;
  float D.43436;
  float D.43435;
  float D.43433;
  float D.43430;
  float D.43429;
  float D.43427;
  float D.43424;
  float D.43423;
  float iftmp.1919;
  struct ImVec2 * D.43418;
  struct ImVec2 * D.43417;
  struct ImVec2 D.21389;
  bool held.1918;
  ImGuiMouseCursor iftmp.1917;
  unsigned int D.43409;
  unsigned int D.43407;
  bool held.1916;
  unsigned int D.43399;
  struct ImVec2 D.21385;
  bool D.43395;
  bool D.43392;
  int D.43391;
  int D.43390;
  bool _3;
  ImGuiMouseCursor iftmp.1917_4;
  float iftmp.1919_5;
  ImGuiCol iftmp.1920_6;
  ImGuiCol iftmp.1922_7;
  int _19;
  int _20;
  bool _25;
  bool _28;
  bool _29;
  unsigned int _38;
  bool held.1916_40;
  unsigned int _41;
  unsigned int _42;
  ImGuiMouseCursor iftmp.1917_43;
  ImGuiMouseCursor iftmp.1917_44;
  bool held.1918_47;
  struct ImVec2 * _48;
  struct ImVec2 * _49;
  float iftmp.1919_53;
  float iftmp.1919_54;
  float _57;
  float _59;
  float _60;
  float _63;
  float _65;
  float _66;
  float _68;
  float _69;
  float _71;
  float _72;
  bool held.1921_79;
  ImGuiCol iftmp.1920_80;
  bool hovered.1923_81;
  ImGuiCol iftmp.1922_82;
  ImGuiCol iftmp.1922_83;
  ImGuiCol iftmp.1920_84;
  float _87;
  struct ImDrawList * _88;
  bool _90;

  <bb 2>:
  g_16 = GImGui;
  window_17 = g_16->CurrentWindow;
  item_flags_backup_18 = window_17->DC.ItemFlags;
  _19 = window_17->DC.ItemFlags;
  _20 = _19 | 24;
  window_17->DC.ItemFlags = _20;
  _25 = ImGui::ItemAdd (bb_22(D), id_23(D), 0B);
  item_add_26 = _25;
  window_17->DC.ItemFlags = item_flags_backup_18;
  _28 = ~item_add_26;
  if (_28 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _29 = 0;
  goto <bb 35>;

  <bb 4>:
  bb_interact = *bb_22(D);
  if (axis_31(D) == 1)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImVec2::ImVec2 (&D.21385, 0.0, hover_extend_32(D));
  goto <bb 7>;

  <bb 6>:
  ImVec2::ImVec2 (&D.21385, hover_extend_32(D), 0.0);

  <bb 7>:
  ImRect::Expand (&bb_interact, &D.21385);
  D.21385 ={v} {CLOBBER};
  ImGui::ButtonBehavior (&bb_interact, id_23(D), &hovered, &held, 96);
  _38 = g_16->ActiveId;
  if (_38 != id_23(D))
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  ImGui::SetItemAllowOverlap ();

  <bb 9>:
  held.1916_40 = held;
  if (held.1916_40 != 0)
    goto <bb 12>;
  else
    goto <bb 10>;

  <bb 10>:
  _41 = g_16->HoveredId;
  if (_41 == id_23(D))
    goto <bb 11>;
  else
    goto <bb 16>;

  <bb 11>:
  _42 = g_16->HoveredIdPreviousFrame;
  if (_42 == id_23(D))
    goto <bb 12>;
  else
    goto <bb 16>;

  <bb 12>:
  if (axis_31(D) == 1)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  iftmp.1917_43 = 3;
  goto <bb 15>;

  <bb 14>:
  iftmp.1917_44 = 4;

  <bb 15>:
  # iftmp.1917_4 = PHI <iftmp.1917_43(13), iftmp.1917_44(14)>
  ImGui::SetMouseCursor (iftmp.1917_4);

  <bb 16>:
  bb_render = *bb_22(D);
  held.1918_47 = held;
  if (held.1918_47 != 0)
    goto <bb 17>;
  else
    goto <bb 28>;

  <bb 17>:
  _48 = &g_16->ActiveIdClickOffset;
  _49 = &g_16->IO.MousePos;
  D.21389 = operator- (_49, _48);
  mouse_delta_2d = operator- (&D.21389, &bb_interact.Min);
  D.21389 ={v} {CLOBBER};
  if (axis_31(D) == 1)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  iftmp.1919_53 = mouse_delta_2d.y;
  goto <bb 20>;

  <bb 19>:
  iftmp.1919_54 = mouse_delta_2d.x;

  <bb 20>:
  # iftmp.1919_5 = PHI <iftmp.1919_53(18), iftmp.1919_54(19)>
  mouse_delta_55 = iftmp.1919_5;
  _57 = *size1_56(D);
  _59 = min_size1_58(D) - _57;
  if (_59 > mouse_delta_55)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  _60 = *size1_56(D);
  mouse_delta_61 = min_size1_58(D) - _60;

  <bb 22>:
  # mouse_delta_1 = PHI <mouse_delta_55(20), mouse_delta_61(21)>
  _63 = *size2_62(D);
  _65 = _63 - min_size2_64(D);
  if (_65 < mouse_delta_1)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _66 = *size2_62(D);
  mouse_delta_67 = _66 - min_size2_64(D);

  <bb 24>:
  # mouse_delta_2 = PHI <mouse_delta_1(22), mouse_delta_67(23)>
  _68 = *size1_56(D);
  _69 = _68 + mouse_delta_2;
  *size1_56(D) = _69;
  _71 = *size2_62(D);
  _72 = _71 - mouse_delta_2;
  *size2_62(D) = _72;
  if (axis_31(D) == 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  ImVec2::ImVec2 (&D.21394, mouse_delta_2, 0.0);
  goto <bb 27>;

  <bb 26>:
  ImVec2::ImVec2 (&D.21394, 0.0, mouse_delta_2);

  <bb 27>:
  ImRect::Translate (&bb_render, &D.21394);
  D.21394 ={v} {CLOBBER};
  mouse_delta_2d ={v} {CLOBBER};

  <bb 28>:
  held.1921_79 = held;
  if (held.1921_79 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

  <bb 29>:
  iftmp.1920_80 = 29;
  goto <bb 34>;

  <bb 30>:
  hovered.1923_81 = hovered;
  if (hovered.1923_81 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

  <bb 31>:
  iftmp.1922_82 = 28;
  goto <bb 33>;

  <bb 32>:
  iftmp.1922_83 = 27;

  <bb 33>:
  # iftmp.1922_7 = PHI <iftmp.1922_82(31), iftmp.1922_83(32)>
  iftmp.1920_84 = iftmp.1922_7;

  <bb 34>:
  # iftmp.1920_6 = PHI <iftmp.1920_80(29), iftmp.1920_84(33)>
  col_86 = ImGui::GetColorU32 (iftmp.1920_6, 1.0e+0);
  _87 = g_16->Style.FrameRounding;
  _88 = window_17->DrawList;
  ImDrawList::AddRectFilled (_88, &bb_render.Min, &bb_render.Max, col_86, _87, 15);
  _90 = held;

  <bb 35>:
  # _3 = PHI <_29(3), _90(34)>
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  bb_interact ={v} {CLOBBER};
  bb_render ={v} {CLOBBER};

<L37>:
  return _3;

}



;; Function void ImGui::Spacing() (_ZN5ImGui7SpacingEv, funcdef_no=1145, decl_uid=2622, cgraph_uid=1044, symbol_order=1055)

void ImGui::Spacing() ()
{
  struct ImGuiWindow * window;
  struct ImVec2 D.21399;
  bool D.43459;
  bool _5;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  _5 = window_4->SkipItems;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 5> (<L2>);

  <bb 4>:
  ImVec2::ImVec2 (&D.21399, 0.0, 0.0);
  ImGui::ItemSize (&D.21399, 0.0);
  D.21399 ={v} {CLOBBER};

<L2>:
  return;

}



;; Function void ImGui::Dummy(const ImVec2&) (_ZN5ImGui5DummyERK6ImVec2, funcdef_no=1146, decl_uid=2624, cgraph_uid=1045, symbol_order=1056)

void ImGui::Dummy(const ImVec2&) (const struct ImVec2 & size)
{
  const struct ImRect bb;
  struct ImGuiWindow * window;
  struct ImVec2 * D.43468;
  struct ImVec2 * D.43467;
  struct ImVec2 D.21405;
  bool D.43464;
  bool _6;
  struct ImVec2 * _7;
  struct ImVec2 * _10;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  bb ={v} {CLOBBER};
  goto <bb 5> (<L4>);

  <bb 4>:
  _7 = &window_5->DC.CursorPos;
  D.21405 = operator+ (_7, size_8(D));
  _10 = &window_5->DC.CursorPos;
  ImRect::ImRect (&bb, _10, &D.21405);
  D.21405 ={v} {CLOBBER};
  ImGui::ItemSize (&bb, 0.0);
  ImGui::ItemAdd (&bb, 0, 0B);
  bb ={v} {CLOBBER};

<L4>:
  return;

}



;; Function bool ImGui::IsRectVisible(const ImVec2&) (_ZN5ImGui13IsRectVisibleERK6ImVec2, funcdef_no=1147, decl_uid=3317, cgraph_uid=1046, symbol_order=1057)

bool ImGui::IsRectVisible(const ImVec2&) (const struct ImVec2 & size)
{
  struct ImGuiWindow * window;
  struct ImRect * D.43476;
  struct ImVec2 * D.43475;
  struct ImVec2 * D.43474;
  struct ImVec2 D.21410;
  struct ImRect D.21411;
  bool D.43473;
  struct ImVec2 * _4;
  struct ImVec2 * _7;
  struct ImRect * _9;
  bool _11;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  _4 = &window_3->DC.CursorPos;
  D.21410 = operator+ (_4, size_5(D));
  _7 = &window_3->DC.CursorPos;
  ImRect::ImRect (&D.21411, _7, &D.21410);
  _9 = &window_3->ClipRect;
  _11 = ImRect::Overlaps (_9, &D.21411);
  D.21411 ={v} {CLOBBER};
  D.21410 ={v} {CLOBBER};

<L2>:
  return _11;

}



;; Function bool ImGui::IsRectVisible(const ImVec2&, const ImVec2&) (_ZN5ImGui13IsRectVisibleERK6ImVec2S2_, funcdef_no=1148, decl_uid=3320, cgraph_uid=1047, symbol_order=1058)

bool ImGui::IsRectVisible(const ImVec2&, const ImVec2&) (const struct ImVec2 & rect_min, const struct ImVec2 & rect_max)
{
  struct ImGuiWindow * window;
  struct ImRect * D.43481;
  struct ImRect D.21417;
  bool D.43480;
  struct ImRect * _7;
  bool _9;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindowRead ();
  ImRect::ImRect (&D.21417, rect_min_4(D), rect_max_5(D));
  _7 = &window_3->ClipRect;
  _9 = ImRect::Overlaps (_7, &D.21417);
  D.21417 ={v} {CLOBBER};

<L1>:
  return _9;

}



;; Function void ImGui::BeginGroup() (_ZN5ImGui10BeginGroupEv, funcdef_no=1149, decl_uid=2629, cgraph_uid=1048, symbol_order=1059)

void ImGui::BeginGroup() ()
{
  struct ImGuiGroupData & group_data;
  struct ImGuiWindow * window;
  float D.43502;
  float D.43501;
  float D.43500;
  float D.43499;
  float D.43498;
  float D.43497;
  float D.43496;
  float D.43495;
  bool D.43494;
  struct ImGuiContext * GImGui.1924;
  float D.43492;
  float D.43491;
  float D.43490;
  float D.43489;
  float D.43488;
  struct ImVector * D.43487;
  struct ImVector * D.43486;
  int D.43485;
  int D.43484;
  int _4;
  int _5;
  struct ImVector * _6;
  struct ImVector * _8;
  float _13;
  float _15;
  float _17;
  float _19;
  float _21;
  struct ImGuiContext * GImGui.1924_23;
  bool _24;
  float _27;
  float _28;
  float _29;
  float _30;
  float _31;
  float _33;
  float _37;
  float _38;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  _4 = window_3->DC.GroupStack.Size;
  _5 = _4 + 1;
  _6 = &window_3->DC.GroupStack;
  ImVector<ImGuiGroupData>::resize (_6, _5);
  _8 = &window_3->DC.GroupStack;
  group_data_10 = ImVector<ImGuiGroupData>::back (_8);
  group_data_10->BackupCursorPos = window_3->DC.CursorPos;
  group_data_10->BackupCursorMaxPos = window_3->DC.CursorMaxPos;
  _13 = window_3->DC.IndentX;
  group_data_10->BackupIndentX = _13;
  _15 = window_3->DC.GroupOffsetX;
  group_data_10->BackupGroupOffsetX = _15;
  _17 = window_3->DC.CurrentLineHeight;
  group_data_10->BackupCurrentLineHeight = _17;
  _19 = window_3->DC.CurrentLineTextBaseOffset;
  group_data_10->BackupCurrentLineTextBaseOffset = _19;
  _21 = window_3->DC.LogLinePosY;
  group_data_10->BackupLogLinePosY = _21;
  GImGui.1924_23 = GImGui;
  _24 = GImGui.1924_23->ActiveIdIsAlive;
  group_data_10->BackupActiveIdIsAlive = _24;
  group_data_10->AdvanceCursor = 1;
  _27 = window_3->DC.CursorPos.x;
  _28 = window_3->Pos.x;
  _29 = _27 - _28;
  _30 = window_3->DC.ColumnsOffsetX;
  _31 = _29 - _30;
  window_3->DC.GroupOffsetX = _31;
  _33 = window_3->DC.GroupOffsetX;
  window_3->DC.IndentX = _33;
  window_3->DC.CursorMaxPos = window_3->DC.CursorPos;
  window_3->DC.CurrentLineHeight = 0.0;
  _37 = window_3->DC.CursorPos.y;
  _38 = _37 - 9.999e+3;
  window_3->DC.LogLinePosY = _38;
  return;

}



;; Function void ImGui::EndGroup() (_ZN5ImGui8EndGroupEv, funcdef_no=1150, decl_uid=2630, cgraph_uid=1049, symbol_order=1060)

void ImGui::EndGroup() ()
{
  const bool active_id_within_group;
  struct ImRect group_bb;
  struct ImGuiGroupData & group_data;
  static const char __PRETTY_FUNCTION__[23] = "void ImGui::EndGroup()";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  struct ImVector * D.43546;
  unsigned int D.43544;
  struct ImGuiWindow * D.43540;
  struct ImGuiWindow * D.43539;
  struct ImGuiWindow * D.43538;
  unsigned int D.43536;
  bool D.43534;
  bool D.43532;
  bool D.43531;
  bool iftmp.1925;
  struct ImVec2 D.21431;
  float D.43526;
  float D.43525;
  float D.43524;
  float D.43523;
  bool D.43520;
  float D.43519;
  float D.43518;
  float D.43517;
  float D.43516;
  float D.43515;
  float D.43514;
  struct ImVec2 * D.43513;
  struct ImVec2 * D.43512;
  struct ImVec2 * D.43511;
  struct ImVec2 * D.43510;
  struct ImVector * D.43509;
  bool D.43505;
  bool D.43504;
  struct ImVector * D.43503;
  bool iftmp.1925_1;
  struct ImVector * _9;
  bool _11;
  bool _12;
  struct ImVector * _13;
  struct ImVec2 * _16;
  struct ImVec2 * _17;
  struct ImVec2 * _21;
  struct ImVec2 * _22;
  float _24;
  float _26;
  float _28;
  float _30;
  float _32;
  float _33;
  bool _35;
  float _36;
  float _37;
  float _39;
  float _41;
  bool _48;
  bool _49;
  bool _50;
  unsigned int _51;
  struct ImGuiWindow * _52;
  struct ImGuiWindow * _53;
  struct ImGuiWindow * _54;
  bool iftmp.1925_55;
  bool iftmp.1925_56;
  unsigned int _58;
  struct ImVector * _61;

  <bb 2>:
  g_6 = GImGui;
  window_8 = ImGui::GetCurrentWindow ();
  _9 = &window_8->DC.GroupStack;
  _11 = ImVector<ImGuiGroupData>::empty (_9);
  _12 = ~_11;
  if (_12 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("!window->DC.GroupStack.empty()", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12324, &__PRETTY_FUNCTION__);

  <bb 4>:
  _13 = &window_8->DC.GroupStack;
  group_data_15 = ImVector<ImGuiGroupData>::back (_13);
  _16 = &window_8->DC.CursorMaxPos;
  _17 = &group_data_15->BackupCursorPos;
  ImRect::ImRect (&group_bb, _17, _16);
  group_bb.Max = ImMax (&group_bb.Min, &group_bb.Max);
  window_8->DC.CursorPos = group_data_15->BackupCursorPos;
  _21 = &window_8->DC.CursorMaxPos;
  _22 = &group_data_15->BackupCursorMaxPos;
  window_8->DC.CursorMaxPos = ImMax (_22, _21);
  _24 = group_data_15->BackupCurrentLineHeight;
  window_8->DC.CurrentLineHeight = _24;
  _26 = group_data_15->BackupCurrentLineTextBaseOffset;
  window_8->DC.CurrentLineTextBaseOffset = _26;
  _28 = group_data_15->BackupIndentX;
  window_8->DC.IndentX = _28;
  _30 = group_data_15->BackupGroupOffsetX;
  window_8->DC.GroupOffsetX = _30;
  _32 = window_8->DC.CursorPos.y;
  _33 = _32 - 9.999e+3;
  window_8->DC.LogLinePosY = _33;
  _35 = group_data_15->AdvanceCursor;
  if (_35 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _36 = group_data_15->BackupCurrentLineTextBaseOffset;
  _37 = window_8->DC.PrevLineTextBaseOffset;
  _39 = ImMax (_37, _36);
  window_8->DC.CurrentLineTextBaseOffset = _39;
  _41 = group_data_15->BackupCurrentLineTextBaseOffset;
  D.21431 = ImRect::GetSize (&group_bb);
  ImGui::ItemSize (&D.21431, _41);
  D.21431 ={v} {CLOBBER};
  ImGui::ItemAdd (&group_bb, 0, 0B);

  <bb 6>:
  _48 = group_data_15->BackupActiveIdIsAlive;
  _49 = ~_48;
  if (_49 != 0)
    goto <bb 7>;
  else
    goto <bb 11>;

  <bb 7>:
  _50 = g_6->ActiveIdIsAlive;
  if (_50 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  _51 = g_6->ActiveId;
  if (_51 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _52 = g_6->ActiveIdWindow;
  _53 = _52->RootWindow;
  _54 = window_8->RootWindow;
  if (_53 == _54)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1925_55 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.1925_56 = 0;

  <bb 12>:
  # iftmp.1925_1 = PHI <iftmp.1925_55(10), iftmp.1925_56(11)>
  active_id_within_group_57 = iftmp.1925_1;
  if (active_id_within_group_57 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _58 = g_6->ActiveId;
  window_8->DC.LastItemId = _58;

  <bb 14>:
  window_8->DC.LastItemRect = group_bb;
  _61 = &window_8->DC.GroupStack;
  ImVector<ImGuiGroupData>::pop_back (_61);
  group_bb ={v} {CLOBBER};
  return;

}



;; Function void ImGui::SameLine(float, float) (_ZN5ImGui8SameLineEff, funcdef_no=1151, decl_uid=2620, cgraph_uid=1050, symbol_order=1061)

void ImGui::SameLine(float, float) (float pos_x, float spacing_w)
{
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.43581;
  float D.43580;
  float D.43579;
  float D.43578;
  float D.43577;
  float D.43572;
  float D.43571;
  float D.43570;
  float D.43569;
  float D.43568;
  float D.43567;
  float D.43566;
  float D.43565;
  float D.43564;
  float D.43563;
  bool D.43555;
  bool _8;
  float _13;
  float _14;
  float _15;
  float _16;
  float _17;
  float _18;
  float _19;
  float _20;
  float _21;
  float _23;
  float _26;
  float _27;
  float _29;
  float _31;
  float _33;

  <bb 2>:
  window_7 = ImGui::GetCurrentWindow ();
  _8 = window_7->SkipItems;
  if (_8 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 12> (<L11>);

  <bb 4>:
  g_9 = GImGui;
  if (pos_x_10(D) != 0.0)
    goto <bb 5>;
  else
    goto <bb 8>;

  <bb 5>:
  if (spacing_w_11(D) < 0.0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  spacing_w_12 = 0.0;

  <bb 7>:
  # spacing_w_1 = PHI <spacing_w_11(D)(5), spacing_w_12(6)>
  _13 = window_7->Pos.x;
  _14 = window_7->Scroll.x;
  _15 = _13 - _14;
  _16 = _15 + pos_x_10(D);
  _17 = _16 + spacing_w_1;
  _18 = window_7->DC.GroupOffsetX;
  _19 = _17 + _18;
  _20 = window_7->DC.ColumnsOffsetX;
  _21 = _19 + _20;
  window_7->DC.CursorPos.x = _21;
  _23 = window_7->DC.CursorPosPrevLine.y;
  window_7->DC.CursorPos.y = _23;
  goto <bb 11>;

  <bb 8>:
  if (spacing_w_11(D) < 0.0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  spacing_w_25 = g_9->Style.ItemSpacing.x;

  <bb 10>:
  # spacing_w_2 = PHI <spacing_w_11(D)(8), spacing_w_25(9)>
  _26 = window_7->DC.CursorPosPrevLine.x;
  _27 = _26 + spacing_w_2;
  window_7->DC.CursorPos.x = _27;
  _29 = window_7->DC.CursorPosPrevLine.y;
  window_7->DC.CursorPos.y = _29;

  <bb 11>:
  _31 = window_7->DC.PrevLineHeight;
  window_7->DC.CurrentLineHeight = _31;
  _33 = window_7->DC.PrevLineTextBaseOffset;
  window_7->DC.CurrentLineTextBaseOffset = _33;

<L11>:
  return;

}



;; Function void ImGui::NewLine() (_ZN5ImGui7NewLineEv, funcdef_no=1152, decl_uid=2621, cgraph_uid=1051, symbol_order=1062)

void ImGui::NewLine() ()
{
  const ImGuiLayoutType backup_layout_type;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.43590;
  struct ImVec2 D.21445;
  struct ImVec2 D.21444;
  float D.43586;
  bool D.43583;
  bool _6;
  float _10;
  float _15;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 8> (<L5>);

  <bb 4>:
  g_7 = GImGui;
  backup_layout_type_8 = window_5->DC.LayoutType;
  window_5->DC.LayoutType = 0;
  _10 = window_5->DC.CurrentLineHeight;
  if (_10 > 0.0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImVec2::ImVec2 (&D.21444, 0.0, 0.0);
  ImGui::ItemSize (&D.21444, 0.0);
  D.21444 ={v} {CLOBBER};
  goto <bb 7>;

  <bb 6>:
  _15 = g_7->FontSize;
  ImVec2::ImVec2 (&D.21445, 0.0, _15);
  ImGui::ItemSize (&D.21445, 0.0);
  D.21445 ={v} {CLOBBER};

  <bb 7>:
  window_5->DC.LayoutType = backup_layout_type_8;

<L5>:
  return;

}



;; Function void ImGui::NextColumn() (_ZN5ImGui10NextColumnEv, funcdef_no=1153, decl_uid=3257, cgraph_uid=1052, symbol_order=1063)

void ImGui::NextColumn() ()
{
  float D.43632;
  float D.43631;
  struct ImGuiColumnsSet * columns;
  struct ImGuiContext & g;
  struct ImGuiWindow * window;
  float D.43629;
  float D.43628;
  float D.43627;
  float D.43626;
  int D.43625;
  float D.43624;
  float D.43623;
  float D.43622;
  float D.43621;
  float D.43620;
  float D.43619;
  struct ImDrawList * D.43618;
  struct ImDrawList * D.43616;
  int D.43615;
  float D.43614;
  float D.43613;
  float D.43612;
  float D.43611;
  float D.43610;
  int D.43609;
  int D.43606;
  int D.43605;
  int D.43604;
  int D.43603;
  bool retval.1926;
  float D.43601;
  float D.43600;
  float D.43599;
  struct ImGuiColumnsSet * D.43598;
  bool D.43596;
  bool _6;
  struct ImGuiColumnsSet * _7;
  float _12;
  float _13;
  float _15;
  int _17;
  int _18;
  int _20;
  int _21;
  bool retval.1926_22;
  int _23;
  float _25;
  float _26;
  float _27;
  float _28;
  float _29;
  float _30;
  int _32;
  struct ImDrawList * _33;
  struct ImDrawList * _36;
  float _39;
  float _41;
  float _42;
  float _43;
  float _44;
  float _45;
  int _46;
  float _47;
  float _49;
  float _55;
  float _56;
  float _57;

  <bb 2>:
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->SkipItems;
  if (_6 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _7 = window_5->DC.ColumnsSet;
  if (_7 == 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 9> (<L6>);

  <bb 5>:
  g_8 = GImGui;
  ImGui::PopItemWidth ();
  ImGui::PopClipRect ();
  columns_11 = window_5->DC.ColumnsSet;
  _12 = window_5->DC.CursorPos.y;
  _13 = columns_11->LineMaxY;
  _15 = ImMax (_13, _12);
  columns_11->LineMaxY = _15;
  _17 = columns_11->Current;
  _18 = _17 + 1;
  columns_11->Current = _18;
  _20 = columns_11->Current;
  _21 = columns_11->Count;
  retval.1926_22 = _20 < _21;
  if (retval.1926_22 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _23 = columns_11->Current;
  _25 = ImGui::GetColumnOffset (_23);
  _26 = _25;
  _27 = window_5->DC.IndentX;
  _28 = _26 - _27;
  _29 = g_8->Style.ItemSpacing.x;
  _30 = _28 + _29;
  window_5->DC.ColumnsOffsetX = _30;
  _32 = columns_11->Current;
  _33 = window_5->DrawList;
  ImDrawList::ChannelsSetCurrent (_33, _32);
  goto <bb 8>;

  <bb 7>:
  window_5->DC.ColumnsOffsetX = 0.0;
  _36 = window_5->DrawList;
  ImDrawList::ChannelsSetCurrent (_36, 0);
  columns_11->Current = 0;
  _39 = columns_11->LineMaxY;
  columns_11->LineMinY = _39;

  <bb 8>:
  _41 = window_5->Pos.x;
  _42 = window_5->DC.IndentX;
  _43 = _41 + _42;
  _44 = window_5->DC.ColumnsOffsetX;
  _45 = _43 + _44;
  _46 = (int) _45;
  _47 = (float) _46;
  window_5->DC.CursorPos.x = _47;
  _49 = columns_11->LineMinY;
  window_5->DC.CursorPos.y = _49;
  window_5->DC.CurrentLineHeight = 0.0;
  window_5->DC.CurrentLineTextBaseOffset = 0.0;
  ImGui::PushColumnClipRect (-1);
  _55 = ImGui::GetColumnWidth (-1);
  _56 = _55;
  _57 = _56 * 6.4999997615814208984375e-1;
  ImGui::PushItemWidth (_57);

<L6>:
  return;

}



;; Function int ImGui::GetColumnIndex() (_ZN5ImGui14GetColumnIndexEv, funcdef_no=1154, decl_uid=3258, cgraph_uid=1053, symbol_order=1064)

int ImGui::GetColumnIndex() ()
{
  struct ImGuiWindow * window;
  struct ImGuiColumnsSet * D.43638;
  struct ImGuiColumnsSet * D.43635;
  int iftmp.1927;
  int D.43633;
  int iftmp.1927_1;
  struct ImGuiColumnsSet * _5;
  struct ImGuiColumnsSet * _6;
  int iftmp.1927_7;
  int iftmp.1927_8;
  int _9;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  _5 = window_4->DC.ColumnsSet;
  if (_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = window_4->DC.ColumnsSet;
  iftmp.1927_7 = _6->Current;
  goto <bb 5>;

  <bb 4>:
  iftmp.1927_8 = 0;

  <bb 5>:
  # iftmp.1927_1 = PHI <iftmp.1927_7(3), iftmp.1927_8(4)>
  _9 = iftmp.1927_1;

<L3>:
  return _9;

}



;; Function int ImGui::GetColumnsCount() (_ZN5ImGui15GetColumnsCountEv, funcdef_no=1155, decl_uid=3269, cgraph_uid=1054, symbol_order=1065)

int ImGui::GetColumnsCount() ()
{
  struct ImGuiWindow * window;
  struct ImGuiColumnsSet * D.43646;
  struct ImGuiColumnsSet * D.43643;
  int iftmp.1928;
  int D.43641;
  int iftmp.1928_1;
  struct ImGuiColumnsSet * _5;
  struct ImGuiColumnsSet * _6;
  int iftmp.1928_7;
  int iftmp.1928_8;
  int _9;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  _5 = window_4->DC.ColumnsSet;
  if (_5 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = window_4->DC.ColumnsSet;
  iftmp.1928_7 = _6->Count;
  goto <bb 5>;

  <bb 4>:
  iftmp.1928_8 = 1;

  <bb 5>:
  # iftmp.1928_1 = PHI <iftmp.1928_7(3), iftmp.1928_8(4)>
  _9 = iftmp.1928_1;

<L3>:
  return _9;

}



;; Function float OffsetNormToPixels(const ImGuiColumnsSet*, float) (_ZL18OffsetNormToPixelsPK15ImGuiColumnsSetf, funcdef_no=1156, decl_uid=21459, cgraph_uid=1055, symbol_order=1066)

float OffsetNormToPixels(const ImGuiColumnsSet*, float) (const struct ImGuiColumnsSet * columns, float offset_norm)
{
  float D.43652;
  float D.43651;
  float D.43650;
  float D.43649;
  float _3;
  float _4;
  float _5;
  float _7;

  <bb 2>:
  _3 = columns_2(D)->MaxX;
  _4 = columns_2(D)->MinX;
  _5 = _3 - _4;
  _7 = _5 * offset_norm_6(D);

<L0>:
  return _7;

}



;; Function float PixelsToOffsetNorm(const ImGuiColumnsSet*, float) (_ZL18PixelsToOffsetNormPK15ImGuiColumnsSetf, funcdef_no=1157, decl_uid=21463, cgraph_uid=1056, symbol_order=1067)

float PixelsToOffsetNorm(const ImGuiColumnsSet*, float) (const struct ImGuiColumnsSet * columns, float offset)
{
  float D.43657;
  float D.43656;
  float D.43655;
  float D.43654;
  float _3;
  float _4;
  float _5;
  float _7;

  <bb 2>:
  _3 = columns_2(D)->MaxX;
  _4 = columns_2(D)->MinX;
  _5 = _3 - _4;
  _7 = offset_6(D) / _5;

<L0>:
  return _7;

}



;; Function float GetColumnsRectHalfWidth() (_ZL23GetColumnsRectHalfWidthv, funcdef_no=1158, decl_uid=21465, cgraph_uid=1057, symbol_order=1068)

float GetColumnsRectHalfWidth() ()
{
  float D.43692;
  float _1;

  <bb 2>:
  _1 = 4.0e+0;

<L0>:
  return _1;

}



;; Function float GetDraggedColumnOffset(ImGuiColumnsSet*, int) (_ZL22GetDraggedColumnOffsetP15ImGuiColumnsSeti, funcdef_no=1159, decl_uid=21469, cgraph_uid=1058, symbol_order=1069)

float GetDraggedColumnOffset(ImGuiColumnsSet*, int) (struct ImGuiColumnsSet * columns, int column_index)
{
  float D.43691;
  float D.43690;
  float x;
  static const char __PRETTY_FUNCTION__[52] = "float GetDraggedColumnOffset(ImGuiColumnsSet*, int)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  float D.43688;
  float D.43686;
  float D.43685;
  float D.43684;
  int D.43683;
  int D.43680;
  int D.43679;
  float D.43678;
  float D.43677;
  float D.43676;
  int D.43675;
  float D.43674;
  float D.43673;
  float D.43672;
  float D.43671;
  float D.43670;
  float D.43669;
  unsigned int D.43665;
  unsigned int column_index.1929;
  unsigned int D.43663;
  unsigned int D.43662;
  unsigned int _7;
  unsigned int _9;
  unsigned int column_index.1929_10;
  unsigned int _11;
  float _12;
  float _13;
  float _14;
  float _16;
  float _17;
  float _18;
  int _20;
  float _22;
  float _23;
  float _24;
  float _25;
  int _28;
  int _29;
  int _30;
  float _32;
  float _33;
  float _34;
  float _35;
  float _38;

  <bb 2>:
  g_4 = GImGui;
  window_5 = g_4->CurrentWindow;
  if (column_index_6(D) > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("column_index > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12466, &__PRETTY_FUNCTION__);

  <bb 4>:
  _7 = g_4->ActiveId;
  _9 = columns_8(D)->ID;
  column_index.1929_10 = (unsigned int) column_index_6(D);
  _11 = _9 + column_index.1929_10;
  if (_7 == _11)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("g.ActiveId == columns->ID + ImGuiID(column_index)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12467, &__PRETTY_FUNCTION__);

  <bb 6>:
  _12 = g_4->IO.MousePos.x;
  _13 = g_4->ActiveIdClickOffset.x;
  _14 = _12 - _13;
  _16 = GetColumnsRectHalfWidth ();
  _17 = _14 + _16;
  _18 = window_5->Pos.x;
  x_19 = _17 - _18;
  _20 = column_index_6(D) + -1;
  _22 = ImGui::GetColumnOffset (_20);
  _23 = _22;
  _24 = g_4->Style.ColumnsMinSpacing;
  _25 = _23 + _24;
  x_27 = ImMax (x_19, _25);
  _28 = columns_8(D)->Flags;
  _29 = _28 & 4;
  if (_29 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _30 = column_index_6(D) + 1;
  _32 = ImGui::GetColumnOffset (_30);
  _33 = _32;
  _34 = g_4->Style.ColumnsMinSpacing;
  _35 = _33 - _34;
  x_37 = ImMin (x_27, _35);

  <bb 8>:
  # x_1 = PHI <x_27(6), x_37(7)>
  _38 = x_1;

<L9>:
  return _38;

}



;; Function float ImGui::GetColumnOffset(int) (_ZN5ImGui15GetColumnOffsetEi, funcdef_no=1160, decl_uid=3265, cgraph_uid=1059, symbol_order=1070)

float ImGui::GetColumnOffset(int) (int column_index)
{
  const float x_offset;
  const float t;
  static const char __PRETTY_FUNCTION__[34] = "float ImGui::GetColumnOffset(int)";
  struct ImGuiColumnsSet * columns;
  struct ImGuiWindow * window;
  float D.43708;
  float D.43707;
  float D.43706;
  struct value_type & D.43705;
  struct ImVector * D.43704;
  int D.43700;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  float _13;
  float _14;
  float _17;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  columns_5 = window_4->DC.ColumnsSet;
  if (columns_5 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12481, &__PRETTY_FUNCTION__);

  <bb 4>:
  if (column_index_6(D) < 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  column_index_7 = columns_5->Current;

  <bb 6>:
  # column_index_1 = PHI <column_index_6(D)(4), column_index_7(5)>
  _8 = columns_5->Columns.Size;
  if (_8 > column_index_1)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("column_index < columns->Columns.Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12485, &__PRETTY_FUNCTION__);

  <bb 8>:
  _9 = &columns_5->Columns;
  _11 = ImVector<ImGuiColumnData>::operator[] (_9, column_index_1);
  t_12 = _11->OffsetNorm;
  _13 = columns_5->MaxX;
  _14 = columns_5->MinX;
  x_offset_16 = ImLerp (_14, _13, t_12);
  _17 = x_offset_16;

<L9>:
  return _17;

}



;; Function float GetColumnWidthEx(ImGuiColumnsSet*, int, bool) (_ZL16GetColumnWidthExP15ImGuiColumnsSetib, funcdef_no=1161, decl_uid=21486, cgraph_uid=1060, symbol_order=1071)

float GetColumnWidthEx(ImGuiColumnsSet*, int, bool) (struct ImGuiColumnsSet * columns, int column_index, bool before_resize)
{
  float offset_norm;
  float D.43739;
  float D.43738;
  struct value_type & D.43737;
  struct ImVector * D.43736;
  float D.43735;
  struct value_type & D.43734;
  struct ImVector * D.43733;
  int D.43732;
  float D.43730;
  struct value_type & D.43729;
  struct ImVector * D.43728;
  float D.43727;
  struct value_type & D.43726;
  struct ImVector * D.43725;
  int D.43724;
  int _9;
  struct ImVector * _10;
  struct value_type & _12;
  float _13;
  struct ImVector * _14;
  struct value_type & _16;
  float _17;
  int _19;
  struct ImVector * _20;
  struct value_type & _22;
  float _23;
  struct ImVector * _24;
  struct value_type & _26;
  float _27;
  float _30;

  <bb 2>:
  if (column_index_4(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  column_index_7 = columns_6(D)->Current;

  <bb 4>:
  # column_index_1 = PHI <column_index_4(D)(2), column_index_7(3)>
  if (before_resize_8(D) != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _9 = column_index_1 + 1;
  _10 = &columns_6(D)->Columns;
  _12 = ImVector<ImGuiColumnData>::operator[] (_10, _9);
  _13 = _12->OffsetNormBeforeResize;
  _14 = &columns_6(D)->Columns;
  _16 = ImVector<ImGuiColumnData>::operator[] (_14, column_index_1);
  _17 = _16->OffsetNormBeforeResize;
  offset_norm_18 = _13 - _17;
  goto <bb 7>;

  <bb 6>:
  _19 = column_index_1 + 1;
  _20 = &columns_6(D)->Columns;
  _22 = ImVector<ImGuiColumnData>::operator[] (_20, _19);
  _23 = _22->OffsetNorm;
  _24 = &columns_6(D)->Columns;
  _26 = ImVector<ImGuiColumnData>::operator[] (_24, column_index_1);
  _27 = _26->OffsetNorm;
  offset_norm_28 = _23 - _27;

  <bb 7>:
  # offset_norm_2 = PHI <offset_norm_18(5), offset_norm_28(6)>
  _30 = OffsetNormToPixels (columns_6(D), offset_norm_2);

<L6>:
  return _30;

}



;; Function float ImGui::GetColumnWidth(int) (_ZN5ImGui14GetColumnWidthEi, funcdef_no=1162, decl_uid=3260, cgraph_uid=1061, symbol_order=1072)

float ImGui::GetColumnWidth(int) (int column_index)
{
  static const char __PRETTY_FUNCTION__[33] = "float ImGui::GetColumnWidth(int)";
  struct ImGuiColumnsSet * columns;
  struct ImGuiWindow * window;
  float D.43755;
  float D.43754;
  struct value_type & D.43753;
  struct ImVector * D.43752;
  float D.43751;
  struct value_type & D.43750;
  struct ImVector * D.43749;
  int D.43748;
  float D.43747;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  float _12;
  struct ImVector * _13;
  struct value_type & _15;
  float _16;
  float _17;
  float _19;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  columns_5 = window_4->DC.ColumnsSet;
  if (columns_5 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12509, &__PRETTY_FUNCTION__);

  <bb 4>:
  if (column_index_6(D) < 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  column_index_7 = columns_5->Current;

  <bb 6>:
  # column_index_1 = PHI <column_index_6(D)(4), column_index_7(5)>
  _8 = column_index_1 + 1;
  _9 = &columns_5->Columns;
  _11 = ImVector<ImGuiColumnData>::operator[] (_9, _8);
  _12 = _11->OffsetNorm;
  _13 = &columns_5->Columns;
  _15 = ImVector<ImGuiColumnData>::operator[] (_13, column_index_1);
  _16 = _15->OffsetNorm;
  _17 = _12 - _16;
  _19 = OffsetNormToPixels (columns_5, _17);

<L6>:
  return _19;

}



;; Function void ImGui::SetColumnOffset(int, float) (_ZN5ImGui15SetColumnOffsetEif, funcdef_no=1163, decl_uid=3268, cgraph_uid=1062, symbol_order=1073)

void ImGui::SetColumnOffset(int, float) (int column_index, float offset)
{
  float D.43806;
  const float width;
  const bool preserve_width;
  static const char __PRETTY_FUNCTION__[40] = "void ImGui::SetColumnOffset(int, float)";
  struct ImGuiColumnsSet * columns;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.43804;
  float D.43803;
  float D.43802;
  float D.43801;
  float D.43798;
  float D.43797;
  float D.43796;
  struct value_type & D.43795;
  struct ImVector * D.43794;
  float D.43792;
  float D.43791;
  float D.43790;
  int D.43789;
  int D.43788;
  float D.43787;
  float D.43786;
  int D.43783;
  int D.43782;
  int D.43780;
  bool D.43779;
  float iftmp.1931;
  int D.43774;
  int D.43773;
  int D.43771;
  int D.43770;
  bool iftmp.1930;
  int D.43763;
  bool iftmp.1930_3;
  float iftmp.1931_4;
  int _14;
  int _15;
  int _16;
  int _17;
  int _18;
  bool iftmp.1930_19;
  bool iftmp.1930_20;
  bool _22;
  int _23;
  float _25;
  float iftmp.1931_26;
  float iftmp.1931_27;
  int _29;
  int _30;
  float _32;
  float _33;
  int _34;
  int _35;
  float _36;
  float _37;
  float _38;
  struct ImVector * _41;
  struct value_type & _43;
  float _44;
  float _45;
  float _47;
  float _49;
  float _51;
  float _52;
  int _53;

  <bb 2>:
  g_9 = GImGui;
  window_10 = g_9->CurrentWindow;
  columns_11 = window_10->DC.ColumnsSet;
  if (columns_11 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12521, &__PRETTY_FUNCTION__);

  <bb 4>:
  if (column_index_12(D) < 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  column_index_13 = columns_11->Current;

  <bb 6>:
  # column_index_1 = PHI <column_index_12(D)(4), column_index_13(5)>
  _14 = columns_11->Columns.Size;
  if (_14 > column_index_1)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("column_index < columns->Columns.Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12525, &__PRETTY_FUNCTION__);

  <bb 8>:
  _15 = columns_11->Flags;
  _16 = _15 & 4;
  if (_16 == 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _17 = columns_11->Count;
  _18 = _17 + -1;
  if (_18 > column_index_1)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1930_19 = 1;
  goto <bb 12>;

  <bb 11>:
  iftmp.1930_20 = 0;

  <bb 12>:
  # iftmp.1930_3 = PHI <iftmp.1930_19(10), iftmp.1930_20(11)>
  preserve_width_21 = iftmp.1930_3;
  if (preserve_width_21 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _22 = columns_11->IsBeingResized;
  _23 = (int) _22;
  _25 = GetColumnWidthEx (columns_11, column_index_1, _23);
  iftmp.1931_26 = _25;
  goto <bb 15>;

  <bb 14>:
  iftmp.1931_27 = 0.0;

  <bb 15>:
  # iftmp.1931_4 = PHI <iftmp.1931_26(13), iftmp.1931_27(14)>
  width_28 = iftmp.1931_4;
  _29 = columns_11->Flags;
  _30 = _29 & 8;
  if (_30 == 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  _32 = columns_11->MaxX;
  _33 = g_9->Style.ColumnsMinSpacing;
  _34 = columns_11->Count;
  _35 = _34 - column_index_1;
  _36 = (float) _35;
  _37 = _33 * _36;
  _38 = _32 - _37;
  offset_40 = ImMin (offset_31(D), _38);

  <bb 17>:
  # offset_2 = PHI <offset_31(D)(15), offset_40(16)>
  _41 = &columns_11->Columns;
  _43 = ImVector<ImGuiColumnData>::operator[] (_41, column_index_1);
  _44 = columns_11->MinX;
  _45 = offset_2 - _44;
  _47 = PixelsToOffsetNorm (columns_11, _45);
  _43->OffsetNorm = _47;
  if (preserve_width_21 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  _49 = g_9->Style.ColumnsMinSpacing;
  _51 = ImMax (_49, width_28);
  _52 = _51 + offset_2;
  _53 = column_index_1 + 1;
  ImGui::SetColumnOffset (_53, _52);

  <bb 19>:
  return;

}



;; Function void ImGui::SetColumnWidth(int, float) (_ZN5ImGui14SetColumnWidthEif, funcdef_no=1164, decl_uid=3263, cgraph_uid=1063, symbol_order=1074)

void ImGui::SetColumnWidth(int, float) (int column_index, float width)
{
  float D.43816;
  static const char __PRETTY_FUNCTION__[39] = "void ImGui::SetColumnWidth(int, float)";
  struct ImGuiColumnsSet * columns;
  struct ImGuiWindow * window;
  int D.43815;
  float D.43814;
  float D.43813;
  float _9;
  float _10;
  float _12;
  int _13;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  columns_5 = window_4->DC.ColumnsSet;
  if (columns_5 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12542, &__PRETTY_FUNCTION__);

  <bb 4>:
  if (column_index_6(D) < 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  column_index_7 = columns_5->Current;

  <bb 6>:
  # column_index_1 = PHI <column_index_6(D)(4), column_index_7(5)>
  _9 = ImGui::GetColumnOffset (column_index_1);
  _10 = _9;
  _12 = _10 + width_11(D);
  _13 = column_index_1 + 1;
  ImGui::SetColumnOffset (_13, _12);
  return;

}



;; Function void ImGui::PushColumnClipRect(int) (_ZN5ImGui18PushColumnClipRectEi, funcdef_no=1165, decl_uid=13868, cgraph_uid=1064, symbol_order=1075)

void ImGui::PushColumnClipRect(int) (int column_index)
{
  struct ImGuiColumnsSet * columns;
  struct ImGuiWindow * window;
  struct ImVec2 * D.43825;
  struct value_type & D.43824;
  struct ImVector * D.43823;
  struct ImVec2 * D.43822;
  struct value_type & D.43821;
  struct ImVector * D.43820;
  struct ImVector * _8;
  struct value_type & _10;
  struct ImVec2 * _11;
  struct ImVector * _12;
  struct value_type & _14;
  struct ImVec2 * _15;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindowRead ();
  columns_5 = window_4->DC.ColumnsSet;
  if (column_index_6(D) < 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  column_index_7 = columns_5->Current;

  <bb 4>:
  # column_index_1 = PHI <column_index_6(D)(2), column_index_7(3)>
  _8 = &columns_5->Columns;
  _10 = ImVector<ImGuiColumnData>::operator[] (_8, column_index_1);
  _11 = &_10->ClipRect.Max;
  _12 = &columns_5->Columns;
  _14 = ImVector<ImGuiColumnData>::operator[] (_12, column_index_1);
  _15 = &_14->ClipRect.Min;
  ImGui::PushClipRect (_15, _11, 0);
  return;

}



;; Function ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow*, ImGuiID) (_ZL19FindOrAddColumnsSetP11ImGuiWindowj, funcdef_no=1166, decl_uid=21519, cgraph_uid=1065, symbol_order=1076)

ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow*, ImGuiID) (struct ImGuiWindow * window, ImGuiID id)
{
  void * D.46813;
  int n;
  struct ImGuiColumnsSet * columns;
  struct ImVector * D.43838;
  struct ImVector * D.43837;
  struct ImGuiColumnsSet D.21540;
  struct ImVector * D.43836;
  struct ImGuiColumnsSet * D.43835;
  unsigned int D.43832;
  struct value_type & D.43831;
  struct ImVector * D.43830;
  bool retval.1932;
  int D.43827;
  struct ImGuiColumnsSet * _2;
  int _8;
  struct ImVector * _9;
  struct value_type & _11;
  unsigned int _12;
  bool retval.1932_14;
  struct ImVector * _16;
  struct ImGuiColumnsSet * _18;
  struct ImVector * _20;
  struct ImVector * _24;
  struct ImGuiColumnsSet * _28;

  <bb 2>:
  n_5 = 0;

  <bb 3>:
  # n_1 = PHI <n_5(2), n_15(6)>
  _8 = window_7(D)->ColumnsStorage.Size;
  if (_8 <= n_1)
    goto <bb 7>;
  else
    goto <bb 4>;

  <bb 4>:
  _9 = &window_7(D)->ColumnsStorage;
  _11 = ImVector<ImGuiColumnsSet>::operator[] (_9, n_1);
  _12 = _11->ID;
  retval.1932_14 = _12 == id_13(D);
  if (retval.1932_14 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _16 = &window_7(D)->ColumnsStorage;
  _18 = ImVector<ImGuiColumnsSet>::operator[] (_16, n_1);
  goto <bb 9> (<L5>);

  <bb 6>:
  n_15 = n_1 + 1;
  goto <bb 3>;

  <bb 7>:
  ImGuiColumnsSet::ImGuiColumnsSet (&D.21540);
  _20 = &window_7(D)->ColumnsStorage;
  ImVector<ImGuiColumnsSet>::push_back (_20, &D.21540);

  <bb 8>:
  ImGuiColumnsSet::~ImGuiColumnsSet (&D.21540);
  D.21540 ={v} {CLOBBER};
  _24 = &window_7(D)->ColumnsStorage;
  columns_26 = ImVector<ImGuiColumnsSet>::back (_24);
  columns_26->ID = id_13(D);
  _28 = columns_26;

  # _2 = PHI <_18(5), _28(8)>
<L5>:
  return _2;

<L6>:
  ImGuiColumnsSet::~ImGuiColumnsSet (&D.21540);
  _30 = __builtin_eh_pointer (2);
  __builtin_unwind_resume (_30);

}



;; Function void ImGui::BeginColumns(const char*, int, ImGuiColumnsFlags) (_ZN5ImGui12BeginColumnsEPKcii, funcdef_no=1167, decl_uid=13865, cgraph_uid=1066, symbol_order=1077)

void ImGui::BeginColumns(const char*, int, ImGuiColumnsFlags) (const char * str_id, int columns_count, ImGuiColumnsFlags flags)
{
  float D.44005;
  float D.44004;
  float D.44003;
  struct ImGuiColumnsSet * D.44001;
  ImGuiID D.44000;
  float clip_x2;
  float clip_x1;
  struct ImGuiColumnData * column;
  int n;
  struct ImGuiColumnData column;
  int n;
  const float content_region_width;
  struct ImGuiColumnsSet * columns;
  ImGuiID id;
  static const char __PRETTY_FUNCTION__[62] = "void ImGui::BeginColumns(const char*, int, ImGuiColumnsFlags)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  float D.43999;
  float D.43998;
  struct ImDrawList * D.43997;
  int D.43996;
  struct ImRect * D.43995;
  struct ImRect * D.43994;
  struct ImRect D.21588;
  float D.43993;
  float D.43992;
  float D.43991;
  int D.43990;
  float D.43989;
  float D.43988;
  float D.43987;
  float D.43986;
  float D.43985;
  float D.43984;
  float D.43983;
  struct ImVector * D.43982;
  struct ImVector * D.43978;
  float D.43977;
  float D.43976;
  float D.43975;
  int D.43973;
  struct ImVector * D.43971;
  int D.43970;
  int D.43967;
  bool D.43966;
  int D.43965;
  struct ImVector * D.43963;
  int D.43960;
  int D.43959;
  int D.43956;
  float D.43955;
  int D.43954;
  float D.43953;
  float D.43952;
  float D.43951;
  float D.43950;
  float D.43949;
  float D.43948;
  float D.43947;
  float D.43946;
  float D.43945;
  float D.43944;
  float D.43943;
  float D.43942;
  float D.43941;
  float D.43940;
  float D.43939;
  float D.43938;
  float D.43937;
  float D.43936;
  float D.43935;
  float D.43931;
  float iftmp.1937;
  unsigned int D.43926;
  const char * iftmp.1936;
  int iftmp.1935;
  struct ImGuiColumnsSet * D.43914;
  int iftmp.1935_3;
  const char * iftmp.1936_4;
  float iftmp.1937_5;
  struct ImGuiColumnsSet * _15;
  int iftmp.1935_17;
  int iftmp.1935_18;
  const char * iftmp.1936_20;
  const char * iftmp.1936_21;
  ImGuiID _23;
  struct ImGuiColumnsSet * _27;
  unsigned int _29;
  float _35;
  float iftmp.1937_36;
  float _37;
  float _38;
  float iftmp.1937_39;
  float _41;
  float _42;
  float _43;
  float _45;
  float _46;
  float _47;
  float _48;
  float _50;
  float _52;
  float _54;
  float _56;
  float _58;
  float _61;
  float _62;
  float _63;
  float _64;
  float _65;
  int _66;
  float _67;
  int _69;
  int _70;
  int _71;
  struct ImVector * _72;
  int _74;
  bool _75;
  int _77;
  int _78;
  struct ImVector * _79;
  int _82;
  float _84;
  float _85;
  float _86;
  struct ImVector * _88;
  struct ImVector * _94;
  float _97;
  float _98;
  float _100;
  float _101;
  float _102;
  float _103;
  float _106;
  float _107;
  int _108;
  float _110;
  float _111;
  float _112;
  float _113;
  struct ImRect * _119;
  struct ImRect * _120;
  int _123;
  struct ImDrawList * _124;
  float _128;
  float _129;
  float _130;

  <bb 2>:
  g_11 = GImGui;
  window_13 = ImGui::GetCurrentWindow ();
  if (columns_count_14(D) > 1)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns_count > 1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12576, &__PRETTY_FUNCTION__);

  <bb 4>:
  _15 = window_13->DC.ColumnsSet;
  if (_15 == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("window->DC.ColumnsSet == __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12577, &__PRETTY_FUNCTION__);

  <bb 6>:
  if (str_id_16(D) == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  iftmp.1935_17 = columns_count_14(D) + 287454023;
  goto <bb 9>;

  <bb 8>:
  iftmp.1935_18 = 287454023;

  <bb 9>:
  # iftmp.1935_3 = PHI <iftmp.1935_17(7), iftmp.1935_18(8)>
  ImGui::PushID (iftmp.1935_3);
  if (str_id_16(D) != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1936_20 = str_id_16(D);
  goto <bb 12>;

  <bb 11>:
  iftmp.1936_21 = "columns";

  <bb 12>:
  # iftmp.1936_4 = PHI <iftmp.1936_20(10), iftmp.1936_21(11)>
  _23 = ImGuiWindow::GetID (window_13, iftmp.1936_4, 0B);
  id_24 = _23;
  ImGui::PopID ();
  _27 = FindOrAddColumnsSet (window_13, id_24);
  columns_28 = _27;
  _29 = columns_28->ID;
  if (_29 == id_24)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  __assert_fail ("columns->ID == id", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12587, &__PRETTY_FUNCTION__);

  <bb 14>:
  columns_28->Current = 0;
  columns_28->Count = columns_count_14(D);
  columns_28->Flags = flags_32(D);
  window_13->DC.ColumnsSet = columns_28;
  _35 = window_13->SizeContentsExplicit.x;
  if (_35 != 0.0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.1937_36 = window_13->SizeContentsExplicit.x;
  goto <bb 17>;

  <bb 16>:
  _37 = window_13->InnerClipRect.Max.x;
  _38 = window_13->Pos.x;
  iftmp.1937_39 = _37 - _38;

  <bb 17>:
  # iftmp.1937_5 = PHI <iftmp.1937_36(15), iftmp.1937_39(16)>
  content_region_width_40 = iftmp.1937_5;
  _41 = window_13->DC.IndentX;
  _42 = g_11->Style.ItemSpacing.x;
  _43 = _41 - _42;
  columns_28->MinX = _43;
  _45 = columns_28->MinX;
  _46 = _45 + 1.0e+0;
  _47 = window_13->Scroll.x;
  _48 = content_region_width_40 - _47;
  _50 = ImMax (_48, _46);
  columns_28->MaxX = _50;
  _52 = window_13->DC.CursorPos.y;
  columns_28->StartPosY = _52;
  _54 = window_13->DC.CursorMaxPos.x;
  columns_28->StartMaxPosX = _54;
  _56 = window_13->DC.CursorPos.y;
  columns_28->LineMaxY = _56;
  _58 = columns_28->LineMaxY;
  columns_28->LineMinY = _58;
  window_13->DC.ColumnsOffsetX = 0.0;
  _61 = window_13->Pos.x;
  _62 = window_13->DC.IndentX;
  _63 = _61 + _62;
  _64 = window_13->DC.ColumnsOffsetX;
  _65 = _63 + _64;
  _66 = (int) _65;
  _67 = (float) _66;
  window_13->DC.CursorPos.x = _67;
  _69 = columns_28->Columns.Size;
  if (_69 != 0)
    goto <bb 18>;
  else
    goto <bb 20>;

  <bb 18>:
  _70 = columns_28->Columns.Size;
  _71 = columns_count_14(D) + 1;
  if (_70 != _71)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _72 = &columns_28->Columns;
  ImVector<ImGuiColumnData>::resize (_72, 0);

  <bb 20>:
  _74 = columns_28->Columns.Size;
  _75 = _74 == 0;
  columns_28->IsFirstFrame = _75;
  _77 = columns_28->Columns.Size;
  if (_77 == 0)
    goto <bb 21>;
  else
    goto <bb 25>;

  <bb 21>:
  _78 = columns_count_14(D) + 1;
  _79 = &columns_28->Columns;
  ImVector<ImGuiColumnData>::reserve (_79, _78);
  n_81 = 0;

  <bb 22>:
  # n_1 = PHI <n_81(21), n_91(23)>
  _82 = columns_count_14(D) + 1;
  if (_82 <= n_1)
    goto <bb 24>;
  else
    goto <bb 23>;

  <bb 23>:
  ImGuiColumnData::ImGuiColumnData (&column);
  _84 = (float) n_1;
  _85 = (float) columns_count_14(D);
  _86 = _84 / _85;
  column.OffsetNorm = _86;
  _88 = &columns_28->Columns;
  ImVector<ImGuiColumnData>::push_back (_88, &column);
  column ={v} {CLOBBER};
  n_91 = n_1 + 1;
  goto <bb 22>;

  <bb 24>:

  <bb 25>:
  n_93 = 0;

  <bb 26>:
  # n_2 = PHI <n_93(25), n_122(27)>
  if (n_2 >= columns_count_14(D))
    goto <bb 28>;
  else
    goto <bb 27>;

  <bb 27>:
  _94 = &columns_28->Columns;
  column_96 = ImVector<ImGuiColumnData>::operator[] (_94, n_2);
  _97 = window_13->Pos.x;
  _98 = _97 + 5.0e-1;
  _100 = ImGui::GetColumnOffset (n_2);
  _101 = _100;
  _102 = _98 + _101;
  _103 = _102 - 1.0e+0;
  clip_x1_105 = ImFloor (_103);
  _106 = window_13->Pos.x;
  _107 = _106 + 5.0e-1;
  _108 = n_2 + 1;
  _110 = ImGui::GetColumnOffset (_108);
  _111 = _110;
  _112 = _107 + _111;
  _113 = _112 - 1.0e+0;
  clip_x2_115 = ImFloor (_113);
  ImRect::ImRect (&D.21588, clip_x1_105, -3.4028234663852885981170418348451692544e+38, clip_x2_115, 3.4028234663852885981170418348451692544e+38);
  column_96->ClipRect = D.21588;
  D.21588 ={v} {CLOBBER};
  _119 = &window_13->ClipRect;
  _120 = &column_96->ClipRect;
  ImRect::ClipWith (_120, _119);
  n_122 = n_2 + 1;
  goto <bb 26>;

  <bb 28>:
  _123 = columns_28->Count;
  _124 = window_13->DrawList;
  ImDrawList::ChannelsSplit (_124, _123);
  ImGui::PushColumnClipRect (-1);
  _128 = ImGui::GetColumnWidth (-1);
  _129 = _128;
  _130 = _129 * 6.4999997615814208984375e-1;
  ImGui::PushItemWidth (_130);
  return;

}



;; Function void ImGui::EndColumns() (_ZN5ImGui10EndColumnsEv, funcdef_no=1168, decl_uid=13866, cgraph_uid=1067, symbol_order=1078)

void ImGui::EndColumns() ()
{
  float D.44166;
  float D.44160;
  int n;
  float x;
  const float xi;
  const ImU32 col;
  bool held;
  bool hovered;
  const struct ImRect column_rect;
  const float column_hw;
  const ImGuiID column_id;
  float x;
  int n;
  int dragging_column;
  const float y2;
  const float y1;
  bool is_being_resized;
  static const char __PRETTY_FUNCTION__[25] = "void ImGui::EndColumns()";
  struct ImGuiColumnsSet * columns;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  float D.44159;
  int D.44158;
  float D.44157;
  float D.44156;
  float D.44155;
  float D.44154;
  float D.44153;
  float D.44149;
  struct value_type & D.44148;
  struct ImVector * D.44147;
  struct value_type & D.44146;
  struct ImVector * D.44145;
  int D.44143;
  int D.44142;
  bool D.44138;
  bool D.44137;
  struct ImDrawList * D.44134;
  float D.44133;
  float D.44132;
  float D.44131;
  struct ImVec2 D.21614;
  float D.44130;
  float D.44129;
  struct ImVec2 D.21615;
  int D.44128;
  bool hovered.1950;
  ImGuiCol iftmp.1949;
  bool held.1948;
  ImGuiCol iftmp.1947;
  int D.44112;
  int D.44111;
  struct value_type & D.44110;
  struct ImVector * D.44109;
  bool held.1946;
  bool iftmp.1945;
  bool retval.1944;
  bool held.1943;
  bool hovered.1942;
  int D.44095;
  int D.44094;
  bool retval.1941;
  float D.44090;
  struct ImVec2 D.21608;
  float D.44089;
  struct ImVec2 D.21609;
  unsigned int n.1940;
  unsigned int D.44087;
  float D.44086;
  float D.44085;
  int D.44083;
  bool D.44079;
  bool D.44078;
  int D.44075;
  int D.44074;
  float D.44072;
  float D.44071;
  float D.44070;
  int D.44067;
  int D.44066;
  float D.44065;
  float D.44064;
  float D.44063;
  float D.44062;
  struct ImDrawList * D.44061;
  bool iftmp.1945_8;
  ImGuiCol iftmp.1947_9;
  ImGuiCol iftmp.1949_10;
  struct ImDrawList * _30;
  float _32;
  float _33;
  float _35;
  float _37;
  int _39;
  int _40;
  float _41;
  float _42;
  float _44;
  int _47;
  int _48;
  bool _49;
  bool _50;
  int _55;
  float _56;
  float _58;
  float _59;
  unsigned int _61;
  unsigned int n.1940_62;
  float _66;
  float _68;
  bool retval.1941_75;
  int _78;
  int _79;
  bool hovered.1942_81;
  bool held.1943_82;
  bool held.1946_84;
  struct ImVector * _85;
  struct value_type & _87;
  int _88;
  int _89;
  bool iftmp.1945_90;
  bool iftmp.1945_91;
  bool retval.1944_92;
  bool held.1948_94;
  ImGuiCol iftmp.1947_95;
  bool hovered.1950_96;
  ImGuiCol iftmp.1949_97;
  ImGuiCol iftmp.1949_98;
  ImGuiCol iftmp.1947_99;
  int _102;
  float _104;
  float _106;
  float _108;
  float _109;
  float _111;
  struct ImDrawList * _113;
  bool _129;
  bool _130;
  int _132;
  int _133;
  struct ImVector * _134;
  struct value_type & _136;
  struct ImVector * _137;
  struct value_type & _139;
  float _140;
  float _146;
  float _152;
  float _153;
  float _154;
  float _155;
  float _156;
  int _157;
  float _158;

  <bb 2>:
  g_24 = GImGui;
  window_26 = ImGui::GetCurrentWindow ();
  columns_27 = window_26->DC.ColumnsSet;
  if (columns_27 != 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12640, &__PRETTY_FUNCTION__);

  <bb 4>:
  ImGui::PopItemWidth ();
  ImGui::PopClipRect ();
  _30 = window_26->DrawList;
  ImDrawList::ChannelsMerge (_30);
  _32 = window_26->DC.CursorPos.y;
  _33 = columns_27->LineMaxY;
  _35 = ImMax (_33, _32);
  columns_27->LineMaxY = _35;
  _37 = columns_27->LineMaxY;
  window_26->DC.CursorPos.y = _37;
  _39 = columns_27->Flags;
  _40 = _39 & 16;
  if (_40 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _41 = columns_27->MaxX;
  _42 = columns_27->StartMaxPosX;
  _44 = ImMax (_42, _41);
  window_26->DC.CursorMaxPos.x = _44;

  <bb 6>:
  is_being_resized_46 = 0;
  _47 = columns_27->Flags;
  _48 = _47 & 1;
  if (_48 == 0)
    goto <bb 7>;
  else
    goto <bb 38>;

  <bb 7>:
  _49 = window_26->SkipItems;
  _50 = ~_49;
  if (_50 != 0)
    goto <bb 8>;
  else
    goto <bb 38>;

  <bb 8>:
  y1_51 = columns_27->StartPosY;
  y2_52 = window_26->DC.CursorPos.y;
  dragging_column_53 = -1;
  n_54 = 1;

  <bb 9>:
  # dragging_column_3 = PHI <dragging_column_53(8), dragging_column_5(29)>
  # n_6 = PHI <n_54(8), n_125(29)>
  _55 = columns_27->Count;
  if (_55 <= n_6)
    goto <bb 30>;
  else
    goto <bb 10>;

  <bb 10>:
  _56 = window_26->Pos.x;
  _58 = ImGui::GetColumnOffset (n_6);
  _59 = _58;
  x_60 = _56 + _59;
  _61 = columns_27->ID;
  n.1940_62 = (unsigned int) n_6;
  column_id_63 = _61 + n.1940_62;
  column_hw_65 = GetColumnsRectHalfWidth ();
  _66 = x_60 + column_hw_65;
  ImVec2::ImVec2 (&D.21609, _66, y2_52);
  _68 = x_60 - column_hw_65;
  ImVec2::ImVec2 (&D.21608, _68, y1_51);
  ImRect::ImRect (&column_rect, &D.21608, &D.21609);
  D.21608 ={v} {CLOBBER};
  D.21609 ={v} {CLOBBER};
  ImGui::KeepAliveID (column_id_63);
  retval.1941_75 = ImGui::IsClippedEx (&column_rect, column_id_63, 0);
  if (retval.1941_75 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  column_rect ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};
  goto <bb 29>;

  <bb 12>:
  hovered = 0;
  held = 0;
  _78 = columns_27->Flags;
  _79 = _78 & 2;
  if (_79 == 0)
    goto <bb 13>;
  else
    goto <bb 22>;

  <bb 13>:
  ImGui::ButtonBehavior (&column_rect, column_id_63, &hovered, &held, 0);
  hovered.1942_81 = hovered;
  if (hovered.1942_81 != 0)
    goto <bb 15>;
  else
    goto <bb 14>;

  <bb 14>:
  held.1943_82 = held;
  if (held.1943_82 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  g_24->MouseCursor = 4;

  <bb 16>:
  held.1946_84 = held;
  if (held.1946_84 != 0)
    goto <bb 17>;
  else
    goto <bb 19>;

  <bb 17>:
  _85 = &columns_27->Columns;
  _87 = ImVector<ImGuiColumnData>::operator[] (_85, n_6);
  _88 = _87->Flags;
  _89 = _88 & 2;
  if (_89 == 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  iftmp.1945_90 = 1;
  goto <bb 20>;

  <bb 19>:
  iftmp.1945_91 = 0;

  <bb 20>:
  # iftmp.1945_8 = PHI <iftmp.1945_90(18), iftmp.1945_91(19)>
  retval.1944_92 = iftmp.1945_8;
  if (retval.1944_92 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  dragging_column_93 = n_6;

  <bb 22>:
  # dragging_column_4 = PHI <dragging_column_3(12), dragging_column_93(21), dragging_column_3(20)>
  held.1948_94 = held;
  if (held.1948_94 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.1947_95 = 29;
  goto <bb 28>;

  <bb 24>:
  hovered.1950_96 = hovered;
  if (hovered.1950_96 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  iftmp.1949_97 = 28;
  goto <bb 27>;

  <bb 26>:
  iftmp.1949_98 = 27;

  <bb 27>:
  # iftmp.1949_10 = PHI <iftmp.1949_97(25), iftmp.1949_98(26)>
  iftmp.1947_99 = iftmp.1949_10;

  <bb 28>:
  # iftmp.1947_9 = PHI <iftmp.1947_95(23), iftmp.1947_99(27)>
  col_101 = ImGui::GetColorU32 (iftmp.1947_9, 1.0e+0);
  _102 = (int) x_60;
  xi_103 = (const float) _102;
  _104 = window_26->ClipRect.Max.y;
  _106 = ImMin (y2_52, _104);
  ImVec2::ImVec2 (&D.21615, xi_103, _106);
  _108 = window_26->ClipRect.Min.y;
  _109 = y1_51 + 1.0e+0;
  _111 = ImMax (_109, _108);
  ImVec2::ImVec2 (&D.21614, xi_103, _111);
  _113 = window_26->DrawList;
  ImDrawList::AddLine (_113, &D.21614, &D.21615, col_101, 1.0e+0);
  D.21614 ={v} {CLOBBER};
  D.21615 ={v} {CLOBBER};
  column_rect ={v} {CLOBBER};
  hovered ={v} {CLOBBER};
  held ={v} {CLOBBER};

  <bb 29>:
  # dragging_column_5 = PHI <dragging_column_4(28), dragging_column_3(11)>
  n_125 = n_6 + 1;
  goto <bb 9>;

  <bb 30>:
  if (dragging_column_3 != -1)
    goto <bb 31>;
  else
    goto <bb 37>;

  <bb 31>:
  _129 = columns_27->IsBeingResized;
  _130 = ~_129;
  if (_130 != 0)
    goto <bb 32>;
  else
    goto <bb 36>;

  <bb 32>:
  n_131 = 0;

  <bb 33>:
  # n_7 = PHI <n_131(32), n_142(34)>
  _132 = columns_27->Count;
  _133 = _132 + 1;
  if (_133 <= n_7)
    goto <bb 35>;
  else
    goto <bb 34>;

  <bb 34>:
  _134 = &columns_27->Columns;
  _136 = ImVector<ImGuiColumnData>::operator[] (_134, n_7);
  _137 = &columns_27->Columns;
  _139 = ImVector<ImGuiColumnData>::operator[] (_137, n_7);
  _140 = _139->OffsetNorm;
  _136->OffsetNormBeforeResize = _140;
  n_142 = n_7 + 1;
  goto <bb 33>;

  <bb 35>:

  <bb 36>:
  is_being_resized_143 = 1;
  columns_27->IsBeingResized = is_being_resized_143;
  _146 = GetDraggedColumnOffset (columns_27, dragging_column_3);
  x_147 = _146;
  ImGui::SetColumnOffset (dragging_column_3, x_147);

  <bb 37>:
  # is_being_resized_1 = PHI <is_being_resized_46(30), is_being_resized_143(36)>

  <bb 38>:
  # is_being_resized_2 = PHI <is_being_resized_46(6), is_being_resized_46(7), is_being_resized_1(37)>
  columns_27->IsBeingResized = is_being_resized_2;
  window_26->DC.ColumnsSet = 0B;
  window_26->DC.ColumnsOffsetX = 0.0;
  _152 = window_26->Pos.x;
  _153 = window_26->DC.IndentX;
  _154 = _152 + _153;
  _155 = window_26->DC.ColumnsOffsetX;
  _156 = _154 + _155;
  _157 = (int) _156;
  _158 = (float) _157;
  window_26->DC.CursorPos.x = _158;
  return;

}



;; Function void ImGui::Columns(int, const char*, bool) (_ZN5ImGui7ColumnsEiPKcb, funcdef_no=1169, decl_uid=3256, cgraph_uid=1068, symbol_order=1079)

void ImGui::Columns(int, const char*, bool) (int columns_count, const char * id, bool border)
{
  ImGuiColumnsFlags flags;
  static const char __PRETTY_FUNCTION__[44] = "void ImGui::Columns(int, const char*, bool)";
  struct ImGuiWindow * window;
  struct ImGuiColumnsSet * D.44185;
  int D.44182;
  struct ImGuiColumnsSet * D.44181;
  int D.44178;
  struct ImGuiColumnsSet * D.44177;
  struct ImGuiColumnsSet * D.44174;
  int iftmp.1951;
  int iftmp.1951_1;
  int iftmp.1951_9;
  int iftmp.1951_10;
  struct ImGuiColumnsSet * _12;
  struct ImGuiColumnsSet * _13;
  int _14;
  struct ImGuiColumnsSet * _15;
  int _16;
  struct ImGuiColumnsSet * _17;

  <bb 2>:
  window_6 = ImGui::GetCurrentWindow ();
  if (columns_count_7(D) > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("columns_count >= 1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12706, &__PRETTY_FUNCTION__);

  <bb 4>:
  if (border_8(D) != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1951_9 = 0;
  goto <bb 7>;

  <bb 6>:
  iftmp.1951_10 = 1;

  <bb 7>:
  # iftmp.1951_1 = PHI <iftmp.1951_9(5), iftmp.1951_10(6)>
  flags_11 = iftmp.1951_1;
  _12 = window_6->DC.ColumnsSet;
  if (_12 != 0B)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  _13 = window_6->DC.ColumnsSet;
  _14 = _13->Count;
  if (_14 == columns_count_7(D))
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _15 = window_6->DC.ColumnsSet;
  _16 = _15->Flags;
  if (_16 == flags_11)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 15> (<L18>);

  <bb 11>:
  _17 = window_6->DC.ColumnsSet;
  if (_17 != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  ImGui::EndColumns ();

  <bb 13>:
  if (columns_count_7(D) != 1)
    goto <bb 14>;
  else
    goto <bb 15> (<L18>);

  <bb 14>:
  ImGui::BeginColumns (id_19(D), columns_count_7(D), flags_11);

<L18>:
  return;

}



;; Function void ImGui::Indent(float) (_ZN5ImGui6IndentEf, funcdef_no=1170, decl_uid=2626, cgraph_uid=1069, symbol_order=1080)

void ImGui::Indent(float) (float indent_w)
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  float D.44203;
  float D.44202;
  float D.44201;
  float D.44200;
  float D.44199;
  float D.44198;
  float iftmp.1952;
  float D.44193;
  float iftmp.1952_1;
  float _6;
  float iftmp.1952_8;
  float iftmp.1952_9;
  float _10;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;

  <bb 2>:
  g_3 = GImGui;
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->DC.IndentX;
  if (indent_w_7(D) == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1952_8 = g_3->Style.IndentSpacing;
  goto <bb 5>;

  <bb 4>:
  iftmp.1952_9 = indent_w_7(D);

  <bb 5>:
  # iftmp.1952_1 = PHI <iftmp.1952_8(3), iftmp.1952_9(4)>
  _10 = _6 + iftmp.1952_1;
  window_5->DC.IndentX = _10;
  _12 = window_5->Pos.x;
  _13 = window_5->DC.IndentX;
  _14 = _12 + _13;
  _15 = window_5->DC.ColumnsOffsetX;
  _16 = _14 + _15;
  window_5->DC.CursorPos.x = _16;
  return;

}



;; Function void ImGui::Unindent(float) (_ZN5ImGui8UnindentEf, funcdef_no=1171, decl_uid=2628, cgraph_uid=1070, symbol_order=1081)

void ImGui::Unindent(float) (float indent_w)
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  float D.44214;
  float D.44213;
  float D.44212;
  float D.44211;
  float D.44210;
  float D.44209;
  float iftmp.1953;
  float D.44204;
  float iftmp.1953_1;
  float _6;
  float iftmp.1953_8;
  float iftmp.1953_9;
  float _10;
  float _12;
  float _13;
  float _14;
  float _15;
  float _16;

  <bb 2>:
  g_3 = GImGui;
  window_5 = ImGui::GetCurrentWindow ();
  _6 = window_5->DC.IndentX;
  if (indent_w_7(D) == 0.0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1953_8 = g_3->Style.IndentSpacing;
  goto <bb 5>;

  <bb 4>:
  iftmp.1953_9 = indent_w_7(D);

  <bb 5>:
  # iftmp.1953_1 = PHI <iftmp.1953_8(3), iftmp.1953_9(4)>
  _10 = _6 - iftmp.1953_1;
  window_5->DC.IndentX = _10;
  _12 = window_5->Pos.x;
  _13 = window_5->DC.IndentX;
  _14 = _12 + _13;
  _15 = window_5->DC.ColumnsOffsetX;
  _16 = _14 + _15;
  window_5->DC.CursorPos.x = _16;
  return;

}



;; Function void ImGui::TreePush(const char*) (_ZN5ImGui8TreePushEPKc, funcdef_no=1172, decl_uid=3136, cgraph_uid=1071, symbol_order=1082)

void ImGui::TreePush(const char*) (const char * str_id)
{
  struct ImGuiWindow * window;
  const char * iftmp.1954;
  int D.44216;
  int D.44215;
  const char * iftmp.1954_1;
  int _6;
  int _7;
  const char * iftmp.1954_10;
  const char * iftmp.1954_11;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  ImGui::Indent (0.0);
  _6 = window_4->DC.TreeDepth;
  _7 = _6 + 1;
  window_4->DC.TreeDepth = _7;
  if (str_id_9(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1954_10 = str_id_9(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.1954_11 = "#TreePush";

  <bb 5>:
  # iftmp.1954_1 = PHI <iftmp.1954_10(3), iftmp.1954_11(4)>
  ImGui::PushID (iftmp.1954_1);
  return;

}



;; Function void ImGui::TreePush(const void*) (_ZN5ImGui8TreePushEPKv, funcdef_no=1173, decl_uid=3138, cgraph_uid=1072, symbol_order=1083)

void ImGui::TreePush(const void*) (const void * ptr_id)
{
  struct ImGuiWindow * window;
  const void * iftmp.1955;
  int D.44222;
  int D.44221;
  const void * iftmp.1955_1;
  int _6;
  int _7;
  const void * iftmp.1955_10;
  const void * iftmp.1955_11;

  <bb 2>:
  window_4 = ImGui::GetCurrentWindow ();
  ImGui::Indent (0.0);
  _6 = window_4->DC.TreeDepth;
  _7 = _6 + 1;
  window_4->DC.TreeDepth = _7;
  if (ptr_id_9(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1955_10 = ptr_id_9(D);
  goto <bb 5>;

  <bb 4>:
  iftmp.1955_11 = "#TreePush";

  <bb 5>:
  # iftmp.1955_1 = PHI <iftmp.1955_10(3), iftmp.1955_11(4)>
  ImGui::PushID (iftmp.1955_1);
  return;

}



;; Function void ImGui::TreePushRawID(ImGuiID) (_ZN5ImGui13TreePushRawIDEj, funcdef_no=1174, decl_uid=14045, cgraph_uid=1073, symbol_order=1084)

void ImGui::TreePushRawID(ImGuiID) (ImGuiID id)
{
  struct ImGuiWindow * window;
  struct ImVector * D.44229;
  int D.44228;
  int D.44227;
  int _5;
  int _6;
  struct ImVector * _8;

  <bb 2>:
  window_3 = ImGui::GetCurrentWindow ();
  ImGui::Indent (0.0);
  _5 = window_3->DC.TreeDepth;
  _6 = _5 + 1;
  window_3->DC.TreeDepth = _6;
  _8 = &window_3->IDStack;
  ImVector<unsigned int>::push_back (_8, &id);
  return;

}



;; Function void ImGui::TreePop() (_ZN5ImGui7TreePopEv, funcdef_no=1175, decl_uid=3139, cgraph_uid=1074, symbol_order=1085)

void ImGui::TreePop() ()
{
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  unsigned int D.44265;
  unsigned int D.44264;
  int D.44263;
  int D.44262;
  int D.44261;
  unsigned int D.44260;
  unsigned int D.44257;
  value_type & D.44256;
  struct ImVector * D.44255;
  int D.44254;
  unsigned int D.44251;
  unsigned int D.44250;
  int D.44249;
  int D.44248;
  unsigned int D.44247;
  bool D.44244;
  bool D.44240;
  struct ImGuiWindow * D.44238;
  int D.44236;
  bool iftmp.1957;
  bool retval.1956;
  int D.44231;
  int D.44230;
  bool iftmp.1957_1;
  int _9;
  int _10;
  int _12;
  struct ImGuiWindow * _13;
  bool _15;
  bool iftmp.1957_16;
  bool iftmp.1957_17;
  bool retval.1956_18;
  bool _19;
  unsigned int _20;
  int _21;
  int _22;
  unsigned int _23;
  unsigned int _24;
  int _25;
  struct ImVector * _26;
  value_type & _28;
  unsigned int _29;
  unsigned int _32;
  int _33;
  int _34;
  int _35;
  unsigned int _36;
  unsigned int _37;

  <bb 2>:
  g_6 = GImGui;
  window_7 = g_6->CurrentWindow;
  ImGui::Unindent (0.0);
  _9 = window_7->DC.TreeDepth;
  _10 = _9 + -1;
  window_7->DC.TreeDepth = _10;
  _12 = g_6->NavMoveDir;
  if (_12 == 0)
    goto <bb 3>;
  else
    goto <bb 6>;

  <bb 3>:
  _13 = g_6->NavWindow;
  if (_13 == window_7)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _15 = NavMoveRequestButNoResultYet ();
  if (_15 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  iftmp.1957_16 = 1;
  goto <bb 7>;

  <bb 6>:
  iftmp.1957_17 = 0;

  <bb 7>:
  # iftmp.1957_1 = PHI <iftmp.1957_16(5), iftmp.1957_17(6)>
  retval.1956_18 = iftmp.1957_1;
  if (retval.1956_18 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

  <bb 8>:
  _19 = g_6->NavIdIsAlive;
  if (_19 != 0)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  _20 = window_7->DC.TreeDepthMayJumpToParentOnPop;
  _21 = window_7->DC.TreeDepth;
  _22 = 1 << _21;
  _23 = (unsigned int) _22;
  _24 = _20 & _23;
  if (_24 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  _25 = g_6->NavLayer;
  _26 = &window_7->IDStack;
  _28 = ImVector<unsigned int>::back (_26);
  _29 = *_28;
  SetNavID (_29, _25);
  ImGui::NavMoveRequestCancel ();

  <bb 11>:
  _32 = window_7->DC.TreeDepthMayJumpToParentOnPop;
  _33 = window_7->DC.TreeDepth;
  _34 = 1 << _33;
  _35 = _34 + -1;
  _36 = (unsigned int) _35;
  _37 = _32 & _36;
  window_7->DC.TreeDepthMayJumpToParentOnPop = _37;
  ImGui::PopID ();
  return;

}



;; Function void ImGui::Value(const char*, bool) (_ZN5ImGui5ValueEPKcb, funcdef_no=1176, decl_uid=3191, cgraph_uid=1075, symbol_order=1086)

void ImGui::Value(const char*, bool) (const char * prefix, bool b)
{
  const char * iftmp.1958;
  const char * iftmp.1958_1;
  const char * iftmp.1958_3;
  const char * iftmp.1958_4;

  <bb 2>:
  if (b_2(D) != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1958_3 = "true";
  goto <bb 5>;

  <bb 4>:
  iftmp.1958_4 = "false";

  <bb 5>:
  # iftmp.1958_1 = PHI <iftmp.1958_3(3), iftmp.1958_4(4)>
  ImGui::Text ("%s: %s", prefix_6(D), iftmp.1958_1);
  return;

}



;; Function void ImGui::Value(const char*, int) (_ZN5ImGui5ValueEPKci, funcdef_no=1177, decl_uid=3194, cgraph_uid=1076, symbol_order=1087)

void ImGui::Value(const char*, int) (const char * prefix, int v)
{
  <bb 2>:
  ImGui::Text ("%s: %d", prefix_2(D), v_3(D));
  return;

}



;; Function void ImGui::Value(const char*, unsigned int) (_ZN5ImGui5ValueEPKcj, funcdef_no=1178, decl_uid=3197, cgraph_uid=1077, symbol_order=1088)

void ImGui::Value(const char*, unsigned int) (const char * prefix, unsigned int v)
{
  <bb 2>:
  ImGui::Text ("%s: %d", prefix_2(D), v_3(D));
  return;

}



;; Function void ImGui::Value(const char*, float, const char*) (_ZN5ImGui5ValueEPKcfS1_, funcdef_no=1179, decl_uid=3201, cgraph_uid=1078, symbol_order=1089)

void ImGui::Value(const char*, float, const char*) (const char * prefix, float v, const char * float_format)
{
  char fmt[64];
  double D.44274;
  double D.44272;
  double _6;
  double _11;

  <bb 2>:
  if (float_format_2(D) != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImFormatString (&fmt, 64, "%%s: %s", float_format_2(D));
  _6 = (double) v_5(D);
  ImGui::Text (&fmt, prefix_7(D), _6);
  fmt ={v} {CLOBBER};
  goto <bb 5>;

  <bb 4>:
  _11 = (double) v_5(D);
  ImGui::Text ("%s: %.3f", prefix_7(D), _11);

  <bb 5>:
  return;

}



;; Function void ImGui::ClearDragDrop() (_ZN5ImGui13ClearDragDropEv, funcdef_no=1180, decl_uid=13860, cgraph_uid=1079, symbol_order=1090)

void ImGui::ClearDragDrop() ()
{
  struct ImGuiContext & g;
  unsigned int D.44277;
  struct ImGuiPayload * D.44276;
  struct ImGuiPayload * _4;
  unsigned int _7;

  <bb 2>:
  g_2 = GImGui;
  g_2->DragDropActive = 0;
  _4 = &g_2->DragDropPayload;
  ImGuiPayload::Clear (_4);
  g_2->DragDropAcceptIdPrev = 0;
  _7 = g_2->DragDropAcceptIdPrev;
  g_2->DragDropAcceptIdCurr = _7;
  g_2->DragDropAcceptIdCurrRectSurface = 3.4028234663852885981170418348451692544e+38;
  g_2->DragDropAcceptFrameCount = -1;
  return;

}



;; Function bool ImGui::BeginDragDropSource(ImGuiDragDropFlags) (_ZN5ImGui19BeginDragDropSourceEi, funcdef_no=1181, decl_uid=3282, cgraph_uid=1080, symbol_order=1091)

bool ImGui::BeginDragDropSource(ImGuiDragDropFlags) (ImGuiDragDropFlags flags)
{
  unsigned int D.44357;
  struct ImGuiPayload & payload;
  bool is_hovered;
  static const char __PRETTY_FUNCTION__[52] = "bool ImGui::BeginDragDropSource(ImGuiDragDropFlags)";
  int mouse_button;
  ImGuiID source_parent_id;
  ImGuiID source_id;
  bool source_drag_active;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.44354;
  int D.44353;
  int D.44350;
  int D.44347;
  const struct ImVec4 & D.44345;
  struct ImVec4 D.21690;
  struct ImVec4 D.21691;
  struct ImVec2 * D.44344;
  struct ImVec2 D.21689;
  int D.44341;
  bool D.44334;
  bool D.44333;
  value_type & D.44329;
  struct ImVector * D.44328;
  unsigned int D.44325;
  unsigned int D.44320;
  bool D.44316;
  unsigned int D.44310;
  struct ImRect * D.44309;
  struct ImGuiWindow * D.44308;
  unsigned int D.44306;
  bool D.44303;
  int D.44300;
  int D.44299;
  int D.44293;
  bool D.44288;
  bool D.44287;
  bool D.44286;
  unsigned int D.44283;
  int D.44278;
  bool _6;
  int _24;
  unsigned int _26;
  bool _27;
  bool _28;
  bool _29;
  bool _30;
  int _31;
  int _32;
  int _33;
  bool _35;
  unsigned int _36;
  struct ImGuiWindow * _37;
  bool _38;
  struct ImRect * _39;
  unsigned int _41;
  unsigned int _42;
  bool _46;
  unsigned int _49;
  unsigned int _52;
  struct ImVector * _53;
  value_type & _55;
  bool _59;
  bool _64;
  bool _65;
  bool _66;
  int _75;
  struct ImVec2 * _77;
  const struct ImVec4 & _82;
  int _90;
  int _91;
  int _92;
  int _93;
  bool _95;

  <bb 2>:
  g_17 = GImGui;
  window_18 = g_17->CurrentWindow;
  source_drag_active_19 = 0;
  source_id_20 = 0;
  source_parent_id_21 = 0;
  mouse_button_22 = 0;
  _24 = flags_23(D) & 16;
  if (_24 == 0)
    goto <bb 3>;
  else
    goto <bb 26>;

  <bb 3>:
  source_id_25 = window_18->DC.LastItemId;
  if (source_id_25 != 0)
    goto <bb 4>;
  else
    goto <bb 6>;

  <bb 4>:
  _26 = g_17->ActiveId;
  if (_26 != source_id_25)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _27 = 0;
  goto <bb 39> (<L51>);

  <bb 6>:
  _28 = g_17->IO.MouseDown[mouse_button_22];
  _29 = ~_28;
  if (_29 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _30 = 0;
  goto <bb 39> (<L51>);

  <bb 8>:
  if (source_id_25 == 0)
    goto <bb 9>;
  else
    goto <bb 23>;

  <bb 9>:
  _31 = flags_23(D) & 8;
  if (_31 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  __assert_fail ("0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12846, &__PRETTY_FUNCTION__);

  <bb 11>:
  _32 = window_18->DC.LastItemStatusFlags;
  _33 = _32 & 1;
  is_hovered_34 = _33 != 0;
  _35 = ~is_hovered_34;
  if (_35 != 0)
    goto <bb 12>;
  else
    goto <bb 15>;

  <bb 12>:
  _36 = g_17->ActiveId;
  if (_36 == 0)
    goto <bb 14>;
  else
    goto <bb 13>;

  <bb 13>:
  _37 = g_17->ActiveIdWindow;
  if (_37 != window_18)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _38 = 0;
  goto <bb 39> (<L51>);

  <bb 15>:
  _39 = &window_18->DC.LastItemRect;
  _41 = ImGuiWindow::GetIDFromRectangle (window_18, _39);
  _42 = _41;
  window_18->DC.LastItemId = _42;
  source_id_44 = window_18->DC.LastItemId;
  if (is_hovered_34 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  ImGui::SetHoveredID (source_id_44);

  <bb 17>:
  if (is_hovered_34 != 0)
    goto <bb 18>;
  else
    goto <bb 20>;

  <bb 18>:
  _46 = g_17->IO.MouseClicked[mouse_button_22];
  if (_46 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  ImGui::SetActiveID (source_id_44, window_18);
  ImGui::FocusWindow (window_18);

  <bb 20>:
  _49 = g_17->ActiveId;
  if (_49 == source_id_44)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  g_17->ActiveIdAllowOverlap = is_hovered_34;

  <bb 22>:

  <bb 23>:
  # source_id_3 = PHI <source_id_25(8), source_id_44(22)>
  _52 = g_17->ActiveId;
  if (_52 != source_id_3)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  _59 = 0;
  goto <bb 39> (<L51>);

  <bb 25>:
  _53 = &window_18->IDStack;
  _55 = ImVector<unsigned int>::back (_53);
  source_parent_id_56 = *_55;
  source_drag_active_58 = ImGui::IsMouseDragging (mouse_button_22, -1.0e+0);
  goto <bb 27>;

  <bb 26>:
  window_60 = 0B;
  source_id_62 = ImHash ("#SourceExtern", 0, 0);
  source_drag_active_63 = 1;

  <bb 27>:
  # window_1 = PHI <window_18(25), window_60(26)>
  # source_drag_active_2 = PHI <source_drag_active_58(25), source_drag_active_63(26)>
  # source_id_4 = PHI <source_id_3(25), source_id_62(26)>
  # source_parent_id_5 = PHI <source_parent_id_56(25), source_parent_id_21(26)>
  if (source_drag_active_2 != 0)
    goto <bb 28>;
  else
    goto <bb 38>;

  <bb 28>:
  _65 = g_17->DragDropActive;
  _66 = ~_65;
  if (_66 != 0)
    goto <bb 29>;
  else
    goto <bb 32>;

  <bb 29>:
  if (source_id_4 != 0)
    goto <bb 31>;
  else
    goto <bb 30>;

  <bb 30>:
  __assert_fail ("source_id != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12884, &__PRETTY_FUNCTION__);

  <bb 31>:
  ImGui::ClearDragDrop ();
  payload_68 = &g_17->DragDropPayload;
  payload_68->SourceId = source_id_4;
  payload_68->SourceParentId = source_parent_id_5;
  g_17->DragDropActive = 1;
  g_17->DragDropSourceFlags = flags_23(D);
  g_17->DragDropMouseButton = mouse_button_22;

  <bb 32>:
  _75 = flags_23(D) & 1;
  if (_75 == 0)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  ImVec2::ImVec2 (&D.21689, 0.0, 0.0);
  _77 = &g_17->IO.MousePos;
  ImGui::SetNextWindowPos (_77, 0, &D.21689);
  D.21689 ={v} {CLOBBER};
  ImVec4::ImVec4 (&D.21690, 1.0e+0, 1.0e+0, 1.0e+0, 6.0000002384185791015625e-1);
  _82 = ImGui::GetStyleColorVec4 (4);
  D.21691 = operator* (_82, &D.21690);
  ImGui::PushStyleColor (4, &D.21691);
  D.21691 ={v} {CLOBBER};
  D.21690 ={v} {CLOBBER};
  ImGui::BeginTooltip ();

  <bb 34>:
  _90 = flags_23(D) & 2;
  if (_90 == 0)
    goto <bb 35>;
  else
    goto <bb 37>;

  <bb 35>:
  _91 = flags_23(D) & 16;
  if (_91 == 0)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  _92 = window_1->DC.LastItemStatusFlags;
  _93 = _92 & -2;
  window_1->DC.LastItemStatusFlags = _93;

  <bb 37>:
  _95 = 1;
  goto <bb 39> (<L51>);

  <bb 38>:
  _64 = 0;

  # _6 = PHI <_27(5), _30(7), _64(38), _38(14), _59(24), _95(37)>
<L51>:
  return _6;

}



;; Function void ImGui::EndDragDropSource() (_ZN5ImGui17EndDragDropSourceEv, funcdef_no=1182, decl_uid=3288, cgraph_uid=1081, symbol_order=1092)

void ImGui::EndDragDropSource() ()
{
  static const char __PRETTY_FUNCTION__[32] = "void ImGui::EndDragDropSource()";
  struct ImGuiContext & g;
  int D.44384;
  int D.44380;
  int D.44379;
  bool D.44375;
  bool _5;
  int _6;
  int _7;
  int _10;

  <bb 2>:
  g_4 = GImGui;
  _5 = g_4->DragDropActive;
  if (_5 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.DragDropActive", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12915, &__PRETTY_FUNCTION__);

  <bb 4>:
  _6 = g_4->DragDropSourceFlags;
  _7 = _6 & 1;
  if (_7 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  ImGui::EndTooltip ();
  ImGui::PopStyleColor (1);

  <bb 6>:
  _10 = g_4->DragDropPayload.DataFrameCount;
  if (_10 == -1)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGui::ClearDragDrop ();

  <bb 8>:
  return;

}



;; Function bool ImGui::SetDragDropPayload(const char*, const void*, size_t, ImGuiCond) (_ZN5ImGui18SetDragDropPayloadEPKcPKvmi, funcdef_no=1183, decl_uid=3287, cgraph_uid=1082, symbol_order=1093)

bool ImGui::SetDragDropPayload(const char*, const void*, size_t, ImGuiCond) (const char * type, const void * data, size_t data_size, ImGuiCond cond)
{
  static const char __PRETTY_FUNCTION__[76] = "bool ImGui::SetDragDropPayload(const char*, const void*, size_t, ImGuiCond)";
  struct ImGuiPayload & payload;
  struct ImGuiContext & g;
  int D.44445;
  int D.44444;
  int D.44443;
  int D.44441;
  int D.44440;
  bool iftmp.1959;
  bool D.44435;
  int D.44434;
  int D.44433;
  const void * D.44431;
  unsigned char[8] * D.44430;
  unsigned char[8] * D.44429;
  const void * D.44425;
  unsigned char * D.44424;
  struct ImVector * D.44423;
  int D.44422;
  struct ImVector * D.44419;
  char[33] * D.44418;
  int D.44417;
  unsigned int D.44410;
  long unsigned int D.44394;
  bool iftmp.1959_2;
  long unsigned int _11;
  unsigned int _16;
  int _17;
  char[33] * _18;
  struct ImVector * _20;
  int _22;
  struct ImVector * _23;
  unsigned char * _25;
  const void * _27;
  unsigned char[8] * _29;
  unsigned char[8] * _31;
  const void * _33;
  int _36;
  int _38;
  int _40;
  int _41;
  int _42;
  int _43;
  int _44;
  bool iftmp.1959_45;
  bool iftmp.1959_46;
  bool _47;

  <bb 2>:
  g_6 = GImGui;
  payload_7 = &g_6->DragDropPayload;
  if (cond_8(D) == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  cond_9 = 1;

  <bb 4>:
  # cond_1 = PHI <cond_8(D)(2), cond_9(3)>
  if (type_10(D) != 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("type != __null", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12937, &__PRETTY_FUNCTION__);

  <bb 6>:
  _11 = strlen (type_10(D));
  if (_11 <= 32)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  __assert_fail ("strlen(type) < ((int)(sizeof(payload.DataType)/sizeof(*payload.DataType))) && \"Payload type can be at most 12 characters long\"", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12938, &__PRETTY_FUNCTION__);

  <bb 8>:
  if (data_12(D) != 0B)
    goto <bb 9>;
  else
    goto <bb 11>;

  <bb 9>:
  if (data_size_13(D) != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  goto <bb 15>;

  <bb 11>:
  if (data_12(D) == 0B)
    goto <bb 12>;
  else
    goto <bb 14>;

  <bb 12>:
  if (data_size_13(D) == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  goto <bb 15>;

  <bb 14>:
  __assert_fail ("(data != __null && data_size > 0) || (data == __null && data_size == 0)", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12939, &__PRETTY_FUNCTION__);

  <bb 15>:
  if (cond_1 == 1)
    goto <bb 18>;
  else
    goto <bb 16>;

  <bb 16>:
  if (cond_1 == 2)
    goto <bb 18>;
  else
    goto <bb 17>;

  <bb 17>:
  __assert_fail ("cond == ImGuiCond_Always || cond == ImGuiCond_Once", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12940, &__PRETTY_FUNCTION__);

  <bb 18>:
  _16 = payload_7->SourceId;
  if (_16 != 0)
    goto <bb 20>;
  else
    goto <bb 19>;

  <bb 19>:
  __assert_fail ("payload.SourceId != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12941, &__PRETTY_FUNCTION__);

  <bb 20>:
  if (cond_1 == 1)
    goto <bb 22>;
  else
    goto <bb 21>;

  <bb 21>:
  _17 = payload_7->DataFrameCount;
  if (_17 == -1)
    goto <bb 22>;
  else
    goto <bb 28>;

  <bb 22>:
  _18 = &payload_7->DataType;
  ImStrncpy (_18, type_10(D), 33);
  _20 = &g_6->DragDropPayloadBufHeap;
  ImVector<unsigned char>::resize (_20, 0);
  if (data_size_13(D) > 8)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _22 = (int) data_size_13(D);
  _23 = &g_6->DragDropPayloadBufHeap;
  ImVector<unsigned char>::resize (_23, _22);
  _25 = g_6->DragDropPayloadBufHeap.Data;
  payload_7->Data = _25;
  _27 = payload_7->Data;
  memcpy (_27, data_12(D), data_size_13(D));
  goto <bb 27>;

  <bb 24>:
  if (data_size_13(D) != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  _29 = &g_6->DragDropPayloadBufLocal;
  memset (_29, 0, 8);
  _31 = &g_6->DragDropPayloadBufLocal;
  payload_7->Data = _31;
  _33 = payload_7->Data;
  memcpy (_33, data_12(D), data_size_13(D));
  goto <bb 27>;

  <bb 26>:
  payload_7->Data = 0B;

  <bb 27>:
  _36 = (int) data_size_13(D);
  payload_7->DataSize = _36;

  <bb 28>:
  _38 = g_6->FrameCount;
  payload_7->DataFrameCount = _38;
  _40 = g_6->DragDropAcceptFrameCount;
  _41 = g_6->FrameCount;
  if (_40 == _41)
    goto <bb 30>;
  else
    goto <bb 29>;

  <bb 29>:
  _42 = g_6->DragDropAcceptFrameCount;
  _43 = g_6->FrameCount;
  _44 = _43 + -1;
  if (_42 == _44)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  iftmp.1959_46 = 1;
  goto <bb 32>;

  <bb 31>:
  iftmp.1959_45 = 0;

  <bb 32>:
  # iftmp.1959_2 = PHI <iftmp.1959_46(30), iftmp.1959_45(31)>
  _47 = iftmp.1959_2;

<L37>:
  return _47;

}



;; Function bool ImGui::BeginDragDropTargetCustom(const ImRect&, ImGuiID) (_ZN5ImGui25BeginDragDropTargetCustomERK6ImRectj, funcdef_no=1184, decl_uid=13859, cgraph_uid=1083, symbol_order=1094)

bool ImGui::BeginDragDropTargetCustom(const ImRect&, ImGuiID) (const struct ImRect & bb, ImGuiID id)
{
  static const char __PRETTY_FUNCTION__[62] = "bool ImGui::BeginDragDropTargetCustom(const ImRect&, ImGuiID)";
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  unsigned int D.44505;
  bool D.44503;
  bool D.44502;
  const struct ImVec2 * D.44501;
  const struct ImVec2 * D.44500;
  bool iftmp.1963;
  bool retval.1962;
  struct ImGuiWindow * D.44491;
  struct ImGuiWindow * D.44490;
  struct ImGuiWindow * D.44489;
  struct ImGuiWindow * D.44487;
  bool D.44484;
  bool D.44481;
  bool D.44480;
  bool _1;
  bool iftmp.1963_2;
  bool _6;
  bool _7;
  bool _8;
  struct ImGuiWindow * _10;
  struct ImGuiWindow * _11;
  struct ImGuiWindow * _12;
  struct ImGuiWindow * _13;
  const struct ImVec2 * _16;
  const struct ImVec2 * _17;
  bool _19;
  bool _20;
  unsigned int _21;
  bool iftmp.1963_22;
  bool iftmp.1963_23;
  bool retval.1962_24;
  bool _25;
  bool _28;
  bool _30;

  <bb 2>:
  g_5 = GImGui;
  _6 = g_5->DragDropActive;
  _7 = ~_6;
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _8 = 0;
  goto <bb 16> (<L14>);

  <bb 4>:
  window_9 = g_5->CurrentWindow;
  _10 = g_5->HoveredWindow;
  if (_10 == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  _11 = window_9->RootWindow;
  _12 = g_5->HoveredWindow;
  _13 = _12->RootWindow;
  if (_11 != _13)
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  _30 = 0;
  goto <bb 16> (<L14>);

  <bb 7>:
  if (id_14(D) != 0)
    goto <bb 9>;
  else
    goto <bb 8>;

  <bb 8>:
  __assert_fail ("id != 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 12982, &__PRETTY_FUNCTION__);

  <bb 9>:
  _16 = &bb_15(D)->Max;
  _17 = &bb_15(D)->Min;
  _19 = ImGui::IsMouseHoveringRect (_17, _16, 1);
  _20 = ~_19;
  if (_20 != 0)
    goto <bb 11>;
  else
    goto <bb 10>;

  <bb 10>:
  _21 = g_5->DragDropPayload.SourceId;
  if (_21 == id_14(D))
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.1963_23 = 1;
  goto <bb 13>;

  <bb 12>:
  iftmp.1963_22 = 0;

  <bb 13>:
  # iftmp.1963_2 = PHI <iftmp.1963_23(11), iftmp.1963_22(12)>
  retval.1962_24 = iftmp.1963_2;
  if (retval.1962_24 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _25 = 0;
  goto <bb 16> (<L14>);

  <bb 15>:
  g_5->DragDropTargetRect = *bb_15(D);
  g_5->DragDropTargetId = id_14(D);
  _28 = 1;

  # _1 = PHI <_8(3), _30(6), _25(14), _28(15)>
<L14>:
  return _1;

}



;; Function bool ImGui::BeginDragDropTarget() (_ZN5ImGui19BeginDragDropTargetEv, funcdef_no=1185, decl_uid=3289, cgraph_uid=1084, symbol_order=1095)

bool ImGui::BeginDragDropTarget() ()
{
  ImGuiID D.44538;
  ImGuiID id;
  const struct ImRect & display_rect;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  unsigned int D.44534;
  int D.44527;
  int D.44526;
  struct ImRect * iftmp.1964;
  struct ImGuiWindow * D.44524;
  struct ImGuiWindow * D.44523;
  struct ImGuiWindow * D.44522;
  struct ImGuiWindow * D.44520;
  int D.44515;
  int D.44514;
  bool D.44513;
  bool D.44510;
  bool D.44509;
  bool _2;
  struct ImRect * iftmp.1964_3;
  bool _8;
  bool _9;
  bool _10;
  int _12;
  int _13;
  bool _14;
  struct ImGuiWindow * _15;
  struct ImGuiWindow * _16;
  struct ImGuiWindow * _17;
  struct ImGuiWindow * _18;
  int _19;
  int _20;
  struct ImRect * iftmp.1964_21;
  struct ImRect * iftmp.1964_22;
  ImGuiID _26;
  unsigned int _28;
  bool _29;
  bool _32;
  bool _33;

  <bb 2>:
  g_7 = GImGui;
  _8 = g_7->DragDropActive;
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _10 = 0;
  goto <bb 17> (<L15>);

  <bb 4>:
  window_11 = g_7->CurrentWindow;
  _12 = window_11->DC.LastItemStatusFlags;
  _13 = _12 & 1;
  if (_13 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _14 = 0;
  goto <bb 17> (<L15>);

  <bb 6>:
  _15 = g_7->HoveredWindow;
  if (_15 == 0B)
    goto <bb 8>;
  else
    goto <bb 7>;

  <bb 7>:
  _16 = window_11->RootWindow;
  _17 = g_7->HoveredWindow;
  _18 = _17->RootWindow;
  if (_16 != _18)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  _33 = 0;
  goto <bb 17> (<L15>);

  <bb 9>:
  _19 = window_11->DC.LastItemStatusFlags;
  _20 = _19 & 2;
  if (_20 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

  <bb 10>:
  iftmp.1964_21 = &window_11->DC.LastItemDisplayRect;
  goto <bb 12>;

  <bb 11>:
  iftmp.1964_22 = &window_11->DC.LastItemRect;

  <bb 12>:
  # iftmp.1964_3 = PHI <iftmp.1964_21(10), iftmp.1964_22(11)>
  display_rect_23 = iftmp.1964_3;
  id_24 = window_11->DC.LastItemId;
  if (id_24 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _26 = ImGuiWindow::GetIDFromRectangle (window_11, display_rect_23);
  id_27 = _26;

  <bb 14>:
  # id_1 = PHI <id_24(12), id_27(13)>
  _28 = g_7->DragDropPayload.SourceId;
  if (_28 == id_1)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  _29 = 0;
  goto <bb 17> (<L15>);

  <bb 16>:
  g_7->DragDropTargetRect = *display_rect_23;
  g_7->DragDropTargetId = id_1;
  _32 = 1;

  # _2 = PHI <_10(3), _14(5), _33(8), _29(15), _32(16)>
<L15>:
  return _2;

}



;; Function bool ImGui::IsDragDropPayloadBeingAccepted() (_ZN5ImGui30IsDragDropPayloadBeingAcceptedEv, funcdef_no=1186, decl_uid=13861, cgraph_uid=1085, symbol_order=1096)

bool ImGui::IsDragDropPayloadBeingAccepted() ()
{
  struct ImGuiContext & g;
  unsigned int D.44545;
  bool D.44543;
  bool iftmp.1965;
  bool D.44539;
  bool iftmp.1965_1;
  bool _4;
  unsigned int _5;
  bool iftmp.1965_6;
  bool iftmp.1965_7;
  bool _8;

  <bb 2>:
  g_3 = GImGui;
  _4 = g_3->DragDropActive;
  if (_4 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _5 = g_3->DragDropAcceptIdPrev;
  if (_5 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1965_6 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.1965_7 = 0;

  <bb 6>:
  # iftmp.1965_1 = PHI <iftmp.1965_6(4), iftmp.1965_7(5)>
  _8 = iftmp.1965_1;

<L4>:
  return _8;

}



;; Function const ImGuiPayload* ImGui::AcceptDragDropPayload(const char*, ImGuiDragDropFlags) (_ZN5ImGui21AcceptDragDropPayloadEPKci, funcdef_no=1187, decl_uid=3292, cgraph_uid=1086, symbol_order=1097)

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char*, ImGuiDragDropFlags) (const char * type, ImGuiDragDropFlags flags)
{
  bool push_clip_rect;
  float r_surface;
  struct ImRect r;
  const bool was_accepted_previously;
  static const char __PRETTY_FUNCTION__[82] = "const ImGuiPayload* ImGui::AcceptDragDropPayload(const char*, ImGuiDragDropFlags)";
  struct ImGuiPayload & payload;
  struct ImGuiWindow * window;
  struct ImGuiContext & g;
  int D.44610;
  bool D.44607;
  bool D.44606;
  bool D.44604;
  bool D.44603;
  int D.44602;
  bool iftmp.1968;
  int D.44597;
  struct ImDrawList * D.44594;
  struct ImDrawList * D.44591;
  unsigned int D.44590;
  struct ImDrawList * D.44588;
  bool D.44585;
  struct ImRect * D.44584;
  bool D.44581;
  int D.44578;
  int D.44577;
  int D.44576;
  unsigned int D.44574;
  float D.44571;
  float D.44570;
  float D.44569;
  unsigned int D.44568;
  unsigned int D.44567;
  const struct ImGuiPayload * D.44566;
  bool D.44562;
  bool D.44561;
  bool iftmp.1967;
  bool retval.1966;
  int D.44552;
  bool D.44548;
  bool iftmp.1967_1;
  const struct ImGuiPayload * _2;
  bool iftmp.1968_3;
  bool _18;
  int _19;
  bool _22;
  bool _23;
  bool iftmp.1967_24;
  bool iftmp.1967_25;
  bool retval.1966_26;
  const struct ImGuiPayload * _27;
  unsigned int _28;
  unsigned int _29;
  float _33;
  float _35;
  float _37;
  unsigned int _38;
  int _42;
  int _43;
  int _46;
  bool _47;
  struct ImRect * _49;
  bool _51;
  struct ImDrawList * _53;
  unsigned int _56;
  struct ImDrawList * _57;
  struct ImDrawList * _59;
  int _62;
  int _64;
  bool _66;
  bool _67;
  bool iftmp.1968_68;
  bool iftmp.1968_69;
  bool _71;
  bool _72;
  int _73;
  const struct ImGuiPayload * _74;
  const struct ImGuiPayload * _75;

  <bb 2>:
  g_15 = GImGui;
  window_16 = g_15->CurrentWindow;
  payload_17 = &g_15->DragDropPayload;
  _18 = g_15->DragDropActive;
  if (_18 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.DragDropActive", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 13030, &__PRETTY_FUNCTION__);

  <bb 4>:
  _19 = payload_17->DataFrameCount;
  if (_19 != -1)
    goto <bb 6>;
  else
    goto <bb 5>;

  <bb 5>:
  __assert_fail ("payload.DataFrameCount != -1", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 13031, &__PRETTY_FUNCTION__);

  <bb 6>:
  if (type_20(D) != 0B)
    goto <bb 7>;
  else
    goto <bb 9>;

  <bb 7>:
  _22 = ImGuiPayload::IsDataType (payload_17, type_20(D));
  _23 = ~_22;
  if (_23 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

  <bb 8>:
  iftmp.1967_24 = 1;
  goto <bb 10>;

  <bb 9>:
  iftmp.1967_25 = 0;

  <bb 10>:
  # iftmp.1967_1 = PHI <iftmp.1967_24(8), iftmp.1967_25(9)>
  retval.1966_26 = iftmp.1967_1;
  if (retval.1966_26 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  _27 = 0B;
  goto <bb 29>;

  <bb 12>:
  _28 = g_15->DragDropAcceptIdPrev;
  _29 = g_15->DragDropTargetId;
  was_accepted_previously_30 = _28 == _29;
  r = g_15->DragDropTargetRect;
  _33 = ImRect::GetWidth (&r);
  _35 = ImRect::GetHeight (&r);
  r_surface_36 = _33 * _35;
  _37 = g_15->DragDropAcceptIdCurrRectSurface;
  if (_37 > r_surface_36)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  _38 = g_15->DragDropTargetId;
  g_15->DragDropAcceptIdCurr = _38;
  g_15->DragDropAcceptIdCurrRectSurface = r_surface_36;

  <bb 14>:
  payload_17->Preview = was_accepted_previously_30;
  _42 = g_15->DragDropSourceFlags;
  _43 = _42 & 2048;
  flags_45 = _43 | flags_44(D);
  _46 = flags_45 & 2048;
  if (_46 == 0)
    goto <bb 15>;
  else
    goto <bb 21>;

  <bb 15>:
  _47 = payload_17->Preview;
  if (_47 != 0)
    goto <bb 16>;
  else
    goto <bb 21>;

  <bb 16>:
  ImRect::Expand (&r, 3.5e+0);
  _49 = &window_16->ClipRect;
  _51 = ImRect::Contains (_49, &r);
  push_clip_rect_52 = ~_51;
  if (push_clip_rect_52 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  _53 = window_16->DrawList;
  ImDrawList::PushClipRectFullScreen (_53);

  <bb 18>:
  _56 = ImGui::GetColorU32 (39, 1.0e+0);
  _57 = window_16->DrawList;
  ImDrawList::AddRect (_57, &r.Min, &r.Max, _56, 0.0, -1, 2.0e+0);
  if (push_clip_rect_52 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

  <bb 19>:
  _59 = window_16->DrawList;
  ImDrawList::PopClipRect (_59);

  <bb 20>:

  <bb 21>:
  _62 = g_15->FrameCount;
  g_15->DragDropAcceptFrameCount = _62;
  if (was_accepted_previously_30 != 0)
    goto <bb 22>;
  else
    goto <bb 24>;

  <bb 22>:
  _64 = g_15->DragDropMouseButton;
  _66 = ImGui::IsMouseDown (_64);
  _67 = ~_66;
  if (_67 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  iftmp.1968_68 = 1;
  goto <bb 25>;

  <bb 24>:
  iftmp.1968_69 = 0;

  <bb 25>:
  # iftmp.1968_3 = PHI <iftmp.1968_68(23), iftmp.1968_69(24)>
  payload_17->Delivery = iftmp.1968_3;
  _71 = payload_17->Delivery;
  _72 = ~_71;
  if (_72 != 0)
    goto <bb 26>;
  else
    goto <bb 28>;

  <bb 26>:
  _73 = flags_45 & 1024;
  if (_73 == 0)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _74 = 0B;
  goto <bb 29>;

  <bb 28>:
  _75 = payload_17;

  <bb 29>:
  # _2 = PHI <_27(11), _74(27), _75(28)>
  r ={v} {CLOBBER};

<L35>:
  return _2;

}



;; Function void ImGui::EndDragDropTarget() (_ZN5ImGui17EndDragDropTargetEv, funcdef_no=1188, decl_uid=3293, cgraph_uid=1087, symbol_order=1098)

void ImGui::EndDragDropTarget() ()
{
  static const char __PRETTY_FUNCTION__[32] = "void ImGui::EndDragDropTarget()";
  struct ImGuiContext & g;
  bool D.44626;
  bool _3;

  <bb 2>:
  g_2 = GImGui;
  _3 = g_2->DragDropActive;
  if (_3 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("g.DragDropActive", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp", 13071, &__PRETTY_FUNCTION__);

  <bb 4>:
  return;

}



;; Function const char* GetClipboardTextFn_DefaultImpl(void*) (_ZL30GetClipboardTextFn_DefaultImplPv, funcdef_no=1189, decl_uid=15129, cgraph_uid=1088, symbol_order=1099)

const char* GetClipboardTextFn_DefaultImpl(void*) (void * D.21738)
{
  struct ImGuiContext & g;
  struct ImVector * D.44637;
  bool D.44633;
  struct ImVector * D.44632;
  const char * iftmp.1970;
  const char * D.44630;
  const char * iftmp.1970_1;
  struct ImVector * _5;
  bool _7;
  const char * iftmp.1970_8;
  struct ImVector * _9;
  const char * iftmp.1970_11;
  const char * _12;

  <bb 2>:
  g_4 = GImGui;
  _5 = &g_4->PrivateClipboard;
  _7 = ImVector<char>::empty (_5);
  if (_7 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.1970_8 = 0B;
  goto <bb 5>;

  <bb 4>:
  _9 = &g_4->PrivateClipboard;
  iftmp.1970_11 = ImVector<char>::begin (_9);

  <bb 5>:
  # iftmp.1970_1 = PHI <iftmp.1970_8(3), iftmp.1970_11(4)>
  _12 = iftmp.1970_1;

<L3>:
  return _12;

}



;; Function void SetClipboardTextFn_DefaultImpl(void*, const char*) (_ZL30SetClipboardTextFn_DefaultImplPvPKc, funcdef_no=1190, decl_uid=15132, cgraph_uid=1089, symbol_order=1100)

void SetClipboardTextFn_DefaultImpl(void*, const char*) (void * D.21742, const char * text)
{
  const char * text_end;
  struct ImGuiContext & g;
  value_type & D.44661;
  struct ImVector * D.44660;
  int D.44659;
  long int D.44658;
  long int text.1976;
  long int text_end.1975;
  value_type & D.44655;
  struct ImVector * D.44654;
  long unsigned int D.44653;
  long int D.44652;
  long int text.1974;
  long int text_end.1973;
  struct ImVector * D.44649;
  int D.44648;
  int D.44647;
  long int D.44646;
  long int text.1972;
  long int text_end.1971;
  long unsigned int D.44643;
  struct ImVector * D.44642;
  struct ImVector * _3;
  long unsigned int _6;
  long int text_end.1971_8;
  long int text.1972_9;
  long int _10;
  int _11;
  int _12;
  struct ImVector * _13;
  long int text_end.1973_15;
  long int text.1974_16;
  long int _17;
  long unsigned int _18;
  struct ImVector * _19;
  value_type & _21;
  long int text_end.1975_23;
  long int text.1976_24;
  long int _25;
  int _26;
  struct ImVector * _27;
  value_type & _29;

  <bb 2>:
  g_2 = GImGui;
  _3 = &g_2->PrivateClipboard;
  ImVector<char>::clear (_3);
  _6 = strlen (text_5(D));
  text_end_7 = text_5(D) + _6;
  text_end.1971_8 = (long int) text_end_7;
  text.1972_9 = (long int) text_5(D);
  _10 = text_end.1971_8 - text.1972_9;
  _11 = (int) _10;
  _12 = _11 + 1;
  _13 = &g_2->PrivateClipboard;
  ImVector<char>::resize (_13, _12);
  text_end.1973_15 = (long int) text_end_7;
  text.1974_16 = (long int) text_5(D);
  _17 = text_end.1973_15 - text.1974_16;
  _18 = (long unsigned int) _17;
  _19 = &g_2->PrivateClipboard;
  _21 = ImVector<char>::operator[] (_19, 0);
  memcpy (_21, text_5(D), _18);
  text_end.1975_23 = (long int) text_end_7;
  text.1976_24 = (long int) text_5(D);
  _25 = text_end.1975_23 - text.1976_24;
  _26 = (int) _25;
  _27 = &g_2->PrivateClipboard;
  _29 = ImVector<char>::operator[] (_27, _26);
  *_29 = 0;
  return;

}



;; Function void ImeSetInputScreenPosFn_DefaultImpl(int, int) (_ZL34ImeSetInputScreenPosFn_DefaultImplii, funcdef_no=1191, decl_uid=15135, cgraph_uid=1090, symbol_order=1101)

void ImeSetInputScreenPosFn_DefaultImpl(int, int) (int D.21748, int D.21749)
{
  <bb 2>:
  GIMPLE_NOP
  return;

}



;; Function static void ImGui::ShowMetricsWindow(bool*)::Funcs::NodeDrawList(ImGuiWindow*, ImDrawList*, const char*) (_ZZN5ImGui17ShowMetricsWindowEPbEN5Funcs12NodeDrawListEP11ImGuiWindowP10ImDrawListPKc, funcdef_no=1193, decl_uid=21761, cgraph_uid=1091, symbol_order=1103)

static void ImGui::ShowMetricsWindow(bool*)::Funcs::NodeDrawList(ImGuiWindow*, ImDrawList*, const char*) (struct ImGuiWindow * window, struct ImDrawList * draw_list, const char * label)
{
  void * D.46844;
  bool D.45142;
  bool D.45140;
  bool D.45138;
  bool D.45137;
  bool D.45135;
  bool D.45132;
  ImDrawListFlags backup_flags;
  struct ImDrawVert & v;
  int n;
  struct ImVec2 triangles_pos[3];
  char * buf_end;
  char * buf_p;
  char buf[300];
  int vtx_i;
  int prim;
  int i;
  struct ImRect vtxs_rect;
  struct ImRect clip_rect;
  struct ImGuiListClipper clipper;
  bool pcmd_node_open;
  ImDrawIdx * idx_buffer;
  const struct ImDrawCmd * pcmd;
  int elem_offset;
  struct ImDrawList * overlay_draw_list;
  bool node_open;
  unsigned int D.45130;
  unsigned int elem_offset.2023;
  unsigned int D.45128;
  int D.45126;
  int D.45125;
  bool retval.2022;
  struct ImVec2 D.21796;
  sizetype D.45121;
  long unsigned int D.45120;
  int D.45119;
  long int D.45118;
  long int buf_p.2021;
  long int buf_end.2020;
  const char[4] * iftmp.2019;
  double D.45111;
  float D.45110;
  double D.45109;
  float D.45108;
  double D.45107;
  float D.45106;
  double D.45105;
  float D.45104;
  unsigned int D.45103;
  int D.21795;
  struct ImVector * D.45102;
  short unsigned int D.45100;
  ImDrawIdx * D.45099;
  long unsigned int D.45098;
  long unsigned int D.45097;
  int iftmp.2018;
  long int D.21792;
  struct ImVec2 * D.21791;
  struct ImVec2 * D.21790;
  struct ImVec2 * retval.2017;
  int D.45087;
  int D.45085;
  int D.45084;
  bool retval.2016;
  int D.45080;
  unsigned int D.45079;
  unsigned int D.45078;
  bool D.45075;
  struct ImVec2 * D.45073;
  struct value_type & D.45072;
  struct ImVector * D.45071;
  short unsigned int D.45069;
  ImDrawIdx * D.45068;
  long unsigned int D.45067;
  long unsigned int D.45066;
  int iftmp.2015;
  int D.45061;
  int D.45060;
  unsigned int D.45059;
  const struct ImVec4 * D.45057;
  bool D.45053;
  bool show_clip_rects.2014;
  bool iftmp.2013;
  bool retval.2012;
  const void * D.45046;
  long int D.45045;
  long int D.45044;
  long int D.45043;
  struct value_type * D.45042;
  struct ImVector * D.45041;
  long int pcmd.2011;
  unsigned int D.45039;
  int D.45035;
  const char * iftmp.2010;
  void * D.45033;
  double D.45032;
  float D.45031;
  double D.45030;
  float D.45029;
  double D.45028;
  float D.45027;
  double D.45026;
  float D.45025;
  int D.45021;
  short unsigned int * iftmp.2009;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) D.45019;
  void * D.45018;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) D.45015;
  unsigned int D.45012;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) D.45009;
  struct value_type * D.45007;
  struct ImVector * D.45006;
  bool retval.2008;
  struct ImVector * D.45003;
  bool D.45000;
  struct ImVec2 * D.44998;
  struct ImVec2 * D.44997;
  struct ImVec2 * D.44996;
  struct ImVec2 D.21774;
  bool D.44992;
  bool iftmp.2007;
  bool retval.2006;
  struct ImColor D.21771;
  struct ImVec4 D.21772;
  struct ImDrawList * D.44981;
  bool retval.2005;
  const char * D.44976;
  const char * iftmp.2004;
  int D.44974;
  int D.44973;
  int D.44972;
  struct ImVec2 * _8;
  long int _9;
  const char * iftmp.2004_11;
  bool iftmp.2007_12;
  short unsigned int * iftmp.2009_13;
  const char * iftmp.2010_14;
  bool iftmp.2013_15;
  int iftmp.2015_16;
  int iftmp.2018_17;
  const char[4] * iftmp.2019_18;
  int _42;
  int _43;
  int _44;
  const char * _45;
  const char * iftmp.2004_46;
  const char * iftmp.2004_47;
  bool _50;
  struct ImDrawList * _53;
  bool retval.2005_54;
  bool _68;
  bool _69;
  bool iftmp.2007_70;
  bool iftmp.2007_71;
  bool retval.2006_72;
  struct ImVec2 * _73;
  struct ImVec2 * _74;
  struct ImVec2 * _76;
  bool _80;
  struct ImVector * _82;
  struct ImVector * _85;
  struct value_type * _87;
  bool retval.2008_88;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) _89;
  unsigned int _90;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) _91;
  int _92;
  short unsigned int * iftmp.2009_93;
  short unsigned int * iftmp.2009_94;
  float _96;
  double _97;
  float _98;
  double _99;
  float _100;
  double _101;
  float _102;
  double _103;
  void * _104;
  int _105;
  const char * iftmp.2010_106;
  const char * iftmp.2010_107;
  unsigned int _108;
  long int pcmd.2011_109;
  struct ImVector * _110;
  struct value_type * _112;
  long int _113;
  long int _114;
  long int _115;
  const void * _116;
  bool _118;
  bool show_clip_rects.2014_120;
  bool _122;
  bool _123;
  bool iftmp.2013_124;
  bool iftmp.2013_125;
  bool retval.2012_126;
  const struct ImVec4 * _127;
  unsigned int _131;
  int _132;
  int _133;
  long unsigned int _134;
  long unsigned int _135;
  ImDrawIdx * _136;
  short unsigned int _137;
  int iftmp.2015_138;
  int iftmp.2015_139;
  struct ImVector * _140;
  struct value_type & _142;
  struct ImVec2 * _143;
  bool _154;
  unsigned int _155;
  unsigned int _156;
  int _157;
  bool _160;
  bool retval.2016_161;
  int _163;
  int _164;
  int _166;
  struct ImVec2 * _169;
  struct ImVec2 * _170;
  long int _171;
  struct ImVec2 * _173;
  long int _174;
  struct ImVec2 * retval.2017_175;
  long unsigned int _177;
  long unsigned int _178;
  ImDrawIdx * _179;
  short unsigned int _180;
  int iftmp.2018_181;
  int iftmp.2018_182;
  struct ImVector * _183;
  unsigned int _187;
  float _188;
  double _189;
  float _190;
  double _191;
  float _192;
  double _193;
  float _194;
  double _195;
  const char[4] * iftmp.2019_196;
  const char[4] * iftmp.2019_197;
  long int buf_end.2020_198;
  long int buf_p.2021_199;
  long int _200;
  int _201;
  long unsigned int _202;
  int _204;
  sizetype _205;
  bool _213;
  bool retval.2022_214;
  int _216;
  int _217;
  void * _231;
  void (*<Tbc9>) (const struct ImDrawList *, const struct ImDrawCmd *) _232;
  unsigned int _236;
  unsigned int elem_offset.2023_237;
  unsigned int _238;

  <bb 2>:
  _42 = draw_list_41(D)->CmdBuffer.Size;
  _43 = draw_list_41(D)->IdxBuffer.Size;
  _44 = draw_list_41(D)->VtxBuffer.Size;
  _45 = draw_list_41(D)->_OwnerName;
  if (_45 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  iftmp.2004_46 = draw_list_41(D)->_OwnerName;
  goto <bb 5>;

  <bb 4>:
  iftmp.2004_47 = "";

  <bb 5>:
  # iftmp.2004_11 = PHI <iftmp.2004_46(3), iftmp.2004_47(4)>
  _50 = ImGui::TreeNode (draw_list_41(D), "%s: \'%s\' %d vtx, %d indices, %d cmds", label_48(D), iftmp.2004_11, _44, _43, _42);
  node_open_51 = _50;
  _53 = ImGui::GetWindowDrawList ();
  retval.2005_54 = _53 == draw_list_41(D);
  if (retval.2005_54 != 0)
    goto <bb 6>;
  else
    goto <bb 9>;

  <bb 6>:
  ImGui::SameLine (0.0, -1.0e+0);
  ImColor::ImColor (&D.21771, 255, 100, 100, 255);
  D.21772 = ImColor::operator ImVec4 (&D.21771);
  ImGui::TextColored (&D.21772, "CURRENTLY APPENDING");
  D.21772 ={v} {CLOBBER};
  D.21771 ={v} {CLOBBER};
  if (node_open_51 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  ImGui::TreePop ();

  <bb 8>:
  goto <bb 70> (<L71>);

  <bb 9>:
  overlay_draw_list_65 = ImGui::GetOverlayDrawList ();
  if (window_66(D) != 0B)
    goto <bb 10>;
  else
    goto <bb 12>;

  <bb 10>:
  _68 = ImGui::IsItemHovered (0);
  _69 = _68;
  if (_69 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

  <bb 11>:
  iftmp.2007_70 = 1;
  goto <bb 13>;

  <bb 12>:
  iftmp.2007_71 = 0;

  <bb 13>:
  # iftmp.2007_12 = PHI <iftmp.2007_70(11), iftmp.2007_71(12)>
  retval.2006_72 = iftmp.2007_12;
  if (retval.2006_72 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

  <bb 14>:
  _73 = &window_66(D)->Size;
  _74 = &window_66(D)->Pos;
  D.21774 = operator+ (_74, _73);
  _76 = &window_66(D)->Pos;
  ImDrawList::AddRect (overlay_draw_list_65, _76, &D.21774, 4278255615, 0.0, 15, 1.0e+0);
  D.21774 ={v} {CLOBBER};

  <bb 15>:
  _80 = ~node_open_51;
  if (_80 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

  <bb 16>:
  goto <bb 70> (<L71>);

  <bb 17>:
  elem_offset_81 = 0;
  _82 = &draw_list_41(D)->CmdBuffer;
  pcmd_84 = ImVector<ImDrawCmd>::begin (_82);

  <bb 18>:
  # elem_offset_1 = PHI <elem_offset_81(17), elem_offset_239(68)>
  # pcmd_2 = PHI <pcmd_84(17), pcmd_240(68)>
  _85 = &draw_list_41(D)->CmdBuffer;
  _87 = ImVector<ImDrawCmd>::end (_85);
  retval.2008_88 = _87 > pcmd_2;
  if (retval.2008_88 != 0)
    goto <bb 19>;
  else
    goto <bb 69>;

  <bb 19>:
  _89 = pcmd_2->UserCallback;
  if (_89 == 0B)
    goto <bb 20>;
  else
    goto <bb 22>;

  <bb 20>:
  _90 = pcmd_2->ElemCount;
  if (_90 == 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  goto <bb 67>;

  <bb 22>:
  _91 = pcmd_2->UserCallback;
  if (_91 != 0B)
    goto <bb 23>;
  else
    goto <bb 24>;

  <bb 23>:
  _231 = pcmd_2->UserCallbackData;
  _232 = pcmd_2->UserCallback;
  ImGui::BulletText ("Callback %p, user_data %p", _232, _231);
  goto <bb 67>;

  <bb 24>:
  _92 = draw_list_41(D)->IdxBuffer.Size;
  if (_92 > 0)
    goto <bb 25>;
  else
    goto <bb 26>;

  <bb 25>:
  iftmp.2009_93 = draw_list_41(D)->IdxBuffer.Data;
  goto <bb 27>;

  <bb 26>:
  iftmp.2009_94 = 0B;

  <bb 27>:
  # iftmp.2009_13 = PHI <iftmp.2009_93(25), iftmp.2009_94(26)>
  idx_buffer_95 = iftmp.2009_13;
  _96 = pcmd_2->ClipRect.w;
  _97 = (double) _96;
  _98 = pcmd_2->ClipRect.z;
  _99 = (double) _98;
  _100 = pcmd_2->ClipRect.y;
  _101 = (double) _100;
  _102 = pcmd_2->ClipRect.x;
  _103 = (double) _102;
  _104 = pcmd_2->TextureId;
  _105 = draw_list_41(D)->IdxBuffer.Size;
  if (_105 > 0)
    goto <bb 28>;
  else
    goto <bb 29>;

  <bb 28>:
  iftmp.2010_106 = "indexed";
  goto <bb 30>;

  <bb 29>:
  iftmp.2010_107 = "non-indexed";

  <bb 30>:
  # iftmp.2010_14 = PHI <iftmp.2010_106(28), iftmp.2010_107(29)>
  _108 = pcmd_2->ElemCount;
  pcmd.2011_109 = (long int) pcmd_2;
  _110 = &draw_list_41(D)->CmdBuffer;
  _112 = ImVector<ImDrawCmd>::begin (_110);
  _113 = (long int) _112;
  _114 = pcmd.2011_109 - _113;
  _115 = _114 /[ex] 48;
  _116 = (const void *) _115;
  _118 = ImGui::TreeNode (_116, "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", _108, iftmp.2010_14, _104, _103, _101, _99, _97);
  pcmd_node_open_119 = _118;
  show_clip_rects.2014_120 = show_clip_rects;
  if (show_clip_rects.2014_120 != 0)
    goto <bb 31>;
  else
    goto <bb 33>;

  <bb 31>:
  _122 = ImGui::IsItemHovered (0);
  _123 = _122;
  if (_123 != 0)
    goto <bb 32>;
  else
    goto <bb 33>;

  <bb 32>:
  iftmp.2013_124 = 1;
  goto <bb 34>;

  <bb 33>:
  iftmp.2013_125 = 0;

  <bb 34>:
  # iftmp.2013_15 = PHI <iftmp.2013_124(32), iftmp.2013_125(33)>
  retval.2012_126 = iftmp.2013_15;
  if (retval.2012_126 != 0)
    goto <bb 35>;
  else
    goto <bb 42>;

  <bb 35>:
  _127 = &pcmd_2->ClipRect;
  ImRect::ImRect (&clip_rect, _127);
  ImRect::ImRect (&vtxs_rect);
  i_130 = elem_offset_1;

  <bb 36>:
  # i_3 = PHI <i_130(35), i_145(40)>
  _131 = pcmd_2->ElemCount;
  _132 = (int) _131;
  _133 = _132 + elem_offset_1;
  if (_133 <= i_3)
    goto <bb 41>;
  else
    goto <bb 37>;

  <bb 37>:
  if (idx_buffer_95 != 0B)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  _134 = (long unsigned int) i_3;
  _135 = _134 * 2;
  _136 = idx_buffer_95 + _135;
  _137 = *_136;
  iftmp.2015_138 = (int) _137;
  goto <bb 40>;

  <bb 39>:
  iftmp.2015_139 = i_3;

  <bb 40>:
  # iftmp.2015_16 = PHI <iftmp.2015_138(38), iftmp.2015_139(39)>
  _140 = &draw_list_41(D)->VtxBuffer;
  _142 = ImVector<ImDrawVert>::operator[] (_140, iftmp.2015_16);
  _143 = &_142->pos;
  ImRect::Add (&vtxs_rect, _143);
  i_145 = i_3 + 1;
  goto <bb 36>;

  <bb 41>:
  ImRect::Floor (&clip_rect);
  ImDrawList::AddRect (overlay_draw_list_65, &clip_rect.Min, &clip_rect.Max, 4278255615, 0.0, 15, 1.0e+0);
  ImRect::Floor (&vtxs_rect);
  ImDrawList::AddRect (overlay_draw_list_65, &vtxs_rect.Min, &vtxs_rect.Max, 4294902015, 0.0, 15, 1.0e+0);
  clip_rect ={v} {CLOBBER};
  vtxs_rect ={v} {CLOBBER};

  <bb 42>:
  _154 = ~pcmd_node_open_119;
  if (_154 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

  <bb 43>:
  goto <bb 67>;

  <bb 44>:
  _155 = pcmd_2->ElemCount;
  _156 = _155 / 3;
  _157 = (int) _156;
  ImGuiListClipper::ImGuiListClipper (&clipper, _157, -1.0e+0);

  <bb 45>:
  _160 = ImGuiListClipper::Step (&clipper);
  retval.2016_161 = _160;
  if (retval.2016_161 != 0)
    goto <bb 46>;
  else
    goto <bb 66>;

  <bb 46>:
  prim_162 = clipper.DisplayStart;
  _163 = clipper.DisplayStart;
  _164 = _163 * 3;
  vtx_i_165 = _164 + elem_offset_1;

  <bb 47>:
  # prim_4 = PHI <prim_162(46), prim_223(64)>
  # vtx_i_5 = PHI <vtx_i_165(46), vtx_i_6(64)>
  _166 = clipper.DisplayEnd;
  if (_166 <= prim_4)
    goto <bb 65>;
  else
    goto <bb 48>;

  <bb 48>:
  buf_p_167 = &buf;
  buf_end_168 = &buf + 300;
  _169 = &triangles_pos;
  _170 = _169;
  _171 = 2;

  <bb 49>:
  # _8 = PHI <_170(48), _173(50)>
  # _9 = PHI <_171(48), _174(50)>
  if (_9 < 0)
    goto <bb 51>;
  else
    goto <bb 50>;

  <bb 50>:
  ImVec2::ImVec2 (_8);
  _173 = _8 + 8;
  _174 = _9 + -1;
  goto <bb 49>;

  <bb 51>:
  retval.2017_175 = _169;
  n_176 = 0;

  <bb 52>:
  # vtx_i_6 = PHI <vtx_i_5(51), vtx_i_208(59)>
  # buf_p_7 = PHI <buf_p_167(51), buf_p_206(59)>
  # n_10 = PHI <n_176(51), n_207(59)>
  if (n_10 > 2)
    goto <bb 60>;
  else
    goto <bb 53>;

  <bb 53>:
  if (idx_buffer_95 != 0B)
    goto <bb 54>;
  else
    goto <bb 55>;

  <bb 54>:
  _177 = (long unsigned int) vtx_i_6;
  _178 = _177 * 2;
  _179 = idx_buffer_95 + _178;
  _180 = *_179;
  iftmp.2018_181 = (int) _180;
  goto <bb 56>;

  <bb 55>:
  iftmp.2018_182 = vtx_i_6;

  <bb 56>:
  # iftmp.2018_17 = PHI <iftmp.2018_181(54), iftmp.2018_182(55)>
  _183 = &draw_list_41(D)->VtxBuffer;
  v_185 = ImVector<ImDrawVert>::operator[] (_183, iftmp.2018_17);
  triangles_pos[n_10] = v_185->pos;
  _187 = v_185->col;
  _188 = v_185->uv.y;
  _189 = (double) _188;
  _190 = v_185->uv.x;
  _191 = (double) _190;
  _192 = v_185->pos.y;
  _193 = (double) _192;
  _194 = v_185->pos.x;
  _195 = (double) _194;
  if (n_10 == 0)
    goto <bb 57>;
  else
    goto <bb 58>;

  <bb 57>:
  iftmp.2019_196 = "vtx";
  goto <bb 59>;

  <bb 58>:
  iftmp.2019_197 = "   ";

  <bb 59>:
  # iftmp.2019_18 = PHI <iftmp.2019_196(57), iftmp.2019_197(58)>
  buf_end.2020_198 = (long int) buf_end_168;
  buf_p.2021_199 = (long int) buf_p_7;
  _200 = buf_end.2020_198 - buf_p.2021_199;
  _201 = (int) _200;
  _202 = (long unsigned int) _201;
  _204 = ImFormatString (buf_p_7, _202, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n", iftmp.2019_18, vtx_i_6, _195, _193, _191, _189, _187);
  _205 = (sizetype) _204;
  buf_p_206 = buf_p_7 + _205;
  n_207 = n_10 + 1;
  vtx_i_208 = vtx_i_6 + 1;
  goto <bb 52>;

  <bb 60>:
  ImVec2::ImVec2 (&D.21796, 0.0, 0.0);
  ImGui::Selectable (&buf, 0, 0, &D.21796);

  <bb 61>:
  D.21796 ={v} {CLOBBER};
  _213 = ImGui::IsItemHovered (0);
  retval.2022_214 = _213;
  if (retval.2022_214 != 0)
    goto <bb 62>;
  else
    goto <bb 64>;

  <bb 62>:
  backup_flags_215 = overlay_draw_list_65->Flags;
  _216 = overlay_draw_list_65->Flags;
  _217 = _216 & -2;
  overlay_draw_list_65->Flags = _217;
  ImDrawList::AddPolyline (overlay_draw_list_65, &triangles_pos, 3, 4278255615, 1, 1.0e+0);

  <bb 63>:
  overlay_draw_list_65->Flags = backup_flags_215;

  <bb 64>:
  buf ={v} {CLOBBER};
  triangles_pos ={v} {CLOBBER};
  prim_223 = prim_4 + 1;
  goto <bb 47>;

  <bb 65>:
  goto <bb 45>;

  <bb 66>:
  ImGui::TreePop ();
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  clipper ={v} {CLOBBER};
  goto <bb 68>;

  <bb 67>:
  clipper ={v} {CLOBBER};

  <bb 68>:
  _236 = pcmd_2->ElemCount;
  elem_offset.2023_237 = (unsigned int) elem_offset_1;
  _238 = _236 + elem_offset.2023_237;
  elem_offset_239 = (int) _238;
  pcmd_240 = pcmd_2 + 48;
  goto <bb 18>;

  <bb 69>:
  ImGui::TreePop ();

<L71>:
  return;

<L78>:
  D.21796 ={v} {CLOBBER};
  buf ={v} {CLOBBER};
  triangles_pos ={v} {CLOBBER};
  ImGuiListClipper::~ImGuiListClipper (&clipper);
  _36 = __builtin_eh_pointer (10);
  __builtin_unwind_resume (_36);

}



;; Function static void ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindows(ImVector<ImGuiWindow*>&, const char*) (_ZZN5ImGui17ShowMetricsWindowEPbEN5Funcs11NodeWindowsER8ImVectorIP11ImGuiWindowEPKc, funcdef_no=1194, decl_uid=21764, cgraph_uid=1092, symbol_order=1104)

static void ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindows(ImVector<ImGuiWindow*>&, const char*) (struct ImVector & windows, const char * label)
{
  bool D.44810;
  int i;
  struct ImGuiWindow * D.44808;
  struct ImGuiWindow * & D.44807;
  int D.44805;
  bool D.44801;
  int D.44800;
  bool retval.1990;
  int _6;
  bool _9;
  bool _10;
  bool retval.1990_11;
  int _13;
  struct ImGuiWindow * & _15;
  struct ImGuiWindow * _16;

  <bb 2>:
  _6 = windows_5(D)->Size;
  _9 = ImGui::TreeNode (label_7(D), "%s (%d)", label_7(D), _6);
  _10 = _9;
  retval.1990_11 = ~_10;
  if (retval.1990_11 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 8> (<L5>);

  <bb 4>:
  i_12 = 0;

  <bb 5>:
  # i_1 = PHI <i_12(4), i_18(6)>
  _13 = windows_5(D)->Size;
  if (_13 <= i_1)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _15 = ImVector<ImGuiWindow*>::operator[] (windows_5(D), i_1);
  _16 = *_15;
  ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindow (_16, "Window");
  i_18 = i_1 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::TreePop ();

<L5>:
  return;

}



;; Function static void ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindow(ImGuiWindow*, const char*) (_ZZN5ImGui17ShowMetricsWindowEPbEN5Funcs10NodeWindowEP11ImGuiWindowPKc, funcdef_no=1195, decl_uid=21767, cgraph_uid=1093, symbol_order=1105)

static void ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindow(ImGuiWindow*, const char*) (struct ImGuiWindow * window, const char * label)
{
  bool D.44962;
  bool D.44961;
  bool D.44960;
  int column_n;
  const struct ImGuiColumnsSet * columns;
  int n;
  ImGuiWindowFlags flags;
  int D.44958;
  int D.44957;
  double D.44954;
  float D.44953;
  const struct value_type & D.44952;
  const struct ImVector * D.44951;
  double D.44950;
  float D.44949;
  float D.44948;
  const struct value_type & D.44947;
  const struct ImVector * D.44946;
  int D.44944;
  double D.44942;
  float D.44941;
  float D.44940;
  float D.44939;
  double D.44938;
  float D.44937;
  double D.44936;
  float D.44935;
  const void * D.44932;
  long unsigned int D.44931;
  unsigned int D.44930;
  unsigned int D.44929;
  int D.44928;
  int D.44927;
  bool retval.2003;
  struct ImVector * D.44925;
  int D.44923;
  bool D.44918;
  int D.44917;
  int D.44915;
  bool iftmp.2002;
  bool retval.2001;
  struct ImVector * D.44909;
  int D.44906;
  struct ImGuiWindow * D.44904;
  struct ImGuiWindow * D.44901;
  double D.44899;
  float D.44898;
  double D.44897;
  float D.44896;
  double D.44895;
  float D.44894;
  double D.44893;
  float D.44892;
  struct ImRect * D.44889;
  bool retval.2000;
  struct ImGuiWindow * D.44886;
  struct ImGuiWindow * D.44883;
  const char * iftmp.1999;
  unsigned int D.44881;
  unsigned int D.44880;
  int D.44879;
  int D.44878;
  bool D.44877;
  int D.44876;
  bool D.44875;
  double D.44874;
  float D.44873;
  double D.44872;
  float D.44871;
  double D.44870;
  float D.44869;
  double D.44868;
  float D.44867;
  int D.44863;
  const char * iftmp.1998;
  int D.44858;
  const char * iftmp.1997;
  int D.44853;
  const char * iftmp.1996;
  int D.44848;
  const char * iftmp.1995;
  int D.44843;
  const char * iftmp.1994;
  int D.44838;
  const char * iftmp.1993;
  double D.44836;
  float D.44835;
  double D.44834;
  float D.44833;
  double D.44832;
  float D.44831;
  double D.44830;
  float D.44829;
  double D.44828;
  float D.44827;
  double D.44826;
  float D.44825;
  struct ImDrawList * D.44824;
  bool D.44821;
  char * D.44820;
  int D.44819;
  bool D.44818;
  bool D.44816;
  bool iftmp.1992;
  bool retval.1991;
  bool iftmp.1992_3;
  const char * iftmp.1993_4;
  const char * iftmp.1994_5;
  const char * iftmp.1995_6;
  const char * iftmp.1996_7;
  const char * iftmp.1997_8;
  const char * iftmp.1998_9;
  const char * iftmp.1999_10;
  bool iftmp.2002_11;
  bool _24;
  bool _25;
  bool iftmp.1992_26;
  bool iftmp.1992_27;
  int _28;
  char * _29;
  bool _32;
  bool _33;
  bool retval.1991_34;
  struct ImDrawList * _36;
  float _38;
  double _39;
  float _40;
  double _41;
  float _42;
  double _43;
  float _44;
  double _45;
  float _46;
  double _47;
  float _48;
  double _49;
  int _51;
  const char * iftmp.1993_52;
  const char * iftmp.1993_53;
  int _54;
  const char * iftmp.1994_55;
  const char * iftmp.1994_56;
  int _57;
  const char * iftmp.1995_58;
  const char * iftmp.1995_59;
  int _60;
  const char * iftmp.1996_61;
  const char * iftmp.1996_62;
  int _63;
  const char * iftmp.1997_64;
  const char * iftmp.1997_65;
  int _66;
  const char * iftmp.1998_67;
  const char * iftmp.1998_68;
  float _71;
  double _72;
  float _73;
  double _74;
  float _76;
  double _77;
  float _78;
  double _79;
  bool _81;
  int _82;
  bool _83;
  int _84;
  int _86;
  unsigned int _87;
  unsigned int _88;
  struct ImGuiWindow * _90;
  struct ImGuiWindow * _91;
  const char * iftmp.1999_92;
  const char * iftmp.1999_93;
  struct ImRect * _95;
  bool retval.2000_97;
  float _98;
  double _99;
  float _100;
  double _101;
  float _102;
  double _103;
  float _104;
  double _105;
  struct ImGuiWindow * _108;
  struct ImGuiWindow * _109;
  int _111;
  struct ImVector * _112;
  int _114;
  int _115;
  bool _117;
  bool _118;
  bool iftmp.2002_119;
  bool iftmp.2002_120;
  bool retval.2001_121;
  int _123;
  struct ImVector * _124;
  int _127;
  int _128;
  unsigned int _129;
  unsigned int _130;
  long unsigned int _131;
  const void * _132;
  bool _134;
  bool retval.2003_135;
  float _136;
  double _137;
  float _138;
  double _139;
  float _140;
  float _141;
  float _142;
  double _143;
  int _146;
  const struct ImVector * _147;
  const struct value_type & _149;
  float _150;
  float _152;
  double _153;
  const struct ImVector * _154;
  const struct value_type & _156;
  float _157;
  double _158;
  int _164;
  int _165;

  <bb 2>:
  _24 = window_23(D)->Active;
  if (_24 != 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  _25 = window_23(D)->WasActive;
  if (_25 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  iftmp.1992_27 = 1;
  goto <bb 6>;

  <bb 5>:
  iftmp.1992_26 = 0;

  <bb 6>:
  # iftmp.1992_3 = PHI <iftmp.1992_27(4), iftmp.1992_26(5)>
  _28 = (int) iftmp.1992_3;
  _29 = window_23(D)->Name;
  _32 = ImGui::TreeNode (window_23(D), "%s \'%s\', %d @ 0x%p", label_30(D), _29, _28, window_23(D));
  _33 = _32;
  retval.1991_34 = ~_33;
  if (retval.1991_34 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  goto <bb 51> (<L52>);

  <bb 8>:
  flags_35 = window_23(D)->Flags;
  _36 = window_23(D)->DrawList;
  ImGui::ShowMetricsWindow(bool*)::Funcs::NodeDrawList (window_23(D), _36, "DrawList");
  _38 = window_23(D)->SizeContents.y;
  _39 = (double) _38;
  _40 = window_23(D)->SizeContents.x;
  _41 = (double) _40;
  _42 = window_23(D)->Size.y;
  _43 = (double) _42;
  _44 = window_23(D)->Size.x;
  _45 = (double) _44;
  _46 = window_23(D)->Pos.y;
  _47 = (double) _46;
  _48 = window_23(D)->Pos.x;
  _49 = (double) _48;
  ImGui::BulletText ("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", _49, _47, _45, _43, _41, _39);
  _51 = flags_35 & 256;
  if (_51 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  iftmp.1993_52 = "NoSavedSettings ";
  goto <bb 11>;

  <bb 10>:
  iftmp.1993_53 = "";

  <bb 11>:
  # iftmp.1993_4 = PHI <iftmp.1993_52(9), iftmp.1993_53(10)>
  _54 = flags_35 & 268435456;
  if (_54 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

  <bb 12>:
  iftmp.1994_55 = "ChildMenu ";
  goto <bb 14>;

  <bb 13>:
  iftmp.1994_56 = "";

  <bb 14>:
  # iftmp.1994_5 = PHI <iftmp.1994_55(12), iftmp.1994_56(13)>
  _57 = flags_35 & 134217728;
  if (_57 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

  <bb 15>:
  iftmp.1995_58 = "Modal ";
  goto <bb 17>;

  <bb 16>:
  iftmp.1995_59 = "";

  <bb 17>:
  # iftmp.1995_6 = PHI <iftmp.1995_58(15), iftmp.1995_59(16)>
  _60 = flags_35 & 67108864;
  if (_60 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

  <bb 18>:
  iftmp.1996_61 = "Popup ";
  goto <bb 20>;

  <bb 19>:
  iftmp.1996_62 = "";

  <bb 20>:
  # iftmp.1996_7 = PHI <iftmp.1996_61(18), iftmp.1996_62(19)>
  _63 = flags_35 & 33554432;
  if (_63 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

  <bb 21>:
  iftmp.1997_64 = "Tooltip ";
  goto <bb 23>;

  <bb 22>:
  iftmp.1997_65 = "";

  <bb 23>:
  # iftmp.1997_8 = PHI <iftmp.1997_64(21), iftmp.1997_65(22)>
  _66 = flags_35 & 16777216;
  if (_66 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

  <bb 24>:
  iftmp.1998_67 = "Child ";
  goto <bb 26>;

  <bb 25>:
  iftmp.1998_68 = "";

  <bb 26>:
  # iftmp.1998_9 = PHI <iftmp.1998_67(24), iftmp.1998_68(25)>
  ImGui::BulletText ("Flags: 0x%08X (%s%s%s%s%s%s..)", flags_35, iftmp.1998_9, iftmp.1997_8, iftmp.1996_7, iftmp.1995_6, iftmp.1994_5, iftmp.1993_4);
  _71 = GetScrollMaxY (window_23(D));
  _72 = (double) _71;
  _73 = window_23(D)->Scroll.y;
  _74 = (double) _73;
  _76 = GetScrollMaxX (window_23(D));
  _77 = (double) _76;
  _78 = window_23(D)->Scroll.x;
  _79 = (double) _78;
  ImGui::BulletText ("Scroll: (%.2f/%.2f,%.2f/%.2f)", _79, _77, _74, _72);
  _81 = window_23(D)->WriteAccessed;
  _82 = (int) _81;
  _83 = window_23(D)->Active;
  _84 = (int) _83;
  ImGui::BulletText ("Active: %d, WriteAccessed: %d", _84, _82);
  _86 = window_23(D)->DC.NavLayerActiveMask;
  _87 = window_23(D)->NavLastIds[1];
  _88 = window_23(D)->NavLastIds[0];
  ImGui::BulletText ("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", _88, _87, _86);
  _90 = window_23(D)->NavLastChildNavWindow;
  if (_90 != 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _91 = window_23(D)->NavLastChildNavWindow;
  iftmp.1999_92 = _91->Name;
  goto <bb 29>;

  <bb 28>:
  iftmp.1999_93 = "NULL";

  <bb 29>:
  # iftmp.1999_10 = PHI <iftmp.1999_92(27), iftmp.1999_93(28)>
  ImGui::BulletText ("NavLastChildNavWindow: %s", iftmp.1999_10);
  _95 = &window_23(D)->NavRectRel[0];
  retval.2000_97 = ImRect::IsInverted (_95);
  if (retval.2000_97 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _98 = window_23(D)->NavRectRel[0].Max.y;
  _99 = (double) _98;
  _100 = window_23(D)->NavRectRel[0].Max.x;
  _101 = (double) _100;
  _102 = window_23(D)->NavRectRel[0].Min.y;
  _103 = (double) _102;
  _104 = window_23(D)->NavRectRel[0].Min.x;
  _105 = (double) _104;
  ImGui::BulletText ("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", _105, _103, _101, _99);
  goto <bb 32>;

  <bb 31>:
  ImGui::BulletText ("NavRectRel[0]: <None>");

  <bb 32>:
  _108 = window_23(D)->RootWindow;
  if (_108 != window_23(D))
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _109 = window_23(D)->RootWindow;
  ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindow (_109, "RootWindow");

  <bb 34>:
  _111 = window_23(D)->DC.ChildWindows.Size;
  if (_111 > 0)
    goto <bb 35>;
  else
    goto <bb 36>;

  <bb 35>:
  _112 = &window_23(D)->DC.ChildWindows;
  ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindows (_112, "ChildWindows");

  <bb 36>:
  _114 = window_23(D)->ColumnsStorage.Size;
  if (_114 > 0)
    goto <bb 37>;
  else
    goto <bb 39>;

  <bb 37>:
  _115 = window_23(D)->ColumnsStorage.Size;
  _117 = ImGui::TreeNode ("Columns", "Columns sets (%d)", _115);
  _118 = _117;
  if (_118 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

  <bb 38>:
  iftmp.2002_119 = 1;
  goto <bb 40>;

  <bb 39>:
  iftmp.2002_120 = 0;

  <bb 40>:
  # iftmp.2002_11 = PHI <iftmp.2002_119(38), iftmp.2002_120(39)>
  retval.2001_121 = iftmp.2002_11;
  if (retval.2001_121 != 0)
    goto <bb 41>;
  else
    goto <bb 50>;

  <bb 41>:
  n_122 = 0;

  <bb 42>:
  # n_1 = PHI <n_122(41), n_162(48)>
  _123 = window_23(D)->ColumnsStorage.Size;
  if (_123 <= n_1)
    goto <bb 49>;
  else
    goto <bb 43>;

  <bb 43>:
  _124 = &window_23(D)->ColumnsStorage;
  columns_126 = ImVector<ImGuiColumnsSet>::operator[] (_124, n_1);
  _127 = columns_126->Flags;
  _128 = columns_126->Count;
  _129 = columns_126->ID;
  _130 = columns_126->ID;
  _131 = (long unsigned int) _130;
  _132 = (const void *) _131;
  _134 = ImGui::TreeNode (_132, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", _129, _128, _127);
  retval.2003_135 = _134;
  if (retval.2003_135 != 0)
    goto <bb 44>;
  else
    goto <bb 48>;

  <bb 44>:
  _136 = columns_126->MaxX;
  _137 = (double) _136;
  _138 = columns_126->MinX;
  _139 = (double) _138;
  _140 = columns_126->MaxX;
  _141 = columns_126->MinX;
  _142 = _140 - _141;
  _143 = (double) _142;
  ImGui::BulletText ("Width: %.1f (MinX: %.1f, MaxX: %.1f)", _143, _139, _137);
  column_n_145 = 0;

  <bb 45>:
  # column_n_2 = PHI <column_n_145(44), column_n_160(46)>
  _146 = columns_126->Columns.Size;
  if (_146 <= column_n_2)
    goto <bb 47>;
  else
    goto <bb 46>;

  <bb 46>:
  _147 = &columns_126->Columns;
  _149 = ImVector<ImGuiColumnData>::operator[] (_147, column_n_2);
  _150 = _149->OffsetNorm;
  _152 = OffsetNormToPixels (columns_126, _150);
  _153 = (double) _152;
  _154 = &columns_126->Columns;
  _156 = ImVector<ImGuiColumnData>::operator[] (_154, column_n_2);
  _157 = _156->OffsetNorm;
  _158 = (double) _157;
  ImGui::BulletText ("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n_2, _158, _153);
  column_n_160 = column_n_2 + 1;
  goto <bb 45>;

  <bb 47>:
  ImGui::TreePop ();

  <bb 48>:
  n_162 = n_1 + 1;
  goto <bb 42>;

  <bb 49>:
  ImGui::TreePop ();

  <bb 50>:
  _164 = window_23(D)->StateStorage.Data.Size;
  _165 = _164 * 16;
  ImGui::BulletText ("Storage: %d bytes", _165);
  ImGui::TreePop ();

<L52>:
  return;

}



;; Function void ImGui::ShowMetricsWindow(bool*) (_ZN5ImGui17ShowMetricsWindowEPb, funcdef_no=1192, decl_uid=2436, cgraph_uid=1094, symbol_order=1106)

void ImGui::ShowMetricsWindow(bool*) (bool * p_open)
{
  bool D.44797;
  bool D.44796;
  bool D.44795;
  bool D.44794;
  const char * input_source_names[5];
  struct ImGuiWindow * window;
  int i;
  int i;
  struct ImGuiContext & g;
  static bool show_clip_rects = 1;
  static const char __PRETTY_FUNCTION__[37] = "void ImGui::ShowMetricsWindow(bool*)";
  int D.44791;
  bool D.44790;
  unsigned int D.44789;
  char[33] * D.44788;
  int D.44787;
  int D.44786;
  bool D.44785;
  int D.44784;
  bool D.44783;
  unsigned int D.44782;
  unsigned int D.44781;
  int D.44780;
  bool D.44779;
  int D.44778;
  bool D.44777;
  const char * D.44776;
  int D.44775;
  ImGuiInputSource D.44774;
  unsigned int D.44773;
  int D.44772;
  struct ImGuiWindow * D.44770;
  struct ImGuiWindow * D.44767;
  const char * iftmp.1989;
  struct ImGuiWindow * D.44764;
  struct ImGuiWindow * D.44761;
  const char * iftmp.1988;
  struct ImGuiWindow * D.44758;
  struct ImGuiWindow * D.44755;
  const char * iftmp.1987;
  unsigned int D.44753;
  unsigned int D.44752;
  double D.44751;
  float D.44750;
  const char * D.44749;
  int D.44748;
  ImGuiInputSource D.44747;
  unsigned int D.44746;
  unsigned int D.44745;
  double D.44744;
  float D.44743;
  struct ImGuiWindow * D.44741;
  struct ImGuiWindow * D.44738;
  const char * iftmp.1986;
  struct ImGuiWindow * D.44735;
  struct ImGuiWindow * D.44732;
  const char * iftmp.1985;
  bool retval.1984;
  unsigned int D.44723;
  struct value_type & D.44722;
  struct ImVector * D.44721;
  const char * iftmp.1983;
  int D.44715;
  int D.44714;
  const char * iftmp.1982;
  int D.44708;
  int D.44707;
  const char * iftmp.1981;
  struct value_type & D.44702;
  struct ImVector * D.44701;
  int D.44699;
  int D.44695;
  bool retval.1980;
  struct ImDrawList * D.44692;
  struct ImDrawList * & D.44691;
  struct ImVector * D.44690;
  int D.44688;
  int D.44684;
  bool retval.1979;
  struct ImVector * D.44682;
  int D.44681;
  long unsigned int GImAllocatorActiveAllocationsCount.1978;
  int D.44679;
  struct ImGuiIO & D.44678;
  int D.44677;
  struct ImGuiIO & D.44676;
  int D.44675;
  int D.44674;
  struct ImGuiIO & D.44673;
  double D.44672;
  float D.44671;
  float D.44670;
  struct ImGuiIO & D.44669;
  double D.44668;
  float D.44667;
  struct ImGuiIO & D.44666;
  const char * D.44665;
  bool retval.1977;
  const char * iftmp.1981_3;
  const char * iftmp.1982_4;
  const char * iftmp.1983_5;
  const char * iftmp.1985_6;
  const char * iftmp.1986_7;
  const char * iftmp.1987_8;
  const char * iftmp.1988_9;
  const char * iftmp.1989_10;
  bool _21;
  bool retval.1977_22;
  const char * _24;
  struct ImGuiIO & _27;
  float _28;
  double _29;
  struct ImGuiIO & _31;
  float _32;
  float _33;
  double _34;
  struct ImGuiIO & _37;
  int _38;
  int _39;
  struct ImGuiIO & _41;
  int _42;
  struct ImGuiIO & _44;
  int _45;
  long unsigned int GImAllocatorActiveAllocationsCount.1978_47;
  int _48;
  struct ImVector * _53;
  int _55;
  bool _57;
  bool retval.1979_58;
  int _60;
  struct ImVector * _61;
  struct ImDrawList * & _63;
  struct ImDrawList * _64;
  int _68;
  bool _70;
  bool retval.1980_71;
  int _73;
  struct ImVector * _74;
  struct value_type & _76;
  int _78;
  int _79;
  const char * iftmp.1981_80;
  const char * iftmp.1981_81;
  int _82;
  int _83;
  const char * iftmp.1982_84;
  const char * iftmp.1982_85;
  const char * iftmp.1983_86;
  const char * iftmp.1983_87;
  struct ImVector * _88;
  struct value_type & _90;
  unsigned int _91;
  bool _96;
  bool retval.1984_97;
  struct ImGuiWindow * _103;
  struct ImGuiWindow * _104;
  const char * iftmp.1985_105;
  const char * iftmp.1985_106;
  struct ImGuiWindow * _108;
  struct ImGuiWindow * _109;
  const char * iftmp.1986_110;
  const char * iftmp.1986_111;
  float _113;
  double _114;
  unsigned int _115;
  unsigned int _116;
  ImGuiInputSource _118;
  int _119;
  const char * _120;
  float _121;
  double _122;
  unsigned int _123;
  unsigned int _124;
  struct ImGuiWindow * _126;
  struct ImGuiWindow * _127;
  const char * iftmp.1987_128;
  const char * iftmp.1987_129;
  struct ImGuiWindow * _131;
  struct ImGuiWindow * _132;
  const char * iftmp.1988_133;
  const char * iftmp.1988_134;
  struct ImGuiWindow * _136;
  struct ImGuiWindow * _137;
  const char * iftmp.1989_138;
  const char * iftmp.1989_139;
  int _141;
  unsigned int _142;
  ImGuiInputSource _144;
  int _145;
  const char * _146;
  bool _148;
  int _149;
  bool _150;
  int _151;
  unsigned int _153;
  unsigned int _154;
  bool _156;
  int _157;
  bool _158;
  int _159;
  int _161;
  char[33] * _162;
  unsigned int _163;
  bool _164;
  int _165;

  <bb 2>:
  _21 = ImGui::Begin ("ImGui Metrics", p_open_19(D), 0);
  retval.1977_22 = _21;
  if (retval.1977_22 != 0)
    goto <bb 3>;
  else
    goto <bb 43>;

  <bb 3>:
  _24 = ImGui::GetVersion ();
  ImGui::Text ("Dear ImGui %s", _24);
  _27 = ImGui::GetIO ();
  _28 = _27->Framerate;
  _29 = (double) _28;
  _31 = ImGui::GetIO ();
  _32 = _31->Framerate;
  _33 = 1.0e+3 / _32;
  _34 = (double) _33;
  ImGui::Text ("Application average %.3f ms/frame (%.1f FPS)", _34, _29);
  _37 = ImGui::GetIO ();
  _38 = _37->MetricsRenderIndices;
  _39 = _38 / 3;
  _41 = ImGui::GetIO ();
  _42 = _41->MetricsRenderIndices;
  _44 = ImGui::GetIO ();
  _45 = _44->MetricsRenderVertices;
  ImGui::Text ("%d vertices, %d indices (%d triangles)", _45, _42, _39);
  GImAllocatorActiveAllocationsCount.1978_47 = GImAllocatorActiveAllocationsCount;
  _48 = (int) GImAllocatorActiveAllocationsCount.1978_47;
  ImGui::Text ("%d allocations", _48);
  ImGui::Checkbox ("Show clipping rectangles when hovering draw commands", &show_clip_rects);
  ImGui::Separator ();
  g_52 = GImGui;
  _53 = &g_52->Windows;
  ImGui::ShowMetricsWindow(bool*)::Funcs::NodeWindows (_53, "Windows");
  _55 = g_52->DrawDataBuilder.Layers[0].Size;
  _57 = ImGui::TreeNode ("DrawList", "Active DrawLists (%d)", _55);
  retval.1979_58 = _57;
  if (retval.1979_58 != 0)
    goto <bb 4>;
  else
    goto <bb 8>;

  <bb 4>:
  i_59 = 0;

  <bb 5>:
  # i_1 = PHI <i_59(4), i_66(6)>
  _60 = g_52->DrawDataBuilder.Layers[0].Size;
  if (_60 <= i_1)
    goto <bb 7>;
  else
    goto <bb 6>;

  <bb 6>:
  _61 = &g_52->DrawDataBuilder.Layers[0];
  _63 = ImVector<ImDrawList*>::operator[] (_61, i_1);
  _64 = *_63;
  ImGui::ShowMetricsWindow(bool*)::Funcs::NodeDrawList (0B, _64, "DrawList");
  i_66 = i_1 + 1;
  goto <bb 5>;

  <bb 7>:
  ImGui::TreePop ();

  <bb 8>:
  _68 = g_52->OpenPopupStack.Size;
  _70 = ImGui::TreeNode ("Popups", "Open Popups Stack (%d)", _68);
  retval.1980_71 = _70;
  if (retval.1980_71 != 0)
    goto <bb 9>;
  else
    goto <bb 24>;

  <bb 9>:
  i_72 = 0;

  <bb 10>:
  # i_2 = PHI <i_72(9), i_93(22)>
  _73 = g_52->OpenPopupStack.Size;
  if (_73 <= i_2)
    goto <bb 23>;
  else
    goto <bb 11>;

  <bb 11>:
  _74 = &g_52->OpenPopupStack;
  _76 = ImVector<ImGuiPopupRef>::operator[] (_74, i_2);
  window_77 = _76->Window;
  if (window_77 != 0B)
    goto <bb 12>;
  else
    goto <bb 14>;

  <bb 12>:
  _78 = window_77->Flags;
  _79 = _78 & 268435456;
  if (_79 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

  <bb 13>:
  iftmp.1981_80 = " ChildMenu";
  goto <bb 15>;

  <bb 14>:
  iftmp.1981_81 = "";

  <bb 15>:
  # iftmp.1981_3 = PHI <iftmp.1981_80(13), iftmp.1981_81(14)>
  if (window_77 != 0B)
    goto <bb 16>;
  else
    goto <bb 18>;

  <bb 16>:
  _82 = window_77->Flags;
  _83 = _82 & 16777216;
  if (_83 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

  <bb 17>:
  iftmp.1982_84 = " ChildWindow";
  goto <bb 19>;

  <bb 18>:
  iftmp.1982_85 = "";

  <bb 19>:
  # iftmp.1982_4 = PHI <iftmp.1982_84(17), iftmp.1982_85(18)>
  if (window_77 != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

  <bb 20>:
  iftmp.1983_86 = window_77->Name;
  goto <bb 22>;

  <bb 21>:
  iftmp.1983_87 = "NULL";

  <bb 22>:
  # iftmp.1983_5 = PHI <iftmp.1983_86(20), iftmp.1983_87(21)>
  _88 = &g_52->OpenPopupStack;
  _90 = ImVector<ImGuiPopupRef>::operator[] (_88, i_2);
  _91 = _90->PopupId;
  ImGui::BulletText ("PopupID: %08x, Window: \'%s\'%s%s", _91, iftmp.1983_5, iftmp.1982_4, iftmp.1981_3);
  i_93 = i_2 + 1;
  goto <bb 10>;

  <bb 23>:
  ImGui::TreePop ();

  <bb 24>:
  _96 = ImGui::TreeNode ("Internal state");
  retval.1984_97 = _96;
  if (retval.1984_97 != 0)
    goto <bb 25>;
  else
    goto <bb 42>;

  <bb 25>:
  input_source_names[0] = "None";
  input_source_names[1] = "Mouse";
  input_source_names[2] = "Nav";
  input_source_names[3] = "NavKeyboard";
  input_source_names[4] = "NavGamepad";

  <bb 26>:
  _103 = g_52->HoveredWindow;
  if (_103 != 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

  <bb 27>:
  _104 = g_52->HoveredWindow;
  iftmp.1985_105 = _104->Name;
  goto <bb 29>;

  <bb 28>:
  iftmp.1985_106 = "NULL";

  <bb 29>:
  # iftmp.1985_6 = PHI <iftmp.1985_105(27), iftmp.1985_106(28)>
  ImGui::Text ("HoveredWindow: \'%s\'", iftmp.1985_6);
  _108 = g_52->HoveredRootWindow;
  if (_108 != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

  <bb 30>:
  _109 = g_52->HoveredRootWindow;
  iftmp.1986_110 = _109->Name;
  goto <bb 32>;

  <bb 31>:
  iftmp.1986_111 = "NULL";

  <bb 32>:
  # iftmp.1986_7 = PHI <iftmp.1986_110(30), iftmp.1986_111(31)>
  ImGui::Text ("HoveredRootWindow: \'%s\'", iftmp.1986_7);
  _113 = g_52->HoveredIdTimer;
  _114 = (double) _113;
  _115 = g_52->HoveredIdPreviousFrame;
  _116 = g_52->HoveredId;
  ImGui::Text ("HoveredId: 0x%08X/0x%08X (%.2f sec)", _116, _115, _114);
  _118 = g_52->ActiveIdSource;
  _119 = (int) _118;
  _120 = input_source_names[_119];
  _121 = g_52->ActiveIdTimer;
  _122 = (double) _121;
  _123 = g_52->ActiveIdPreviousFrame;
  _124 = g_52->ActiveId;
  ImGui::Text ("ActiveId: 0x%08X/0x%08X (%.2f sec), ActiveIdSource: %s", _124, _123, _122, _120);
  _126 = g_52->ActiveIdWindow;
  if (_126 != 0B)
    goto <bb 33>;
  else
    goto <bb 34>;

  <bb 33>:
  _127 = g_52->ActiveIdWindow;
  iftmp.1987_128 = _127->Name;
  goto <bb 35>;

  <bb 34>:
  iftmp.1987_129 = "NULL";

  <bb 35>:
  # iftmp.1987_8 = PHI <iftmp.1987_128(33), iftmp.1987_129(34)>
  ImGui::Text ("ActiveIdWindow: \'%s\'", iftmp.1987_8);
  _131 = g_52->MovingWindow;
  if (_131 != 0B)
    goto <bb 36>;
  else
    goto <bb 37>;

  <bb 36>:
  _132 = g_52->MovingWindow;
  iftmp.1988_133 = _132->Name;
  goto <bb 38>;

  <bb 37>:
  iftmp.1988_134 = "NULL";

  <bb 38>:
  # iftmp.1988_9 = PHI <iftmp.1988_133(36), iftmp.1988_134(37)>
  ImGui::Text ("MovingWindow: \'%s\'", iftmp.1988_9);
  _136 = g_52->NavWindow;
  if (_136 != 0B)
    goto <bb 39>;
  else
    goto <bb 40>;

  <bb 39>:
  _137 = g_52->NavWindow;
  iftmp.1989_138 = _137->Name;
  goto <bb 41>;

  <bb 40>:
  iftmp.1989_139 = "NULL";

  <bb 41>:
  # iftmp.1989_10 = PHI <iftmp.1989_138(39), iftmp.1989_139(40)>
  ImGui::Text ("NavWindow: \'%s\'", iftmp.1989_10);
  _141 = g_52->NavLayer;
  _142 = g_52->NavId;
  ImGui::Text ("NavId: 0x%08X, NavLayer: %d", _142, _141);
  _144 = g_52->NavInputSource;
  _145 = (int) _144;
  _146 = input_source_names[_145];
  ImGui::Text ("NavInputSource: %s", _146);
  _148 = g_52->IO.NavVisible;
  _149 = (int) _148;
  _150 = g_52->IO.NavActive;
  _151 = (int) _150;
  ImGui::Text ("NavActive: %d, NavVisible: %d", _151, _149);
  _153 = g_52->NavInputId;
  _154 = g_52->NavActivateId;
  ImGui::Text ("NavActivateId: 0x%08X, NavInputId: 0x%08X", _154, _153);
  _156 = g_52->NavDisableMouseHover;
  _157 = (int) _156;
  _158 = g_52->NavDisableHighlight;
  _159 = (int) _158;
  ImGui::Text ("NavDisableHighlight: %d, NavDisableMouseHover: %d", _159, _157);
  _161 = g_52->DragDropPayload.DataSize;
  _162 = &g_52->DragDropPayload.DataType;
  _163 = g_52->DragDropPayload.SourceId;
  _164 = g_52->DragDropActive;
  _165 = (int) _164;
  ImGui::Text ("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", _165, _163, _162, _161);
  ImGui::TreePop ();
  input_source_names ={v} {CLOBBER};

  <bb 42>:

  <bb 43>:
  ImGui::End ();
  return;

}



;; Function bool ImVector<T>::empty() const [with T = ImGuiTextFilter::TextRange] (_ZNK8ImVectorIN15ImGuiTextFilter9TextRangeEE5emptyEv, funcdef_no=1196, decl_uid=4260, cgraph_uid=1095, symbol_order=1107)

bool ImVector<T>::empty() const [with T = ImGuiTextFilter::TextRange] (const struct ImVector * const this)
{
  int D.23885;
  bool D.23884;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::ImVector() [with T = char] (_ZN8ImVectorIcEC2Ev, funcdef_no=1198, decl_uid=4481, cgraph_uid=1097, symbol_order=1109)

ImVector<T>::ImVector() [with T = char] (struct ImVector * const this)
{
  int D.25448;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = char] (_ZN8ImVectorIcED2Ev, funcdef_no=1201, decl_uid=4486, cgraph_uid=1100, symbol_order=1112)

ImVector<T>::~ImVector() [with T = char] (struct ImVector * const this)
{
  char * D.25464;
  char * D.25461;
  char * _4;
  char * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = char] (_ZN8ImVectorIcE9push_backERKc, funcdef_no=1203, decl_uid=4455, cgraph_uid=1102, symbol_order=1114)

void ImVector<T>::push_back(const value_type&) [with T = char] (struct ImVector * const this, const value_type & v)
{
  int D.27758;
  int D.27757;
  unsigned char D.27756;
  char * D.27755;
  sizetype D.27754;
  int D.27753;
  char * D.27752;
  int D.27750;
  int D.27749;
  int D.27748;
  int D.27745;
  int D.27744;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  char * _11;
  int _12;
  sizetype _13;
  char * _14;
  unsigned char _16;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<char>::_grow_capacity (this_3(D), _7);
  ImVector<char>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (sizetype) _12;
  _14 = _11 + _13;
  _16 = MEM[(char * {ref-all})v_15(D)];
  MEM[(char * {ref-all})_14] = _16;
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function const value_type& ImVector<T>::front() const [with T = char] (_ZNK8ImVectorIcE5frontEv, funcdef_no=1204, decl_uid=4433, cgraph_uid=1103, symbol_order=1115)

const value_type& ImVector<T>::front() const [with T = char] (const struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[93] = "const value_type& ImVector<T>::front() const [with T = char; ImVector<T>::value_type = char]";
  const value_type & D.35080;
  int D.35076;
  int _3;
  const value_type & _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1178, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;

<L3>:
  return _4;

}



;; Function void ImVector<T>::clear() [with T = char] (_ZN8ImVectorIcE5clearEv, funcdef_no=1206, decl_uid=4421, cgraph_uid=1105, symbol_order=1117)

void ImVector<T>::clear() [with T = char] (struct ImVector * const this)
{
  char * D.27985;
  int D.27984;
  char * D.27981;
  char * _4;
  int _6;
  char * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::reserve(int) [with T = char] (_ZN8ImVectorIcE7reserveEi, funcdef_no=1207, decl_uid=4452, cgraph_uid=1106, symbol_order=1118)

void ImVector<T>::reserve(int) [with T = char] (struct ImVector * const this, int new_capacity)
{
  value_type * D.23940;
  value_type * new_data;
  char * D.23938;
  char * D.23936;
  long unsigned int D.23935;
  int D.23934;
  char * D.23931;
  long unsigned int D.23930;
  int D.23927;
  int _5;
  long unsigned int _7;
  value_type * _9;
  char * _11;
  int _12;
  long unsigned int _13;
  char * _14;
  char * _16;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _9 = ImGui::MemAlloc (_7);
  new_data_10 = _9;
  _11 = this_4(D)->Data;
  if (_11 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _12 = this_4(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = this_4(D)->Data;
  memcpy (new_data_10, _14, _13);

  <bb 6>:
  _16 = this_4(D)->Data;
  ImGui::MemFree (_16);
  this_4(D)->Data = new_data_10;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEE5clearEv, funcdef_no=1208, decl_uid=4618, cgraph_uid=1107, symbol_order=1119)

void ImVector<T>::clear() [with T = ImGuiStorage::Pair] (struct ImVector * const this)
{
  struct Pair * D.27940;
  int D.27939;
  struct Pair * D.27936;
  struct Pair * _4;
  int _6;
  struct Pair * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImDrawCmd] (_ZN8ImVectorI9ImDrawCmdEC2Ev, funcdef_no=1210, decl_uid=5144, cgraph_uid=1109, symbol_order=1121)

ImVector<T>::ImVector() [with T = ImDrawCmd] (struct ImVector * const this)
{
  int D.24304;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImDrawCmd] (_ZN8ImVectorI9ImDrawCmdED2Ev, funcdef_no=1213, decl_uid=5149, cgraph_uid=1112, symbol_order=1124)

ImVector<T>::~ImVector() [with T = ImDrawCmd] (struct ImVector * const this)
{
  struct ImDrawCmd * D.24344;
  struct ImDrawCmd * D.24341;
  struct ImDrawCmd * _4;
  struct ImDrawCmd * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = short unsigned int] (_ZN8ImVectorItEC2Ev, funcdef_no=1216, decl_uid=5247, cgraph_uid=1115, symbol_order=1127)

ImVector<T>::ImVector() [with T = short unsigned int] (struct ImVector * const this)
{
  int D.24305;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = short unsigned int] (_ZN8ImVectorItED2Ev, funcdef_no=1219, decl_uid=5252, cgraph_uid=1118, symbol_order=1130)

ImVector<T>::~ImVector() [with T = short unsigned int] (struct ImVector * const this)
{
  short unsigned int * D.24339;
  short unsigned int * D.24336;
  short unsigned int * _4;
  short unsigned int * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImDrawVert] (_ZN8ImVectorI10ImDrawVertEC2Ev, funcdef_no=1222, decl_uid=5368, cgraph_uid=1121, symbol_order=1133)

ImVector<T>::ImVector() [with T = ImDrawVert] (struct ImVector * const this)
{
  int D.24306;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImDrawVert] (_ZN8ImVectorI10ImDrawVertED2Ev, funcdef_no=1225, decl_uid=5373, cgraph_uid=1124, symbol_order=1136)

ImVector<T>::~ImVector() [with T = ImDrawVert] (struct ImVector * const this)
{
  struct ImDrawVert * D.24334;
  struct ImDrawVert * D.24331;
  struct ImDrawVert * _4;
  struct ImDrawVert * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImVec4] (_ZN8ImVectorI6ImVec4EC2Ev, funcdef_no=1228, decl_uid=5477, cgraph_uid=1127, symbol_order=1139)

ImVector<T>::ImVector() [with T = ImVec4] (struct ImVector * const this)
{
  int D.24307;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImVec4] (_ZN8ImVectorI6ImVec4ED2Ev, funcdef_no=1231, decl_uid=5482, cgraph_uid=1130, symbol_order=1142)

ImVector<T>::~ImVector() [with T = ImVec4] (struct ImVector * const this)
{
  struct ImVec4 * D.24329;
  struct ImVec4 * D.24326;
  struct ImVec4 * _4;
  struct ImVec4 * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = void*] (_ZN8ImVectorIPvEC2Ev, funcdef_no=1234, decl_uid=5580, cgraph_uid=1133, symbol_order=1145)

ImVector<T>::ImVector() [with T = void*] (struct ImVector * const this)
{
  int D.24308;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = void*] (_ZN8ImVectorIPvED2Ev, funcdef_no=1237, decl_uid=5585, cgraph_uid=1136, symbol_order=1148)

ImVector<T>::~ImVector() [with T = void*] (struct ImVector * const this)
{
  void * * D.24324;
  void * * D.24321;
  void * * _4;
  void * * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImVec2] (_ZN8ImVectorI6ImVec2EC2Ev, funcdef_no=1240, decl_uid=5683, cgraph_uid=1139, symbol_order=1151)

ImVector<T>::ImVector() [with T = ImVec2] (struct ImVector * const this)
{
  int D.24309;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImVec2] (_ZN8ImVectorI6ImVec2ED2Ev, funcdef_no=1243, decl_uid=5688, cgraph_uid=1142, symbol_order=1154)

ImVector<T>::~ImVector() [with T = ImVec2] (struct ImVector * const this)
{
  struct ImVec2 * D.24319;
  struct ImVec2 * D.24316;
  struct ImVec2 * _4;
  struct ImVec2 * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImDrawChannel] (_ZN8ImVectorI13ImDrawChannelEC2Ev, funcdef_no=1246, decl_uid=5788, cgraph_uid=1145, symbol_order=1157)

ImVector<T>::ImVector() [with T = ImDrawChannel] (struct ImVector * const this)
{
  int D.24310;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImDrawChannel] (_ZN8ImVectorI13ImDrawChannelED2Ev, funcdef_no=1249, decl_uid=5793, cgraph_uid=1148, symbol_order=1160)

ImVector<T>::~ImVector() [with T = ImDrawChannel] (struct ImVector * const this)
{
  struct ImDrawChannel * D.24314;
  struct ImDrawChannel * D.24311;
  struct ImDrawChannel * _4;
  struct ImDrawChannel * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::resize(int) [with T = ImVec2] (_ZN8ImVectorI6ImVec2E6resizeEi, funcdef_no=1252, decl_uid=5647, cgraph_uid=1151, symbol_order=1163)

void ImVector<T>::resize(int) [with T = ImVec2] (struct ImVector * const this, int new_size)
{
  int D.29122;
  int D.29119;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImVec2>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImVec2>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImVec2] (_ZN8ImVectorI6ImVec2E9push_backERKS0_, funcdef_no=1253, decl_uid=5657, cgraph_uid=1152, symbol_order=1164)

void ImVector<T>::push_back(const value_type&) [with T = ImVec2] (struct ImVector * const this, const struct value_type & v)
{
  int D.29084;
  int D.29083;
  long unsigned int D.29082;
  struct ImVec2 * D.29081;
  long unsigned int D.29080;
  long unsigned int D.29079;
  int D.29078;
  struct ImVec2 * D.29077;
  int D.29075;
  int D.29074;
  int D.29073;
  int D.29070;
  int D.29069;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImVec2 * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImVec2 * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImVec2>::_grow_capacity (this_3(D), _7);
  ImVector<ImVec2>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::ImVector() [with T = unsigned char] (_ZN8ImVectorIhEC2Ev, funcdef_no=1256, decl_uid=6395, cgraph_uid=1155, symbol_order=1167)

ImVector<T>::ImVector() [with T = unsigned char] (struct ImVector * const this)
{
  int D.25441;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = unsigned char] (_ZN8ImVectorIhED2Ev, funcdef_no=1259, decl_uid=6400, cgraph_uid=1158, symbol_order=1170)

ImVector<T>::~ImVector() [with T = unsigned char] (struct ImVector * const this)
{
  unsigned char * D.25472;
  unsigned char * D.25469;
  unsigned char * _4;
  unsigned char * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::resize(int) [with T = unsigned char] (_ZN8ImVectorIhE6resizeEi, funcdef_no=1261, decl_uid=6359, cgraph_uid=1160, symbol_order=1172)

void ImVector<T>::resize(int) [with T = unsigned char] (struct ImVector * const this, int new_size)
{
  int D.44450;
  int D.44447;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<unsigned char>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<unsigned char>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function const value_type& ImVector<T>::operator[](int) const [with T = float] (_ZNK8ImVectorIfEixEi, funcdef_no=1264, decl_uid=6981, cgraph_uid=1163, symbol_order=1175)

const value_type& ImVector<T>::operator[](int) const [with T = float] (const struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[103] = "const value_type& ImVector<T>::operator[](int) const [with T = float; ImVector<T>::value_type = float]";
  long unsigned int D.37435;
  long unsigned int D.37434;
  float * D.37433;
  const value_type & D.37432;
  int D.37428;
  int _3;
  float * _5;
  long unsigned int _6;
  long unsigned int _7;
  const value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1170, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 4;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataEC2Ev, funcdef_no=1266, decl_uid=11478, cgraph_uid=1165, symbol_order=1177)

ImVector<T>::ImVector() [with T = ImGuiColumnData] (struct ImVector * const this)
{
  int D.43845;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataED2Ev, funcdef_no=1269, decl_uid=11483, cgraph_uid=1168, symbol_order=1180)

ImVector<T>::~ImVector() [with T = ImGuiColumnData] (struct ImVector * const this)
{
  struct ImGuiColumnData * D.24432;
  struct ImGuiColumnData * D.24429;
  struct ImGuiColumnData * _4;
  struct ImGuiColumnData * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataE5clearEv, funcdef_no=1271, decl_uid=11418, cgraph_uid=1170, symbol_order=1182)

void ImVector<T>::clear() [with T = ImGuiColumnData] (struct ImVector * const this)
{
  struct ImGuiColumnData * D.43853;
  int D.43852;
  struct ImGuiColumnData * D.43849;
  struct ImGuiColumnData * _4;
  int _6;
  struct ImGuiColumnData * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::resize(int) [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListE6resizeEi, funcdef_no=1272, decl_uid=11591, cgraph_uid=1171, symbol_order=1183)

void ImVector<T>::resize(int) [with T = ImDrawList*] (struct ImVector * const this, int new_size)
{
  int D.28451;
  int D.28448;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImDrawList*>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImDrawList*>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::clear() [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListE5clearEv, funcdef_no=1273, decl_uid=11567, cgraph_uid=1172, symbol_order=1184)

void ImVector<T>::clear() [with T = ImDrawList*] (struct ImVector * const this)
{
  struct ImDrawList * * D.27973;
  int D.27972;
  struct ImDrawList * * D.27969;
  struct ImDrawList * * _4;
  int _6;
  struct ImDrawList * * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowEC2Ev, funcdef_no=1275, decl_uid=11845, cgraph_uid=1174, symbol_order=1186)

ImVector<T>::ImVector() [with T = ImGuiWindow*] (struct ImVector * const this)
{
  int D.24226;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowED2Ev, funcdef_no=1278, decl_uid=11850, cgraph_uid=1177, symbol_order=1189)

ImVector<T>::~ImVector() [with T = ImGuiWindow*] (struct ImVector * const this)
{
  struct ImGuiWindow * * D.24387;
  struct ImGuiWindow * * D.24384;
  struct ImGuiWindow * * _4;
  struct ImGuiWindow * * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEEC2Ev, funcdef_no=1281, decl_uid=4678, cgraph_uid=1180, symbol_order=1192)

ImVector<T>::ImVector() [with T = ImGuiStorage::Pair] (struct ImVector * const this)
{
  int D.24233;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEED2Ev, funcdef_no=1284, decl_uid=4683, cgraph_uid=1183, symbol_order=1195)

ImVector<T>::~ImVector() [with T = ImGuiStorage::Pair] (struct ImVector * const this)
{
  struct Pair * D.24357;
  struct Pair * D.24354;
  struct Pair * _4;
  struct Pair * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModEC2Ev, funcdef_no=1287, decl_uid=11970, cgraph_uid=1186, symbol_order=1198)

ImVector<T>::ImVector() [with T = ImGuiColMod] (struct ImVector * const this)
{
  int D.25387;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModED2Ev, funcdef_no=1290, decl_uid=11975, cgraph_uid=1189, symbol_order=1201)

ImVector<T>::~ImVector() [with T = ImGuiColMod] (struct ImVector * const this)
{
  struct ImGuiColMod * D.25506;
  struct ImGuiColMod * D.25503;
  struct ImGuiColMod * _4;
  struct ImGuiColMod * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModEC2Ev, funcdef_no=1293, decl_uid=12073, cgraph_uid=1192, symbol_order=1204)

ImVector<T>::ImVector() [with T = ImGuiStyleMod] (struct ImVector * const this)
{
  int D.25388;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModED2Ev, funcdef_no=1296, decl_uid=12078, cgraph_uid=1195, symbol_order=1207)

ImVector<T>::~ImVector() [with T = ImGuiStyleMod] (struct ImVector * const this)
{
  struct ImGuiStyleMod * D.25501;
  struct ImGuiStyleMod * D.25498;
  struct ImGuiStyleMod * _4;
  struct ImGuiStyleMod * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImFont*] (_ZN8ImVectorIP6ImFontEC2Ev, funcdef_no=1299, decl_uid=6588, cgraph_uid=1198, symbol_order=1210)

ImVector<T>::ImVector() [with T = ImFont*] (struct ImVector * const this)
{
  int D.25389;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImFont*] (_ZN8ImVectorIP6ImFontED2Ev, funcdef_no=1302, decl_uid=6593, cgraph_uid=1201, symbol_order=1213)

ImVector<T>::~ImVector() [with T = ImFont*] (struct ImVector * const this)
{
  struct ImFont * * D.25496;
  struct ImFont * * D.25493;
  struct ImFont * * _4;
  struct ImFont * * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefEC2Ev, funcdef_no=1305, decl_uid=12177, cgraph_uid=1204, symbol_order=1216)

ImVector<T>::ImVector() [with T = ImGuiPopupRef] (struct ImVector * const this)
{
  int D.25390;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefED2Ev, funcdef_no=1308, decl_uid=12182, cgraph_uid=1207, symbol_order=1219)

ImVector<T>::~ImVector() [with T = ImGuiPopupRef] (struct ImVector * const this)
{
  struct ImGuiPopupRef * D.25491;
  struct ImGuiPopupRef * D.25488;
  struct ImGuiPopupRef * _4;
  struct ImGuiPopupRef * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListEC2Ev, funcdef_no=1311, decl_uid=11627, cgraph_uid=1210, symbol_order=1222)

ImVector<T>::ImVector() [with T = ImDrawList*] (struct ImVector * const this)
{
  int D.25437;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListED2Ev, funcdef_no=1314, decl_uid=11632, cgraph_uid=1213, symbol_order=1225)

ImVector<T>::~ImVector() [with T = ImDrawList*] (struct ImVector * const this)
{
  struct ImDrawList * * D.25486;
  struct ImDrawList * * D.25483;
  struct ImDrawList * * _4;
  struct ImDrawList * * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsEC2Ev, funcdef_no=1317, decl_uid=12352, cgraph_uid=1216, symbol_order=1228)

ImVector<T>::ImVector() [with T = ImGuiWindowSettings] (struct ImVector * const this)
{
  int D.25449;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsED2Ev, funcdef_no=1320, decl_uid=12357, cgraph_uid=1219, symbol_order=1231)

ImVector<T>::~ImVector() [with T = ImGuiWindowSettings] (struct ImVector * const this)
{
  struct ImGuiWindowSettings * D.25459;
  struct ImGuiWindowSettings * D.25456;
  struct ImGuiWindowSettings * _4;
  struct ImGuiWindowSettings * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerEC2Ev, funcdef_no=1323, decl_uid=12455, cgraph_uid=1222, symbol_order=1234)

ImVector<T>::ImVector() [with T = ImGuiSettingsHandler] (struct ImVector * const this)
{
  int D.25450;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerED2Ev, funcdef_no=1326, decl_uid=12460, cgraph_uid=1225, symbol_order=1237)

ImVector<T>::~ImVector() [with T = ImGuiSettingsHandler] (struct ImVector * const this)
{
  struct ImGuiSettingsHandler * D.25454;
  struct ImGuiSettingsHandler * D.25451;
  struct ImGuiSettingsHandler * _4;
  struct ImGuiSettingsHandler * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = int] (_ZN8ImVectorIiEC2Ev, funcdef_no=1329, decl_uid=13123, cgraph_uid=1228, symbol_order=1240)

ImVector<T>::ImVector() [with T = int] (struct ImVector * const this)
{
  int D.24227;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = int] (_ZN8ImVectorIiED2Ev, funcdef_no=1332, decl_uid=13128, cgraph_uid=1231, symbol_order=1243)

ImVector<T>::~ImVector() [with T = int] (struct ImVector * const this)
{
  int * D.24382;
  int * D.24379;
  int * _4;
  int * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = float] (_ZN8ImVectorIfEC2Ev, funcdef_no=1335, decl_uid=7044, cgraph_uid=1234, symbol_order=1246)

ImVector<T>::ImVector() [with T = float] (struct ImVector * const this)
{
  int D.24228;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = float] (_ZN8ImVectorIfED2Ev, funcdef_no=1338, decl_uid=7049, cgraph_uid=1237, symbol_order=1249)

ImVector<T>::~ImVector() [with T = float] (struct ImVector * const this)
{
  float * D.24377;
  float * D.24374;
  float * _4;
  float * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiGroupData] (_ZN8ImVectorI14ImGuiGroupDataEC2Ev, funcdef_no=1341, decl_uid=13228, cgraph_uid=1240, symbol_order=1252)

ImVector<T>::ImVector() [with T = ImGuiGroupData] (struct ImVector * const this)
{
  int D.24229;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiGroupData] (_ZN8ImVectorI14ImGuiGroupDataED2Ev, funcdef_no=1344, decl_uid=13233, cgraph_uid=1243, symbol_order=1255)

ImVector<T>::~ImVector() [with T = ImGuiGroupData] (struct ImVector * const this)
{
  struct ImGuiGroupData * D.24372;
  struct ImGuiGroupData * D.24369;
  struct ImGuiGroupData * _4;
  struct ImGuiGroupData * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::begin() [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEE5beginEv, funcdef_no=1346, decl_uid=4620, cgraph_uid=1245, symbol_order=1257)

ImVector<T>::value_type* ImVector<T>::begin() [with T = ImGuiStorage::Pair] (struct ImVector * const this)
{
  struct value_type * D.23378;
  struct value_type * _3;

  <bb 2>:
  _3 = this_2(D)->Data;

<L0>:
  return _3;

}



;; Function ImVector<T>::value_type* ImVector<T>::end() [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEE3endEv, funcdef_no=1347, decl_uid=4624, cgraph_uid=1246, symbol_order=1258)

ImVector<T>::value_type* ImVector<T>::end() [with T = ImGuiStorage::Pair] (struct ImVector * const this)
{
  long unsigned int D.23384;
  long unsigned int D.23383;
  int D.23382;
  struct Pair * D.23381;
  struct value_type * D.23380;
  struct Pair * _3;
  int _4;
  long unsigned int _5;
  long unsigned int _6;
  struct value_type * _7;

  <bb 2>:
  _3 = this_2(D)->Data;
  _4 = this_2(D)->Size;
  _5 = (long unsigned int) _4;
  _6 = _5 * 16;
  _7 = _3 + _6;

<L0>:
  return _7;

}



;; Function const value_type* ImVector<T>::end() const [with T = ImGuiStorage::Pair] (_ZNK8ImVectorIN12ImGuiStorage4PairEE3endEv, funcdef_no=1348, decl_uid=4626, cgraph_uid=1247, symbol_order=1259)

const value_type* ImVector<T>::end() const [with T = ImGuiStorage::Pair] (const struct ImVector * const this)
{
  long unsigned int D.23422;
  long unsigned int D.23421;
  int D.23420;
  struct Pair * D.23419;
  const struct value_type * D.23418;
  struct Pair * _3;
  int _4;
  long unsigned int _5;
  long unsigned int _6;
  const struct value_type * _7;

  <bb 2>:
  _3 = this_2(D)->Data;
  _4 = this_2(D)->Size;
  _5 = (long unsigned int) _4;
  _6 = _5 * 16;
  _7 = _3 + _6;

<L0>:
  return _7;

}



;; Function ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEE6insertEPKS1_RS3_, funcdef_no=1349, decl_uid=4663, cgraph_uid=1248, symbol_order=1260)

ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiStorage::Pair] (struct ImVector * const this, const struct value_type * it, const struct value_type & v)
{
  const ptrdiff_t off;
  static const char __PRETTY_FUNCTION__[271] = "ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiStorage::Pair; ImVector<T>::iterator = ImGuiStorage::Pair*; ImVector<T>::value_type = ImGuiStorage::Pair; ImVector<T>::const_iterator = const ImGuiStorage::Pair*]";
  long unsigned int D.23532;
  long unsigned int off.103;
  struct Pair * D.23530;
  struct value_type * D.23529;
  int D.23528;
  int D.23527;
  __int128 unsigned D.23526;
  struct Pair * D.23525;
  long unsigned int D.23524;
  long unsigned int off.102;
  struct Pair * D.23522;
  struct Pair * D.23520;
  sizetype D.23519;
  sizetype D.23518;
  sizetype off.101;
  struct Pair * D.23516;
  struct Pair * D.23515;
  long unsigned int D.23514;
  long unsigned int off.100;
  struct Pair * D.23512;
  long unsigned int D.23511;
  long unsigned int D.23510;
  long unsigned int off.99;
  long unsigned int D.23508;
  int D.23507;
  long int D.23504;
  int D.23503;
  int D.23501;
  int D.23500;
  int D.23499;
  int D.23496;
  int D.23495;
  long int D.23494;
  long int D.23493;
  struct Pair * D.23492;
  long int it.98;
  struct Pair * D.23489;
  long unsigned int D.23488;
  long unsigned int D.23487;
  int D.23486;
  struct Pair * D.23485;
  struct Pair * D.23483;
  struct Pair * _5;
  struct Pair * _7;
  int _8;
  long unsigned int _9;
  long unsigned int _10;
  struct Pair * _11;
  long int it.98_12;
  struct Pair * _13;
  long int _14;
  long int _15;
  int _17;
  int _18;
  int _19;
  int _20;
  int _22;
  int _24;
  long int _25;
  int _26;
  long unsigned int _27;
  long unsigned int off.99_28;
  long unsigned int _29;
  long unsigned int _30;
  struct Pair * _31;
  long unsigned int off.100_32;
  long unsigned int _33;
  struct Pair * _34;
  struct Pair * _35;
  sizetype off.101_36;
  sizetype _37;
  sizetype _38;
  struct Pair * _39;
  struct Pair * _41;
  long unsigned int off.102_42;
  long unsigned int _43;
  struct Pair * _44;
  __int128 unsigned _46;
  int _48;
  int _49;
  struct Pair * _51;
  long unsigned int off.103_52;
  long unsigned int _53;
  struct value_type * _54;

  <bb 2>:
  _5 = this_4(D)->Data;
  if (_5 <= it_6(D))
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = this_4(D)->Data;
  _8 = this_4(D)->Size;
  _9 = (long unsigned int) _8;
  _10 = _9 * 16;
  _11 = _7 + _10;
  if (_11 >= it_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("it >= Data && it <= Data+Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1203, &__PRETTY_FUNCTION__);

  <bb 6>:
  it.98_12 = (long int) it_6(D);
  _13 = this_4(D)->Data;
  _14 = (long int) _13;
  _15 = it.98_12 - _14;
  off_16 = _15 /[ex] 16;
  _17 = this_4(D)->Size;
  _18 = this_4(D)->Capacity;
  if (_17 == _18)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _19 = this_4(D)->Size;
  _20 = _19 + 1;
  _22 = ImVector<ImGuiStorage::Pair>::_grow_capacity (this_4(D), _20);
  ImVector<ImGuiStorage::Pair>::reserve (this_4(D), _22);

  <bb 8>:
  _24 = this_4(D)->Size;
  _25 = (long int) _24;
  if (_25 > off_16)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _26 = this_4(D)->Size;
  _27 = (long unsigned int) _26;
  off.99_28 = (long unsigned int) off_16;
  _29 = _27 - off.99_28;
  _30 = _29 * 16;
  _31 = this_4(D)->Data;
  off.100_32 = (long unsigned int) off_16;
  _33 = off.100_32 * 16;
  _34 = _31 + _33;
  _35 = this_4(D)->Data;
  off.101_36 = (sizetype) off_16;
  _37 = off.101_36 + 1;
  _38 = _37 * 16;
  _39 = _35 + _38;
  memmove (_39, _34, _30);

  <bb 10>:
  _41 = this_4(D)->Data;
  off.102_42 = (long unsigned int) off_16;
  _43 = off.102_42 * 16;
  _44 = _41 + _43;
  _46 = MEM[(char * {ref-all})v_45(D)];
  MEM[(char * {ref-all})_44] = _46;
  _48 = this_4(D)->Size;
  _49 = _48 + 1;
  this_4(D)->Size = _49;
  _51 = this_4(D)->Data;
  off.103_52 = (long unsigned int) off_16;
  _53 = off.103_52 * 16;
  _54 = _51 + _53;

<L10>:
  return _54;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEEixEi, funcdef_no=1350, decl_uid=4612, cgraph_uid=1249, symbol_order=1261)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiStorage::Pair] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[130] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiStorage::Pair; ImVector<T>::value_type = ImGuiStorage::Pair]";
  long unsigned int D.23673;
  long unsigned int D.23672;
  struct Pair * D.23671;
  struct value_type & D.23670;
  int D.23666;
  int _3;
  struct Pair * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 16;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEEC2Ev, funcdef_no=1352, decl_uid=4332, cgraph_uid=1251, symbol_order=1263)

ImVector<T>::ImVector() [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this)
{
  int D.23682;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEED2Ev, funcdef_no=1355, decl_uid=4337, cgraph_uid=1254, symbol_order=1266)

ImVector<T>::~ImVector() [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this)
{
  struct TextRange * D.23686;
  struct TextRange * D.23683;
  struct TextRange * _4;
  struct TextRange * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::resize(int) [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEE6resizeEi, funcdef_no=1357, decl_uid=4296, cgraph_uid=1256, symbol_order=1268)

void ImVector<T>::resize(int) [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this, int new_size)
{
  int D.23716;
  int D.23713;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImGuiTextFilter::TextRange>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImGuiTextFilter::TextRange>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEE9push_backERKS1_, funcdef_no=1358, decl_uid=4306, cgraph_uid=1257, symbol_order=1269)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this, const struct value_type & v)
{
  int D.23763;
  int D.23762;
  __int128 unsigned D.23761;
  struct TextRange * D.23760;
  long unsigned int D.23759;
  long unsigned int D.23758;
  int D.23757;
  struct TextRange * D.23756;
  int D.23754;
  int D.23753;
  int D.23752;
  int D.23749;
  int D.23748;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct TextRange * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct TextRange * _15;
  __int128 unsigned _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiTextFilter::TextRange>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiTextFilter::TextRange>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 16;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEEixEi, funcdef_no=1359, decl_uid=4266, cgraph_uid=1258, symbol_order=1270)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[146] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiTextFilter::TextRange; ImVector<T>::value_type = ImGuiTextFilter::TextRange]";
  long unsigned int D.23842;
  long unsigned int D.23841;
  struct TextRange * D.23840;
  struct value_type & D.23839;
  int D.23835;
  int _3;
  struct TextRange * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 16;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function const value_type& ImVector<T>::operator[](int) const [with T = ImGuiTextFilter::TextRange] (_ZNK8ImVectorIN15ImGuiTextFilter9TextRangeEEixEi, funcdef_no=1360, decl_uid=4269, cgraph_uid=1259, symbol_order=1271)

const value_type& ImVector<T>::operator[](int) const [with T = ImGuiTextFilter::TextRange] (const struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[145] = "const value_type& ImVector<T>::operator[](int) const [with T = ImGuiTextFilter::TextRange; ImVector<T>::value_type = ImGuiTextFilter::TextRange]";
  long unsigned int D.23894;
  long unsigned int D.23893;
  struct TextRange * D.23892;
  const struct value_type & D.23891;
  int D.23887;
  int _3;
  struct TextRange * _5;
  long unsigned int _6;
  long unsigned int _7;
  const struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1170, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 16;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::resize(int) [with T = char] (_ZN8ImVectorIcE6resizeEi, funcdef_no=1361, decl_uid=4445, cgraph_uid=1260, symbol_order=1272)

void ImVector<T>::resize(int) [with T = char] (struct ImVector * const this, int new_size)
{
  int D.23944;
  int D.23941;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<char>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<char>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = char] (_ZN8ImVectorIcEixEi, funcdef_no=1362, decl_uid=4415, cgraph_uid=1261, symbol_order=1273)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = char] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[102] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = char; ImVector<T>::value_type = char]";
  sizetype D.23966;
  char * D.23965;
  value_type & D.23964;
  int D.23960;
  int _3;
  char * _5;
  sizetype _6;
  value_type & _7;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (sizetype) i_4(D);
  _7 = _5 + _6;

<L3>:
  return _7;

}



;; Function ImVector<T>::ImVector() [with T = unsigned int] (_ZN8ImVectorIjEC2Ev, funcdef_no=1364, decl_uid=13435, cgraph_uid=1263, symbol_order=1275)

ImVector<T>::ImVector() [with T = unsigned int] (struct ImVector * const this)
{
  int D.24230;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = unsigned int] (_ZN8ImVectorIjED2Ev, funcdef_no=1367, decl_uid=13440, cgraph_uid=1266, symbol_order=1278)

ImVector<T>::~ImVector() [with T = unsigned int] (struct ImVector * const this)
{
  unsigned int * D.24362;
  unsigned int * D.24359;
  unsigned int * _4;
  unsigned int * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function ImVector<T>::ImVector() [with T = ImGuiColumnsSet] (_ZN8ImVectorI15ImGuiColumnsSetEC2Ev, funcdef_no=1370, decl_uid=13546, cgraph_uid=1269, symbol_order=1281)

ImVector<T>::ImVector() [with T = ImGuiColumnsSet] (struct ImVector * const this)
{
  int D.24234;
  int _5;

  <bb 2>:
  MEM[(struct  &)this_2(D)] ={v} {CLOBBER};
  this_2(D)->Capacity = 0;
  _5 = this_2(D)->Capacity;
  this_2(D)->Size = _5;
  this_2(D)->Data = 0B;
  return;

}



;; Function ImVector<T>::~ImVector() [with T = ImGuiColumnsSet] (_ZN8ImVectorI15ImGuiColumnsSetED2Ev, funcdef_no=1373, decl_uid=13551, cgraph_uid=1272, symbol_order=1284)

ImVector<T>::~ImVector() [with T = ImGuiColumnsSet] (struct ImVector * const this)
{
  struct ImGuiColumnsSet * D.24351;
  struct ImGuiColumnsSet * D.24348;
  struct ImGuiColumnsSet * _4;
  struct ImGuiColumnsSet * _5;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = this_3(D)->Data;
  ImGui::MemFree (_5);

  <bb 4>:
  MEM[(struct  &)this_3(D)] ={v} {CLOBBER};
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = unsigned int] (_ZN8ImVectorIjE9push_backERKj, funcdef_no=1375, decl_uid=13409, cgraph_uid=1274, symbol_order=1286)

void ImVector<T>::push_back(const value_type&) [with T = unsigned int] (struct ImVector * const this, const value_type & v)
{
  int D.24250;
  int D.24249;
  unsigned int D.24248;
  unsigned int * D.24247;
  long unsigned int D.24246;
  long unsigned int D.24245;
  int D.24244;
  unsigned int * D.24243;
  int D.24241;
  int D.24240;
  int D.24239;
  int D.24236;
  int D.24235;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  unsigned int * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  unsigned int * _15;
  unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<unsigned int>::_grow_capacity (this_3(D), _7);
  ImVector<unsigned int>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 4;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function void IM_DELETE(T*&) [with T = ImDrawList] (_Z9IM_DELETEI10ImDrawListEvRPT_, funcdef_no=1376, decl_uid=15946, cgraph_uid=1275, symbol_order=1287)

void IM_DELETE(T*&) [with T = ImDrawList] (struct ImDrawList * & p)
{
  struct ImDrawList * D.24404;
  struct ImDrawList * D.24403;
  struct ImDrawList * D.24400;
  struct ImDrawList * _4;
  struct ImDrawList * _5;
  struct ImDrawList * _7;

  <bb 2>:
  _4 = *p_3(D);
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = *p_3(D);
  ImDrawList::~ImDrawList (_5);
  _7 = *p_3(D);
  ImGui::MemFree (_7);
  *p_3(D) = 0B;

  <bb 4>:
  return;

}



;; Function void IM_DELETE(T*&) [with T = char] (_Z9IM_DELETEIcEvRPT_, funcdef_no=1377, decl_uid=15948, cgraph_uid=1276, symbol_order=1288)

void IM_DELETE(T*&) [with T = char] (char * & p)
{
  char * D.24417;
  char * D.24416;
  char * D.24413;
  char * _4;
  char * _5;
  char * _6;

  <bb 2>:
  _4 = *p_3(D);
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = *p_3(D);
  _6 = *p_3(D);
  ImGui::MemFree (_6);
  *p_3(D) = 0B;

  <bb 4>:
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiColumnsSet] (_ZN8ImVectorI15ImGuiColumnsSetEixEi, funcdef_no=1378, decl_uid=13480, cgraph_uid=1277, symbol_order=1289)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiColumnsSet] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[124] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiColumnsSet; ImVector<T>::value_type = ImGuiColumnsSet]";
  long unsigned int D.24426;
  long unsigned int D.24425;
  struct ImGuiColumnsSet * D.24424;
  struct value_type & D.24423;
  int D.24419;
  int _3;
  struct ImGuiColumnsSet * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 64;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = unsigned int] (_ZN8ImVectorIjE4backEv, funcdef_no=1379, decl_uid=13389, cgraph_uid=1278, symbol_order=1290)

ImVector<T>::value_type& ImVector<T>::back() [with T = unsigned int] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[109] = "ImVector<T>::value_type& ImVector<T>::back() [with T = unsigned int; ImVector<T>::value_type = unsigned int]";
  sizetype D.24454;
  long unsigned int D.24453;
  long unsigned int D.24452;
  int D.24451;
  unsigned int * D.24450;
  value_type & D.24449;
  int D.24445;
  int _3;
  unsigned int * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 4;
  _8 = _7 + 18446744073709551612;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function ImGuiContext::~ImGuiContext() (_ZN12ImGuiContextD2Ev, funcdef_no=1382, decl_uid=22141, cgraph_uid=1280, symbol_order=1292)

ImGuiContext::~ImGuiContext() (struct ImGuiContext * const this)
{
  struct ImVector * D.25542;
  struct ImVector * D.25541;
  struct ImVector * D.25540;
  struct ImGuiStorage * D.25539;
  struct ImVector * D.25538;
  struct ImVector * D.25537;
  struct ImVector * D.25536;
  struct ImVector * D.25535;
  struct ImVector * D.25534;
  struct ImDrawData * D.25533;
  struct ImDrawDataBuilder * D.25532;
  struct ImDrawList * D.25531;
  struct ImVector * D.25530;
  struct ImGuiTextEditState * D.25529;
  struct ImFont * D.25528;
  struct ImVector * D.25527;
  struct ImVector * D.25526;
  struct ImVector * D.25525;
  struct ImVector * _2;
  struct ImVector * _5;
  struct ImVector * _7;
  struct ImFont * _9;
  struct ImGuiTextEditState * _11;
  struct ImVector * _13;
  struct ImDrawList * _15;
  struct ImDrawDataBuilder * _17;
  struct ImDrawData * _19;
  struct ImVector * _21;
  struct ImVector * _23;
  struct ImVector * _25;
  struct ImVector * _27;
  struct ImVector * _29;
  struct ImGuiStorage * _31;
  struct ImVector * _33;
  struct ImVector * _35;
  struct ImVector * _37;

  <bb 2>:
  _2 = &this_1(D)->SettingsHandlers;
  ImVector<ImGuiSettingsHandler>::~ImVector (_2);
  _5 = &this_1(D)->SettingsWindows;
  ImVector<ImGuiWindowSettings>::~ImVector (_5);
  _7 = &this_1(D)->PrivateClipboard;
  ImVector<char>::~ImVector (_7);
  _9 = &this_1(D)->InputTextPasswordFont;
  ImFont::~ImFont (_9);
  _11 = &this_1(D)->InputTextState;
  ImGuiTextEditState::~ImGuiTextEditState (_11);
  _13 = &this_1(D)->DragDropPayloadBufHeap;
  ImVector<unsigned char>::~ImVector (_13);
  _15 = &this_1(D)->OverlayDrawList;
  ImDrawList::~ImDrawList (_15);
  _17 = &this_1(D)->DrawDataBuilder;
  ImDrawDataBuilder::~ImDrawDataBuilder (_17);
  _19 = &this_1(D)->DrawData;
  ImDrawData::~ImDrawData (_19);
  _21 = &this_1(D)->CurrentPopupStack;
  ImVector<ImGuiPopupRef>::~ImVector (_21);
  _23 = &this_1(D)->OpenPopupStack;
  ImVector<ImGuiPopupRef>::~ImVector (_23);
  _25 = &this_1(D)->FontStack;
  ImVector<ImFont*>::~ImVector (_25);
  _27 = &this_1(D)->StyleModifiers;
  ImVector<ImGuiStyleMod>::~ImVector (_27);
  _29 = &this_1(D)->ColorModifiers;
  ImVector<ImGuiColMod>::~ImVector (_29);
  _31 = &this_1(D)->WindowsById;
  ImGuiStorage::~ImGuiStorage (_31);
  _33 = &this_1(D)->CurrentWindowStack;
  ImVector<ImGuiWindow*>::~ImVector (_33);
  _35 = &this_1(D)->WindowsSortBuffer;
  ImVector<ImGuiWindow*>::~ImVector (_35);
  _37 = &this_1(D)->Windows;
  ImVector<ImGuiWindow*>::~ImVector (_37);
  MEM[(struct  &)this_1(D)] ={v} {CLOBBER};
  return;

}



;; Function void IM_DELETE(T*&) [with T = ImGuiContext] (_Z9IM_DELETEI12ImGuiContextEvRPT_, funcdef_no=1380, decl_uid=16243, cgraph_uid=1282, symbol_order=1294)

void IM_DELETE(T*&) [with T = ImGuiContext] (struct ImGuiContext * & p)
{
  struct ImGuiContext * D.25523;
  struct ImGuiContext * D.25522;
  struct ImGuiContext * D.25519;
  struct ImGuiContext * _4;
  struct ImGuiContext * _5;
  struct ImGuiContext * _7;

  <bb 2>:
  _4 = *p_3(D);
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = *p_3(D);
  ImGuiContext::~ImGuiContext (_5);
  _7 = *p_3(D);
  ImGui::MemFree (_7);
  *p_3(D) = 0B;

  <bb 4>:
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowEixEi, funcdef_no=1384, decl_uid=11779, cgraph_uid=1283, symbol_order=1295)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiWindow*] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[118] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiWindow*; ImVector<T>::value_type = ImGuiWindow*]";
  long unsigned int D.25657;
  long unsigned int D.25656;
  struct ImGuiWindow * * D.25655;
  struct ImGuiWindow * & D.25654;
  int D.25650;
  int _3;
  struct ImGuiWindow * * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct ImGuiWindow * & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefE4backEv, funcdef_no=1385, decl_uid=12131, cgraph_uid=1284, symbol_order=1296)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiPopupRef] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[111] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiPopupRef; ImVector<T>::value_type = ImGuiPopupRef]";
  sizetype D.26807;
  long unsigned int D.26806;
  long unsigned int D.26805;
  int D.26804;
  struct ImGuiPopupRef * D.26803;
  struct value_type & D.26802;
  int D.26798;
  int _3;
  struct ImGuiPopupRef * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 48;
  _8 = _7 + 18446744073709551568;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function bool ImVector<T>::empty() const [with T = ImGuiPopupRef] (_ZNK8ImVectorI13ImGuiPopupRefE5emptyEv, funcdef_no=1386, decl_uid=12105, cgraph_uid=1285, symbol_order=1297)

bool ImVector<T>::empty() const [with T = ImGuiPopupRef] (const struct ImVector * const this)
{
  int D.27153;
  bool D.27152;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImFont*] (_ZN8ImVectorIP6ImFontEixEi, funcdef_no=1387, decl_uid=6522, cgraph_uid=1286, symbol_order=1298)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImFont*] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[108] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImFont*; ImVector<T>::value_type = ImFont*]";
  long unsigned int D.27534;
  long unsigned int D.27533;
  struct ImFont * * D.27532;
  struct ImFont * & D.27531;
  int D.27527;
  int _3;
  struct ImFont * * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct ImFont * & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function bool ImVector<T>::empty() const [with T = ImGuiWindowSettings] (_ZNK8ImVectorI19ImGuiWindowSettingsE5emptyEv, funcdef_no=1388, decl_uid=12280, cgraph_uid=1287, symbol_order=1299)

bool ImVector<T>::empty() const [with T = ImGuiWindowSettings] (const struct ImVector * const this)
{
  int D.27537;
  bool D.27536;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function void ImVector<T>::clear() [with T = unsigned char] (_ZN8ImVectorIhE5clearEv, funcdef_no=1389, decl_uid=6335, cgraph_uid=1288, symbol_order=1300)

void ImVector<T>::clear() [with T = unsigned char] (struct ImVector * const this)
{
  unsigned char * D.27546;
  int D.27545;
  unsigned char * D.27542;
  unsigned char * _4;
  int _6;
  unsigned char * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::resize(int) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE6resizeEi, funcdef_no=1390, decl_uid=11809, cgraph_uid=1289, symbol_order=1301)

void ImVector<T>::resize(int) [with T = ImGuiWindow*] (struct ImVector * const this, int new_size)
{
  int D.27569;
  int D.27566;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImGuiWindow*>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImGuiWindow*>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::resize(int) [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefE6resizeEi, funcdef_no=1391, decl_uid=12141, cgraph_uid=1290, symbol_order=1302)

void ImVector<T>::resize(int) [with T = ImGuiPopupRef] (struct ImVector * const this, int new_size)
{
  int D.27604;
  int D.27601;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImGuiPopupRef>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImGuiPopupRef>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsEixEi, funcdef_no=1392, decl_uid=12286, cgraph_uid=1291, symbol_order=1303)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiWindowSettings] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[132] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiWindowSettings; ImVector<T>::value_type = ImGuiWindowSettings]";
  long unsigned int D.27720;
  long unsigned int D.27719;
  struct ImGuiWindowSettings * D.27718;
  struct value_type & D.27717;
  int D.27713;
  int _3;
  struct ImGuiWindowSettings * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 32;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::push_front(const value_type&) [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerE10push_frontERKS0_, funcdef_no=1393, decl_uid=12434, cgraph_uid=1292, symbol_order=1304)

void ImVector<T>::push_front(const value_type&) [with T = ImGuiSettingsHandler] (struct ImVector * const this, const struct value_type & v)
{
  struct ImGuiSettingsHandler * D.27763;
  int D.27759;
  int _4;
  struct ImGuiSettingsHandler * _7;

  <bb 2>:
  _4 = this_3(D)->Size;
  if (_4 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  ImVector<ImGuiSettingsHandler>::push_back (this_3(D), v_5(D));
  goto <bb 5>;

  <bb 4>:
  _7 = this_3(D)->Data;
  ImVector<ImGuiSettingsHandler>::insert (this_3(D), _7, v_5(D));

  <bb 5>:
  return;

}



;; Function void IM_DELETE(T*&) [with T = ImFontAtlas] (_Z9IM_DELETEI11ImFontAtlasEvRPT_, funcdef_no=1394, decl_uid=16566, cgraph_uid=1293, symbol_order=1305)

void IM_DELETE(T*&) [with T = ImFontAtlas] (struct ImFontAtlas * & p)
{
  struct ImFontAtlas * D.27921;
  struct ImFontAtlas * D.27920;
  struct ImFontAtlas * D.27917;
  struct ImFontAtlas * _4;
  struct ImFontAtlas * _5;
  struct ImFontAtlas * _7;

  <bb 2>:
  _4 = *p_3(D);
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = *p_3(D);
  ImFontAtlas::~ImFontAtlas (_5);
  _7 = *p_3(D);
  ImGui::MemFree (_7);
  *p_3(D) = 0B;

  <bb 4>:
  return;

}



;; Function void IM_DELETE(T*&) [with T = ImGuiWindow] (_Z9IM_DELETEI11ImGuiWindowEvRPT_, funcdef_no=1395, decl_uid=16569, cgraph_uid=1294, symbol_order=1306)

void IM_DELETE(T*&) [with T = ImGuiWindow] (struct ImGuiWindow * & p)
{
  struct ImGuiWindow * D.27927;
  struct ImGuiWindow * D.27926;
  struct ImGuiWindow * D.27923;
  struct ImGuiWindow * _4;
  struct ImGuiWindow * _5;
  struct ImGuiWindow * _7;

  <bb 2>:
  _4 = *p_3(D);
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = *p_3(D);
  ImGuiWindow::~ImGuiWindow (_5);
  _7 = *p_3(D);
  ImGui::MemFree (_7);
  *p_3(D) = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE5clearEv, funcdef_no=1396, decl_uid=11785, cgraph_uid=1295, symbol_order=1307)

void ImVector<T>::clear() [with T = ImGuiWindow*] (struct ImVector * const this)
{
  struct ImGuiWindow * * D.27933;
  int D.27932;
  struct ImGuiWindow * * D.27929;
  struct ImGuiWindow * * _4;
  int _6;
  struct ImGuiWindow * * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModE5clearEv, funcdef_no=1397, decl_uid=11910, cgraph_uid=1296, symbol_order=1308)

void ImVector<T>::clear() [with T = ImGuiColMod] (struct ImVector * const this)
{
  struct ImGuiColMod * D.27946;
  int D.27945;
  struct ImGuiColMod * D.27942;
  struct ImGuiColMod * _4;
  int _6;
  struct ImGuiColMod * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModE5clearEv, funcdef_no=1398, decl_uid=12013, cgraph_uid=1297, symbol_order=1309)

void ImVector<T>::clear() [with T = ImGuiStyleMod] (struct ImVector * const this)
{
  struct ImGuiStyleMod * D.27952;
  int D.27951;
  struct ImGuiStyleMod * D.27948;
  struct ImGuiStyleMod * _4;
  int _6;
  struct ImGuiStyleMod * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImFont*] (_ZN8ImVectorIP6ImFontE5clearEv, funcdef_no=1399, decl_uid=6528, cgraph_uid=1298, symbol_order=1310)

void ImVector<T>::clear() [with T = ImFont*] (struct ImVector * const this)
{
  struct ImFont * * D.27958;
  int D.27957;
  struct ImFont * * D.27954;
  struct ImFont * * _4;
  int _6;
  struct ImFont * * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefE5clearEv, funcdef_no=1400, decl_uid=12117, cgraph_uid=1299, symbol_order=1311)

void ImVector<T>::clear() [with T = ImGuiPopupRef] (struct ImVector * const this)
{
  struct ImGuiPopupRef * D.27964;
  int D.27963;
  struct ImGuiPopupRef * D.27960;
  struct ImGuiPopupRef * _4;
  int _6;
  struct ImGuiPopupRef * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = short unsigned int] (_ZN8ImVectorItE5clearEv, funcdef_no=1401, decl_uid=5187, cgraph_uid=1300, symbol_order=1312)

void ImVector<T>::clear() [with T = short unsigned int] (struct ImVector * const this)
{
  short unsigned int * D.27979;
  int D.27978;
  short unsigned int * D.27975;
  short unsigned int * _4;
  int _6;
  short unsigned int * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsE5clearEv, funcdef_no=1402, decl_uid=12292, cgraph_uid=1301, symbol_order=1313)

void ImVector<T>::clear() [with T = ImGuiWindowSettings] (struct ImVector * const this)
{
  struct ImGuiWindowSettings * D.27991;
  int D.27990;
  struct ImGuiWindowSettings * D.27987;
  struct ImGuiWindowSettings * _4;
  int _6;
  struct ImGuiWindowSettings * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::clear() [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerE5clearEv, funcdef_no=1403, decl_uid=12395, cgraph_uid=1302, symbol_order=1314)

void ImVector<T>::clear() [with T = ImGuiSettingsHandler] (struct ImVector * const this)
{
  struct ImGuiSettingsHandler * D.27997;
  int D.27996;
  struct ImGuiSettingsHandler * D.27993;
  struct ImGuiSettingsHandler * _4;
  int _6;
  struct ImGuiSettingsHandler * _8;

  <bb 2>:
  _4 = this_3(D)->Data;
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  this_3(D)->Capacity = 0;
  _6 = this_3(D)->Capacity;
  this_3(D)->Size = _6;
  _8 = this_3(D)->Data;
  ImGui::MemFree (_8);
  this_3(D)->Data = 0B;

  <bb 4>:
  return;

}



;; Function void IM_DELETE(T*&) [with T = ImGuiTextBuffer] (_Z9IM_DELETEI15ImGuiTextBufferEvRPT_, funcdef_no=1404, decl_uid=16572, cgraph_uid=1303, symbol_order=1315)

void IM_DELETE(T*&) [with T = ImGuiTextBuffer] (struct ImGuiTextBuffer * & p)
{
  struct ImGuiTextBuffer * D.28003;
  struct ImGuiTextBuffer * D.28002;
  struct ImGuiTextBuffer * D.27999;
  struct ImGuiTextBuffer * _4;
  struct ImGuiTextBuffer * _5;
  struct ImGuiTextBuffer * _7;

  <bb 2>:
  _4 = *p_3(D);
  if (_4 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _5 = *p_3(D);
  ImGuiTextBuffer::~ImGuiTextBuffer (_5);
  _7 = *p_3(D);
  ImGui::MemFree (_7);
  *p_3(D) = 0B;

  <bb 4>:
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsE9push_backERKS0_, funcdef_no=1405, decl_uid=12326, cgraph_uid=1304, symbol_order=1316)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiWindowSettings] (struct ImVector * const this, const struct value_type & v)
{
  int D.28043;
  int D.28042;
  struct ImGuiWindowSettings * D.28041;
  long unsigned int D.28040;
  long unsigned int D.28039;
  int D.28038;
  struct ImGuiWindowSettings * D.28037;
  int D.28035;
  int D.28034;
  int D.28033;
  int D.28030;
  int D.28029;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiWindowSettings * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiWindowSettings * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiWindowSettings>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiWindowSettings>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 32;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 32);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsE4backEv, funcdef_no=1406, decl_uid=12306, cgraph_uid=1305, symbol_order=1317)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiWindowSettings] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[123] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiWindowSettings; ImVector<T>::value_type = ImGuiWindowSettings]";
  sizetype D.28083;
  long unsigned int D.28082;
  long unsigned int D.28081;
  int D.28080;
  struct ImGuiWindowSettings * D.28079;
  struct value_type & D.28078;
  int D.28074;
  int _3;
  struct ImGuiWindowSettings * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 32;
  _8 = _7 + 18446744073709551584;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerEixEi, funcdef_no=1407, decl_uid=12389, cgraph_uid=1306, symbol_order=1318)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiSettingsHandler] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[134] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiSettingsHandler; ImVector<T>::value_type = ImGuiSettingsHandler]";
  long unsigned int D.28110;
  long unsigned int D.28109;
  struct ImGuiSettingsHandler * D.28108;
  struct value_type & D.28107;
  int D.28103;
  int _3;
  struct ImGuiSettingsHandler * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 48;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::pop_back() [with T = char] (_ZN8ImVectorIcE8pop_backEv, funcdef_no=1408, decl_uid=4458, cgraph_uid=1307, symbol_order=1319)

void ImVector<T>::pop_back() [with T = char] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[45] = "void ImVector<T>::pop_back() [with T = char]";
  int D.28190;
  int D.28189;
  int D.28185;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function void ImVector<T>::swap(ImVector<T>&) [with T = char] (_ZN8ImVectorIcE4swapERS0_, funcdef_no=1409, decl_uid=4439, cgraph_uid=1308, symbol_order=1320)

void ImVector<T>::swap(ImVector<T>&) [with T = char] (struct ImVector * const this, struct ImVector & rhs)
{
  value_type * rhs_data;
  int rhs_cap;
  int rhs_size;
  char * D.28193;
  int D.28192;
  int D.28191;
  int _5;
  int _9;
  char * _13;

  <bb 2>:
  rhs_size_3 = rhs_2(D)->Size;
  _5 = this_4(D)->Size;
  rhs_2(D)->Size = _5;
  this_4(D)->Size = rhs_size_3;
  rhs_cap_8 = rhs_2(D)->Capacity;
  _9 = this_4(D)->Capacity;
  rhs_2(D)->Capacity = _9;
  this_4(D)->Capacity = rhs_cap_8;
  rhs_data_12 = rhs_2(D)->Data;
  _13 = this_4(D)->Data;
  rhs_2(D)->Data = _13;
  this_4(D)->Data = rhs_data_12;
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE9push_backERKS1_, funcdef_no=1410, decl_uid=11819, cgraph_uid=1309, symbol_order=1321)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiWindow*] (struct ImVector * const this, struct ImGuiWindow * const & v)
{
  int D.28262;
  int D.28261;
  long unsigned int D.28260;
  struct ImGuiWindow * * D.28259;
  long unsigned int D.28258;
  long unsigned int D.28257;
  int D.28256;
  struct ImGuiWindow * * D.28255;
  int D.28253;
  int D.28252;
  int D.28251;
  int D.28248;
  int D.28247;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiWindow * * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiWindow * * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiWindow*>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiWindow*>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::begin() [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE5beginEv, funcdef_no=1411, decl_uid=11787, cgraph_uid=1310, symbol_order=1322)

ImVector<T>::value_type* ImVector<T>::begin() [with T = ImGuiWindow*] (struct ImVector * const this)
{
  struct ImGuiWindow * * D.28263;
  struct ImGuiWindow * * _3;

  <bb 2>:
  _3 = this_2(D)->Data;

<L0>:
  return _3;

}



;; Function bool ImVector<T>::empty() const [with T = ImDrawCmd] (_ZNK8ImVectorI9ImDrawCmdE5emptyEv, funcdef_no=1412, decl_uid=5072, cgraph_uid=1311, symbol_order=1323)

bool ImVector<T>::empty() const [with T = ImDrawCmd] (const struct ImVector * const this)
{
  int D.28350;
  bool D.28349;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImDrawCmd] (_ZN8ImVectorI9ImDrawCmdE4backEv, funcdef_no=1413, decl_uid=5098, cgraph_uid=1312, symbol_order=1324)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImDrawCmd] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[103] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImDrawCmd; ImVector<T>::value_type = ImDrawCmd]";
  sizetype D.28341;
  long unsigned int D.28340;
  long unsigned int D.28339;
  int D.28338;
  struct ImDrawCmd * D.28337;
  struct value_type & D.28336;
  int D.28332;
  int _3;
  struct ImDrawCmd * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 48;
  _8 = _7 + 18446744073709551568;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::pop_back() [with T = ImDrawCmd] (_ZN8ImVectorI9ImDrawCmdE8pop_backEv, funcdef_no=1414, decl_uid=5121, cgraph_uid=1313, symbol_order=1325)

void ImVector<T>::pop_back() [with T = ImDrawCmd] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[50] = "void ImVector<T>::pop_back() [with T = ImDrawCmd]";
  int D.28348;
  int D.28347;
  int D.28343;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListE9push_backERKS1_, funcdef_no=1415, decl_uid=11601, cgraph_uid=1314, symbol_order=1326)

void ImVector<T>::push_back(const value_type&) [with T = ImDrawList*] (struct ImVector * const this, struct ImDrawList * const & v)
{
  int D.28367;
  int D.28366;
  long unsigned int D.28365;
  struct ImDrawList * * D.28364;
  long unsigned int D.28363;
  long unsigned int D.28362;
  int D.28361;
  struct ImDrawList * * D.28360;
  int D.28358;
  int D.28357;
  int D.28356;
  int D.28353;
  int D.28352;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImDrawList * * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImDrawList * * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImDrawList*>::_grow_capacity (this_3(D), _7);
  ImVector<ImDrawList*>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = ImDrawList*] (_ZNK8ImVectorIP10ImDrawListE5emptyEv, funcdef_no=1416, decl_uid=11555, cgraph_uid=1315, symbol_order=1327)

bool ImVector<T>::empty() const [with T = ImDrawList*] (const struct ImVector * const this)
{
  int D.28437;
  bool D.28436;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListEixEi, funcdef_no=1417, decl_uid=11561, cgraph_uid=1316, symbol_order=1328)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImDrawList*] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[116] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImDrawList*; ImVector<T>::value_type = ImDrawList*]";
  long unsigned int D.28446;
  long unsigned int D.28445;
  struct ImDrawList * * D.28444;
  struct ImDrawList * & D.28443;
  int D.28439;
  int _3;
  struct ImDrawList * * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct ImDrawList * & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 8;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImVec4] (_ZN8ImVectorI6ImVec4E4backEv, funcdef_no=1418, decl_uid=5431, cgraph_uid=1317, symbol_order=1329)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImVec4] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[97] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImVec4; ImVector<T>::value_type = ImVec4]";
  sizetype D.28493;
  long unsigned int D.28492;
  long unsigned int D.28491;
  int D.28490;
  struct ImVec4 * D.28489;
  struct value_type & D.28488;
  int D.28484;
  int _3;
  struct ImVec4 * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 16;
  _8 = _7 + 18446744073709551600;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE7reserveEi, funcdef_no=1419, decl_uid=11816, cgraph_uid=1318, symbol_order=1330)

void ImVector<T>::reserve(int) [with T = ImGuiWindow*] (struct ImVector * const this, int new_capacity)
{
  struct ImGuiWindow * * D.27600;
  struct ImGuiWindow * * new_data;
  struct ImGuiWindow * * D.27598;
  struct ImGuiWindow * * D.27596;
  long unsigned int D.27595;
  long unsigned int D.27594;
  int D.27593;
  struct ImGuiWindow * * D.27590;
  long unsigned int D.27589;
  long unsigned int D.27588;
  int D.27585;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct ImGuiWindow * * _10;
  struct ImGuiWindow * * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiWindow * * _16;
  struct ImGuiWindow * * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function void ImVector<T>::swap(ImVector<T>&) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE4swapERS2_, funcdef_no=1420, decl_uid=11803, cgraph_uid=1319, symbol_order=1331)

void ImVector<T>::swap(ImVector<T>&) [with T = ImGuiWindow*] (struct ImVector * const this, struct ImVector & rhs)
{
  struct ImGuiWindow * * rhs_data;
  int rhs_cap;
  int rhs_size;
  struct ImGuiWindow * * D.28650;
  int D.28649;
  int D.28648;
  int _5;
  int _9;
  struct ImGuiWindow * * _13;

  <bb 2>:
  rhs_size_3 = rhs_2(D)->Size;
  _5 = this_4(D)->Size;
  rhs_2(D)->Size = _5;
  this_4(D)->Size = rhs_size_3;
  rhs_cap_8 = rhs_2(D)->Capacity;
  _9 = this_4(D)->Capacity;
  rhs_2(D)->Capacity = _9;
  this_4(D)->Capacity = rhs_cap_8;
  rhs_data_12 = rhs_2(D)->Data;
  _13 = this_4(D)->Data;
  rhs_2(D)->Data = _13;
  this_4(D)->Data = rhs_data_12;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = ImDrawVert] (_ZNK8ImVectorI10ImDrawVertE5emptyEv, funcdef_no=1421, decl_uid=5296, cgraph_uid=1320, symbol_order=1332)

bool ImVector<T>::empty() const [with T = ImDrawVert] (const struct ImVector * const this)
{
  int D.28773;
  bool D.28772;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefEixEi, funcdef_no=1422, decl_uid=12111, cgraph_uid=1321, symbol_order=1333)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiPopupRef] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[120] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiPopupRef; ImVector<T>::value_type = ImGuiPopupRef]";
  long unsigned int D.29457;
  long unsigned int D.29456;
  struct ImGuiPopupRef * D.29455;
  struct value_type & D.29454;
  int D.29450;
  int _3;
  struct ImGuiPopupRef * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 48;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefE9push_backERKS0_, funcdef_no=1423, decl_uid=12151, cgraph_uid=1322, symbol_order=1334)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiPopupRef] (struct ImVector * const this, const struct value_type & v)
{
  int D.29684;
  int D.29683;
  struct ImGuiPopupRef * D.29682;
  long unsigned int D.29681;
  long unsigned int D.29680;
  int D.29679;
  struct ImGuiPopupRef * D.29678;
  int D.29676;
  int D.29675;
  int D.29674;
  int D.29671;
  int D.29670;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiPopupRef * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiPopupRef * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiPopupRef>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiPopupRef>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 48;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 48);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE6insertEPKS1_RS3_, funcdef_no=1424, decl_uid=11830, cgraph_uid=1323, symbol_order=1335)

ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiWindow*] (struct ImVector * const this, struct ImGuiWindow * const * it, struct ImGuiWindow * const & v)
{
  const ptrdiff_t off;
  static const char __PRETTY_FUNCTION__[247] = "ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiWindow*; ImVector<T>::iterator = ImGuiWindow**; ImVector<T>::value_type = ImGuiWindow*; ImVector<T>::const_iterator = ImGuiWindow* const*]";
  long unsigned int D.30545;
  long unsigned int off.501;
  struct ImGuiWindow * * D.30543;
  struct ImGuiWindow * * D.30542;
  int D.30541;
  int D.30540;
  long unsigned int D.30539;
  struct ImGuiWindow * * D.30538;
  long unsigned int D.30537;
  long unsigned int off.500;
  struct ImGuiWindow * * D.30535;
  struct ImGuiWindow * * D.30533;
  sizetype D.30532;
  sizetype D.30531;
  sizetype off.499;
  struct ImGuiWindow * * D.30529;
  struct ImGuiWindow * * D.30528;
  long unsigned int D.30527;
  long unsigned int off.498;
  struct ImGuiWindow * * D.30525;
  long unsigned int D.30524;
  long unsigned int D.30523;
  long unsigned int off.497;
  long unsigned int D.30521;
  int D.30520;
  long int D.30517;
  int D.30516;
  int D.30514;
  int D.30513;
  int D.30512;
  int D.30509;
  int D.30508;
  long int D.30507;
  long int D.30506;
  struct ImGuiWindow * * D.30505;
  long int it.496;
  struct ImGuiWindow * * D.30502;
  long unsigned int D.30501;
  long unsigned int D.30500;
  int D.30499;
  struct ImGuiWindow * * D.30498;
  struct ImGuiWindow * * D.30496;
  struct ImGuiWindow * * _5;
  struct ImGuiWindow * * _7;
  int _8;
  long unsigned int _9;
  long unsigned int _10;
  struct ImGuiWindow * * _11;
  long int it.496_12;
  struct ImGuiWindow * * _13;
  long int _14;
  long int _15;
  int _17;
  int _18;
  int _19;
  int _20;
  int _22;
  int _24;
  long int _25;
  int _26;
  long unsigned int _27;
  long unsigned int off.497_28;
  long unsigned int _29;
  long unsigned int _30;
  struct ImGuiWindow * * _31;
  long unsigned int off.498_32;
  long unsigned int _33;
  struct ImGuiWindow * * _34;
  struct ImGuiWindow * * _35;
  sizetype off.499_36;
  sizetype _37;
  sizetype _38;
  struct ImGuiWindow * * _39;
  struct ImGuiWindow * * _41;
  long unsigned int off.500_42;
  long unsigned int _43;
  struct ImGuiWindow * * _44;
  long unsigned int _46;
  int _48;
  int _49;
  struct ImGuiWindow * * _51;
  long unsigned int off.501_52;
  long unsigned int _53;
  struct ImGuiWindow * * _54;

  <bb 2>:
  _5 = this_4(D)->Data;
  if (_5 <= it_6(D))
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = this_4(D)->Data;
  _8 = this_4(D)->Size;
  _9 = (long unsigned int) _8;
  _10 = _9 * 8;
  _11 = _7 + _10;
  if (_11 >= it_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("it >= Data && it <= Data+Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1203, &__PRETTY_FUNCTION__);

  <bb 6>:
  it.496_12 = (long int) it_6(D);
  _13 = this_4(D)->Data;
  _14 = (long int) _13;
  _15 = it.496_12 - _14;
  off_16 = _15 /[ex] 8;
  _17 = this_4(D)->Size;
  _18 = this_4(D)->Capacity;
  if (_17 == _18)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _19 = this_4(D)->Size;
  _20 = _19 + 1;
  _22 = ImVector<ImGuiWindow*>::_grow_capacity (this_4(D), _20);
  ImVector<ImGuiWindow*>::reserve (this_4(D), _22);

  <bb 8>:
  _24 = this_4(D)->Size;
  _25 = (long int) _24;
  if (_25 > off_16)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _26 = this_4(D)->Size;
  _27 = (long unsigned int) _26;
  off.497_28 = (long unsigned int) off_16;
  _29 = _27 - off.497_28;
  _30 = _29 * 8;
  _31 = this_4(D)->Data;
  off.498_32 = (long unsigned int) off_16;
  _33 = off.498_32 * 8;
  _34 = _31 + _33;
  _35 = this_4(D)->Data;
  off.499_36 = (sizetype) off_16;
  _37 = off.499_36 + 1;
  _38 = _37 * 8;
  _39 = _35 + _38;
  memmove (_39, _34, _30);

  <bb 10>:
  _41 = this_4(D)->Data;
  off.500_42 = (long unsigned int) off_16;
  _43 = off.500_42 * 8;
  _44 = _41 + _43;
  _46 = MEM[(char * {ref-all})v_45(D)];
  MEM[(char * {ref-all})_44] = _46;
  _48 = this_4(D)->Size;
  _49 = _48 + 1;
  this_4(D)->Size = _49;
  _51 = this_4(D)->Data;
  off.501_52 = (long unsigned int) off_16;
  _53 = off.501_52 * 8;
  _54 = _51 + _53;

<L10>:
  return _54;

}



;; Function bool ImVector<T>::empty() const [with T = ImGuiWindow*] (_ZNK8ImVectorIP11ImGuiWindowE5emptyEv, funcdef_no=1425, decl_uid=11773, cgraph_uid=1324, symbol_order=1336)

bool ImVector<T>::empty() const [with T = ImGuiWindow*] (const struct ImVector * const this)
{
  int D.32759;
  bool D.32758;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE4backEv, funcdef_no=1426, decl_uid=11799, cgraph_uid=1325, symbol_order=1337)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiWindow*] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[109] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiWindow*; ImVector<T>::value_type = ImGuiWindow*]";
  sizetype D.32770;
  long unsigned int D.32769;
  long unsigned int D.32768;
  int D.32767;
  struct ImGuiWindow * * D.32766;
  struct ImGuiWindow * & D.32765;
  int D.32761;
  int _3;
  struct ImGuiWindow * * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct ImGuiWindow * & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::resize(int) [with T = unsigned int] (_ZN8ImVectorIjE6resizeEi, funcdef_no=1427, decl_uid=13399, cgraph_uid=1326, symbol_order=1338)

void ImVector<T>::resize(int) [with T = unsigned int] (struct ImVector * const this, int new_size)
{
  int D.32775;
  int D.32772;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<unsigned int>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<unsigned int>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::resize(int) [with T = int] (_ZN8ImVectorIiE6resizeEi, funcdef_no=1428, decl_uid=13087, cgraph_uid=1327, symbol_order=1339)

void ImVector<T>::resize(int) [with T = int] (struct ImVector * const this, int new_size)
{
  int D.32819;
  int D.32816;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<int>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<int>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::resize(int) [with T = float] (_ZN8ImVectorIfE6resizeEi, funcdef_no=1429, decl_uid=7008, cgraph_uid=1328, symbol_order=1340)

void ImVector<T>::resize(int) [with T = float] (struct ImVector * const this, int new_size)
{
  int D.32854;
  int D.32851;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<float>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<float>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::resize(int) [with T = ImGuiGroupData] (_ZN8ImVectorI14ImGuiGroupDataE6resizeEi, funcdef_no=1430, decl_uid=13192, cgraph_uid=1329, symbol_order=1341)

void ImVector<T>::resize(int) [with T = ImGuiGroupData] (struct ImVector * const this, int new_size)
{
  int D.32889;
  int D.32886;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImGuiGroupData>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImGuiGroupData>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = int] (_ZN8ImVectorIiE9push_backERKi, funcdef_no=1431, decl_uid=13097, cgraph_uid=1330, symbol_order=1342)

void ImVector<T>::push_back(const value_type&) [with T = int] (struct ImVector * const this, const value_type & v)
{
  int D.32936;
  int D.32935;
  unsigned int D.32934;
  int * D.32933;
  long unsigned int D.32932;
  long unsigned int D.32931;
  int D.32930;
  int * D.32929;
  int D.32927;
  int D.32926;
  int D.32925;
  int D.32922;
  int D.32921;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  int * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  int * _15;
  unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<int>::_grow_capacity (this_3(D), _7);
  ImVector<int>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 4;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function void ImVector<T>::pop_back() [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE8pop_backEv, funcdef_no=1432, decl_uid=11822, cgraph_uid=1331, symbol_order=1343)

void ImVector<T>::pop_back() [with T = ImGuiWindow*] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[53] = "void ImVector<T>::pop_back() [with T = ImGuiWindow*]";
  int D.32982;
  int D.32981;
  int D.32977;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function void ImVector<T>::pop_back() [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefE8pop_backEv, funcdef_no=1433, decl_uid=12154, cgraph_uid=1332, symbol_order=1344)

void ImVector<T>::pop_back() [with T = ImGuiPopupRef] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[54] = "void ImVector<T>::pop_back() [with T = ImGuiPopupRef]";
  int D.32988;
  int D.32987;
  int D.32983;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::erase(ImVector<T>::const_iterator) [with T = ImGuiWindow*] (_ZN8ImVectorIP11ImGuiWindowE5eraseEPKS1_, funcdef_no=1434, decl_uid=11827, cgraph_uid=1333, symbol_order=1345)

ImVector<T>::value_type* ImVector<T>::erase(ImVector<T>::const_iterator) [with T = ImGuiWindow*] (struct ImVector * const this, struct ImGuiWindow * const * it)
{
  const ptrdiff_t off;
  static const char __PRETTY_FUNCTION__[227] = "ImVector<T>::value_type* ImVector<T>::erase(ImVector<T>::const_iterator) [with T = ImGuiWindow*; ImVector<T>::iterator = ImGuiWindow**; ImVector<T>::value_type = ImGuiWindow*; ImVector<T>::const_iterator = ImGuiWindow* const*]";
  long unsigned int D.33271;
  long unsigned int off.1039;
  struct ImGuiWindow * * D.33269;
  struct ImGuiWindow * * D.33268;
  int D.33267;
  int D.33266;
  struct ImGuiWindow * * D.33265;
  long unsigned int D.33264;
  long unsigned int off.1038;
  struct ImGuiWindow * * D.33262;
  struct ImGuiWindow * * D.33261;
  sizetype D.33260;
  sizetype D.33259;
  sizetype off.1037;
  struct ImGuiWindow * * D.33257;
  long unsigned int D.33256;
  long unsigned int D.33255;
  long unsigned int D.33254;
  long unsigned int off.1036;
  long unsigned int D.33252;
  int D.33251;
  long int D.33250;
  long int D.33249;
  struct ImGuiWindow * * D.33248;
  long int it.1035;
  struct ImGuiWindow * * D.33245;
  long unsigned int D.33244;
  long unsigned int D.33243;
  int D.33242;
  struct ImGuiWindow * * D.33241;
  struct ImGuiWindow * * D.33239;
  struct ImGuiWindow * * _3;
  struct ImGuiWindow * * _5;
  int _6;
  long unsigned int _7;
  long unsigned int _8;
  struct ImGuiWindow * * _9;
  long int it.1035_10;
  struct ImGuiWindow * * _11;
  long int _12;
  long int _13;
  int _15;
  long unsigned int _16;
  long unsigned int off.1036_17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  struct ImGuiWindow * * _21;
  sizetype off.1037_22;
  sizetype _23;
  sizetype _24;
  struct ImGuiWindow * * _25;
  struct ImGuiWindow * * _26;
  long unsigned int off.1038_27;
  long unsigned int _28;
  struct ImGuiWindow * * _29;
  int _31;
  int _32;
  struct ImGuiWindow * * _34;
  long unsigned int off.1039_35;
  long unsigned int _36;
  struct ImGuiWindow * * _37;

  <bb 2>:
  _3 = this_2(D)->Data;
  if (_3 <= it_4(D))
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _5 = this_2(D)->Data;
  _6 = this_2(D)->Size;
  _7 = (long unsigned int) _6;
  _8 = _7 * 8;
  _9 = _5 + _8;
  if (_9 > it_4(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("it >= Data && it < Data+Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1202, &__PRETTY_FUNCTION__);

  <bb 6>:
  it.1035_10 = (long int) it_4(D);
  _11 = this_2(D)->Data;
  _12 = (long int) _11;
  _13 = it.1035_10 - _12;
  off_14 = _13 /[ex] 8;
  _15 = this_2(D)->Size;
  _16 = (long unsigned int) _15;
  off.1036_17 = (long unsigned int) off_14;
  _18 = _16 - off.1036_17;
  _19 = _18 * 8;
  _20 = _19 + 18446744073709551608;
  _21 = this_2(D)->Data;
  off.1037_22 = (sizetype) off_14;
  _23 = off.1037_22 + 1;
  _24 = _23 * 8;
  _25 = _21 + _24;
  _26 = this_2(D)->Data;
  off.1038_27 = (long unsigned int) off_14;
  _28 = off.1038_27 * 8;
  _29 = _26 + _28;
  memmove (_29, _25, _20);
  _31 = this_2(D)->Size;
  _32 = _31 + -1;
  this_2(D)->Size = _32;
  _34 = this_2(D)->Data;
  off.1039_35 = (long unsigned int) off_14;
  _36 = off.1039_35 * 8;
  _37 = _34 + _36;

<L4>:
  return _37;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = float] (_ZN8ImVectorIfE9push_backERKf, funcdef_no=1435, decl_uid=7018, cgraph_uid=1334, symbol_order=1346)

void ImVector<T>::push_back(const value_type&) [with T = float] (struct ImVector * const this, const value_type & v)
{
  int D.33388;
  int D.33387;
  unsigned int D.33386;
  float * D.33385;
  long unsigned int D.33384;
  long unsigned int D.33383;
  int D.33382;
  float * D.33381;
  int D.33379;
  int D.33378;
  int D.33377;
  int D.33374;
  int D.33373;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  float * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  float * _15;
  unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<float>::_grow_capacity (this_3(D), _7);
  ImVector<float>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 4;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = float] (_ZN8ImVectorIfE4backEv, funcdef_no=1436, decl_uid=6998, cgraph_uid=1335, symbol_order=1347)

ImVector<T>::value_type& ImVector<T>::back() [with T = float] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[95] = "ImVector<T>::value_type& ImVector<T>::back() [with T = float; ImVector<T>::value_type = float]";
  sizetype D.33432;
  long unsigned int D.33431;
  long unsigned int D.33430;
  int D.33429;
  float * D.33428;
  value_type & D.33427;
  int D.33423;
  int _3;
  float * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 4;
  _8 = _7 + 18446744073709551612;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::pop_back() [with T = float] (_ZN8ImVectorIfE8pop_backEv, funcdef_no=1437, decl_uid=7021, cgraph_uid=1336, symbol_order=1348)

void ImVector<T>::pop_back() [with T = float] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[46] = "void ImVector<T>::pop_back() [with T = float]";
  int D.33448;
  int D.33447;
  int D.33443;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = float] (_ZNK8ImVectorIfE5emptyEv, funcdef_no=1438, decl_uid=6972, cgraph_uid=1337, symbol_order=1349)

bool ImVector<T>::empty() const [with T = float] (const struct ImVector * const this)
{
  int D.33450;
  bool D.33449;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImFont*] (_ZN8ImVectorIP6ImFontE9push_backERKS1_, funcdef_no=1439, decl_uid=6562, cgraph_uid=1338, symbol_order=1350)

void ImVector<T>::push_back(const value_type&) [with T = ImFont*] (struct ImVector * const this, struct ImFont * const & v)
{
  int D.33522;
  int D.33521;
  long unsigned int D.33520;
  struct ImFont * * D.33519;
  long unsigned int D.33518;
  long unsigned int D.33517;
  int D.33516;
  struct ImFont * * D.33515;
  int D.33513;
  int D.33512;
  int D.33511;
  int D.33508;
  int D.33507;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImFont * * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImFont * * _15;
  long unsigned int _17;
  int _19;
  int _20;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImFont*>::_grow_capacity (this_3(D), _7);
  ImVector<ImFont*>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 8;
  _15 = _11 + _14;
  _17 = MEM[(char * {ref-all})v_16(D)];
  MEM[(char * {ref-all})_15] = _17;
  _19 = this_3(D)->Size;
  _20 = _19 + 1;
  this_3(D)->Size = _20;
  return;

}



;; Function void ImVector<T>::pop_back() [with T = ImFont*] (_ZN8ImVectorIP6ImFontE8pop_backEv, funcdef_no=1440, decl_uid=6565, cgraph_uid=1339, symbol_order=1351)

void ImVector<T>::pop_back() [with T = ImFont*] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[48] = "void ImVector<T>::pop_back() [with T = ImFont*]";
  int D.33570;
  int D.33569;
  int D.33565;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = ImFont*] (_ZNK8ImVectorIP6ImFontE5emptyEv, funcdef_no=1441, decl_uid=6516, cgraph_uid=1340, symbol_order=1352)

bool ImVector<T>::empty() const [with T = ImFont*] (const struct ImVector * const this)
{
  int D.33572;
  bool D.33571;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImFont*] (_ZN8ImVectorIP6ImFontE4backEv, funcdef_no=1442, decl_uid=6542, cgraph_uid=1341, symbol_order=1353)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImFont*] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[99] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImFont*; ImVector<T>::value_type = ImFont*]";
  sizetype D.33583;
  long unsigned int D.33582;
  long unsigned int D.33581;
  int D.33580;
  struct ImFont * * D.33579;
  struct ImFont * & D.33578;
  int D.33574;
  int _3;
  struct ImFont * * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct ImFont * & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::pop_back() [with T = int] (_ZN8ImVectorIiE8pop_backEv, funcdef_no=1443, decl_uid=13100, cgraph_uid=1342, symbol_order=1354)

void ImVector<T>::pop_back() [with T = int] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[44] = "void ImVector<T>::pop_back() [with T = int]";
  int D.33609;
  int D.33608;
  int D.33604;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = int] (_ZNK8ImVectorIiE5emptyEv, funcdef_no=1444, decl_uid=13051, cgraph_uid=1343, symbol_order=1355)

bool ImVector<T>::empty() const [with T = int] (const struct ImVector * const this)
{
  int D.33611;
  bool D.33610;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = int] (_ZN8ImVectorIiE4backEv, funcdef_no=1445, decl_uid=13077, cgraph_uid=1344, symbol_order=1356)

ImVector<T>::value_type& ImVector<T>::back() [with T = int] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[91] = "ImVector<T>::value_type& ImVector<T>::back() [with T = int; ImVector<T>::value_type = int]";
  sizetype D.33622;
  long unsigned int D.33621;
  long unsigned int D.33620;
  int D.33619;
  int * D.33618;
  value_type & D.33617;
  int D.33613;
  int _3;
  int * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 4;
  _8 = _7 + 18446744073709551612;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModE9push_backERKS0_, funcdef_no=1446, decl_uid=11944, cgraph_uid=1345, symbol_order=1357)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiColMod] (struct ImVector * const this, const struct value_type & v)
{
  int D.33654;
  int D.33653;
  struct ImGuiColMod * D.33652;
  long unsigned int D.33651;
  long unsigned int D.33650;
  int D.33649;
  struct ImGuiColMod * D.33648;
  int D.33646;
  int D.33645;
  int D.33644;
  int D.33641;
  int D.33640;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiColMod * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiColMod * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiColMod>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiColMod>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 20;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 20);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModE4backEv, funcdef_no=1447, decl_uid=11924, cgraph_uid=1346, symbol_order=1358)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiColMod] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[107] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiColMod; ImVector<T>::value_type = ImGuiColMod]";
  sizetype D.33701;
  long unsigned int D.33700;
  long unsigned int D.33699;
  int D.33698;
  struct ImGuiColMod * D.33697;
  struct value_type & D.33696;
  int D.33692;
  int _3;
  struct ImGuiColMod * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 20;
  _8 = _7 + 18446744073709551596;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::pop_back() [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModE8pop_backEv, funcdef_no=1448, decl_uid=11947, cgraph_uid=1347, symbol_order=1359)

void ImVector<T>::pop_back() [with T = ImGuiColMod] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[52] = "void ImVector<T>::pop_back() [with T = ImGuiColMod]";
  int D.33708;
  int D.33707;
  int D.33703;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModE9push_backERKS0_, funcdef_no=1449, decl_uid=12047, cgraph_uid=1348, symbol_order=1360)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiStyleMod] (struct ImVector * const this, const struct value_type & v)
{
  int D.33750;
  int D.33749;
  struct ImGuiStyleMod * D.33748;
  long unsigned int D.33747;
  long unsigned int D.33746;
  int D.33745;
  struct ImGuiStyleMod * D.33744;
  int D.33742;
  int D.33741;
  int D.33740;
  int D.33737;
  int D.33736;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiStyleMod * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiStyleMod * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiStyleMod>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiStyleMod>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 12;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 12);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModE4backEv, funcdef_no=1450, decl_uid=12027, cgraph_uid=1349, symbol_order=1361)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiStyleMod] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[111] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiStyleMod; ImVector<T>::value_type = ImGuiStyleMod]";
  sizetype D.33828;
  long unsigned int D.33827;
  long unsigned int D.33826;
  int D.33825;
  struct ImGuiStyleMod * D.33824;
  struct value_type & D.33823;
  int D.33819;
  int _3;
  struct ImGuiStyleMod * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 12;
  _8 = _7 + 18446744073709551604;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::pop_back() [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModE8pop_backEv, funcdef_no=1451, decl_uid=12050, cgraph_uid=1350, symbol_order=1362)

void ImVector<T>::pop_back() [with T = ImGuiStyleMod] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[54] = "void ImVector<T>::pop_back() [with T = ImGuiStyleMod]";
  int D.33835;
  int D.33834;
  int D.33830;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function void ImVector<T>::pop_back() [with T = unsigned int] (_ZN8ImVectorIjE8pop_backEv, funcdef_no=1452, decl_uid=13412, cgraph_uid=1351, symbol_order=1363)

void ImVector<T>::pop_back() [with T = unsigned int] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[53] = "void ImVector<T>::pop_back() [with T = unsigned int]";
  int D.35592;
  int D.35591;
  int D.35587;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::begin() [with T = char] (_ZN8ImVectorIcE5beginEv, funcdef_no=1453, decl_uid=4423, cgraph_uid=1352, symbol_order=1364)

ImVector<T>::value_type* ImVector<T>::begin() [with T = char] (struct ImVector * const this)
{
  value_type * D.35991;
  value_type * _3;

  <bb 2>:
  _3 = this_2(D)->Data;

<L0>:
  return _3;

}



;; Function const value_type& ImVector<T>::operator[](int) const [with T = short unsigned int] (_ZNK8ImVectorItEixEi, funcdef_no=1454, decl_uid=5184, cgraph_uid=1353, symbol_order=1365)

const value_type& ImVector<T>::operator[](int) const [with T = short unsigned int] (const struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[129] = "const value_type& ImVector<T>::operator[](int) const [with T = short unsigned int; ImVector<T>::value_type = short unsigned int]";
  long unsigned int D.37450;
  long unsigned int D.37449;
  short unsigned int * D.37448;
  const value_type & D.37447;
  int D.37443;
  int _3;
  short unsigned int * _5;
  long unsigned int _6;
  long unsigned int _7;
  const value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1170, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 2;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = short unsigned int] (_ZN8ImVectorItEixEi, funcdef_no=1455, decl_uid=5181, cgraph_uid=1354, symbol_order=1366)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = short unsigned int] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[130] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = short unsigned int; ImVector<T>::value_type = short unsigned int]";
  long unsigned int D.37477;
  long unsigned int D.37476;
  short unsigned int * D.37475;
  value_type & D.37474;
  int D.37470;
  int _3;
  short unsigned int * _5;
  long unsigned int _6;
  long unsigned int _7;
  value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 2;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function bool ImVector<T>::empty() const [with T = ImFontGlyph] (_ZNK8ImVectorI11ImFontGlyphE5emptyEv, funcdef_no=1456, decl_uid=6869, cgraph_uid=1355, symbol_order=1367)

bool ImVector<T>::empty() const [with T = ImFontGlyph] (const struct ImVector * const this)
{
  int D.40282;
  bool D.40281;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function bool ImVector<T>::empty() const [with T = short unsigned int] (_ZNK8ImVectorItE5emptyEv, funcdef_no=1457, decl_uid=5175, cgraph_uid=1356, symbol_order=1368)

bool ImVector<T>::empty() const [with T = short unsigned int] (const struct ImVector * const this)
{
  int D.40285;
  bool D.40284;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function void ImVector<T>::resize(int) [with T = short unsigned int] (_ZN8ImVectorItE6resizeEi, funcdef_no=1458, decl_uid=5211, cgraph_uid=1357, symbol_order=1369)

void ImVector<T>::resize(int) [with T = short unsigned int] (struct ImVector * const this, int new_size)
{
  int D.40290;
  int D.40287;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<short unsigned int>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<short unsigned int>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiGroupData] (_ZN8ImVectorI14ImGuiGroupDataE4backEv, funcdef_no=1459, decl_uid=13182, cgraph_uid=1358, symbol_order=1370)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiGroupData] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[113] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiGroupData; ImVector<T>::value_type = ImGuiGroupData]";
  sizetype D.41374;
  long unsigned int D.41373;
  long unsigned int D.41372;
  int D.41371;
  struct ImGuiGroupData * D.41370;
  struct value_type & D.41369;
  int D.41365;
  int _3;
  struct ImGuiGroupData * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 40;
  _8 = _7 + 18446744073709551576;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function bool ImVector<T>::empty() const [with T = ImGuiGroupData] (_ZNK8ImVectorI14ImGuiGroupDataE5emptyEv, funcdef_no=1460, decl_uid=13156, cgraph_uid=1359, symbol_order=1371)

bool ImVector<T>::empty() const [with T = ImGuiGroupData] (const struct ImVector * const this)
{
  int D.43357;
  bool D.43356;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function void ImVector<T>::pop_back() [with T = ImGuiGroupData] (_ZN8ImVectorI14ImGuiGroupDataE8pop_backEv, funcdef_no=1461, decl_uid=13205, cgraph_uid=1360, symbol_order=1372)

void ImVector<T>::pop_back() [with T = ImGuiGroupData] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[55] = "void ImVector<T>::pop_back() [with T = ImGuiGroupData]";
  int D.43554;
  int D.43553;
  int D.43549;
  int _3;
  int _4;
  int _5;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1200, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Size;
  _5 = _4 + -1;
  this_2(D)->Size = _5;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataEixEi, funcdef_no=1462, decl_uid=11412, cgraph_uid=1361, symbol_order=1373)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiColumnData] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[124] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImGuiColumnData; ImVector<T>::value_type = ImGuiColumnData]";
  long unsigned int D.43717;
  long unsigned int D.43716;
  struct ImGuiColumnData * D.43715;
  struct value_type & D.43714;
  int D.43710;
  int _3;
  struct ImGuiColumnData * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 28;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiColumnsSet] (_ZN8ImVectorI15ImGuiColumnsSetE9push_backERKS0_, funcdef_no=1463, decl_uid=13520, cgraph_uid=1362, symbol_order=1374)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiColumnsSet] (struct ImVector * const this, const struct value_type & v)
{
  int D.43869;
  int D.43868;
  struct ImGuiColumnsSet * D.43867;
  long unsigned int D.43866;
  long unsigned int D.43865;
  int D.43864;
  struct ImGuiColumnsSet * D.43863;
  int D.43861;
  int D.43860;
  int D.43859;
  int D.43856;
  int D.43855;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiColumnsSet * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiColumnsSet * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiColumnsSet>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiColumnsSet>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 64;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 64);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiColumnsSet] (_ZN8ImVectorI15ImGuiColumnsSetE4backEv, funcdef_no=1464, decl_uid=13500, cgraph_uid=1363, symbol_order=1375)

ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiColumnsSet] (struct ImVector * const this)
{
  static const char __PRETTY_FUNCTION__[115] = "ImVector<T>::value_type& ImVector<T>::back() [with T = ImGuiColumnsSet; ImVector<T>::value_type = ImGuiColumnsSet]";
  sizetype D.43909;
  long unsigned int D.43908;
  long unsigned int D.43907;
  int D.43906;
  struct ImGuiColumnsSet * D.43905;
  struct value_type & D.43904;
  int D.43900;
  int _3;
  struct ImGuiColumnsSet * _4;
  int _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  struct value_type & _9;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > 0)
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("Size > 0", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1179, &__PRETTY_FUNCTION__);

  <bb 4>:
  _4 = this_2(D)->Data;
  _5 = this_2(D)->Size;
  _6 = (long unsigned int) _5;
  _7 = _6 * 64;
  _8 = _7 + 18446744073709551552;
  _9 = _4 + _8;

<L3>:
  return _9;

}



;; Function void ImVector<T>::resize(int) [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataE6resizeEi, funcdef_no=1465, decl_uid=11442, cgraph_uid=1364, symbol_order=1376)

void ImVector<T>::resize(int) [with T = ImGuiColumnData] (struct ImVector * const this, int new_size)
{
  int D.44009;
  int D.44006;
  int _4;
  int _7;

  <bb 2>:
  _4 = this_3(D)->Capacity;
  if (_4 < new_size_5(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _7 = ImVector<ImGuiColumnData>::_grow_capacity (this_3(D), new_size_5(D));
  ImVector<ImGuiColumnData>::reserve (this_3(D), _7);

  <bb 4>:
  this_3(D)->Size = new_size_5(D);
  return;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataE7reserveEi, funcdef_no=1466, decl_uid=11449, cgraph_uid=1365, symbol_order=1377)

void ImVector<T>::reserve(int) [with T = ImGuiColumnData] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.44040;
  struct value_type * new_data;
  struct ImGuiColumnData * D.44038;
  struct ImGuiColumnData * D.44036;
  long unsigned int D.44035;
  long unsigned int D.44034;
  int D.44033;
  struct ImGuiColumnData * D.44030;
  long unsigned int D.44029;
  long unsigned int D.44028;
  int D.44025;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiColumnData * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiColumnData * _16;
  struct ImGuiColumnData * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 28;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 28;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiColumnData] (_ZN8ImVectorI15ImGuiColumnDataE9push_backERKS0_, funcdef_no=1467, decl_uid=11452, cgraph_uid=1366, symbol_order=1378)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiColumnData] (struct ImVector * const this, const struct value_type & v)
{
  int D.44057;
  int D.44056;
  struct ImGuiColumnData * D.44055;
  long unsigned int D.44054;
  long unsigned int D.44053;
  int D.44052;
  struct ImGuiColumnData * D.44051;
  int D.44049;
  int D.44048;
  int D.44047;
  int D.44044;
  int D.44043;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiColumnData * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiColumnData * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiColumnData>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiColumnData>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 28;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 28);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function bool ImVector<T>::empty() const [with T = char] (_ZNK8ImVectorIcE5emptyEv, funcdef_no=1468, decl_uid=4409, cgraph_uid=1367, symbol_order=1379)

bool ImVector<T>::empty() const [with T = char] (const struct ImVector * const this)
{
  int D.44640;
  bool D.44639;
  int _3;
  bool _4;

  <bb 2>:
  _3 = this_2(D)->Size;
  _4 = _3 == 0;

<L0>:
  return _4;

}



;; Function ImVector<T>::value_type* ImVector<T>::begin() [with T = ImDrawCmd] (_ZN8ImVectorI9ImDrawCmdE5beginEv, funcdef_no=1469, decl_uid=5086, cgraph_uid=1368, symbol_order=1380)

ImVector<T>::value_type* ImVector<T>::begin() [with T = ImDrawCmd] (struct ImVector * const this)
{
  struct value_type * D.45165;
  struct value_type * _3;

  <bb 2>:
  _3 = this_2(D)->Data;

<L0>:
  return _3;

}



;; Function ImVector<T>::value_type* ImVector<T>::end() [with T = ImDrawCmd] (_ZN8ImVectorI9ImDrawCmdE3endEv, funcdef_no=1470, decl_uid=5090, cgraph_uid=1369, symbol_order=1381)

ImVector<T>::value_type* ImVector<T>::end() [with T = ImDrawCmd] (struct ImVector * const this)
{
  long unsigned int D.45163;
  long unsigned int D.45162;
  int D.45161;
  struct ImDrawCmd * D.45160;
  struct value_type * D.45159;
  struct ImDrawCmd * _3;
  int _4;
  long unsigned int _5;
  long unsigned int _6;
  struct value_type * _7;

  <bb 2>:
  _3 = this_2(D)->Data;
  _4 = this_2(D)->Size;
  _5 = (long unsigned int) _4;
  _6 = _5 * 48;
  _7 = _3 + _6;

<L0>:
  return _7;

}



;; Function ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImDrawVert] (_ZN8ImVectorI10ImDrawVertEixEi, funcdef_no=1471, decl_uid=5302, cgraph_uid=1370, symbol_order=1382)

ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImDrawVert] (struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[114] = "ImVector<T>::value_type& ImVector<T>::operator[](int) [with T = ImDrawVert; ImVector<T>::value_type = ImDrawVert]";
  long unsigned int D.45210;
  long unsigned int D.45209;
  struct ImDrawVert * D.45208;
  struct value_type & D.45207;
  int D.45203;
  int _3;
  struct ImDrawVert * _5;
  long unsigned int _6;
  long unsigned int _7;
  struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1169, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 20;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function const value_type& ImVector<T>::operator[](int) const [with T = ImGuiColumnData] (_ZNK8ImVectorI15ImGuiColumnDataEixEi, funcdef_no=1472, decl_uid=11415, cgraph_uid=1371, symbol_order=1383)

const value_type& ImVector<T>::operator[](int) const [with T = ImGuiColumnData] (const struct ImVector * const this, int i)
{
  static const char __PRETTY_FUNCTION__[123] = "const value_type& ImVector<T>::operator[](int) const [with T = ImGuiColumnData; ImVector<T>::value_type = ImGuiColumnData]";
  long unsigned int D.44970;
  long unsigned int D.44969;
  struct ImGuiColumnData * D.44968;
  const struct value_type & D.44967;
  int D.44963;
  int _3;
  struct ImGuiColumnData * _5;
  long unsigned int _6;
  long unsigned int _7;
  const struct value_type & _8;

  <bb 2>:
  _3 = this_2(D)->Size;
  if (_3 > i_4(D))
    goto <bb 4>;
  else
    goto <bb 3>;

  <bb 3>:
  __assert_fail ("i < Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1170, &__PRETTY_FUNCTION__);

  <bb 4>:
  _5 = this_2(D)->Data;
  _6 = (long unsigned int) i_4(D);
  _7 = _6 * 28;
  _8 = _5 + _7;

<L3>:
  return _8;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = char] (_ZNK8ImVectorIcE14_grow_capacityEi, funcdef_no=1473, decl_uid=4442, cgraph_uid=1372, symbol_order=1384)

int ImVector<T>::_grow_capacity(int) const [with T = char] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.137;
  int D.23954;
  int D.23952;
  int D.23951;
  int D.23950;
  int D.23947;
  int iftmp.136;
  int iftmp.136_1;
  int iftmp.137_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.136_9;
  int iftmp.136_10;
  int iftmp.137_13;
  int iftmp.137_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.136_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.136_10 = 8;

  <bb 5>:
  # iftmp.136_1 = PHI <iftmp.136_9(3), iftmp.136_10(4)>
  new_capacity_11 = iftmp.136_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.137_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.137_14 = sz_12(D);

  <bb 8>:
  # iftmp.137_2 = PHI <iftmp.137_13(6), iftmp.137_14(7)>
  _15 = iftmp.137_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImVec2] (_ZN8ImVectorI6ImVec2E7reserveEi, funcdef_no=1474, decl_uid=5654, cgraph_uid=1373, symbol_order=1385)

void ImVector<T>::reserve(int) [with T = ImVec2] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.29114;
  struct value_type * new_data;
  struct ImVec2 * D.29112;
  struct ImVec2 * D.29110;
  long unsigned int D.29109;
  long unsigned int D.29108;
  int D.29107;
  struct ImVec2 * D.29104;
  long unsigned int D.29103;
  long unsigned int D.29102;
  int D.29099;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImVec2 * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImVec2 * _16;
  struct ImVec2 * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImVec2] (_ZNK8ImVectorI6ImVec2E14_grow_capacityEi, funcdef_no=1475, decl_uid=5644, cgraph_uid=1374, symbol_order=1386)

int ImVector<T>::_grow_capacity(int) const [with T = ImVec2] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.383;
  int D.29093;
  int D.29091;
  int D.29090;
  int D.29089;
  int D.29086;
  int iftmp.382;
  int iftmp.382_1;
  int iftmp.383_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.382_9;
  int iftmp.382_10;
  int iftmp.383_13;
  int iftmp.383_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.382_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.382_10 = 8;

  <bb 5>:
  # iftmp.382_1 = PHI <iftmp.382_9(3), iftmp.382_10(4)>
  new_capacity_11 = iftmp.382_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.383_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.383_14 = sz_12(D);

  <bb 8>:
  # iftmp.383_2 = PHI <iftmp.383_13(6), iftmp.383_14(7)>
  _15 = iftmp.383_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = unsigned char] (_ZN8ImVectorIhE7reserveEi, funcdef_no=1476, decl_uid=6366, cgraph_uid=1375, symbol_order=1387)

void ImVector<T>::reserve(int) [with T = unsigned char] (struct ImVector * const this, int new_capacity)
{
  value_type * D.44479;
  value_type * new_data;
  unsigned char * D.44477;
  unsigned char * D.44475;
  long unsigned int D.44474;
  int D.44473;
  unsigned char * D.44470;
  long unsigned int D.44469;
  int D.44466;
  int _5;
  long unsigned int _7;
  value_type * _9;
  unsigned char * _11;
  int _12;
  long unsigned int _13;
  unsigned char * _14;
  unsigned char * _16;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _9 = ImGui::MemAlloc (_7);
  new_data_10 = _9;
  _11 = this_4(D)->Data;
  if (_11 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _12 = this_4(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = this_4(D)->Data;
  memcpy (new_data_10, _14, _13);

  <bb 6>:
  _16 = this_4(D)->Data;
  ImGui::MemFree (_16);
  this_4(D)->Data = new_data_10;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = unsigned char] (_ZNK8ImVectorIhE14_grow_capacityEi, funcdef_no=1477, decl_uid=6356, cgraph_uid=1376, symbol_order=1388)

int ImVector<T>::_grow_capacity(int) const [with T = unsigned char] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1961;
  int D.44460;
  int D.44458;
  int D.44457;
  int D.44456;
  int D.44453;
  int iftmp.1960;
  int iftmp.1960_1;
  int iftmp.1961_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1960_9;
  int iftmp.1960_10;
  int iftmp.1961_13;
  int iftmp.1961_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1960_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1960_10 = 8;

  <bb 5>:
  # iftmp.1960_1 = PHI <iftmp.1960_9(3), iftmp.1960_10(4)>
  new_capacity_11 = iftmp.1960_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1961_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1961_14 = sz_12(D);

  <bb 8>:
  # iftmp.1961_2 = PHI <iftmp.1961_13(6), iftmp.1961_14(7)>
  _15 = iftmp.1961_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImDrawList*] (_ZN8ImVectorIP10ImDrawListE7reserveEi, funcdef_no=1478, decl_uid=11598, cgraph_uid=1377, symbol_order=1389)

void ImVector<T>::reserve(int) [with T = ImDrawList*] (struct ImVector * const this, int new_capacity)
{
  struct ImDrawList * * D.28397;
  struct ImDrawList * * new_data;
  struct ImDrawList * * D.28395;
  struct ImDrawList * * D.28393;
  long unsigned int D.28392;
  long unsigned int D.28391;
  int D.28390;
  struct ImDrawList * * D.28387;
  long unsigned int D.28386;
  long unsigned int D.28385;
  int D.28382;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct ImDrawList * * _10;
  struct ImDrawList * * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImDrawList * * _16;
  struct ImDrawList * * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImDrawList*] (_ZNK8ImVectorIP10ImDrawListE14_grow_capacityEi, funcdef_no=1479, decl_uid=11588, cgraph_uid=1378, symbol_order=1390)

int ImVector<T>::_grow_capacity(int) const [with T = ImDrawList*] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.353;
  int D.28376;
  int D.28374;
  int D.28373;
  int D.28372;
  int D.28369;
  int iftmp.352;
  int iftmp.352_1;
  int iftmp.353_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.352_9;
  int iftmp.352_10;
  int iftmp.353_13;
  int iftmp.353_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.352_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.352_10 = 8;

  <bb 5>:
  # iftmp.352_1 = PHI <iftmp.352_9(3), iftmp.352_10(4)>
  new_capacity_11 = iftmp.352_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.353_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.353_14 = sz_12(D);

  <bb 8>:
  # iftmp.353_2 = PHI <iftmp.353_13(6), iftmp.353_14(7)>
  _15 = iftmp.353_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiStorage::Pair] (_ZN8ImVectorIN12ImGuiStorage4PairEE7reserveEi, funcdef_no=1480, decl_uid=4649, cgraph_uid=1379, symbol_order=1391)

void ImVector<T>::reserve(int) [with T = ImGuiStorage::Pair] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.23563;
  struct value_type * new_data;
  struct Pair * D.23561;
  struct Pair * D.23559;
  long unsigned int D.23558;
  long unsigned int D.23557;
  int D.23556;
  struct Pair * D.23553;
  long unsigned int D.23552;
  long unsigned int D.23551;
  int D.23548;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct Pair * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct Pair * _16;
  struct Pair * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 16;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 16;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiStorage::Pair] (_ZNK8ImVectorIN12ImGuiStorage4PairEE14_grow_capacityEi, funcdef_no=1481, decl_uid=4639, cgraph_uid=1380, symbol_order=1392)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiStorage::Pair] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.105;
  int D.23542;
  int D.23540;
  int D.23539;
  int D.23538;
  int D.23535;
  int iftmp.104;
  int iftmp.104_1;
  int iftmp.105_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.104_9;
  int iftmp.104_10;
  int iftmp.105_13;
  int iftmp.105_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.104_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.104_10 = 8;

  <bb 5>:
  # iftmp.104_1 = PHI <iftmp.104_9(3), iftmp.104_10(4)>
  new_capacity_11 = iftmp.104_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.105_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.105_14 = sz_12(D);

  <bb 8>:
  # iftmp.105_2 = PHI <iftmp.105_13(6), iftmp.105_14(7)>
  _15 = iftmp.105_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiTextFilter::TextRange] (_ZN8ImVectorIN15ImGuiTextFilter9TextRangeEE7reserveEi, funcdef_no=1482, decl_uid=4303, cgraph_uid=1381, symbol_order=1393)

void ImVector<T>::reserve(int) [with T = ImGuiTextFilter::TextRange] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.23747;
  struct value_type * new_data;
  struct TextRange * D.23745;
  struct TextRange * D.23743;
  long unsigned int D.23742;
  long unsigned int D.23741;
  int D.23740;
  struct TextRange * D.23737;
  long unsigned int D.23736;
  long unsigned int D.23735;
  int D.23732;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct TextRange * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct TextRange * _16;
  struct TextRange * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 16;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 16;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiTextFilter::TextRange] (_ZNK8ImVectorIN15ImGuiTextFilter9TextRangeEE14_grow_capacityEi, funcdef_no=1483, decl_uid=4293, cgraph_uid=1382, symbol_order=1394)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiTextFilter::TextRange] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.119;
  int D.23726;
  int D.23724;
  int D.23723;
  int D.23722;
  int D.23719;
  int iftmp.118;
  int iftmp.118_1;
  int iftmp.119_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.118_9;
  int iftmp.118_10;
  int iftmp.119_13;
  int iftmp.119_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.118_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.118_10 = 8;

  <bb 5>:
  # iftmp.118_1 = PHI <iftmp.118_9(3), iftmp.118_10(4)>
  new_capacity_11 = iftmp.118_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.119_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.119_14 = sz_12(D);

  <bb 8>:
  # iftmp.119_2 = PHI <iftmp.119_13(6), iftmp.119_14(7)>
  _15 = iftmp.119_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = unsigned int] (_ZN8ImVectorIjE7reserveEi, funcdef_no=1484, decl_uid=13406, cgraph_uid=1383, symbol_order=1395)

void ImVector<T>::reserve(int) [with T = unsigned int] (struct ImVector * const this, int new_capacity)
{
  value_type * D.24280;
  value_type * new_data;
  unsigned int * D.24278;
  unsigned int * D.24276;
  long unsigned int D.24275;
  long unsigned int D.24274;
  int D.24273;
  unsigned int * D.24270;
  long unsigned int D.24269;
  long unsigned int D.24268;
  int D.24265;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  value_type * _10;
  unsigned int * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  unsigned int * _16;
  unsigned int * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 4;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 4;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = unsigned int] (_ZNK8ImVectorIjE14_grow_capacityEi, funcdef_no=1485, decl_uid=13396, cgraph_uid=1384, symbol_order=1396)

int ImVector<T>::_grow_capacity(int) const [with T = unsigned int] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.145;
  int D.24259;
  int D.24257;
  int D.24256;
  int D.24255;
  int D.24252;
  int iftmp.144;
  int iftmp.144_1;
  int iftmp.145_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.144_9;
  int iftmp.144_10;
  int iftmp.145_13;
  int iftmp.145_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.144_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.144_10 = 8;

  <bb 5>:
  # iftmp.144_1 = PHI <iftmp.144_9(3), iftmp.144_10(4)>
  new_capacity_11 = iftmp.144_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.145_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.145_14 = sz_12(D);

  <bb 8>:
  # iftmp.145_2 = PHI <iftmp.145_13(6), iftmp.145_14(7)>
  _15 = iftmp.145_2;

<L6>:
  return _15;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiWindow*] (_ZNK8ImVectorIP11ImGuiWindowE14_grow_capacityEi, funcdef_no=1486, decl_uid=11806, cgraph_uid=1385, symbol_order=1397)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiWindow*] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.303;
  int D.27579;
  int D.27577;
  int D.27576;
  int D.27575;
  int D.27572;
  int iftmp.302;
  int iftmp.302_1;
  int iftmp.303_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.302_9;
  int iftmp.302_10;
  int iftmp.303_13;
  int iftmp.303_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.302_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.302_10 = 8;

  <bb 5>:
  # iftmp.302_1 = PHI <iftmp.302_9(3), iftmp.302_10(4)>
  new_capacity_11 = iftmp.302_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.303_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.303_14 = sz_12(D);

  <bb 8>:
  # iftmp.303_2 = PHI <iftmp.303_13(6), iftmp.303_14(7)>
  _15 = iftmp.303_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiPopupRef] (_ZN8ImVectorI13ImGuiPopupRefE7reserveEi, funcdef_no=1487, decl_uid=12148, cgraph_uid=1386, symbol_order=1398)

void ImVector<T>::reserve(int) [with T = ImGuiPopupRef] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.27635;
  struct value_type * new_data;
  struct ImGuiPopupRef * D.27633;
  struct ImGuiPopupRef * D.27631;
  long unsigned int D.27630;
  long unsigned int D.27629;
  int D.27628;
  struct ImGuiPopupRef * D.27625;
  long unsigned int D.27624;
  long unsigned int D.27623;
  int D.27620;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiPopupRef * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiPopupRef * _16;
  struct ImGuiPopupRef * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 48;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 48;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiPopupRef] (_ZNK8ImVectorI13ImGuiPopupRefE14_grow_capacityEi, funcdef_no=1488, decl_uid=12138, cgraph_uid=1387, symbol_order=1399)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiPopupRef] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.305;
  int D.27614;
  int D.27612;
  int D.27611;
  int D.27610;
  int D.27607;
  int iftmp.304;
  int iftmp.304_1;
  int iftmp.305_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.304_9;
  int iftmp.304_10;
  int iftmp.305_13;
  int iftmp.305_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.304_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.304_10 = 8;

  <bb 5>:
  # iftmp.304_1 = PHI <iftmp.304_9(3), iftmp.304_10(4)>
  new_capacity_11 = iftmp.304_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.305_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.305_14 = sz_12(D);

  <bb 8>:
  # iftmp.305_2 = PHI <iftmp.305_13(6), iftmp.305_14(7)>
  _15 = iftmp.305_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::push_back(const value_type&) [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerE9push_backERKS0_, funcdef_no=1489, decl_uid=12429, cgraph_uid=1388, symbol_order=1400)

void ImVector<T>::push_back(const value_type&) [with T = ImGuiSettingsHandler] (struct ImVector * const this, const struct value_type & v)
{
  int D.27778;
  int D.27777;
  struct ImGuiSettingsHandler * D.27776;
  long unsigned int D.27775;
  long unsigned int D.27774;
  int D.27773;
  struct ImGuiSettingsHandler * D.27772;
  int D.27770;
  int D.27769;
  int D.27768;
  int D.27765;
  int D.27764;
  int _4;
  int _5;
  int _6;
  int _7;
  int _9;
  struct ImGuiSettingsHandler * _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  struct ImGuiSettingsHandler * _15;
  int _18;
  int _19;

  <bb 2>:
  _4 = this_3(D)->Size;
  _5 = this_3(D)->Capacity;
  if (_4 == _5)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_3(D)->Size;
  _7 = _6 + 1;
  _9 = ImVector<ImGuiSettingsHandler>::_grow_capacity (this_3(D), _7);
  ImVector<ImGuiSettingsHandler>::reserve (this_3(D), _9);

  <bb 4>:
  _11 = this_3(D)->Data;
  _12 = this_3(D)->Size;
  _13 = (long unsigned int) _12;
  _14 = _13 * 48;
  _15 = _11 + _14;
  memcpy (_15, v_16(D), 48);
  _18 = this_3(D)->Size;
  _19 = _18 + 1;
  this_3(D)->Size = _19;
  return;

}



;; Function ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerE6insertEPKS0_RS2_, funcdef_no=1490, decl_uid=12440, cgraph_uid=1389, symbol_order=1401)

ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiSettingsHandler] (struct ImVector * const this, const struct value_type * it, const struct value_type & v)
{
  const ptrdiff_t off;
  static const char __PRETTY_FUNCTION__[279] = "ImVector<T>::value_type* ImVector<T>::insert(ImVector<T>::const_iterator, const value_type&) [with T = ImGuiSettingsHandler; ImVector<T>::iterator = ImGuiSettingsHandler*; ImVector<T>::value_type = ImGuiSettingsHandler; ImVector<T>::const_iterator = const ImGuiSettingsHandler*]";
  long unsigned int D.27859;
  long unsigned int off.322;
  struct ImGuiSettingsHandler * D.27857;
  struct value_type * D.27856;
  int D.27855;
  int D.27854;
  struct ImGuiSettingsHandler * D.27853;
  long unsigned int D.27852;
  long unsigned int off.321;
  struct ImGuiSettingsHandler * D.27850;
  struct ImGuiSettingsHandler * D.27848;
  sizetype D.27847;
  sizetype D.27846;
  sizetype off.320;
  struct ImGuiSettingsHandler * D.27844;
  struct ImGuiSettingsHandler * D.27843;
  long unsigned int D.27842;
  long unsigned int off.319;
  struct ImGuiSettingsHandler * D.27840;
  long unsigned int D.27839;
  long unsigned int D.27838;
  long unsigned int off.318;
  long unsigned int D.27836;
  int D.27835;
  long int D.27832;
  int D.27831;
  int D.27829;
  int D.27828;
  int D.27827;
  int D.27824;
  int D.27823;
  long int D.27822;
  long int D.27821;
  struct ImGuiSettingsHandler * D.27820;
  long int it.317;
  struct ImGuiSettingsHandler * D.27817;
  long unsigned int D.27816;
  long unsigned int D.27815;
  int D.27814;
  struct ImGuiSettingsHandler * D.27813;
  struct ImGuiSettingsHandler * D.27811;
  struct ImGuiSettingsHandler * _5;
  struct ImGuiSettingsHandler * _7;
  int _8;
  long unsigned int _9;
  long unsigned int _10;
  struct ImGuiSettingsHandler * _11;
  long int it.317_12;
  struct ImGuiSettingsHandler * _13;
  long int _14;
  long int _15;
  int _17;
  int _18;
  int _19;
  int _20;
  int _22;
  int _24;
  long int _25;
  int _26;
  long unsigned int _27;
  long unsigned int off.318_28;
  long unsigned int _29;
  long unsigned int _30;
  struct ImGuiSettingsHandler * _31;
  long unsigned int off.319_32;
  long unsigned int _33;
  struct ImGuiSettingsHandler * _34;
  struct ImGuiSettingsHandler * _35;
  sizetype off.320_36;
  sizetype _37;
  sizetype _38;
  struct ImGuiSettingsHandler * _39;
  struct ImGuiSettingsHandler * _41;
  long unsigned int off.321_42;
  long unsigned int _43;
  struct ImGuiSettingsHandler * _44;
  int _47;
  int _48;
  struct ImGuiSettingsHandler * _50;
  long unsigned int off.322_51;
  long unsigned int _52;
  struct value_type * _53;

  <bb 2>:
  _5 = this_4(D)->Data;
  if (_5 <= it_6(D))
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  _7 = this_4(D)->Data;
  _8 = this_4(D)->Size;
  _9 = (long unsigned int) _8;
  _10 = _9 * 48;
  _11 = _7 + _10;
  if (_11 >= it_6(D))
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  goto <bb 6>;

  <bb 5>:
  __assert_fail ("it >= Data && it <= Data+Size", "/home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.h", 1203, &__PRETTY_FUNCTION__);

  <bb 6>:
  it.317_12 = (long int) it_6(D);
  _13 = this_4(D)->Data;
  _14 = (long int) _13;
  _15 = it.317_12 - _14;
  off_16 = _15 /[ex] 48;
  _17 = this_4(D)->Size;
  _18 = this_4(D)->Capacity;
  if (_17 == _18)
    goto <bb 7>;
  else
    goto <bb 8>;

  <bb 7>:
  _19 = this_4(D)->Size;
  _20 = _19 + 1;
  _22 = ImVector<ImGuiSettingsHandler>::_grow_capacity (this_4(D), _20);
  ImVector<ImGuiSettingsHandler>::reserve (this_4(D), _22);

  <bb 8>:
  _24 = this_4(D)->Size;
  _25 = (long int) _24;
  if (_25 > off_16)
    goto <bb 9>;
  else
    goto <bb 10>;

  <bb 9>:
  _26 = this_4(D)->Size;
  _27 = (long unsigned int) _26;
  off.318_28 = (long unsigned int) off_16;
  _29 = _27 - off.318_28;
  _30 = _29 * 48;
  _31 = this_4(D)->Data;
  off.319_32 = (long unsigned int) off_16;
  _33 = off.319_32 * 48;
  _34 = _31 + _33;
  _35 = this_4(D)->Data;
  off.320_36 = (sizetype) off_16;
  _37 = off.320_36 + 1;
  _38 = _37 * 48;
  _39 = _35 + _38;
  memmove (_39, _34, _30);

  <bb 10>:
  _41 = this_4(D)->Data;
  off.321_42 = (long unsigned int) off_16;
  _43 = off.321_42 * 48;
  _44 = _41 + _43;
  memcpy (_44, v_45(D), 48);
  _47 = this_4(D)->Size;
  _48 = _47 + 1;
  this_4(D)->Size = _48;
  _50 = this_4(D)->Data;
  off.322_51 = (long unsigned int) off_16;
  _52 = off.322_51 * 48;
  _53 = _50 + _52;

<L10>:
  return _53;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiWindowSettings] (_ZN8ImVectorI19ImGuiWindowSettingsE7reserveEi, funcdef_no=1491, decl_uid=12323, cgraph_uid=1390, symbol_order=1402)

void ImVector<T>::reserve(int) [with T = ImGuiWindowSettings] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.28073;
  struct value_type * new_data;
  struct ImGuiWindowSettings * D.28071;
  struct ImGuiWindowSettings * D.28069;
  long unsigned int D.28068;
  long unsigned int D.28067;
  int D.28066;
  struct ImGuiWindowSettings * D.28063;
  long unsigned int D.28062;
  long unsigned int D.28061;
  int D.28058;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiWindowSettings * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiWindowSettings * _16;
  struct ImGuiWindowSettings * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 32;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 32;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiWindowSettings] (_ZNK8ImVectorI19ImGuiWindowSettingsE14_grow_capacityEi, funcdef_no=1492, decl_uid=12313, cgraph_uid=1391, symbol_order=1403)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiWindowSettings] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.326;
  int D.28052;
  int D.28050;
  int D.28049;
  int D.28048;
  int D.28045;
  int iftmp.325;
  int iftmp.325_1;
  int iftmp.326_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.325_9;
  int iftmp.325_10;
  int iftmp.326_13;
  int iftmp.326_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.325_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.325_10 = 8;

  <bb 5>:
  # iftmp.325_1 = PHI <iftmp.325_9(3), iftmp.325_10(4)>
  new_capacity_11 = iftmp.325_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.326_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.326_14 = sz_12(D);

  <bb 8>:
  # iftmp.326_2 = PHI <iftmp.326_13(6), iftmp.326_14(7)>
  _15 = iftmp.326_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = int] (_ZN8ImVectorIiE7reserveEi, funcdef_no=1493, decl_uid=13094, cgraph_uid=1392, symbol_order=1404)

void ImVector<T>::reserve(int) [with T = int] (struct ImVector * const this, int new_capacity)
{
  value_type * D.32850;
  value_type * new_data;
  int * D.32848;
  int * D.32846;
  long unsigned int D.32845;
  long unsigned int D.32844;
  int D.32843;
  int * D.32840;
  long unsigned int D.32839;
  long unsigned int D.32838;
  int D.32835;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  value_type * _10;
  int * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  int * _16;
  int * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 4;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 4;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = int] (_ZNK8ImVectorIiE14_grow_capacityEi, funcdef_no=1494, decl_uid=13084, cgraph_uid=1393, symbol_order=1405)

int ImVector<T>::_grow_capacity(int) const [with T = int] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1002;
  int D.32829;
  int D.32827;
  int D.32826;
  int D.32825;
  int D.32822;
  int iftmp.1001;
  int iftmp.1001_1;
  int iftmp.1002_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1001_9;
  int iftmp.1001_10;
  int iftmp.1002_13;
  int iftmp.1002_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1001_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1001_10 = 8;

  <bb 5>:
  # iftmp.1001_1 = PHI <iftmp.1001_9(3), iftmp.1001_10(4)>
  new_capacity_11 = iftmp.1001_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1002_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1002_14 = sz_12(D);

  <bb 8>:
  # iftmp.1002_2 = PHI <iftmp.1002_13(6), iftmp.1002_14(7)>
  _15 = iftmp.1002_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = float] (_ZN8ImVectorIfE7reserveEi, funcdef_no=1495, decl_uid=7015, cgraph_uid=1394, symbol_order=1406)

void ImVector<T>::reserve(int) [with T = float] (struct ImVector * const this, int new_capacity)
{
  value_type * D.32885;
  value_type * new_data;
  float * D.32883;
  float * D.32881;
  long unsigned int D.32880;
  long unsigned int D.32879;
  int D.32878;
  float * D.32875;
  long unsigned int D.32874;
  long unsigned int D.32873;
  int D.32870;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  value_type * _10;
  float * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  float * _16;
  float * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 4;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 4;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = float] (_ZNK8ImVectorIfE14_grow_capacityEi, funcdef_no=1496, decl_uid=7005, cgraph_uid=1395, symbol_order=1407)

int ImVector<T>::_grow_capacity(int) const [with T = float] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1004;
  int D.32864;
  int D.32862;
  int D.32861;
  int D.32860;
  int D.32857;
  int iftmp.1003;
  int iftmp.1003_1;
  int iftmp.1004_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1003_9;
  int iftmp.1003_10;
  int iftmp.1004_13;
  int iftmp.1004_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1003_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1003_10 = 8;

  <bb 5>:
  # iftmp.1003_1 = PHI <iftmp.1003_9(3), iftmp.1003_10(4)>
  new_capacity_11 = iftmp.1003_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1004_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1004_14 = sz_12(D);

  <bb 8>:
  # iftmp.1004_2 = PHI <iftmp.1004_13(6), iftmp.1004_14(7)>
  _15 = iftmp.1004_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiGroupData] (_ZN8ImVectorI14ImGuiGroupDataE7reserveEi, funcdef_no=1497, decl_uid=13199, cgraph_uid=1396, symbol_order=1408)

void ImVector<T>::reserve(int) [with T = ImGuiGroupData] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.32920;
  struct value_type * new_data;
  struct ImGuiGroupData * D.32918;
  struct ImGuiGroupData * D.32916;
  long unsigned int D.32915;
  long unsigned int D.32914;
  int D.32913;
  struct ImGuiGroupData * D.32910;
  long unsigned int D.32909;
  long unsigned int D.32908;
  int D.32905;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiGroupData * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiGroupData * _16;
  struct ImGuiGroupData * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 40;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 40;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiGroupData] (_ZNK8ImVectorI14ImGuiGroupDataE14_grow_capacityEi, funcdef_no=1498, decl_uid=13189, cgraph_uid=1397, symbol_order=1409)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiGroupData] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1006;
  int D.32899;
  int D.32897;
  int D.32896;
  int D.32895;
  int D.32892;
  int iftmp.1005;
  int iftmp.1005_1;
  int iftmp.1006_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1005_9;
  int iftmp.1005_10;
  int iftmp.1006_13;
  int iftmp.1006_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1005_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1005_10 = 8;

  <bb 5>:
  # iftmp.1005_1 = PHI <iftmp.1005_9(3), iftmp.1005_10(4)>
  new_capacity_11 = iftmp.1005_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1006_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1006_14 = sz_12(D);

  <bb 8>:
  # iftmp.1006_2 = PHI <iftmp.1006_13(6), iftmp.1006_14(7)>
  _15 = iftmp.1006_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImFont*] (_ZN8ImVectorIP6ImFontE7reserveEi, funcdef_no=1499, decl_uid=6559, cgraph_uid=1398, symbol_order=1410)

void ImVector<T>::reserve(int) [with T = ImFont*] (struct ImVector * const this, int new_capacity)
{
  struct ImFont * * D.33552;
  struct ImFont * * new_data;
  struct ImFont * * D.33550;
  struct ImFont * * D.33548;
  long unsigned int D.33547;
  long unsigned int D.33546;
  int D.33545;
  struct ImFont * * D.33542;
  long unsigned int D.33541;
  long unsigned int D.33540;
  int D.33537;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct ImFont * * _10;
  struct ImFont * * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImFont * * _16;
  struct ImFont * * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 8;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 8;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImFont*] (_ZNK8ImVectorIP6ImFontE14_grow_capacityEi, funcdef_no=1500, decl_uid=6549, cgraph_uid=1399, symbol_order=1411)

int ImVector<T>::_grow_capacity(int) const [with T = ImFont*] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1058;
  int D.33531;
  int D.33529;
  int D.33528;
  int D.33527;
  int D.33524;
  int iftmp.1057;
  int iftmp.1057_1;
  int iftmp.1058_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1057_9;
  int iftmp.1057_10;
  int iftmp.1058_13;
  int iftmp.1058_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1057_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1057_10 = 8;

  <bb 5>:
  # iftmp.1057_1 = PHI <iftmp.1057_9(3), iftmp.1057_10(4)>
  new_capacity_11 = iftmp.1057_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1058_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1058_14 = sz_12(D);

  <bb 8>:
  # iftmp.1058_2 = PHI <iftmp.1058_13(6), iftmp.1058_14(7)>
  _15 = iftmp.1058_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiColMod] (_ZN8ImVectorI11ImGuiColModE7reserveEi, funcdef_no=1501, decl_uid=11941, cgraph_uid=1400, symbol_order=1412)

void ImVector<T>::reserve(int) [with T = ImGuiColMod] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.33684;
  struct value_type * new_data;
  struct ImGuiColMod * D.33682;
  struct ImGuiColMod * D.33680;
  long unsigned int D.33679;
  long unsigned int D.33678;
  int D.33677;
  struct ImGuiColMod * D.33674;
  long unsigned int D.33673;
  long unsigned int D.33672;
  int D.33669;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiColMod * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiColMod * _16;
  struct ImGuiColMod * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 20;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 20;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiColMod] (_ZNK8ImVectorI11ImGuiColModE14_grow_capacityEi, funcdef_no=1502, decl_uid=11931, cgraph_uid=1401, symbol_order=1413)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiColMod] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1064;
  int D.33663;
  int D.33661;
  int D.33660;
  int D.33659;
  int D.33656;
  int iftmp.1063;
  int iftmp.1063_1;
  int iftmp.1064_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1063_9;
  int iftmp.1063_10;
  int iftmp.1064_13;
  int iftmp.1064_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1063_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1063_10 = 8;

  <bb 5>:
  # iftmp.1063_1 = PHI <iftmp.1063_9(3), iftmp.1063_10(4)>
  new_capacity_11 = iftmp.1063_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1064_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1064_14 = sz_12(D);

  <bb 8>:
  # iftmp.1064_2 = PHI <iftmp.1064_13(6), iftmp.1064_14(7)>
  _15 = iftmp.1064_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiStyleMod] (_ZN8ImVectorI13ImGuiStyleModE7reserveEi, funcdef_no=1503, decl_uid=12044, cgraph_uid=1402, symbol_order=1414)

void ImVector<T>::reserve(int) [with T = ImGuiStyleMod] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.33780;
  struct value_type * new_data;
  struct ImGuiStyleMod * D.33778;
  struct ImGuiStyleMod * D.33776;
  long unsigned int D.33775;
  long unsigned int D.33774;
  int D.33773;
  struct ImGuiStyleMod * D.33770;
  long unsigned int D.33769;
  long unsigned int D.33768;
  int D.33765;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiStyleMod * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiStyleMod * _16;
  struct ImGuiStyleMod * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 12;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 12;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiStyleMod] (_ZNK8ImVectorI13ImGuiStyleModE14_grow_capacityEi, funcdef_no=1504, decl_uid=12034, cgraph_uid=1403, symbol_order=1415)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiStyleMod] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1066;
  int D.33759;
  int D.33757;
  int D.33756;
  int D.33755;
  int D.33752;
  int iftmp.1065;
  int iftmp.1065_1;
  int iftmp.1066_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1065_9;
  int iftmp.1065_10;
  int iftmp.1066_13;
  int iftmp.1066_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1065_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1065_10 = 8;

  <bb 5>:
  # iftmp.1065_1 = PHI <iftmp.1065_9(3), iftmp.1065_10(4)>
  new_capacity_11 = iftmp.1065_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1066_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1066_14 = sz_12(D);

  <bb 8>:
  # iftmp.1066_2 = PHI <iftmp.1066_13(6), iftmp.1066_14(7)>
  _15 = iftmp.1066_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = short unsigned int] (_ZN8ImVectorItE7reserveEi, funcdef_no=1505, decl_uid=5218, cgraph_uid=1404, symbol_order=1416)

void ImVector<T>::reserve(int) [with T = short unsigned int] (struct ImVector * const this, int new_capacity)
{
  value_type * D.40321;
  value_type * new_data;
  short unsigned int * D.40319;
  short unsigned int * D.40317;
  long unsigned int D.40316;
  long unsigned int D.40315;
  int D.40314;
  short unsigned int * D.40311;
  long unsigned int D.40310;
  long unsigned int D.40309;
  int D.40306;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  value_type * _10;
  short unsigned int * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  short unsigned int * _16;
  short unsigned int * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 2;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 2;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = short unsigned int] (_ZNK8ImVectorItE14_grow_capacityEi, funcdef_no=1506, decl_uid=5208, cgraph_uid=1405, symbol_order=1417)

int ImVector<T>::_grow_capacity(int) const [with T = short unsigned int] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1696;
  int D.40300;
  int D.40298;
  int D.40297;
  int D.40296;
  int D.40293;
  int iftmp.1695;
  int iftmp.1695_1;
  int iftmp.1696_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1695_9;
  int iftmp.1695_10;
  int iftmp.1696_13;
  int iftmp.1696_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1695_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1695_10 = 8;

  <bb 5>:
  # iftmp.1695_1 = PHI <iftmp.1695_9(3), iftmp.1695_10(4)>
  new_capacity_11 = iftmp.1695_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1696_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1696_14 = sz_12(D);

  <bb 8>:
  # iftmp.1696_2 = PHI <iftmp.1696_13(6), iftmp.1696_14(7)>
  _15 = iftmp.1696_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiColumnsSet] (_ZN8ImVectorI15ImGuiColumnsSetE7reserveEi, funcdef_no=1507, decl_uid=13517, cgraph_uid=1406, symbol_order=1418)

void ImVector<T>::reserve(int) [with T = ImGuiColumnsSet] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.43899;
  struct value_type * new_data;
  struct ImGuiColumnsSet * D.43897;
  struct ImGuiColumnsSet * D.43895;
  long unsigned int D.43894;
  long unsigned int D.43893;
  int D.43892;
  struct ImGuiColumnsSet * D.43889;
  long unsigned int D.43888;
  long unsigned int D.43887;
  int D.43884;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiColumnsSet * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiColumnsSet * _16;
  struct ImGuiColumnsSet * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 64;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 64;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiColumnsSet] (_ZNK8ImVectorI15ImGuiColumnsSetE14_grow_capacityEi, funcdef_no=1508, decl_uid=13507, cgraph_uid=1407, symbol_order=1419)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiColumnsSet] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1934;
  int D.43878;
  int D.43876;
  int D.43875;
  int D.43874;
  int D.43871;
  int iftmp.1933;
  int iftmp.1933_1;
  int iftmp.1934_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1933_9;
  int iftmp.1933_10;
  int iftmp.1934_13;
  int iftmp.1934_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1933_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1933_10 = 8;

  <bb 5>:
  # iftmp.1933_1 = PHI <iftmp.1933_9(3), iftmp.1933_10(4)>
  new_capacity_11 = iftmp.1933_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1934_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1934_14 = sz_12(D);

  <bb 8>:
  # iftmp.1934_2 = PHI <iftmp.1934_13(6), iftmp.1934_14(7)>
  _15 = iftmp.1934_2;

<L6>:
  return _15;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiColumnData] (_ZNK8ImVectorI15ImGuiColumnDataE14_grow_capacityEi, funcdef_no=1509, decl_uid=11439, cgraph_uid=1408, symbol_order=1420)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiColumnData] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.1939;
  int D.44019;
  int D.44017;
  int D.44016;
  int D.44015;
  int D.44012;
  int iftmp.1938;
  int iftmp.1938_1;
  int iftmp.1939_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.1938_9;
  int iftmp.1938_10;
  int iftmp.1939_13;
  int iftmp.1939_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.1938_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.1938_10 = 8;

  <bb 5>:
  # iftmp.1938_1 = PHI <iftmp.1938_9(3), iftmp.1938_10(4)>
  new_capacity_11 = iftmp.1938_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.1939_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.1939_14 = sz_12(D);

  <bb 8>:
  # iftmp.1939_2 = PHI <iftmp.1939_13(6), iftmp.1939_14(7)>
  _15 = iftmp.1939_2;

<L6>:
  return _15;

}



;; Function void ImVector<T>::reserve(int) [with T = ImGuiSettingsHandler] (_ZN8ImVectorI20ImGuiSettingsHandlerE7reserveEi, funcdef_no=1510, decl_uid=12426, cgraph_uid=1409, symbol_order=1421)

void ImVector<T>::reserve(int) [with T = ImGuiSettingsHandler] (struct ImVector * const this, int new_capacity)
{
  struct value_type * D.27808;
  struct value_type * new_data;
  struct ImGuiSettingsHandler * D.27806;
  struct ImGuiSettingsHandler * D.27804;
  long unsigned int D.27803;
  long unsigned int D.27802;
  int D.27801;
  struct ImGuiSettingsHandler * D.27798;
  long unsigned int D.27797;
  long unsigned int D.27796;
  int D.27793;
  int _5;
  long unsigned int _7;
  long unsigned int _8;
  struct value_type * _10;
  struct ImGuiSettingsHandler * _12;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  struct ImGuiSettingsHandler * _16;
  struct ImGuiSettingsHandler * _18;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 >= new_capacity_6(D))
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  goto <bb 7> (<L5>);

  <bb 4>:
  _7 = (long unsigned int) new_capacity_6(D);
  _8 = _7 * 48;
  _10 = ImGui::MemAlloc (_8);
  new_data_11 = _10;
  _12 = this_4(D)->Data;
  if (_12 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

  <bb 5>:
  _13 = this_4(D)->Size;
  _14 = (long unsigned int) _13;
  _15 = _14 * 48;
  _16 = this_4(D)->Data;
  memcpy (new_data_11, _16, _15);

  <bb 6>:
  _18 = this_4(D)->Data;
  ImGui::MemFree (_18);
  this_4(D)->Data = new_data_11;
  this_4(D)->Capacity = new_capacity_6(D);

<L5>:
  return;

}



;; Function int ImVector<T>::_grow_capacity(int) const [with T = ImGuiSettingsHandler] (_ZNK8ImVectorI20ImGuiSettingsHandlerE14_grow_capacityEi, funcdef_no=1511, decl_uid=12416, cgraph_uid=1410, symbol_order=1422)

int ImVector<T>::_grow_capacity(int) const [with T = ImGuiSettingsHandler] (const struct ImVector * const this, int sz)
{
  int new_capacity;
  int iftmp.316;
  int D.27787;
  int D.27785;
  int D.27784;
  int D.27783;
  int D.27780;
  int iftmp.315;
  int iftmp.315_1;
  int iftmp.316_2;
  int _5;
  int _6;
  int _7;
  int _8;
  int iftmp.315_9;
  int iftmp.315_10;
  int iftmp.316_13;
  int iftmp.316_14;
  int _15;

  <bb 2>:
  _5 = this_4(D)->Capacity;
  if (_5 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

  <bb 3>:
  _6 = this_4(D)->Capacity;
  _7 = this_4(D)->Capacity;
  _8 = _7 / 2;
  iftmp.315_9 = _6 + _8;
  goto <bb 5>;

  <bb 4>:
  iftmp.315_10 = 8;

  <bb 5>:
  # iftmp.315_1 = PHI <iftmp.315_9(3), iftmp.315_10(4)>
  new_capacity_11 = iftmp.315_1;
  if (new_capacity_11 > sz_12(D))
    goto <bb 6>;
  else
    goto <bb 7>;

  <bb 6>:
  iftmp.316_13 = new_capacity_11;
  goto <bb 8>;

  <bb 7>:
  iftmp.316_14 = sz_12(D);

  <bb 8>:
  # iftmp.316_2 = PHI <iftmp.316_13(6), iftmp.316_14(7)>
  _15 = iftmp.316_2;

<L6>:
  return _15;

}



;; Function void __static_initialization_and_destruction_0(int, int) (_Z41__static_initialization_and_destruction_0ii, funcdef_no=1512, decl_uid=22364, cgraph_uid=1411, symbol_order=1423)

void __static_initialization_and_destruction_0(int, int) (int __initialize_p, int __priority)
{
  struct ImVec2 * D.45224;
  struct ImVec2 * D.45223;
  struct ImVec2 * D.45222;
  struct ImVec2 * D.45221;
  struct ImVec2 * D.45220;
  struct ImVec2 * D.45219;
  struct ImVec2 * D.45218;
  struct ImVec2 * D.45217;
  long int D.17629;
  struct ImGuiResizeGripDef * D.17628;
  struct ImGuiResizeGripDef * D.17627;
  struct ImGuiResizeGripDef * retval.2024;
  struct ImGuiResizeGripDef * _5;
  struct ImGuiResizeGripDef * _6;
  long int _7;
  struct ImVec2 * _8;
  struct ImVec2 * _10;
  struct ImGuiResizeGripDef * _14;
  long int _15;
  struct ImVec2 * _16;
  struct ImVec2 * _18;
  struct ImGuiResizeGripDef * _22;
  long int _23;
  struct ImVec2 * _24;
  struct ImVec2 * _26;
  struct ImGuiResizeGripDef * _30;
  long int _31;
  struct ImVec2 * _32;
  struct ImVec2 * _34;
  struct ImGuiResizeGripDef * _38;
  long int _39;
  struct ImGuiResizeGripDef * retval.2024_40;

  <bb 2>:
  if (__initialize_p_2(D) == 1)
    goto <bb 3>;
  else
    goto <bb 5>;

  <bb 3>:
  if (__priority_4(D) == 65535)
    goto <bb 4>;
  else
    goto <bb 5>;

  <bb 4>:
  _5 = &resize_grip_def;
  _6 = _5;
  _7 = 3;
  _8 = &_6->CornerPos;
  ImVec2::ImVec2 (_8, 1.0e+0, 1.0e+0);
  _10 = &_6->InnerDir;
  ImVec2::ImVec2 (_10, -1.0e+0, -1.0e+0);
  _6->AngleMin12 = 0;
  _6->AngleMax12 = 3;
  _14 = _6 + 24;
  _15 = _7 + -1;
  _16 = &_14->CornerPos;
  ImVec2::ImVec2 (_16, 0.0, 1.0e+0);
  _18 = &_14->InnerDir;
  ImVec2::ImVec2 (_18, 1.0e+0, -1.0e+0);
  _14->AngleMin12 = 3;
  _14->AngleMax12 = 6;
  _22 = _14 + 24;
  _23 = _15 + -1;
  _24 = &_22->CornerPos;
  ImVec2::ImVec2 (_24, 0.0, 0.0);
  _26 = &_22->InnerDir;
  ImVec2::ImVec2 (_26, 1.0e+0, 1.0e+0);
  _22->AngleMin12 = 6;
  _22->AngleMax12 = 9;
  _30 = _22 + 24;
  _31 = _23 + -1;
  _32 = &_30->CornerPos;
  ImVec2::ImVec2 (_32, 1.0e+0, 0.0);
  _34 = &_30->InnerDir;
  ImVec2::ImVec2 (_34, -1.0e+0, 1.0e+0);
  _30->AngleMin12 = 9;
  _30->AngleMax12 = 12;
  _38 = _30 + 24;
  _39 = _31 + -1;
  retval.2024_40 = _5;

  <bb 5>:
  return;

}



;; Function (static initializers for /home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp) (_GLOBAL__sub_I_GImGui, funcdef_no=1513, decl_uid=22368, cgraph_uid=1412, symbol_order=1424)

(static initializers for /home/benjamin/Videos/openGLSeries/code/vendor/imgui/imgui.cpp) ()
{
  <bb 2>:
  __static_initialization_and_destruction_0 (1, 65535);
  return;

}


